[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of AT45DB321E-SHF-T production of ADESTO from the text: 8784M–DFLASH–02/2022Features\n\x01Single 2.3V - 3.6V supply\n\x01Serial Peripheral Interface (SPI) compatible\n\x01Supports SPI modes 0 and 3\n\x01Supports RapidS™ operation\n\x01Continuous read capability through entire array\n\x01Up to 85MHz\n\x01Low-power read option up to 15MHz\n\x01Clock-to-output time (tV) of 6ns maximum\n\x01User configurable page size\n\x01512 bytes per page\n\x01528 bytes per page (default)\n\x01Page size can be factory pre-configured for 512 bytes\n\x01Two fully independent SRAM data buffers (512/528 bytes)\n\x01Flexible programming options\n\x01Byte/Page Program (1 to 512/528 bytes) directly into main memory\n\x01Buffer Write\n\x01Buffer to Main Memory Page Program\n\x01Flexible erase options\n\x01Page Erase (512/528 bytes)\n\x01Block Erase (4 KB)\n\x01Sector Erase (64 KB)\n\x01Chip Erase (32 Mbits)\n\x01Program and Erase Suspend/Resume\n\x01Advanced hardware and software data protection features\n\x01Individual sector protection\n\x01Individual sector lock-down to make any sector permanently read-only\n\x01128-byte, One-Time Programmable (OTP) Security Register\n\x0164 bytes factory programmed with a unique identifier\n\x0164 bytes user programmable\n\x01Hardware and software controlled reset options\n\x01JEDEC Standard Manufacturer and Device ID Read\n\x01Low-power dissipation\n\x01400nA Ultra-Deep Power-Down current (typical)\n\x013µA Deep Power-Down current (typical)\n\x0125µA Standby current (typical)\n\x017mA Active Read current (typical)\n\x01Endurance: 100,000 program/erase cycles per page minimum\n\x01Data retention: 20 years\n\x01Green (Pb/Halide-free/RoHS compliant) packaging options\n\x018-lead SOIC (0.208" wide)\n\x018-pad Ultra-thin DFN (5 x 6 x 0.6mm)\n\x01Die in Wafer FormAT45DB321E\n32-Mbit DataFlash (with Extra 1-Mbits), 2.3V Minimum\nSPI Serial Flash Memory \n\n 2 AT45DB321E \n 8784M–DFLASH–02/2022\nDescription\nThe Adesto® AT45DB321E is a 2.3V minimum, serial-interface sequential access Flash memory ideally suited for a wide \nv\nariety of digital voice, image, program code, and data storage applications. The AT45DB321E also supports the RapidS \nserial interface for applications requiring very high speed operation. Its 34,603,008 bits of memory are organized as \n8,192 pages of 512 bytes or 528 bytes each. In addition to the main memory, the AT45DB321E also contains two SRAM \nbuffers of 512/528 bytes each. The buffers allow receiving of data while a page in the main memory is being \nreprogrammed. Interleaving between both buffers can dramatically increase a system\'s ability to write a continuous data \nstream. In addition, the SRAM buffers can be used as additional system scratch pad memory, and E2PROM emulation \n(\nbit or byte alterability) can be easily handled with a self-contained three step read-modify-write operation.\nUnlike conventional Flash memories that are accessed randomly with multiple address lines and a parallel interface, the \nAdesto DataFlash® uses a serial interface to sequentially access its data. The simple sequential access dramatically \nr\neduces active pin count, facilitates simplified hardware layout, increases system reliability, minimizes switching noise, \nand reduces package size. The device is optimized for use in many commercial and industrial applications where  \nhigh-density, low-pin count, low-voltage, and low-power are essential.\nTo allow for simple in-system re-programmability, the AT45DB321E does not require high input voltages for \nprogramming. The device operates from a single 2.3V to 3.6V power supply for the erase and program and read \noperations. The AT45DB321E is enabled through the Chip Select pin (CS ) and accessed via a 3-wire interface consisting \nof the Serial Input (SI), Serial Output (SO), and the Serial Clock (SCK).\nAll programming and erase cycles are self-timed.\n1. Pin Configurations and Pinouts\nFigure 1-1. Pinouts\nNote: 1. The metal pad on the bottom of the UDFN package is not internally connected to a voltage potential.\nT\nhis pad can be a “no connect” or connected to GND.1\n2\n3\n48\n7\n6\n5SI\nSCK\nRESET\nCSSO\nGND\nVCC\nWP8-lead SOIC\nTop View\nSI\nSCK\nRESET\nCSSO\nGND\nVCC\nWP8\n7\n6\n51\n2\n3\n48-pad UDFN\nTop View\n(Through Package)\n\n 3 AT45DB321E \n 8784M–DFLASH–02/2022\nTable 1-1. Pin Configurations\nSymbol Name and FunctionAsserted \nState Type\nCSChip Select: Asserting the CS  pin selects the device. When the CS  pin is deasserted, the \ndevice will be deselected and normally be placed in the standby mode (not Deep Power-Down \nmode) and the output pin (SO) will be in a high-impedance state. When the device is \ndeselected, data will not be accepted on the input pin (SI).\nA high-to-low transition on the CS  pin is required to start an operation and a low-to-high \ntransition is required to end an operation. When ending an internally self-timed operation such \nas a program or erase cycle, the device will not enter the standby mode until the completion of \nthe operation.Low Input\nSCKSerial Clock:  This pin is used to provide a clock to the device and is used to control the flow of \ndata to and from the device. Command, address, and input data present on the SI pin is \nalways latched on the rising edge of SCK, while output data on the SO pin is always clocked \nout on the falling edge of SCK.— Input\nSISerial Input:  The SI pin is used to shift data into the device. The SI pin is used for all data input \nincluding command and address sequences. Data on the SI pin is always latched on the rising \nedge of SCK. Data present on the SI pin will be ignored whenever the device is deselected (CS  \nis deasserted).— Input\nSOSerial Output:  The SO pin is used to shift data out from the device. Data on the SO pin is \nalways clocked out on the falling edge of SCK. The SO pin will be in a high-impedance state \nwhenever the device is deselected (CS  is deasserted).— Output\nWPWrite Protect:  When the WP  pin is asserted, all sectors specified for protection by the Sector \nProtection Register will be protected against program and erase operations regardless of \nwhether the Enable Sector Protection command has been issued or not. The WP pin functions \nindependently of the software controlled protection method. After the WP  pin goes low, the \ncontents of the Sector Protection Register cannot be modified.\nIf a program or erase command is issued to the device while the WP  pin is asserted, the device \nwill simply ignore the command and perform no operation. The device will return to the idle \nstate once the CS  pin has been deasserted. The Enable Sector Protection command and the \nSector Lockdown command, however, will be recognized by the device when the WP  pin is \nasserted.\nThe WP  pin is internally pulled-high and may be left floating if hardware controlled protection \nwill not be used. However, it is recommended that the WP  pin also be externally connected to \nVCC whenever possible.Low Input\nRESETReset:  A low state on the reset pin (RESET ) will terminate the operation in progress and reset \nthe internal state machine to an idle state. The device will remain in the reset condition as long \nas a low level is present on the RESET  pin. Normal operation can resume once the RESET  pin \nis brought back to a high level.\nThe device incorporates an internal power-on reset circuit, so there are no restrictions on the \nRESET  pin during power-on sequences. If this pin and feature is not utilized, then it is \nrecommended that the RESET  pin be driven high externally.Low Input\nVCCDevice Power Supply:  The VCC pin is used to supply the source voltage to the device. \nOperations at invalid VCC voltages may produce spurious results and should not be attempted.— Power\nGNDGround:  The ground reference for the power supply. GND should be connected to the system \nground.— Ground\n\n 4 AT45DB321E \n 8784M–DFLASH–02/2022\n2. Block Diagram\nFigure 2-1. Block Diagram\nFlash Memory Array\nI/O InterfaceSCK\nCS\nRESET\nVCC\nGNDWP\nSO SIPage (512/528 bytes)\nBuffer 1 (512/528 bytes) Buffer 2 (512/528 bytes)\n\n 5 AT45DB321E \n 8784M–DFLASH–02/2022\n3. Memory Array\nTo provide optimal flexibility, the AT45DB321E memory array is divided into three levels of granularity comprising of\ns\nectors, blocks, and pages. Figure 3-1, Memory Architecture Diagram  illustrates the breakdown of each level and details\nth\ne number of pages per sector and block. Program operations to the DataFlash can be done at the full page level or at\nthe byte level (a variable number of bytes). The erase operations can be performed at the chip, sector, block, or page\nlevel.\nFigure 3-1. Memory Architecture Diagram\nSector 0a = 8 pages\n4,096/4,224 bytes\nSector 0b = 120 pages\n61,440/63,360 bytes\nBlock = 4,096/4,224 bytes8 Pages Sector 0a\nSector 0b\nPage = 512/528 bytesPage 0\nPage 1\nPage 6\nPage 7\nPage 8\nPage 9\nPage 8,190\nPage 8,191Block 0\nPage 14\nPage 15\nPage 16\nPage 17\nPage 18Block 1Sector Architecture Block Architecture Page Architecture\nBlock 0\nBlock 1\nBlock 14\nBlock 15\nBlock 16\nBlock 17\nBlock 1,022\nBlock 1,023Block 30\nBlock 31\nBlock 32\nBlock 33Sector 1\nSector 63 = 128 pages\n65,536/67,584 bytesBlock 2\nSector 1 = 128 pages\n65,536/67,584 bytes\nSector 62 = 128 pages\n65,536/67,584 bytesSector 2 = 128 pages\n65,536/67,584 bytes\n\n 6 AT45DB321E \n 8784M–DFLASH–02/2022\n4. Device Operation\nThe device operation is controlled by instructions from the host processor. The list of instructions and their associated\no\npcodes are contained in Table 14-1 on page 39  through Table 14-4 on page 40 . A valid instruction starts with the falling\ned\nge of CS  followed by the appropriate 8-bit opcode and the desired buffer or main memory address location. While the\nCS pin is low, toggling the SCK pin controls the loading of the opcode and the desired buffer or main memory address\nlocation through the SI (Serial Input) pin. All instructions, addresses, and data are transferred with the Most Significant\nBit (MSB) first.\nThree address bytes are used to address memory locations in either the main memory array or in one of the SRAM\nbuffers. The three address bytes will be comprised of a number of dummy bits and a number of actual device address\nbits, with the number of dummy bits varying depending on the operation being performed and the selected device page\nsize. Buffer addressing for the standard DataFlash page size (528 bytes) is referenced in the datasheet using the\nterminology BFA9 - BFA0 to denote the 10 address bits required to designate a byte address within a buffer. The main\nmemory addressing is referenced using the terminology PA12 - PA0 and BA9 - BA0, where PA12 - PA0 denotes the\n13 address bits required to designate a page address, and BA9 - BA0 denotes the 10 address bits required to designate\na byte address within the page. Therefore, when using the standard DataFlash page size, a total of 23 address bits are\nused.\nFor the “power of 2” binary page size (512 bytes), the buffer addressing is referenced in the datasheet using the\nconventional terminology BFA8 - BFA0 to denote the nine address bits required to designate a byte address within a\nbuffer. Main memory addressing is referenced using the terminology A21 - A0, where A21 - A9 denotes the 13 address\nbits required to designate a page address, and A8 - A0 denotes the nine address bits required to designate a byte\naddress within a page. Therefore, when using the binary page size, a total of 22 address bits are used.\n5. Read Commands\nBy specifying the appropriate opcode, data can be read from the main memory or from either one of the two SRAM data\nb\nuffers. The DataFlash supports RapidS protocols for Mode 0 and Mode 3. Please see Section 24., Detailed Bit-level\nRe\nad Waveforms: RapidS Mode 0/Mode 3  diagrams in this datasheet for details on the clock cycle sequences for each\nmode.\n5.1 Continuous Array Read (Legacy Command: E8h Opcode) \nBy supplying an initial starting address for the main memory array, the Continuous Array Read command can be utilized \nt\no sequentially read a continuous stream of data from the device by simply providing a clock signal; no additional \naddressing information or control signals need to be provided. The DataFlash incorporates an internal address counter \nthat will automatically increment on every clock cycle, allowing one continuous read from memory to be performed \nwithout the need for additional address sequences. To perform a Continuous Array Read using the standard DataFlash \npage size (528 bytes), an opcode of E8h must be clocked into the device followed by three address bytes (which \ncomprise the 24-bit page and byte address sequence) and four dummy bytes. The first 13 bits (PA12 - PA0) of the 23-bit \naddress sequence specify which page of the main memory array to read and the last 10 bits (BA9 - BA0) of the 23-bit \naddress sequence specify the starting byte address within the page. To perform a Continuous Array Read using the \nbinary page size  \n(512 bytes), an opcode of E8h must be clocked into the device followed by three address bytes and four dummy bytes. \nThe first 13 bits (A21 - A9) of the 22-bit address sequence specify which page of the main memory array to read and the \nlast nine bits (A8 - A0) of the 22-bit address sequence specify the starting byte address within the page. The dummy \nbytes that follow the address bytes are needed to initialize the read operation. Following the dummy bytes, additional \nclock pulses on the SCK pin will result in data being output on the SO (serial output) pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy bytes, and the reading of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no delays incurred during the page boundary crossover (the crossover \nfrom the end of one page to the beginning of the next page). When the last bit in the main memory array has been read, \n\n 7 AT45DB321E \n 8784M–DFLASH–02/2022\nthe device will continue reading back at the beginning of the first page of memory. As with crossing over page \nboundaries, no delays will be incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR1 specification. The Continuous Array \nR\nead bypasses the data buffers and leaves the contents of the buffers unchanged.\nWarning: This command is not recommended for new designs .\n5.2 Continuous Array Read (High Frequency Mode: 1Bh Opcode)\nThis command can be used to read the main memory array sequentially at the highest possible operating clock \nf\nrequency up to the maximum specified by fCAR4. To perform a Continuous Array Read using the standard DataFlash \np\nage size (528 bytes), the CS  pin must first be asserted, and then an opcode of 1Bh must be clocked into the device \nfollowed by three address bytes and two dummy bytes. The first 13 bits (PA12 - PA0) of the 23-bit address sequence \nspecify which page of the main memory array to read and the last 10 bits (BA9 - BA0) of the 23-bit address sequence \nspecify the starting byte address within the page. To perform a Continuous Array Read using the binary page size (512 \nbytes), the opcode 1Bh must be clocked into the device followed by three address bytes (A21 - A0) and two dummy \nbytes. Following the dummy bytes, additional clock pulses on the SCK pin will result in data being output on the SO \n(Serial Output) pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy bytes, and the reading of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no delays incurred during the page boundary crossover (the crossover \nfrom the end of one page to the beginning of the next page). When the last bit in the main memory array has been read, \nthe device will continue reading back at the beginning of the first page of memory. As with crossing over page \nboundaries, no delays will be incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR1 specification. The Continuous Array \nR\nead bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.3 Continuous Array Read (High Frequency Mode: 0Bh Opcode)\nThis command can be used to read the main memory array sequentially at higher clock frequencies up to the maximum \ns\npecified by fCAR1. To perform a Continuous Array Read using the standard DataFlash page size (528 bytes), the CS  pin \nmust first be asserted, and then an opcode of 0Bh must be clocked into the device followed by three address bytes and \none dummy byte. The first 13 bits (PA12 - PA0) of the 23-bit address sequence specify which page of the main memory \narray to read and the last 10 bits (BA9 - BA0) of the 23-bit address sequence specify the starting byte address within the \npage. To perform a Continuous Array Read using the binary page size (512 bytes), the opcode 0Bh must be clocked into \nthe device followed by three address bytes (A21 - A0) and one dummy byte. Following the dummy byte, additional clock \npulses on the SCK pin will result in data being output on the SO pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy byte, and the reading of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no delays incurred during the page boundary crossover (the crossover \nfrom the end of one page to the beginning of the next page). When the last bit in the main memory array has been read, \nthe device will continue reading back at the beginning of the first page of memory. As with crossing over page \nboundaries, no delays will be incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR1 specification. The Continuous Array \nR\nead bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.4 Continuous Array Read (Low Frequency Mode: 03h Opcode) \nThis command can be used to read the main memory array sequentially at lower clock frequencies up to maximum \ns\npecified by fCAR2. Unlike the previously described read commands, this Continuous Array Read command for the lower \n\n 8 AT45DB321E \n 8784M–DFLASH–02/2022\nclock frequencies does not require the clocking in of dummy bytes after the address byte sequence. To perform a \nContinuous Array Read using the standard DataFlash page size (528 bytes), the CS  pin must first be asserted, and then \nan opcode of 03h must be clocked into the device followed by three address bytes. The first 13 bits (PA12 - PA0) of the \n23-bit address sequence specify which page of the main memory array to read and the last 10 bits (BA9 - BA0) of the 23-\nbit address sequence specify the starting byte address within the page. To perform a Continuous Array Read using the\nbinary page size (512 bytes), the opcode 03h must be clocked into the device followed by three address bytes (A21 -\nA0). Following the address bytes, additional clock pulses on the SCK pin will result in data being output on the SO pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, and the reading of data. When the end \nof a page in the main memory is reached during a Continuous Array Read, the device will continue reading at the \nbeginning of the next page with no delays incurred during the page boundary crossover (the crossover from the end of \none page to the beginning of the next page). When the last bit in the main memory array has been read, the device will \ncontinue reading back at the beginning of the first page of memory. As with crossing over page boundaries, no delays will \nbe incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR2 specification. The Continuous Array \nR\nead bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.5 Continuous Array Read (Low Power Mode: 01h Opcode) \nThis command is ideal for applications that want to minimize power consumption and do not need to read the memory \na\nrray at high frequencies. Like the 03h opcode, this Continuous Array Read command allows reading the main memory \narray sequentially without the need for dummy bytes to be clocked in after the address byte sequence. The memory can \nbe read at clock frequencies up to maximum specified by fCAR3. To perform a Continuous Array Read using the standard \nD\nataFlash page size (528 bytes), the CS  pin must first be asserted, and then an opcode of 01h must be clocked into the \ndevice followed by three address bytes. The first 13 bits (PA12 - PA0) of the 23-bit address sequence specify which page \nof the main memory array to read and the last 10 bits (BA9 - BA0) of the 23-bit address sequence specify the starting \nbyte address within the page. To perform a Continuous Array Read using the binary page size (512 bytes), the opcode \n01h must be clocked into the device followed by three address bytes (A21 - A0). Following the address bytes, additional \nclock pulses on the SCK pin will result in data being output on the SO pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, and the reading of data. When the end \nof a page in the main memory is reached during a Continuous Array Read, the device will continue reading at the \nbeginning of the next page with no delays incurred during the page boundary crossover (the crossover from the end of \none page to the beginning of the next page). When the last bit in the main memory array has been read, the device will \ncontinue reading back at the beginning of the first page of memory. As with crossing over page boundaries, no delays will \nbe incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR3 specification. The Continuous Array \nR\nead bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.6 Main Memory Page Read\nA Main Memory Page Read allows the reading of data directly from a single page in the main memory, bypassing both of \nt\nhe data buffers and leaving the contents of the buffers unchanged. To start a page read using the standard DataFlash \npage size (528 bytes), an opcode of D2h must be clocked into the device followed by three address bytes (which \ncomprise the 24-bit page and byte address sequence) and four dummy bytes. The first 13 bits  \n(PA12 - PA0) of the 23-bit address sequence specify the page in main memory to be read and the last 10 bits  \n(BA9 - BA0) of the 23-bit address sequence specify the starting byte address within that page. To start a page read using \nthe binary page size (512 bytes), the opcode D2h must be clocked into the device followed by three address bytes and \nfour dummy bytes. The first 13 bits (A21 - A9) of the 22-bit address sequence specify which page of the main memory \narray to read, and the last nine bits (A8 - A0) of the 22-bit address sequence specify the starting byte address within that \npage. The dummy bytes that follow the address bytes are sent to initialize the read operation. Following the dummy \nbytes, the additional pulses on SCK result in data being output on the SO (serial output) pin. \n\n 9 AT45DB321E \n 8784M–DFLASH–02/2022\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy bytes, and the reading of \ndata. Unlike the Continuous Array Read command, when the end of a page in main memory is reached, the device will \ncontinue reading back at the beginning of the same page rather than the beginning of the next page. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Main Memory Page Read is defined by the fSCK specification. The Main Memory Page \nR\nead bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.7 Buffer Read \nThe SRAM data buffers can be accessed independently from the main memory array, and utilizing the Buffer Read \nc\nommand allows data to be sequentially read directly from either one of the buffers. Four opcodes, D4h or D1h for Buffer \n1 and D6h or D3h for Buffer 2, can be used for the Buffer Read command. The use of each opcode depends on the \nmaximum SCK frequency that will be used to read data from the buffers. The D4h and D6h opcode can be used at any \nSCK frequency up to the maximum specified by fCAR1 while the D1h and D3h opcode can be used for lower frequency \nr\nead operations up to the maximum specified by fCAR2.\nT\no perform a Buffer Read using the standard DataFlash buffer size (528 bytes), the opcode must be clocked into the \ndevice followed by three address bytes comprised of 14 dummy bits and 10 buffer address bits (BFA9 - BFA0). To \nperform a Buffer Read using the binary buffer size (512 bytes), the opcode must be clocked into the device followed by \nthree address bytes comprised of 15 dummy bits and nine buffer address bits (BFA8 - BFA0). Following the address \nbytes, one dummy byte must be clocked into the device to initialize the read operation if using opcodes D4h or D6h. The \nCS pin must remain low during the loading of the opcode, the address bytes, the dummy byte (if using opcodes D4h or \nD6h), and the reading of data. When the end of a buffer is reached, the device will continue reading back at the beginning \nof the buffer. A low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO).\n6. Program and Erase Commands\n6.1 Buffer Write\nUtilizing the Buffer Write command allows data clocked in from the SI pin to be written directly into either one of the\nS\nRAM data buffers.\nTo load data into a buffer using the standard DataFlash buffer size (528 bytes), an opcode of 84h for Buffer 1 or 87h for\nBuffer 2 must be clocked into the device followed by three address bytes comprised of 14 dummy bits and 10 buffer\naddress bits (BFA9 - BFA0). The 10 buffer address bits specify the first byte in the buffer to be written.\nTo load data into a buffer using the binary buffer size (512 bytes), an opcode of 84h for Buffer 1 or 87h for Buffer 2, must\nbe clocked into the device followed by 15 dummy bits and nine buffer address bits (BFA8 - BFA0). The nine buffer\naddress bits specify the first byte in the buffer to be written.\nAfter the last address byte has been clocked into the device, data can then be clocked in on subsequent clock cycles. If\nthe end of the data buffer is reached, the device will wrap around back to the beginning of the buffer. Data will continue to\nbe loaded into the buffer until a low-to-high transition is detected on the CS  pin.\n6.2 Buffer to Main Memory Page Program with Built-In Erase\nThe Buffer to Main Memory Page Program with Built-In Erase command allows data that is stored in one of the SRAM\nb\nuffers to be written into an erased or programmed page in the main memory array. It is not necessary to pre-erase the\npage in main memory to be written because this command will automatically erase the selected page prior to the\nprogram cycle.\nTo perform a Buffer to Main Memory Page Program with Built-In Erase using the standard DataFlash page size\n(528 bytes), an opcode of 83h for Buffer 1 or 86h for Buffer 2 must be clocked into the device followed by three address\nbytes comprised of one dummy bit, 13 page address bits (PA12 - PA0) that specify the page in the main memory to be\nwritten, and 10 dummy bits.\n\n 10 AT45DB321E \n 8784M–DFLASH–02/2022\nTo perform a Buffer to Main Memory Page Program with Built-In Erase using the binary page size (512 bytes), an opcode \nof 83h for Buffer 1 or 86h for Buffer 2 must be clocked into the device followed by three address bytes comprised of two \ndummy bits, 13 page address bits (A21 - A9) that specify the page in the main memory to be written, and nine dummy \nbits.\nWhen a low-to-high transition occurs on the CS  pin, the device will first erase the selected page in main memory (the \nerased state is a Logic 1) and then program the data stored in the appropriate buffer into that same page in main \nmemory. Both the erasing and the programming of the page are internally self-timed and should take place in a \nmaximum time of tEP. During this time, the RDY/BUSY  bit in the Status Register will indicate that the dev ice is busy.\nThe device also incorporates an intelligent erase and program algorithm that can detect when a byte location fails to \nerase or program properly. If an erase or programming error arises, it will be indicated by the EPE bit in the Status \nRegister.\n6.3 Buffer to Main Memory Page Program without Built-In Erase\nThe Buffer to Main Memory Page Program without Built-In Erase command allows data that is stored in one of the SRAM \nb\nuffers to be written into a pre-erased page in the main memory array. It is necessary that the page in main memory to be \nwritten be previously erased in order to avoid programming errors.\nTo perform a Buffer to Main Memory Page Program without Built-In Erase using the standard DataFlash page size (528 \nbytes), an opcode of 88h for Buffer 1 or 89h for Buffer 2 must be clocked into the device followed by three address bytes \ncomprised of one dummy bit, 13 page address bits (PA12 - PA0) that specify the page in the main memory to be written, \nand 10 dummy bits.\nTo perform a Buffer to Main Memory Page Program using the binary page size (512 bytes), an opcode of 88h for Buffer \n1 or 89h for Buffer 2 must be clocked into the device followed by three address bytes comprised of two dummy bits, 13 \npage address bits (A21 - A9) that specify the page in the main memory to be written, and nine dummy bits.\nWhen a low-to-high transition occurs on the CS  pin, the device will program the data stored in the appropriate buffer into \nthe specified page in the main memory. The page in main memory that is being programmed must have been previously \nerased using one of the erase commands (Page Erase, Block Erase, Sector Erase, or Chip Erase). The programming of \nthe page is internally self-timed and should take place in a maximum time of tP. During this time, the RDY/BUSY  bit in the \nSt\natus Register will indicate that the device is busy.\nThe device also incorporates an intelligent programming algorithm that can detect when a byte location fails to program \nproperly. If a programming error arises, it will be indicated by the EPE bit in the Status Register.\n6.4 Main Memory Page Program through Buffer with Built-In Erase\nThe Main Memory Page Program through Buffer with Built-In Erase command combines the Buffer Write and Buffer to \nM\nain Memory Page Program with Built-In Erase operations into a single operation to help simplify application firmware \ndevelopment. With the Main Memory Page Program through Buffer with Built-In Erase command, data is first clocked \ninto either Buffer 1 or Buffer 2, the addressed page in memory is then automatically erased, and then the contents of the \nappropriate buffer are programmed into the just-erased main memory page.\nTo perform a Main Memory Page Program through Buffer using the standard DataFlash page size (528 bytes), an \nopcode of 82h for Buffer 1 or 85h for Buffer 2 must first be clocked into the device followed by three address bytes \ncomprised of one dummy bit, 13 page address bits (PA12 - PA0) that specify the page in the main memory to be written, \nand 10 buffer address bits (BFA9 - BFA0) that select the first byte in the buffer to be written.\nTo perform a Main Memory Page Program through Buffer using the binary page size (512 bytes), an opcode of 82h for \nBuffer 1 or 85h for Buffer 2 must first be clocked into the device followed by three address bytes comprised of two dummy \nbits, 13 page address bits (A21 - A9) that specify the page in the main memory to be written, and nine buffer address bits \n(BFA8 - BFA0) that select the first byte in the buffer to be written.\nAfter all address bytes have been clocked in, the device will take data from the input pin (SI) and store it in the specified \ndata buffer. If the end of the buffer is reached, the device will wrap around back to the beginning of the buffer. When \nthere is a low-to-high transition on the CS  pin, the device will first erase the selected page in main memory (the erased \nstate is a Logic 1) and then program the data stored in the buffer into that main memory page. Both the erasing and the \n\n 11 AT45DB321E \n 8784M–DFLASH–02/2022\nprogramming of the page are internally self-timed and should take place in a maximum time of tEP. During this time, the \nR\nDY/BUSY  bit in the Status Register will indicate that the dev ice is busy.\nThe device also incorporates an intelligent erase and programming algorithm that can detect when a byte location fails to \nerase or program properly. If an erase or program error arises, it will be indicated by the EPE bit in the Status Register.\n6.5 Main Memory Byte/Page Program through Buffer 1 without Built-In Erase\nThe Main Memory Byte/Page Program through Buffer 1 without Built-In Erase command combines both the Buffer Write \na\nnd Buffer to Main Memory Program without Built-In Erase operations to allow any number of bytes (1 to 512/528 bytes) \nto be programmed directly into previously erased locations in the main memory array. With the Main Memory Byte/Page \nProgram through Buffer 1 without Built-In Erase command, data is first clocked into Buffer 1, and then only the bytes \nclocked into the buffer are programmed into the pre-erased byte locations in main memory. Multiple bytes up to the page \nsize can be entered with one command sequence.\nTo perform a Main Memory Byte/Page Program through Buffer 1 using the standard DataFlash page size (528 bytes), an \nopcode of 02h must first be clocked into the device followed by three address bytes comprised of one dummy bit,  \n13 page address bits (PA12 - PA0) that specify the page in the main memory to be written, and 10 buffer address bits \n(BFA9 - BFA0) that select the first byte in the buffer to be written. After all address bytes are clocked in, the device will \ntake data from the input pin (SI) and store it in Buffer 1. Any number of bytes (1 to 528) can be entered. If the end of the \nbuffer is reached, then the device will wrap around back to the beginning of the buffer.\nTo perform a Main Memory Byte/Page Program through Buffer 1 using the binary page size (512 bytes), an opcode of \n02h for Buffer 1 using must first be clocked into the device followed by three address bytes comprised of two dummy bits, \n13 page address bits (A21 - A9) that specify the page in the main memory to be written, and nine buffer address bits \n(BFA8 - BFA0) that selects the first byte in the buffer to be written. After all address bytes are clocked in, the device will \ntake data from the input pin (SI) and store it in Buffer 1. Any number of bytes (1 to 512) can be entered. If the end of the \nbuffer is reached, then the device will wrap around back to the beginning of the buffer. When using the binary page size, \nthe page and buffer address bits correspond to a 22-bit logical address (A21-A0) in the main memory.\nAfter all data bytes have been clocked into the device, a low-to-high transition on the CS  pin will start the program \noperation in which the device will program the data stored in Buffer 1 into the main memory array. Only the data bytes \nthat were clocked into the device will be programmed into the main memory. \nExample: If only two data bytes were clocked into the device, then only two bytes will be programmed into main \nmemory and the remaining bytes in the memory page will remain in their previous state. \nThe CS  pin must be deasserted on a byte boundary (multiples of eight bits); otherwise, the operation will be aborted and \nno data will be programmed. The programming of the data bytes is internally self-timed and should take place in a \nmaximum time of tP (the program time will be a multiple of the tBP time depending on the number of bytes being \np\nrogrammed). During this time, the RDY/BUSY  bit in the Status Register will indicate that the dev ice is busy.\nThe device also incorporates an intelligent programming algorithm that can detect when a byte location fails to program \nproperly. If a programming error arises, it will be indicated by the EPE bit in the Status Register.\n6.6 Read-Modify-Write\nA completely self-contained read-modify-write operation can be performed to reprogram any number of sequential bytes \ni\nn a page in the main memory array without affecting the rest of the bytes in the same page. This command allows the \ndevice to easily emulate an EEPROM by providing a method to modify a single byte or more in the main memory in a \nsingle operation, without the need for pre-erasing the memory or the need for any external RAM buffers. The  \nRead-Modify-Write command is essentially a combination of the Main Memory Page to Buffer Transfer, Buffer Write, and \nBuffer to Main Memory Page Program with Built-in Erase commands. \nTo perform a Read-Modify-Write using the standard DataFlash page size (528 bytes), an opcode of 58h for Buffer 1 or \n59h for Buffer 2 must be clocked into the device followed by three address bytes comprised of 1 dummy bit, 13 page \naddress bits (PA12 - PA0) that specify the page in the main memory to be written, and 10 byte address bits (BA9 - BA0) \nthat designate the starting byte address within the page to reprogram. \nTo perform a Read-Modify-Write using the binary page size (512 bytes), an opcode of 58h for Buffer 1 or 59h for Buffer 2 \n\n 12 AT45DB321E \n 8784M–DFLASH–02/2022\nmust be clocked into the device followed by three address bytes comprised of 2 dummy bits, 13 page address bits (A21 - \nA9) that specify the page in the main memory to be written, and 9 byte address bits (A8 - A0) designate the starting byte \naddress within the page to reprogram. \nAfter the address bytes have been clocked in, any number of sequential data bytes from one to 512/528 bytes can be \nclocked into the device. If the end of the buffer is reached when clocking in the data, then the device will wrap around \nback to the beginning of the buffer. After all data bytes have been clocked into the device, a low-to-high transition on the \nCS pin will start the self-contained, internal read-modify-write operation. Only the data bytes that were clocked into the \ndevice will be reprogrammed in the main memory.\nExample: If only one data byte was clocked into the device, then only one byte in main memory will be reprogrammed \nand the remaining bytes in the main memory page will remain in their previous state. \nThe CS  pin must be deasserted on a byte boundary (multiples of 8 bits); otherwise, the operation will be aborted and no \ndata will be programmed. The reprogramming of the data bytes is internally self-timed and should take place in a \nmaximum time of tP. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device is busy.\nThe device also incorporates an intelligent erase and programming algorithm that can detect when a byte location fails to \nerase or program properly. If an erase or program error arises, it will be indicated by the EPE bit in the Status Register.\nThe Read-Modify-Write command uses the same opcodes as the Auto Page Rewrite command. If no data bytes are \nclocked into the device, then the device will perform an Auto Page Rewrite operation. See the Auto Page Rewrite \ncommand description on page 26  for more details.\n6.7 Page Erase\nThe Page Erase command can be used to individually erase any page in the main memory array allowing the Buffer to \nM\nain Memory Page Program without Built-In Erase command or the Main Memory Byte/Page Program through Buffer 1 \ncommand to be utilized at a later time.\nTo perform a Page Erase with the standard DataFlash page size (528 bytes), an opcode of 81h must be clocked into the \ndevice followed by three address bytes comprised of one dummy bits, 13 page address bits (PA12 - PA0) that specify the \npage in the main memory to be erased, and 10 dummy bits. To perform a Page Erase with the binary page size (512 \nbytes), an opcode of 81h must be clocked into the device followed by three address bytes comprised of two dummy bits, \n13 page address bits (A21 - A9) that specify the page in the main memory to be erased, and nine dummy bits.\nWhen a low-to-high transition occurs on the CS  pin, the device will erase the selected page (the erased state is a Logic \n1). The erase operation is internally self-timed and should take place in a maximum time of tPE. During this time, the \nR\nDY/BUSY  bit in the Status Register will indicate that the dev ice is busy.\nThe device also incorporates an intelligent erase algorithm that can detect when a byte location fails to erase properly. If \nan erase error arises, it will be indicated by the EPE bit in the Status Register.\n6.8 Block Erase\nThe Block Erase command can be used to erase a block of eight pages at one time. This command is useful when \nn\needing to pre-erase larger amounts of memory and is more efficient than issuing eight separate Page Erase \ncommands.\nTo perform a Block Erase with the standard DataFlash page size (528 bytes), an opcode of 50h must be clocked into the \ndevice followed by three address bytes comprised of one dummy bit, 10 page address bits (PA12 - PA3), and 13 dummy \nbits. The 10 page address bits are used to specify which block of eight pages is to be erased.\nTo perform a Block Erase with the binary page size (512 bytes), an opcode of 50h must be clocked into the device \nfollowed by three address bytes comprised of two dummy bits, 10 page address bits (A21 - A12), and 12 dummy bits. \nThe 10 page address bits are used to specify which block of eight pages is to be erased.\nWhen a low-to-high transition occurs on the CS  pin, the device will erase the selected block of eight pages. The erase \noperation is internally self-timed and should take place in a maximum time of tBE. During this time, the RDY/BUSY  bit in \nth\ne Status Register will indicate that the device is busy. \n\n 13 AT45DB321E \n 8784M–DFLASH–02/2022\nThe device also incorporates an intelligent erase algorithm that can detect when a byte location fails to erase properly. If \nan erase error arises, it will be indicated by the EPE bit in the Status Register.\nTable 6-1. Block Erase Addressing\n6.9 Sector Erase\nThe Sector Erase command can be used to individually erase any sector in the main memory.\nT\nhe main memory array is comprised of 64 sectors, and only one sector can be erased at a time. To perform an erase of \nSector 0a or Sector 0b with the standard DataFlash page size (528 bytes), an opcode of 7Ch must be clocked into the \ndevice followed by three address bytes comprised of one dummy bit, 10 page address bits (PA12 - PA3), and  \n13 dummy bits. To perform a Sector 1-63 erase, an opcode of 7Ch must be clocked into the device followed by three \naddress bytes comprised of one dummy bit, six page address bits (PA12 - PA7), and 17 dummy bits.\nTo perform a Sector 0a or Sector 0b erase with the binary page size (512 bytes), an opcode of 7Ch must be clocked into \nthe device followed by three address bytes comprised of two dummy bits, 10 page address bits (A21 - A12), and  \n12 dummy bits. To perform a Sector 1-63 erase, an opcode of 7Ch must be clocked into the device followed by two \ndummy bits, six page address bits (A21 - A16), and 16 dummy bits. \nThe page address bits are used to specify any valid address location within the sector to be erased. When a  \nlow-to high transition occurs on the CS  pin, the device will erase the selected sector. The erase operation is internally  \nself-timed and should take place in a maximum time of tSE. During this time, the RDY/BUSY  bit in the Status Register will \nin\ndicate that the device is busy.\nThe device also incorporates an intelligent algorithm that can detect when a byte location fails to erase properly. If an \nerase error arises, it will be indicated by the EPE bit in the Status Register.\nTable 6-2. Sector Erase AddressingPA12/\nA21PA11/\nA20PA10/\nA19PA9/\nA18PA8/\nA17PA7/\nA16PA6/\nA15PA5/\nA14PA4/\nA13PA3/\nA12PA2/\nA11PA1/\nA10PA0/\nA9 Block\n0 0 0 0 0 0 0 0 0 0 X X X 0\n0 0 0 0 0 0 0 0 0 1 X X X 1\n0 0 0 0 0 0 0 0 1 0 X X X 2\n0 0 0 0 0 0 0 0 1 1 X X X 3\n•\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n•\n1 1 1 1 1 1 1 1 0 0 X X X 1020\n1 1 1 1 1 1 1 1 0 1 X X X 1021\n1 1 1 1 1 1 1 1 1 0 X X X 1022\n1 1 1 1 1 1 1 1 1 1 X X X 1023\nPA12/\nA21PA11/\nA20PA10/\nA19PA9/\nA18PA8/\nA17PA7/\nA16PA6/\nA15PA5/\nA14PA4/\nA13PA3/\nA12PA2/\nA11PA1/\nA10PA0/\nA9 Sector\n0 0 0 0 0 0 0 0 0 0 X X X 0a\n0 0 0 0 0 0 0 0 0 1 X X X 0b\n0 0 0 0 0 1 X X X X X X X 1\n0 0 0 0 1 0 X X X X X X X 2\n\n 14 AT45DB321E \n 8784M–DFLASH–02/2022\n6.10 Chip Erase\nThe Chip Erase command allows the entire main memory array to be erased can be erased at one time.\nT\no execute the Chip Erase command, a 4-byte command sequence of C7h, 94h, 80h, and 9Ah must be clocked into the \ndevice. Since the entire memory array is to be erased, no address bytes need to be clocked into the device, and any data \nclocked in after the opcode will be ignored. After the last bit of the opcode sequence has been clocked in, the CS  pin \nmust be deasserted to start the erase process. The erase operation is internally self-timed and should take place in a \ntime of tCE. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device is busy.\nThe Chip Erase command will not affect sectors that are protected or locked down; the contents of those sectors will \nremain unchanged. Only those sectors that are not protected or locked down will be erased.\nThe WP  pin can be asserted while the device is erasing, but protection will not be activated until the internal erase cycle \ncompletes.\nThe device also incorporates an intelligent algorithm that can detect when a byte location fails to erase properly. If an \nerase error arises, it will be indicated by the EPE bit in the Status Register.\nTable 6-3. Chip Erase Command\nF\nigure 6-1. Chip Erase\n6.11 Program/Erase Suspend(1)\nIn some code and data storage applications, it may not be possible for the system to wait the milliseconds required for \nt\nhe Flash memory to complete a program or erase cycle. The Program/Erase Suspend command allows a program or \nerase operation in progress to a particular 64KB sector of the main memory array to be suspended so that other device \noperations can be performed. •\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n•\n1 1 1 1 0 0 X X X X X X X 60\n1 1 1 1 0 1 X X X X X X X 61\n1 1 1 1 1 0 X X X X X X X 62\n1 1 1 1 1 1 X X X X X X X 63PA12/\nA21PA11/\nA20PA10/\nA19PA9/\nA18PA8/\nA17PA7/\nA16PA6/\nA15PA5/\nA14PA4/\nA13PA3/\nA12PA2/\nA11PA1/\nA10PA0/\nA9 Sector\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nChip Erase C7h 94h 80h 9Ah\nC7h 94h 80h 9AhCS\nEach transition represents eight bits\n\n 15 AT45DB321E \n 8784M–DFLASH–02/2022\nExample: By suspending an erase operation to a particular sector, the system can perform functions such as a \nprogram or read operation within a different 64KB sector. Other device operations, such as Read Status \nRegister, can also be performed while a program or erase operation is suspended.\nTo perform a Program/Erase Suspend, an opcode of B0h must be clocked into the device. No address bytes need to be \nclocked into the device, and any data clocked in after the opcode will be ignored. When the CS  pin is deasserted, the \nprogram or erase operation currently in progress will be suspended within a time of tSUSP. One of the Program Suspend \nb\nits (PS1 or PS2) or the Erase Suspend bit (ES) in the Status Register will then be set to the Logic 1 state. In addition, \nthe RDY/BUSY  bit in the Status Register will indicate that the device is ready for another operation. \nRead operations are not allowed to a 64KB sector that has had its program or erase operation suspended. If a read is \nattempted to a suspended sector, then the device will output undefined data. Therefore, when performing a Continuous \nArray Read operation and the device\'s internal address counter increments and crosses the sector boundary to a \nsuspended sector, the device will then start outputting undefined data continuously until the address counter increments \nand crosses a sector boundary to an unsuspended sector.\nA program operation is not allowed to a sector that has been erase suspended. If a program operation is attempted to an \nerase suspended sector, then the program operation will abort. \nDuring an Erase Suspend, a program operation to a different 64KB sector can be started and subsequently suspended. \nThis results in a simultaneous Erase Suspend/Program Suspend condition and will be indicated by the states of both the \nES and PS1 or PS2 bits in the Status Register being set to a Logic 1.\nIf a Reset command is performed, or if the RESET  pin is asserted while a sector is erase suspended, then the suspend \noperation will be aborted and the contents of the sector will be left in an undefined state. However, if a reset is performed \nwhile a page is program or erase suspended, the suspend operation will abort but only the contents of the page that was \nbeing programmed or erased will be undefined; the remaining pages in the 64KB sector will retain their previous \ncontents.\n\n 16 AT45DB321E \n 8784M–DFLASH–02/2022\nTable 6-4. Operations Allowed and Not Allowed During Suspend\nCommandOperation During \nProgram Suspend in \nBuffer 1 (PS1)Operation During \nProgram Suspend in \nBuffer 2 (PS2)Operation During \nErase Suspend (ES)\nRead Commands\nRead Array (All Opcodes) Allowed Allowed Allowed\nRead Buffer 1 (All Opcodes) Allowed Allowed Allowed\nRead Buffer 2 (All Opcodes) Allowed Allowed Allowed\nProgram and Erase Commands\nBuffer 1 Write Not Allowed Allowed Allowed\nBuffer 2 Write Allowed Not Allowed Allowed\nBuffer 1 to Memory Program w/ Erase Not Allowed Not Allowed Not Allowed\nBuffer 2 to Memory Program w/ Erase Not Allowed Not Allowed Not Allowed\nBuffer 1 to Memory Program w/o Erase Not Allowed Not Allowed Allowed\nBuffer 2 to Memory Program w/o Erase Not Allowed Not Allowed Allowed\nMemory Program through Buffer 1 w/ Erase Not Allowed Not Allowed Not Allowed\nMemory Program through Buffer 2 w/ Erase Not Allowed Not Allowed Not Allowed\nMemory Program through Buffer 1 w/o Erase Not Allowed Not Allowed Allowed\nAuto Page Rewrite Not Allowed Not Allowed Not Allowed\nPage Erase Not Allowed Not Allowed Not Allowed\nBlock Erase Not Allowed Not Allowed Not Allowed\nSector Erase Not Allowed Not Allowed Not Allowed\nChip Erase Not Allowed Not Allowed Not Allowed\nProtection and Security Commands\nEnable Sector Protection Not Allowed Not Allowed Not Allowed\nDisable Sector Protection Not Allowed Not Allowed Not Allowed\nErase Sector Protection Register Not Allowed Not Allowed Not Allowed\nProgram Sector Protection Register Not Allowed Not Allowed Not Allowed\nRead Sector Protection Register Allowed Allowed Allowed\nSector Lockdown Not Allowed Not Allowed Not Allowed\nRead Sector Lockdown Allowed Allowed Allowed\nFreeze Sector Lockdown State Not Allowed Not Allowed Not Allowed\nProgram Security Register Not Allowed Not Allowed Not Allowed\nRead Security Register Allowed Allowed Allowed\nAdditional Commands\nMain Memory to Buffer 1 Transfer Not Allowed  Allowed  Allowed\nMain Memory to Buffer 2 Transfer Allowed Not Allowed Allowed\nMain Memory to Buffer 1 Compare Not Allowed  Allowed  Allowed\nMain Memory to Buffer 2 Compare Allowed Not Allowed Allowed\nEnter Deep Power-Down Not Allowed Not Allowed Not Allowed\nResume from Deep Power-Down Not Allowed Not Allowed Not Allowed\nEnter Ultra-Deep Power-Down mode Not Allowed Not Allowed Not Allowed\nRead Configuration Register Allowed Allowed Allowed\nRead Status Register Allowed Allowed Allowed\nRead Manufacturer and Device ID Allowed Allowed Allowed\nReset (via Hardware or Software) Allowed Allowed Allowed\n\n 17 AT45DB321E \n 8784M–DFLASH–02/2022\n6.12 Program/Erase Resume(1)\nThe Program/Erase Resume command allows a suspended program or erase operation to be resumed and continue \nw\nhere it left off.\nTo perform a Program/Erase Resume, an opcode of D0h must be clocked into the device. No address bytes need to be \nclocked into the device, and any data clocked in after the opcode will be ignored. When the CS  pin is deasserted, the \nprogram or erase operation currently suspended will be resumed within a time of tRES. The PS1 bit, PS2 bit, or ES bit in \nt\nhe Status Register will then be reset back to a Logic 0 state to indicate that the program or erase operation is no longer \nsuspended. In addition, the RDY/BUSY  bit in the Status Register will indicate that the dev ice is busy performing a \nprogram or erase operation. \nDuring a simultaneous Erase Suspend/Program Suspend condition, issuing the Program/Erase Resume command will \nresult in the program operation resuming first. After the program operation has been completed, the Program/Erase \nResume command must be issued again in order for the erase operation to be resumed.\nWhile the device is busy resuming a program or erase operation, any attempts at issuing the Program/Erase Suspend \ncommand will be ignored. Therefore, if a resumed program or erase operation needs to be subsequently suspended \nagain, the system must either wait the entire tRES time before issuing the Program/Erase Suspend command, or it must \nc\nheck the status of the RDY/BUSY  bit or the appropriate PS1, PS2, or ES bit in the Status Register to determine if the \npreviously suspended program or erase operation has resumed.\n6.13 Sector Protection\nTwo protection methods, hardware and software controlled, are provided for protection against inadvertent or erroneous \np\nrogram and erase cycles. The software controlled method relies on the use of software commands to enable and \ndisable sector protection while the hardware controlled method employs the use of the Write Protect (WP ) pin. The \nselection of which sectors that are to be protected or unprotected against program and erase operations is specified in \nthe Nonvolatile Sector Protection Register. The status of whether or not sector protection has been enabled or disabled \nby either the software or the hardware controlled methods can be determined by checking the Status Register.\n6.14 Software Sector Protection\nSoftware controlled protection is useful in applications in which the WP  pin is not or cannot be controlled by a host \nprocessor. In such instances, the WP  pin may be left floating (the WP  pin is internally pulled high) and sector protection \ncan be controlled using the Enable Sector Protection and Disable Sector Protection commands.\nIf the device is power cycled, then the software controlled protection will be disabled. Once the device is powered up, the \nEnable Sector Protection command should be reissued if sector protection is desired and if the WP  pin is not used.\n6.14.1 Enable Sector Protection\nSectors specified for protection in the Sector Protection Register can be protected from program and erase operations by \ni\nssuing the Enable Sector Protection command. To enable the sector protection, a 4-byte command sequence of 3Dh, \n2Ah, 7Fh, and A9h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the \nCS pin must be deasserted to enable the Sector Protection.\nTable 6-5. Enable Sector Protection Command\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nEnable Sector Protection 3Dh 2Ah 7Fh A9h\n\n 18 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 6-2. Enable Sector Protection \n6.14.2 Disable Sector Protection \nTo disable the sector protection, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and 9Ah must be clocked into the \nd\nevice. After the last bit of the opcode sequence has been clocked in, the CS  pin must be deasserted to disable the \nsector protection.\nTable 6-6. Disable Sector Protection Command\nF\nigure 6-3. Disable Sector Protection \n6.15 Hardware Controlled Protection\nSectors specified for protection in the Sector Protection Register and the Sector Protection Register itself can be \np\nrotected from program and erase operations by asserting the WP  pin and keeping the pin in its asserted state. The \nSector Protection Register and any sector specified for protection cannot be erased or programmed as long as the WP  \npin is asserted. In order to modify the Sector Protection Register, the WP  pin must be deasserted. If the WP  pin is \npermanently connected to GND, then the contents of the Sector Protection Register cannot be changed. If the WP  pin is \ndeasserted or permanently connected to VCC, then the contents of the Sector Protection Register can be modified.\nT\nhe WP  pin will override the software controlled protection method but only for protecting the sectors. \nExample: If the sectors were not previously protected by the Enable Sector Protection command, then simply \nasserting the WP  pin would enable the sector protection within the maximum specified tWPE time. When the \nW\nP pin is deasserted, however, the sector protection would no longer be enabled (after the maximum \nspecified tWPD time) as long as the Enable Sector Protection command was not issued while the WP  pin was \nasserted. If the Enable Sector Protection command was issued before or while the WP  pin was asserted, \nthen simply deasserting the WP  pin would not disable the sector protection. In this case, the Disable Sector \nProtection command would need to be issued while the WP  pin is deasserted to disable the sector \nprotection. The Disable Sector Protection command is also ignored whenever the WP  pin is asserted.\nA noise filter is incorporated to help protect against spurious noise that may inadvertently assert or deassert the WP  pin.\nFigures 6-4 and  Table 6-7  detail the sector protection status for various scen arios of the WP  pin, the Enable Sector \nProtection command, and the Disable Sector Protection command. 3Dh 2Ah 7Fh A9hCS\nEach transition represents eight bitsSI\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nDisable Sector Protection 3Dh 2Ah 7Fh 9Ah\n3Dh 2Ah 7Fh 9AhCS\nEach transition represents eight bitsSI\n\n 19 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 6-4. WP  Pin and Protection Status\nTable 6-7. WP  Pin and Protection Status\n6.16 Sector Protection Register\nThe nonvolatile Sector Protection Register specifies which sectors are to be protected or unprotected with either the \ns\noftware or hardware controlled protection methods. The Sector Protection Register contains 64 bytes of data, of which \nbyte locations 0 through 63 contain values that specify whether Sectors 0 through 63 will be protected or unprotected. \nThe Sector Protection Register is user modifiable and must be erased before it can be reprogrammed. Table 6-8  \nil\nlustrates the format of the Sector Protection Register.\nTable 6-8. Sector Protection Register\nNote: 1. The default values for bytes 0 through 63 are 00h when shipped from Adesto.\nTable 6-9. Sector 0 (0a, 0b) Sector Protection Register Byte Value\nNote: 1. x = Don’t careTime \nPeriod WP Pin Enable Sector Protection CommandDisable Sector \nProtection CommandSector \nProtection \nStatusSector \nProtection \nRegister\n1 HighCommand Not Issued Previously X Disabled Read/Write\n— Issue Command Disabled Read/Write\nIssue Command — Enabled Read/Write\n2 Low X X Enabled Read\n3 HighCommand Issued During Period 1 or 2 Not Issued Yet Enabled Read/Write\n— Issue Command Disabled Read/Write\nIssue Command — Enabled Read/WriteWP1 2 3\nSector Number 0 (0a, 0b) 1 to 63\nProtected\nSee Table 6-9FFh\nUnprotected 00h\nBit 7:6 Bit 5:4 Bit 3:2 Bit 1:0\nData \nValueSector 0a\n(Page 0-7)Sector 0b\n(Page 8-127) N/A N/A\nSectors 0a and 0b Unprotected 00 00 XX XX 0xh\nProtect Sector 0a 11 00 XX XX Cxh\nProtect Sector 0b 00 11 XX XX 3xh\nProtect Sectors 0a and 0b 11 11 XX XX Fxh\n\n 20 AT45DB321E \n 8784M–DFLASH–02/2022\n6.16.1 Erase Sector Protection Register \nIn order to modify and change the values of the Sector Protection Register, it must first be erased using the Erase Sector \nP\nrotection Register command.\nTo erase the Sector Protection Register, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and CFh must be clocked into \nthe device. After the last bit of the opcode sequence has been clocked in, the CS  pin must be deasserted to initiate the \ninternally self-timed erase cycle. The erasing of the Sector Protection Register should take place in a maximum time of \ntPE. During this time, the RDY/BUSY  bit in the Status Register will indicate that the dev ice is busy. If the device is \npowered-down before the completion of the erase cycle, then the contents of the Sector Protection Register cannot be \nguaranteed.\nThe Sector Protection Register can be erased with sector protection enabled or disabled. Since the erased state (FFh) of \neach byte in the Sector Protection Register is used to indicate that a sector is specified for protection, leaving the sector \nprotection enabled during the erasing of the register allows the protection scheme to be more effective in the prevention \nof accidental programming or erasing of the device. If for some reason an erroneous program or erase command is sent \nto the device immediately after erasing the Sector Protection Register and before the register can be reprogrammed, \nthen the erroneous program or erase command will not be processed because all sectors would be protected.\nTable 6-10. Erase Sector Protection Register Command\nF\nigure 6-5. Erase Sector Protection Register \n6.16.2 Program Sector Protection Register \nOnce the Sector Protection Register has been erased, it can be reprogrammed using the Program Sector Protection \nR\negister command.\nTo program the Sector Protection Register, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and FCh must be clocked \ninto the device followed by 64 bytes of data corresponding to Sectors 0 through 63. After the last bit of the opcode \nsequence and data have been clocked in, the CS  pin must be deasserted to initiate the internally self-timed program \ncycle. The programming of the Sector Protection Register should take place in a maximum time of tP. During this time, \nt\nhe RDY/BUSY  bit in the Status Register will indicate that the dev ice is busy. If the device is powered-down before the \ncompletion of the erase cycle, then the contents of the Sector Protection Register cannot be guaranteed.\nIf the proper number of data bytes is not clocked in before the CS  pin is deasserted, then the protection status of the \nsectors corresponding to the bytes not clocked in cannot be guaranteed. \nExample: If only the first two bytes are clocked in instead of the complete 64 bytes, then the protection status of the \nlast 62 sectors cannot be guaranteed. Furthermore, if more than 64 bytes of data is clocked into the device, \nthen the data will wrap back around to the beginning of the register. For instance, if 65 bytes of data are \nclocked in, then the 65th byte will be stored at  byte location 0 of the Sector Protection Register.\nTh\ne data bytes clocked into the Sector Protection Register need to be valid values (0xh, 3xh, Cxh, and Fxh for Sector 0a \nor Sector 0b, and 00h or FFh for other sectors) in order for the protection to function correctly. If a non-valid value is Command Byte 1 Byte 2 Byte 3 Byte 4\nErase Sector Protection Register 3Dh 2Ah 7Fh CFh\n3Dh 2Ah 7Fh CFhCS\nEach transition represents eight bitsSI\n\n 21 AT45DB321E \n 8784M–DFLASH–02/2022\nclocked into a byte location of the Sector Protection Register, then the protection status of the sector corresponding to \nthat byte location cannot be guaranteed. \nExample: If a value of 17h is clocked into byte location 2 of the Sector Protection Register, then the protection status \nof Sector 2 cannot be guaranteed.\nThe Sector Protection Register can be reprogrammed while the sector protection is enabled or disabled. Being able to \nreprogram the Sector Protection Register with the sector protection enabled allows the user to temporarily disable the \nsector protection to an individual sector rather than disabling sector protection completely.\nThe Program Sector Protection Register command utilizes Buffer 1 for processing. Therefore, the contents of Buffer 1 \nwill be altered from its previous state when this command is issued.\nTable 6-11. Program Sector Protection Register Command\nF\nigure 6-6. Program Sector Protection Register \n6.16.3 Read Sector Protection Register\nTo read the Sector Protection Register, an opcode of 32h and three dummy bytes must be clocked into the device. After \nt\nhe last bit of the opcode and dummy bytes have been clocked in, any additional clock pulses on the SCK pin will result \nin the Sector Protection Register contents being output on the SO pin. The first byte (byte location 0) corresponds to \nSector 0 (0a and 0b), the second byte corresponds to Sector 1, and the last byte (byte location 63) corresponds to Sector \n63. Once the last byte of the Sector Protection Register has been clocked out, any additional clock pulses will result in\nundefined data being output on the SO pin. The CS  pin must be deasserted to terminate the Read Sector Protection\nRegister operation and put the output into a high-impedance state.\nTable 6-12. Read Sector Protection Register Command\nNote: 1. XX = Dummy byteCommand Byte 1 Byte 2 Byte 3 Byte 4\nProgram Sector Protection Register 3Dh 2Ah 7Fh FCh\nData Byte\nn3Dh 2Ah 7Fh FChData Byte\nn + 1Data Byte\nn + 63CS\nEach transition represents eight bitsSI\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nRead Sector Protection Register 32h XXh XXh XXh\n\n 22 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 6-7. Read Sector Protection Register\n6.16.4 About the Sector Protection Register\nThe Sector Protection Register is subject to a limit of 10,000 erase/program cycles. Users are encouraged to carefully \ne\nvaluate the number of times the Sector Protection Register will be modified during the course of the application’s life \ncycle. If the application requires that the Security Protection Register be modified more than the specified limit of 10,000 \ncycles because the application needs to temporarily unprotect individual sectors (sector protection remains enabled \nwhile the Sector Protection Register is reprogrammed), then the application will need to limit this practice. Instead, a \ncombination of temporarily unprotecting individual sectors along with disabling sector protection completely will need to \nbe implemented by the application to ensure that the limit of 10,000 cycles is not exceeded.\n7. Security Features\n7.1 Sector Lockdown\nThe device incorporates a sector lockdown mechanism that allows each individual sector to be permanently locked so\nt\nhat it becomes read-only (ROM). This is useful for applications that require the ability to permanently protect a number of\nsectors against malicious attempts at altering program code or security information.\nWarning: Once a sector is locked down, it can never be erased or programmed, and it can never be unlocked.\nT\no issue the sector lockdown command, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and 30h must be clocked into\nthe device followed by three address bytes specifying any address within the sector to be locked down. After the last\naddress bit has been clocked in, the CS  pin must be deasserted to initiate the internally self-timed lockdown sequence.\nThe lockdown sequence should take place in a maximum time of tP. During this time, the RDY/BUSY  bit in the Status\nRe\ngister will indicate that the device is busy. If the device is powered-down before the completion of the lockdown\nsequence, then the lockdown status of the sector cannot be guaranteed. In this case, it is recommended that the user\nread the Sector Lockdown Register to determine the status of the appropriate sector lockdown bits or bytes and re-issue\nthe Sector Lockdown command if necessary.\nTable 7-1. Sector Lockdown Command32h XX XX XX\nData\nnData\nn + 1CS\nSI\nSOData\nn + 63\nEach transition represents eight bits\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nSector Lockdown 3Dh 2Ah 7Fh 30h\n\n 23 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 7-1. Sector Lockdown\n7.1.1 Read Sector Lockdown Register\nThe nonvolatile Sector Lockdown Register specifies which sectors in the main memory are currently unlocked or have \nb\neen permanently locked down. The Sector Lockdown Register is a read-only register and contains 64 bytes of data \nwhich correspond to Sectors 0 through 63. To read the Sector Lockdown Register, an opcode of 35h must be clocked \ninto the device followed by three dummy bytes. After the last bit of the opcode and dummy bytes have been clocked in, \nthe data for the contents of the Sector Lockdown Register will be clocked out on the SO pin. The first byte (byte  \nlocation 0) corresponds to Sector 0 (0a and 0b), the second byte corresponds to Sector 1, and the last byte (byte location \n63) corresponds to Sector 63. After the last byte of the Sector Lockdown Register has been read, additional pulses on\nthe SCK pin will result in undefined data being output on the SO pin.\nDeasserting the CS  pin will terminate the Read Sector Lockdown Register operation and put the SO pin into a \nhigh-impedance state. Table 7-2  details the format the Sector Lockdown Register.\nTable 7-2. Sector Lockdown Register \nT\nable 7-3. Sector 0 (0a and 0b) Sector Lockdown Register Byte Value\nTable 7-4. Read Sector Lockdown Register Command3Dh 2Ah 7Fh 30hCS\nAddress\nbyteAddress\nbyteAddress\nbyteSI\nEach transition represents eight bits\nSector Number 0 (0a, 0b) 1 to 63\nLocked\nSee Table 7-3FFh\nUnlocked 00h\nBit 7:6 Bit 5:4 Bit 3:2 Bit 1:0\nData \nValueSector 0a\n(Page 0-7)Sector 0b\n(Page 8-127) N/A N/A\nSectors 0a and 0b Unlocked 00 00 00 00 00h\nSector 0a Locked 11 00 00 00 C0h\nSector 0b Locked 00 11 00 00 30h\nSectors 0a and 0b Locked 11 11 00 00 F0h\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nRead Sector Lockdown Register 35h XXh XXh XXh\n\n 24 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 7-2. Read Sector Lockdown Register\n7.1.2 Freeze Sector Lockdown \nThe Sector Lockdown command can be permanently disabled, and the current sector lockdown state can be \np\nermanently frozen so that no additional sectors can be locked down aside from those already locked down. Any \nattempts to issue the Sector Lockdown command after the Sector Lockdown State has been frozen will be ignored.\nTo issue the Freeze Sector Lockdown command, the CS  pin must be asserted and the opcode sequence of 34h, 55h, \nAAh, and 40h must be clocked into the device. Any additional data clocked into the device will be ignored. When the CS  \npin is deasserted, the current sector lockdown state will be permanently frozen within a time of tLOCK. In addition, the SLE \nb\nit in the Status Register will be permanently reset to a Logic 0 to indicate that the Sector Lockdown command is \npermanently disabled.\nTable 7-5. Freeze Sector Lockdown \nF\nigure 7-3. Freeze Sector Lockdown \n7.2 Security Register\nThe device contains a specialized Security Register that can be used for purposes such as unique device serialization or \nl\nocked key storage. The register is comprised of a total of 128 bytes that is divided into two portions. The first 64 bytes \n(byte locations 0 through 63) of the Security Register are allocated as a One-Time Programmable space. Once these 64 \nbytes have been programmed, they cannot be erased or reprogrammed. The remaining 64 bytes of the register (byte \nlocations 64 through 127) are factory programmed by Adesto and will contain a unique value for each device. The factory \nprogrammed data is fixed and cannot be changed.\nTable 7-6. Security Register35h XX XX XX\nData\nnData\nn + 1CS\nSI\nSOData\nn + 63\nEach transition represents eight bits\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nFreeze Sector Lockdown 34h 55h AAh 40h\n34h 55h AAh 40hCS\nSI\nEach transition represents eight bits\nSecurity Register Byte Number\n0 1 · · · 63 64 65 · · · 127\nData Type One-Time User Programmable Factory Programmed by Adesto\n\n 25 AT45DB321E \n 8784M–DFLASH–02/2022\n7.2.1 Programming the Security Register\nThe user programmable portion of the Security Register does not need to be erased before it is programmed.\nT\no program the Security Register, a 4-byte opcode sequence of 9Bh, 00h, 00h, and 00h must be clocked into the device. \nAfter the last bit of the opcode sequence has been clocked into the device, the data for the contents of the 64-byte user \nprogrammable portion of the Security Register must be clocked in.\nAfter the last data byte has been clocked in, the CS  pin must be deasserted to initiate the internally self-timed program \ncycle. The programming of the Security Register should take place in a time of tP, during which time the RDY/BUSY  bit in \nth\ne Status Register will indicate that the device is busy. If the device is powered-down during the program cycle, then the \ncontents of the 64-byte user programmable portion of the Security Register cannot be guaranteed.\nIf the full 64 bytes of data are not clocked in before the CS  pin is deasserted, then the values of the byte locations not \nclocked in cannot be guaranteed. \nExample: If only the first two bytes are clocked in instead of the complete 64 bytes, then the remaining 62 bytes of the \nuser programmable portion of the Security Register cannot be guaranteed. Furthermore, if more than  \n64 bytes of data is clocked into the device, then the data will wrap back around to the beginning of the \nregister. For example, if 65 bytes of data are clocked in, then the 65th byte will be stored at byte location 0 of \nthe Security Register.\nWarning: The user programmable portion of the Security Register can only be programmed one time.  \nT\nherefore, it is not possible, for example, to only program the first two bytes of the register and then program \nthe remaining 62 bytes at a later time.\nThe Program Security Register command utilizes Buffer 1 for processing. Therefore, the contents of Buffer \n1 will be altered from its previous state when this command is issued.\nFigure 7-4. Program Security Register\n7.2.2 Reading the Security Register\nTo read the Security Register, an opcode of 77h and three dummy bytes must be clocked into the device. After the last \nd\nummy bit has been clocked in, the contents of the Security Register can be clocked out on the SO pin. After the last \nbyte of the Security Register has been read, additional pulses on the SCK pin will result in undefined data being output \non the SO pin.\nDeasserting the CS  pin will terminate the Read Security Register operation and put the SO pin into a high-impedance \nstate.\nTable 7-7. Read Security RegisterData\nn9Bh 00h 00h 00hData\nn + 1Data\nn + xCS\nSI\nEach transition represents eight bits\n77h XX XX XX\nData\nnData \nn + 1CS\nData\nn + xSI\nSO\nEach transition represents eight bits\n\n 26 AT45DB321E \n 8784M–DFLASH–02/2022\n8. Additional Commands\n8.1 Main Memory Page to Buffer Transfer\nA page of data can be transferred from the main memory to either Buffer 1 or Buffer 2. To transfer a page of data using\nt\nhe standard DataFlash page size (528 bytes), an opcode of 53h for Buffer 1 or 55h for Buffer 2 must be clocked into the\ndevice followed by three address bytes comprised of one dummy bit, 13 page address bits (PA12 - PA0) which specify\nthe page in main memory to be transferred, and 10 dummy bits. To transfer a page of data using the binary page size\n(512 bytes), an opcode of 53h for Buffer 1 and 55h for Buffer 2 must be clocked into the device followed by three address\nbytes comprised of two dummy bits, 13 page address bits (A21 - A9) which specify the page in the main memory to be\ntransferred, and nine dummy bits.\nThe CS  pin must be low while toggling the SCK pin to load the opcode and the three address bytes from the input pin\n(SI). The transfer of the page of data from the main memory to the buffer will begin when the CS  pin transitions from a\nlow to a high state. During the page transfer time (tXFR), the RDY/BUSY  bit in the Status Register can be read to\ndetermine whether or not the transfer has been completed.\n8.2 Main Memory Page to Buffer Compare\nA page of data in main memory can be compared to the data in Buffer 1 or Buffer 2 as a method to ensure that data was\ns\nuccessfully programmed after a Buffer to Main Memory Page Program command. To compare a page of data with the\nstandard DataFlash page size (528 bytes), an opcode of 60h for Buffer 1 or 61h for Buffer 2 must be clocked into the\ndevice followed by three address bytes comprised of one dummy bit, 13 page address bits (PA12 - PA0) which specify\nthe page in the main memory to be compared to the buffer, and 10 dummy bits. To compare a page of data with the\nbinary page size (512 bytes), an opcode of 60h for Buffer 1 or 61h for Buffer 2 must be clocked into the device followed\nby three address bytes comprised of two dummy bits, 13 page address bits (A21 - A9) which specify the page in the main\nmemory to be compared to the buffer, and nine dummy bits.\nThe CS  pin must be low while toggling the SCK pin to load the opcode and the address bytes from the input pin (SI). On\nthe low-to-high transition of the CS  pin, the data bytes in the selected Main Memory Page will be compared with the data\nbytes in Buffer 1 or Buffer 2. During the compare time (tCOMP ), the RDY/BUSY  bit in the Status Register will indicate that\nthe part is busy. On completion of the compare operation, bit 6 of the Status Register will be updated with the result of the\ncompare.\n8.3 Auto Page Rewrite\nThis command only needs to be used if the possibility exists that static (non-changing) data may be stored in a page or\np\nages of a sector and the other pages of the same sector are erased and programmed a large number of times.\nApplications that modify data in a random fashion within a sector may fall into this category. To preserve data integrity of\na sector, each page within a sector must be updated/rewritten at least once within every 50,000 cumulative page\nerase/program operations within that sector. The Auto Page Rewrite command provides a simple and efficient method to\n“refresh” a page in the main memory array in a single operation.\nThe Auto Page Rewrite command is a combination of the Main Memory Page to Buffer Transfer and Buffer to Main\nMemory Page Program with Built-In Erase commands. With the Auto Page Rewrite command, a page of data is first\ntransferred from the main memory to Buffer 1 or Buffer 2 and then the same data (from Buffer 1 or Buffer 2) is\nprogrammed back into the same page of main memory, essentially “refreshing” the contents of that page. To start the\nAuto Page Rewrite operation with the standard DataFlash page size (528 bytes), a 1-byte opcode, 58H for Buffer 1 or\n59H for Buffer 2, must be clocked into the device followed by three address bytes comprised of one dummy bit, 13 page\naddress bits (PA12-PA0) that specify the page in main memory to be rewritten, and 10 dummy bits.\nTo initiate an Auto Page Rewrite with the a binary page size (512 bytes), the opcode 58H for Buffer 1 or 59H for Buffer 2,\nmust be clocked into the device followed by three address bytes consisting of two dummy bits, 13 page address bits\n(A21 - A9) that specify the page in the main memory that is to be rewritten, and nine dummy bits. When a low-to-high\ntransition occurs on the CS  pin, the part will first transfer data from the page in main memory to a buffer and then\n\n 27 AT45DB321E \n 8784M–DFLASH–02/2022\nprogram the data from the buffer back into same page of main memory. The operation is internally self-timed and should \ntake place in a maximum time of tEP. During this time, the RDY/BUSY  Status Register will indicate that the part is busy.\nIf a sector is programmed or reprogrammed sequentially page by page and the possibility does not exist that there will be \na page or pages of static data, then the programming algorithm shown in Figure 25-1 on page 61  is recommended. \nOt\nherwise, if there is a chance that there may be a page or pages of a sector that will contain static data, then the \nprogramming algorithm shown in Figure 25-2 on page 62  is recommended. \nPl\nease contact Adesto for availability of devices that are specified to exceed the 50,000 cycle cumulative limit.\n8.4 Status Register Read\nThe 2-byte Status Register can be used to determine the device\'s ready/busy status, page size, a Main Memory Page to \nB\nuffer Compare operation result, the sector protection status, Freeze Sector Lockdown status, erase/program error \nstatus, Program/Erase Suspend status, and the device density. The Status Register can be read at any time, including \nduring an internally self-timed program or erase operation. \nTo read the Status Register, the CS  pin must first be asserted and then the opcode D7h must be clocked into the device. \nAfter the opcode has been clocked in, the device will begin outputting Status Register data on the SO pin during every \nsubsequent clock cycle. After the second byte of the Status Register has been clocked out, the sequence will repeat \nitself, starting again with the first byte of the Status Register, as long as the CS  pin remains asserted and the clock pin is \nbeing pulsed. The data in the Status Register is constantly being updated, so each repeating sequence may output new \ndata. The RDY/BUSY  status is available for both bytes of the Status Register and is updated for each byte.\nDeasserting the CS  pin will terminate the Status Register Read operation and put the SO pin into a high-impedance \nstate. The CS  pin can be deasserted at any time and does not require that a full byte of data be read.\nTable 8-1. Status Register Format – Byte 1\nNote: 1. R = Readable onlyBit Name Type(1)Description\n7 RDY/BUSY Ready/Busy Status R0 Device is busy with an internal operation.\n1 Device is ready.\n6 COMP Compare Result R0 Main memory page data matches buffer data.\n1 Main memory page data does not match buffer data.\n5:2 DENSITY Density Code R 1101 32-Mbit\n1 PROTECT Sector Protection Status R0 Sector protection is disabled.\n1 Sector protection is enabled.\n0 PAGE SIZE Page Size Configuration R0 Device is configured for standard DataFlash page size (528 bytes).\n1 Device is configured for “power of 2” binary page size (512 bytes).\n\n 28 AT45DB321E \n 8784M–DFLASH–02/2022\nTable 8-2. Status Register Format – Byte 2\nNote: 1. R = Readable only\n8.4.1 RDY/BUSY  Bit\nThe RDY/BUSY  bit is used to determine whether or not an internal operation, such as a program or erase, is in progress. \nTo poll the RDY/BUSY  bit to detect the completion of an internally timed operation, new Status Register data must be \ncontinually clocked out of the device until the state of the RDY/BUSY  bit changes from a Logic 0 to a Logic 1.\n8.4.2 COMP Bit\nThe result of the most recent Main Memory Page to Buffer Compare operation is indicated using the COMP bit. If the \nC\nOMP bit is a Logic 1, then at least one bit of the data in the Main Memory Page does not match the data in the buffer.\n8.4.3 DENSITY Bits\nThe device density is indicated using the DENSITY bits. For the AT45DB321E, the four bit binary value is 1101. The \nd\necimal value of these four binary bits does not actually equate to the device density; the four bits represent a \ncombinational code relating to differing densities of DataFlash devices. The DENSITY bits are not the same as the \ndensity code indicated in the JEDEC Device ID information. The DENSITY bits are provided only for backward \ncompatibility to older generation DataFlash devices.\n8.4.4 PROTECT Bit\nThe PROTECT bit provides information to the user on whether or not the sector protection has been enabled or disabled, \ne\nither by the software-controlled method or the hardware-controlled method. \n8.4.5 PAGE SIZE Bit\nThe PAGE SIZE bit indicates whether the buffer size and the page size of the main memory array is configured for the \n“\npower of 2” binary page size (512 bytes) or the standard DataFlash page size (528 bytes). Bit Name Type(1)Description\n7 RDY/BUSY Ready/Busy Status R0 Device is busy with an internal operation.\n1 Device is ready.\n6 RES Reserved for Future Use R 0 Reserved for future use.\n5 EPE Erase/Program Error R0 Erase or program operation was successful.\n1 Erase or program error detected.\n4 RES Reserved for Future Use R 0 Reserved for future use.\n3 SLE Sector Lockdown Enabled R0 Sector Lockdown command is disabled.\n1 Sector Lockdown command is enabled.\n2 PS2Program Suspend Status \n(Buffer 2)R0 No program operation has been suspended while using Buffer 2.\n1 A sector is program suspended while using Buffer 2.\n1 PS1Program Suspend Status \n(Buffer 1)R0 No program operation has been suspended while using Buffer 1.\n1 A sector is program suspended while using Buffer 1.\n0 ES Erase Suspend R0 No sectors are erase suspended.\n1 A sector is erase suspended.\n\n 29 AT45DB321E \n 8784M–DFLASH–02/2022\n8.4.6 EPE Bit \nThe EPE bit indicates whether the last erase or program operation completed successfully or not. If at least one byte \nd\nuring the erase or program operation did not erase or program properly, then the EPE bit will be set to the Logic 1 state. \nThe EPE bit will not be set if an erase or program operation aborts for any reason, such as an attempt to erase or \nprogram a protected region or a locked down sector or an attempt to erase or program a suspended sector. The EPE bit \nis updated after every erase and program operation.\n8.4.7 SLE Bit\nThe SLE bit indicates whether or not the Sector Lockdown command is enabled or disabled. If the SLE bit is a Logic 1, \nt\nhen the Sector Lockdown command is still enabled and sectors can be locked down. If the SLE bit is a Logic 0, then the \nSector Lockdown command has been disabled and no further sectors can be locked down.\n8.4.8 PS2 Bit\nThe PS2 bit indicates if a program operation has been suspended while using Buffer 2. If the PS2 bit is a Logic 1, then a \np\nrogram operation has been suspended while Buffer 2 was being used, and any command attempts that would modify \nthe contents of Buffer 2 will be ignored.\n8.4.9 PS1 Bit\nThe PS1 bit indicates if a program operation has been suspended while using Buffer 1. If the PS1 bit is a Logic 1, then a \np\nrogram operation has been suspended while Buffer 1 was being used, and any command attempts that would modify \nthe contents of Buffer 1 will be ignored.\n8.4.10 The ES bit\nThe ES bit indicates whether or not an erase has been suspended. If the ES bit is a Logic 1, then an erase operation \n(\npage, block or sector) has been suspended.\n\n 30 AT45DB321E \n 8784M–DFLASH–02/2022\n9. Deep Power-Down\nDuring normal operation, the device will be placed in the standby mode to consume less power as long as the CS  pin\nremains deasserted and no internal operation is in progress. The Deep Power-Down command offers the ability to place\nthe device into an even lower power consumption state called the Deep Power-Down mode.\nWhen the device is in the Deep Power-Down mode, all commands including the Status Register Read command will be\nignored with the exception of the Resume from Deep Power-Down command. Since all commands will be ignored, the\nmode can be used as an extra protection mechanism against program and erase operations.\nEntering the Deep Power-Down mode is accomplished by simply asserting the CS  pin, clocking in the opcode B9h, and\nthen deasserting the CS  pin. Any additional data clocked into the device after the opcode will be ignored. When the CS\npi\nn is deasserted, the device will enter the Deep Power-Down mode within the maximum time of tEDPD.\nT\nhe complete opcode must be clocked in before the CS  pin is deasserted, and the CS  pin must be deasserted on an\neven byte boundary (multiples of eight bits); otherwise, the device will abort the operation and return to the standby mode\nonce the CS  pin is deasserted. In addition, the device will default to the standby mode after a power cycle.\nThe Deep Power-Down command will be ignored if an internally self-timed operation such as a program or erase cycle is\nin progress. The Deep Power-Down command must be reissued after the internally self-timed operation has been\ncompleted in order for the device to enter the Deep Power-Down mode.\nFigure 9-1. Deep Power-Down\nSCKCS\nSI\nSOMSB\nICC2 3 1 0\n1 0 1 1 1 0 0 16 7 5 4\nOpcode\nHigh-impedance\nStandby Mode CurrentActive Current\nDeep Power-Down Mode CurrenttEDPD\n\n 31 AT45DB321E \n 8784M–DFLASH–02/2022\n9.1 Resume from Deep Power-Down\nIn order to exit the Deep Power-Down mode and resume normal device operation, the Resume from Deep Power-Down \nc\nommand must be issued. The Resume from Deep Power-Down command is the only command that the device will \nrecognize while in the Deep Power-Down mode.\nTo resume from the Deep Power-Down mode, the CS  pin must first be asserted and then the opcode ABh must be \nclocked into the device. Any additional data clocked into the device after the opcode will be ignored. When the CS  pin is \ndeasserted, the device will exit the Deep Power-Down mode and return to the standby mode within the maximum time of \ntRDPD. After the device has returned to the standby mode, normal command operations such as Continuous Array Read \nc\nan be resumed.\nIf the complete opcode is not clocked in before the CS  pin is deasserted, or if the CS  pin is not deasserted on an even \nbyte boundary (multiples of eight bits), then the device will abort the operation and return to the Deep Power-Down \nmode.\nFigure 9-2. Resume from Deep Power-Down\nSCKCS\nSI\nSOMSB\nICC2 3 1 0\n1 0 1 0 1 0 1 16 7 5 4\nOpcode\nHigh-impedance\nDeep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttRDPD\n\n 32 AT45DB321E \n 8784M–DFLASH–02/2022\n9.2 Ultra-Deep Power-Down\nThe Ultra-Deep Power-Down mode allows the device to consume far less power compared to the standby and Deep \nP\nower-Down modes by shutting down additional internal circuitry. Since almost all active circuitry is shutdown in this \nmode to conserve power, the contents of the SRAM buffers cannot be maintained. Therefore, any data stored in the \nSRAM buffers will be lost once the device enters the Ultra-Deep Power-Down mode.\nWhen the device is in the Ultra-Deep Power-Down mode, all commands including the Status Register Read and Resume \nfrom Deep Power-Down commands will be ignored. Since all commands will be ignored, the mode can be used as an \nextra protection mechanism against program and erase operations.\nEntering the Ultra-Deep Power-Down mode is accomplished by simply asserting the CS  pin, clocking in the opcode 79h, \nand then deasserting the CS  pin. Any additional data clocked into the device after the opcode will be ignored. When the \nCS pin is deasserted, the device will enter the Ultra-Deep Power-Down mode within the maximum time of tEUDPD .\nT\nhe complete opcode must be clocked in before the CS  pin is deasserted, and the CS  pin must be deasserted on an \neven byte boundary (multiples of eight bits); otherwise, the device will abort the operation and return to the standby mode \nonce the CS  pin is deasserted. In addition, the device will default to the standby mode after a power cycle.\nThe Ultra-Deep Power-Down command will be ignored if an internally self-timed operation such as a program or erase \ncycle is in progress. The Ultra-Deep Power-Down command must be reissued after the internally self-timed operation \nhas been completed in order for the device to enter the Ultra-Deep Power-Down mode.\nFigure 9-3. Ultra-Deep Power-Down\nSCKCS\nSI\nSOMSB\nICC2 3 1 0\n06 7 5 4\nOpcode\nHigh-impedance\nUltra-Deep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttEUDPD\n1 1 1 1 0 0 1\n\n 33 AT45DB321E \n 8784M–DFLASH–02/2022\n9.2.1 Exit Ultra-Deep Power-Down\nTo exit from the Ultra-Deep Power-Down mode, the CS  pin must simply be pulsed by asserting the CS  pin, waiting the \nminimum necessary tCSLU time, and then deasserting the CS  pin again. To facilitate simple software development, a \ndummy byte opcode can also be entered while the CS  pin is being pulsed just as in a normal operation like the Program \nSuspend operation; the dummy byte opcode is simply ignored by the device in this case. After the CS  pin has been \ndeasserted, the device will exit from the Ultra-Deep Power-Down mode and return to the standby mode within a \nmaximum time of tXUDPD . If the CS  pin is reasserted before the tXUDPD  time has elapsed in an attempt to start a new \no\nperation, then that operation will be ignored and nothing will be performed. The system must wait for the device to return \nto the standby mode before normal command operations such as Continuous Array Read can be resumed.\nSince the contents of the SRAM buffers cannot be maintained while in the Ultra-Deep Power-Down mode, the SRAM \nbuffers will contain undefined data when the device returns to the standby mode.\nFigure 9-4. Exit Ultra-Deep Power-Down\nCS\nSO\nICCHigh-impedance\nUltra-Deep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttXUDPDtCSLU\n\n 34 AT45DB321E \n 8784M–DFLASH–02/2022\n10. Buffer and Page Size Configuration\nThe memory array of DataFlash devices is actually larger than other Serial Flash devices in that extra user-accessible\nb\nytes are provided in each page of the memory array. For the AT45DB321E, there are an extra 16 bytes of memory in\neach page for a total of an extra 128KB (1-Mbits) of user-accessible memory. Therefore, the device density is actually\n33-Mbits instead of 32-Mbits.\nSome applications, however, may not want to take advantage of this extra memory and instead architect their software to \noperate on a “power of 2” binary, logical addressing scheme. To allow this, the DataFlash can be configured so that the \nbuffer and page sizes are 512 bytes instead of the standard 528 bytes. In addition, the configuration of the buffer and \npage sizes is reversible and can be changed from 528 bytes to 512 bytes or from 512 bytes to 528 bytes. The configured \nsetting is stored in an internal nonvolatile register so that the buffer and page size configuration is not affected by power \ncycles. The nonvolatile register has a limit of 10,000 erase/program cycles; therefore, care should be taken to not switch \nbetween the size options more than 10,000 times.\nDevices are initially shipped from Adesto with the buffer and page sizes set to 528 bytes. Devices can be ordered from \nAdesto pre-configured for the “power of 2” binary size of 512 bytes. For details, see Section 26., Ordering Information on \npa\nge 63 .\nTo\n configure the device for “power of 2” binary page size (512 bytes), a 4-byte opcode sequence of 3Dh, 2Ah, 80h, and \nA6h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the CS  pin must be \ndeasserted to initiate the internally self-timed configuration process and nonvolatile register program cycle. The \nprogramming of the nonvolatile register should take place in a time of tEP, during which time the RDY/BUSY  bit in the \nSt\natus Register will indicate that the device is busy. The device does not need to be power cycled after the completion of \nthe configuration process and register program cycle in order for the buffer and page size to be configured to 512 bytes. \nTo configure the device for standard DataFlash page size (528 bytes), a 4-byte opcode sequence of 3Dh, 2Ah, 80h, and \nA7h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the CS  pin must be \ndeasserted to initial the internally self-timed configuration process and nonvolatile register program cycle. The \nprogramming of the nonvolatile register should take place in a time of tEP, during which time the RDY/BUSY  bit in the \nSt\natus Register will indicate that the device is busy. The device does not need to be power cycled after the completion of \nthe configuration process and register program cycle in order for the buffer and page size to be configured to 528 bytes.\nTable 10-1. Buffer and Page Size Configuration Commands\nF\nigure 10-1. Buffer and Page Size ConfigurationCommand Byte 1 Byte 2 Byte 3 Byte 4\n“Power of 2” binary page size (512 bytes) 3Dh 2Ah 80h A6h\nDataFlash page size (528 bytes) 3Dh 2Ah 80h A7h\nCS\nSI 3Dh 2Ah 80hOpcode\nByte 4\nEach transition represents eight bits\n\n 35 AT45DB321E \n 8784M–DFLASH–02/2022\n11. Manufacturer and Device ID Read\nIdentification information can be read from the device to enable systems to electronically query and identify the device\nw\nhile it is in the system. The identification method and the command opcode comply with the JEDEC Standard for\n“Manufacturer and Device ID Read Methodology for SPI Compatible Serial Interface Memory Devices”. The type of\ninformation that can be read from the device includes the JEDEC-defined Manufacturer ID, the vendor-specific\nDevice ID, and the vendor-specific Extended Device Information.\nThe Read Manufacturer and Device ID command is limited to a maximum clock frequency of fCLK. Since not all Flash\nd\nevices are capable of operating at very high clock frequencies, applications should be designed to read the\nidentification information from the devices at a reasonably low clock frequency to ensure that all devices to be used in the\napplication can be identified properly. Once the identification process is complete, the application can then increase the\nclock frequency to accommodate specific Flash devices that are capable of operating at the higher clock frequencies.\nTo read the identification information, the CS  pin must first be asserted and then the opcode 9Fh must be clocked into\nthe device. After the opcode has been clocked in, the device will begin outputting the identification data on the SO pin\nduring the subsequent clock cycles. The first byte to be output will be the Manufacturer ID, followed by two bytes of the\nDevice ID information. The fourth byte output will be the Extended Device Information (EDI) String Length, which will be\n01h indicating that one byte of EDI data follows. After the one byte of EDI data is output, the SO pin will go into a\nhigh-impedance state; therefore, additional clock cycles will have no affect on the SO pin and no data will be output. As\nindicated in the JEDEC Standard, reading the EDI String Length and any subsequent data is optional.\nDeasserting the CS  pin will terminate the Manufacturer and Device ID Read operation and put the SO pin into a\nhigh-impedance state. The CS  pin can be deasserted at any time and does not require that a full byte of data be read.\nTable 11-1. Manufacturer and Device ID Information\nByte No. Data Type Value\n1 Manufacturer ID 1Fh\n2 Device ID (Byte 1) 27h\n3 Device ID (Byte 2) 01h\n4 Extended Device Information (EDI) String Length 01h\n5 [Optional to Read] EDI Byte 1 00h\nTable 11-2. Manufacturer and Device ID Details\nData Type Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0Hex\nValue Details\nManufacturer IDJEDEC Assigned Code\n1Fh JEDEC code: 0001 1111 (1Fh for Adesto)\n0 0 0 1 1 1 1 1\nDevice ID (Byte 1)Family Code Density Code\n27hFamily code: 001 (AT45Dxxx Family)  \nDensity code: 00111 (32-Mbit)0 0 1 0 0 1 1 1\nDevice ID (Byte 2)Sub Code Product Variant\n01hSub code: 000 (Standard Series)  \nProduct variant:000010 0 0 0 0 0 0 1\n\n 36 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 11-1. Read Manufacturer and Device IDTable 11-3. EDI Data\nByte Number Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0Hex\nValue Details\n5RFU Device Revision\n00hRFU: Reserved for Future Use  \nDevice revision:00000 (Initial Version)0 0 0 0 0 0 0 0\nSCKCS\nSI\nSO6 0\n9Fh8 7 46\nOpcode\n1Fh 01h 01h 00h\nManufacturer ID Device ID\nByte 1Device ID\nByte 2EDI\nString LengthEDI\nData Byte 1High-impedance14 16 15 22 24 23 38 40 39 30 32 31\nNote:  Each transition shown for SI and SO represents one byte (8 bits)27h\n\n 37 AT45DB321E \n 8784M–DFLASH–02/2022\n12. Software Reset\nIn some applications, it may be necessary to prematurely terminate a program or erase cycle early rather than wait the\nh\nundreds of microseconds or milliseconds necessary for the program or erase operation to complete normally. The\nSoftware Reset command allows a program or erase operation in progress to be ended abruptly and returns the device\nto an idle state.\nTo perform a Software Reset, the CS  pin must be asserted and a 4-byte command sequence of F0h, 00h, 00h, and 00h\nmust be clocked into the device. Any additional data clocked into the device after the last byte will be ignored. When the\nCS pin is deasserted, the program or erase operation currently in progress will be terminated within a time tSWRST . Since\nt\nhe program or erase operation may not complete before the device is reset, the contents of the page being programmed\nor erased cannot be guaranteed to be valid.\nThe Software Reset command has no effect on the states of the Sector Protection Register, the Sector Lockdown\nRegister, or the buffer and page size configuration. The PS2, PS1, and ES bits of the Status Register, however, will be\nreset back to their default states. If a Software Reset operation is performed while a sector is erase suspended, the\nsuspend operation will abort and the contents of the page or block being erased in the suspended sector will be left in an\nundefined state. If a Software Reset is performed while a sector is program suspended, the suspend operation will abort\nand the contents of the page that was being programmed and subsequently suspended will be undefined. The remaining\npages in the sector will retain their previous contents.\nThe complete 4-byte opcode must be clocked into the device before the CS  pin is deasserted, and the CS  pin must be\ndeasserted on a byte boundary (multiples of eight bits); otherwise, no reset operation will be performed.\nTable 12-1. Software Reset\nF\nigure 12-1. Software ResetCommand Byte 1 Byte 2 Byte 3 Byte 4\nSoftware Reset F0h 00h 00h 00h\nCS\nSI F0h 00h 00h 00h\nEach transition represents eight bits\n\n 38 AT45DB321E \n 8784M–DFLASH–02/2022\n13. Operation Mode Summary\nThe commands described previously can be grouped into four different categories to better describe which commands\nc\nan be executed at what times.\nGroup A commands consist of:\n1. Main Memory Page Read\n2\n. Continuous Array Read (SPI)\n3. Read Sector Protection Register\n4. Read Sector Lockdown Register\n5. Read Security Register\n6. Buffer 1 (or 2) Read\nGroup B commands consist of:\n1. Page Erase\n2\n. Block Erase\n3. Sector Erase\n4. Chip Erase\n5. Main Memory Page to Buffer 1 (or 2) Transfer\n6. Main Memory Page to Buffer 1 (or 2) Compare\n7. Buffer 1 (or 2) to Main Memory Page Program with Built-In Erase\n8. Buffer 1 (or 2) to Main Memory Page Program without Built-In Erase\n9. Main Memory Page Program through Buffer 1 (or 2) with Built-In Erase\n10. Main Memory Byte/Page Program through Buffer 1 without Built-In Erase\n11. Auto Page Rewrite\nGroup C commands consist of:\n1. Buffer 1 (or 2) Write\n2\n. Status Register Read\n3. Manufacturer and Device ID Read\nGroup D commands consist of:\n1. Erase Sector Protection Register\n2\n. Program Sector Protection Register\n3. Sector Lockdown\n4. Program Security Register\n5. Buffer and Page Size Configuration\n6. Freeze Sector Lockdown\nIf a Group A command is in progress (not fully completed), then another command in Group A, B, C, or D should not be \nstarted. However, during the internally self-timed portion of Group B commands, any command in Group C can be \nexecuted. The Group B commands using Buffer 1 should use Group C commands using Buffer 2 and vice versa. Finally, \nduring the internally self-timed portion of a Group D command, only the Status Register Read command should be \nexecuted.\nMost of the commands in Group B can be suspended and resumed, except the Buffer Transfer, Buffer Compare, and \nAuto Page Rewrite operations. If a Group B command is suspended, all of the Group A commands can be executed. See \nTable 6-4  to determine which of the Group B, Group C, and Grou p  D commands are allowed.\n\n 39 AT45DB321E \n 8784M–DFLASH–02/2022\n14. Command Tables\nTable 14-1. Read Commands\nT\nable 14-2. Program and Erase CommandsCommand Opcode\nMain Memory Page Read D2h\nContinuous Array Read (Low Power Mode) 01h\nContinuous Array Read (Low Frequency) 03h\nContinuous Array Read (High Frequency) 0Bh\nContinuous Array Read (High Frequency) 1Bh\nContinuous Array Read (Legacy Command – Not Recommended for New Designs) E8h\nBuffer 1 Read (Low Frequency) D1h\nBuffer 2 Read (Low Frequency) D3h\nBuffer 1 Read (High Frequency) D4h\nBuffer 2 Read (High Frequency) D6h\nCommand Opcode\nBuffer 1 Write 84h\nBuffer 2 Write 87h\nBuffer 1 to Main Memory Page Program with Built-In Erase 83h\nBuffer 2 to Main Memory Page Program with Built-In Erase 86h\nBuffer 1 to Main Memory Page Program without Built-In Erase 88h\nBuffer 2 to Main Memory Page Program without Built-In Erase 89h\nMain Memory Page Program through Buffer 1 with Built-In Erase 82h\nMain Memory Page Program through Buffer 2 with Built-In Erase 85h\nMain Memory Byte/Page Program through Buffer 1 without Built-In Erase 02h\nPage Erase 81h\nBlock Erase 50h\nSector Erase 7Ch\nChip Erase C7h + 94h + 80h + 9Ah\nProgram/Erase Suspend B0h\nProgram/Erase Resume D0h\nRead-Modify-Write through Buffer 1 58h\nRead-Modify-Write through Buffer 2 59h\n\n 40 AT45DB321E \n 8784M–DFLASH–02/2022\nTable 14-3. Protection and Security Commands\nTable 14-4. Additional Commands\nTable 14-5. Legacy Commands(1)\nNote: 1. Legacy commands are not recommended for new designs.Command Opcode\nEnable Sector Protection 3Dh + 2Ah + 7Fh + A9h\nDisable Sector Protection 3Dh + 2Ah + 7Fh + 9Ah\nErase Sector Protection Register 3Dh + 2Ah + 7Fh + CFh\nProgram Sector Protection Register 3Dh + 2Ah + 7Fh + FCh\nRead Sector Protection Register 32h\nSector Lockdown 3Dh + 2Ah + 7Fh + 30h\nRead Sector Lockdown Register 35h\nFreeze Sector Lockdown 34h + 55h + AAh + 40h\nProgram Security Register 9Bh + 00h + 00h + 00h\nRead Security Register 77h\nCommand Opcode\nMain Memory Page to Buffer 1 Transfer 53h\nMain Memory Page to Buffer 2 Transfer 55h\nMain Memory Page to Buffer 1 Compare 60h\nMain Memory Page to Buffer 2 Compare 61h\nAuto Page Rewrite through Buffer 1 58h\nAuto Page Rewrite through Buffer 2 59h\nDeep Power-Down B9h\nResume from Deep Power-Down ABh\nUltra-Deep Power-Down 79h\nStatus Register Read D7h\nManufacturer and Device ID Read 9Fh\nConfigure “Power of 2” (Binary) Page Size 3Dh + 2Ah + 80h + A6h\nConfigure Standard DataFlash Page Size 3Dh + 2Ah + 80h + A7h\nSoftware Reset F0h + 00h + 00h + 00h\nCommand Opcode\nBuffer 1 Read 54H\nBuffer 2 Read 56H\nMain Memory Page Read 52H\nContinuous Array Read 68H\nStatus Register Read 57H\n\n 41 AT45DB321E \n 8784M–DFLASH–02/2022\nTable 14-6. Detailed Bit-level Addressing Sequence for Binary Page Size (512 bytes)\nPage Size = 512 bytes Address Byte Address Byte Address Byte\nAdditional \nDummy \nBytes Opcode Opcode\nReserved \nReserved \nA21\nA20 \nA19 \nA18 \nA17 \nA16 \nA15 \nA14 \nA13 \nA12 \nA11 \nA10 \nA9 \nA8 \nA7 \nA6 \nA5\nA4 \nA3\nA2 \nA1\nA0 \n01h 00000001XXAAAAAAAAAAAAAAAAAAAAAA N/A\n02h 00000010XXAAAAAAAAAAAAAAAAAAAAAA N/A\n03h 00000011XXAAAAAAAAAAAAAAAAAAAAAA N/A\n0Bh 00001011XXAAAAAAAAAAAAAAAAAAAAAA 1\n1Bh 00011011XXAAAAAAAAAAAAAAAAAAAAAA 2\n32h 00110010XXXXXXXXXXXXXXXXXXXXXXXX N/A\n35h 00110101XXXXXXXXXXXXXXXXXXXXXXXX N/A\n50h 01010000XXAAAAAAAAAAXXXXXXXXXXXX N/A\n53h 01010011XXAAAAAAAAAAAAAXXXXXXXXX N/A\n55h 01010101XXAAAAAAAAAAAAAXXXXXXXXX N/A\n 58h (1)01011000XXAAAAAAAAAAAAAXXXXXXXXX N/A\n 58h (2)01011000XXAAAAAAAAAAAAAAAAAAAAAA N/A\n59h(1)01011001XXAAAAAAAAAAAAAXXXXXXXXX N/A\n59h(2)01011001XXAAAAAAAAAAAAAAAAAAAAAA N/A\n60h 01100000XXAAAAAAAAAAAAAXXXXXXXXX N/A\n61h 01100001XXAAAAAAAAAAAAAXXXXXXXXX N/A\n77h 01110111XXXXXXXXXXXXXXXXXXXXXXXX N/A\n79h 01111001 N/A N/A N/A N/A\n7Ch 01111100XXAAAAAAXXXXXXXXXXXXXXXX N/A\n81h 10000001XXAAAAAAAAAAAAAXXXXXXXXX N/A\n82h 10000010XXAAAAAAAAAAAAAAAAAAAAAA N/A\n83h 10000011XXAAAAAAAAAAAAAXXXXXXXXX N/A\n84h 10000100XXXXXXXXXXXXXXXAAAAAAAAA N/A\n85h 10000101XXAAAAAAAAAAAAAAAAAAAAAA N/A\n86h 10000110XXAAAAAAAAAAAAAXXXXXXXXX N/A\n87h 10000111XXXXXXXXXXXXXXXAAAAAAAAA N/A\n88h 10001000XXAAAAAAAAAAAAAXXXXXXXXX N/A\n89h 10001001XXAAAAAAAAAAAAAXXXXXXXXX N/A\n9Fh 10011111 N/A N/A N/A N/A\nB9h 10111001 N/A N/A N/A N/A\nABh 10101011 N/A N/A N/A N/A\nB0h 10110000 N/A N/A N/A N/A\nD0h 11010000 N/A N/A N/A N/A\nD1h 11010001XXXXXXXXXXXXXXXAAAAAAAAA N/A\nD2h 11010010XXAAAAAAAAAAAAAAAAAAAAAA 4 \nD3h 11010011XXXXXXXXXXXXXXXAAAAAAAAA N/A\nD4h 11010100XXXXXXXXXXXXXXXAAAAAAAAA 1\nD6h 11010110XXXXXXXXXXXXXXXAAAAAAAAA 1\nD7h 11010111 N/A N/A N/A N/A\n\n 42 AT45DB321E \n 8784M–DFLASH–02/2022\nNote: X = Dummy Bit\nTable 14-7. Detailed Bit-level Addressing Sequence for Standard DataFlash Page Size (528 bytes)1. Shown to indicate when Auto Page Rewrite Operation is executed.\n2. Shown to indicate when Read Modify Write Operation is executed.\nPage Size = 528-bytes Address Byte Address Byte Address Byte\nAdditional \nDummy \nBytes Opcode Opcode\nReserved \nPA12 \nPA11 \nPA10 \nPA9\nPA8\nPA7\nPA6 \nPA5\nPA4 \nPA3 \nPA2\nPA1 \nPA0 \nBA9 \nBA8 \nBA7 \nBA6 \nBA5\nBA4 \nBA3\nBA2 \nBA1\nBA0 \n01h 00000001XPPPPPPPPPPPPPBBBBBBBBBB N/A\n02h 00000010XPPPPPPPPPPPPPBBBBBBBBBB N/A\n03h 00000011XPPPPPPPPPPPPPBBBBBBBBBB N/A\n0Bh 00001011XPPPPPPPPPPPPPBBBBBBBBBB 1\n1Bh 00011011XPPPPPPPPPPPPPBBBBBBBBBB 2\n32h 00110010XXXXXXXXXXXXXXXXXXXXXXXX N/A\n35h 00110101XXXXXXXXXXXXXXXXXXXXXXXX N/A\n50h 01010000XPPPPPPPPPPXXXXXXXXXXXXX N/A\n53h 01010011XPPPPPPPPPPPPPXXXXXXXXXX N/A\n55h 01010101XPPPPPPPPPPPPPXXXXXXXXXX N/A\n58h (1)01011000XPPPPPPPPPPPPPXXXXXXXXXX N/A\n58h(2)01011000XPPPPPPPPPPPPPBBBBBBBBBB N/A\n59h(1)01011001XPPPPPPPPPPPPPXXXXXXXXXX N/A\n59h (2)01011001XPPPPPPPPPPPPPBBBBBBBBBB N/A\n60h 01100000XPPPPPPPPPPPPPXXXXXXXXXX N/A\n61h 01100001XPPPPPPPPPPPPPXXXXXXXXXX N/A\n77h 01110111XXXXXXXXXXXXXXXXXXXXXXXX N/A\n79h 01111001 N/A N/A N/A N/A\n7Ch 01111100XPPPPPPXXXXXXXXXXXXXXXXX N/A\n81h 10000001XPPPPPPPPPPPPPXXXXXXXXXX N/A\n82h 10000010XPPPPPPPPPPPPPBBBBBBBBBB N/A\n83h 10000011XPPPPPPPPPPPPPXXXXXXXXXX N/A\n84h 10000100XXXXXXXXXXXXXXBBBBBBBBBB N/A\n85h 10000101XPPPPPPPPPPPPPBBBBBBBBBB N/A\n86h 10000110XPPPPPPPPPPPPPXXXXXXXXXX N/A\n87h 10000111XXXXXXXXXXXXXXBBBBBBBBBB N/A\n88h 10001000XPPPPPPPPPPPPPXXXXXXXXXX N/A\n89h 10001001XPPPPPPPPPPPPPXXXXXXXXXX N/A\n9Fh 10011111 N/A N/A N/A N/A\nB9h 10111001 N/A N/A N/A N/A\nABh 10101011 N/A N/A N/A N/A\nB0h 10110000 N/A N/A N/A N/A\nD0h 11010000 N/A N/A N/A N/A\n\n 43 AT45DB321E \n 8784M–DFLASH–02/2022\nNote: P = Page Address Bit B = Byte/Buffer Address Bit X = Dummy Bit\n15. Power-On/Reset State\nWhen power is first applied to the device, or when recovering from a reset condition, the device will default to SPI\nM\node 3. In addition, the output pin (SO) will be in a high impedance state, and a high-to-low transition on the CS  pin will\nbe required to start a valid instruction. The SPI mode (Mode 3 or Mode 0) will be automatically selected on every falling\nedge of CS  by sampling the inactive clock state.\n15.1 Initial Power-Up Timing Restrictions\nAs the device initializes, there will be a transient current demand. The system needs to be capable of providing this \nc\nurrent to ensure correct initialization. During power-up, the device must not be accessed for at least the minimum tVCSL \nt\nime after the supply voltage reaches the minimum VCC level. While the device is being powered-up, the internal Power-\nO\nn Reset (POR) circuitry keeps the device in a reset mode until the supply voltage rises above the maximum POR \nthreshold value (VPOR). During this time, all operations are disabled and the device will not respond to any commands. \nA\nfter power-up, the device will be in the standby mode.\nIf the first operation to the device after power-up will be a program or erase operation, then the operation cannot be \nstarted until the supply voltage reaches the minimum VCC level and an internal device delay has elapsed. This delay will \nb\ne a maximum time of tPUW.\nTable 15-1. Power-Up TimingD1h 11010001XXXXXXXXXXXXXXBBBBBBBBBB N/A\nD2h 11010010XPPPPPPPPPPPPPBBBBBBBBBB 4\nD3h 11010001XXXXXXXXXXXXXXBBBBBBBBBB N/A\nD4h 11010100XXXXXXXXXXXXXXBBBBBBBBBB 1\nD6h 11010110XXXXXXXXXXXXXXBBBBBBBBBB 1\nD7h 11010111 N/A N/A N/A N/A\n1. Shown to indicate when Auto Page Rewrite Operation is executed.\n2. Shown to indicate when Read Modify Write Operation is executed.Page Size = 528-bytes Address Byte Address Byte Address Byte\nAdditional \nDummy \nBytes Opcode Opcode\nReserved \nPA12 \nPA11 \nPA10 \nPA9\nPA8\nPA7\nPA6 \nPA5\nPA4 \nPA3 \nPA2\nPA1 \nPA0 \nBA9 \nBA8 \nBA7 \nBA6 \nBA5\nBA4 \nBA3\nBA2 \nBA1\nBA0 \nSymbol Parameter Min Max Units\ntVCSL Minimum VCC to Chip Select Low Time 105 µs\ntPUW Power-Up Device Delay Before Program or Erase Allowed 3 ms\nVPOR Power-On Reset (POR) Voltage 1.5 2.2 V\n\n 44 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 15-1. Power-Up Timing\nProgram/Erase Operations PermittedRead Operation PermittedVCC\nVCC (min)\nVPOR (max)\nVPOR (min)\nTimeDo Not \nAttempt\nDevice Access\nDuring this TimetPUWtVCSL\n\n 45 AT45DB321E \n 8784M–DFLASH–02/2022\n16. System Considerations\nThe serial interface is controlled by the Serial Clock (SCK), Serial Input (SI), and Chip Select (CS ) pins. These signals\nmust rise and fall monotonically and be free from noise. Excessive noise or ringing on these pins can be misinterpreted\nas multiple edges and cause improper operation of the device. PCB traces must be kept to a minimum distance or\nappropriately terminated to ensure proper operation. If necessary, decoupling capacitors can be added on these pins to\nprovide filtering against noise glitches.\nAs system complexity continues to increase, voltage regulation is becoming more important. A key element of any\nvoltage regulation scheme is its current sourcing capability. Like all Flash memories, the peak current for DataFlash\ndevices occurs during the programming and erasing operations. The supply voltage regulator needs to be able to supply\nthis peak current requirement. An under specified regulator can cause current starvation. Besides increasing system\nnoise, current starvation during programming or erasing can lead to improper operation and possible data corruption.\n\n 46 AT45DB321E \n 8784M–DFLASH–02/2022\n17. Electrical Specifications\n17.1 Absolute Maximum Ratings*\n1\n7.2 DC and AC Operating RangeTemperature under Bias  . . . . . . . -55°C to +125°C\nStorage Temperature. . . . . . . . . . -65°C to +150°C\nAbsolute Maximum Vcc . . . . . . . . . . . . . . . . .3.96V\nAll Output Voltages with Respect to Ground  \n . . . . . . . . -0.6V to 4.2V (Max VCC of 3.6V + 0.6V)\nAll Input Voltages with Respect to Ground  \n(excluding VCC pin, including NC pins)\n . . . . . . . . -0.6V to 4.2V (Max VCC of 3.6V + 0.6V)*Notice: Stresses beyond those listed under “Absolute Maximum\nR\natings” may cause permanent damage to the device. The \n“Absolute Maximum Ratings” are stress ratings only and \nfunctional operation of the device at these or any other \nconditions beyond those indicated in the operational \nsections of this specification is not implied. Exposure to \nabsolute maximum rating conditions for extended periods \nmay affect device reliability. Voltage extremes referenced in \nthe “Absolute Maximum Ratings” are intended to \naccommodate short duration undershoot/overshoot \nconditions and does not imply or guarantee functional device \noperation at these levels for any extended period of time.\nAT45DB321E\n2.3V \nOperating Temperature (Case) Industrial -40°C to 85 °C\nVCC Power Supply 2.3V to 3.6V\n\n 47 AT45DB321E \n 8784M–DFLASH–02/2022\n17.3 DC Characteristics \nNotes: 1. Typical values measured at 3.0V at 25 °C .\n2. ICC2 during a Buffer Read is 20mA maximum @ 20MHz.Symbol Parameter Condition Min Typ Max Units\nIUDPD Ultra-Deep Power-Down Current CS= VCC. All other inputs at 0V or VCC 0.4 1 µA\nIDPD Deep Power-Down Current CS= VCC. All other inputs at 0V or VCC 5 12 µA\nISB Standby Current CS= VCC. All other inputs at 0V or VCC 25 50 µA\nICC1Active Current, Low Power Read \n(01h) Operationf = 1MHz; IOUT = 0mA 6 9 mA\nf = 15MHz; IOUT = 0mA 7 11 mA\nICC2(1)(2) Active Current,  \nRead Operationf = 50MHz; IOUT = 0mA 12 17 mA\nf = 85MHz; IOUT = 0mA 16 22 mA\nICC3Active Current,  \nProgram OperationCS=VCC 12 18 mA\nICC4Active Current,  \nErase OperationCS=VCC 12 18 mA\nILI Input Load Current All inputs at CMOS levels 1 µA\nILO Output Leakage Current All inputs at CMOS levels 1 µA\nVIL Input Low Voltage VCC x 0.3 V\nVIH Input High VoltageVCC x \n0.7VCC + 0.6 V\nVOL Output Low Voltage IOL = 100µA 0.4 V\nVOH Output High Voltage IOH = -100µAVCC - \n0.2VV\n\n 48 AT45DB321E \n 8784M–DFLASH–02/2022\n17.4 AC Characteristics\nNote: 1. Values are based on device characterization, not 100% tested in production.Symbol Parameter Min Max Units\nfSCK SCK Frequency 70 MHz\nfCAR1 SCK Frequency for Continuous Read (0x0B) 85 MHz\nfCAR2SCK Frequency for Continuous Read (0x03)  \n(Low Frequency)50 MHz\nfCAR3SCK Frequency for Continuous Read \n(Low Power Mode – 01h Opcode)15 MHz\nfCAR4 SCK Frequency for Continuous Read (0x1B) 104 MHz\ntWH SCK High Time 4 ns\ntWL SCK Low Time 4 ns\ntSCKR(1)SCK Rise Time, Peak-to-peak 0.1 V/ns\ntSCKF(1)SCK Fall Time, Peak-to-peak 0.1 V/ns\ntCS Minimum CS  High Time 20 ns\ntCSS CS Setup Time 5 ns\ntCSH CS Hold Time 5 ns\ntSU Data In Setup Time 2 ns\ntH Data In Hold Time 1 ns\ntHO Output Hold Time 0 ns\ntDIS(1)Output Disable Time 6 ns\ntV Output Valid 7 ns\ntWPE WP Low to Protection Enabled 1 µs\ntWPD WP High to Protection Disabled 1 µs\ntLOCK Freeze Sector Lockdown Time (from CS  High) 100 µs\ntEUDPD(1)CS High to Ultra-Deep Power-Down 4 µs\ntCSLU Minimum CS  Low Time to Exit Ultra-Deep Power-Down 20 ns\ntXUDPD Exit Ultra-Deep Power-Down Time 180 µs\ntEDPD(1)CS High to Deep Power-Down 2 µs\ntRDPD Resume from Deep Power-Down Time 35 µs\ntXFR Page to Buffer Transfer Time 200 µs\ntCOMP Page to Buffer Compare Time 200 µs\ntRST RESET  Pulse Width 10 µs\ntREC RESET  Recovery Time 1 µs\ntSWRST  Software Reset Time 35 µs\n\n 49 AT45DB321E \n 8784M–DFLASH–02/2022\n17.5 Program and Erase Characteristics\nNotes: 1. Values are based on device characterization, not 100% tested in production.\n2\n. Not 100% tested (value guaranteed by design and characterization).\n18. Input Test Waveforms and Measurement Levels\n1\n9. Output Test LoadSymbol Parameter Min Typ Max Units\ntEP Page Erase and Programming Time (512/528 bytes) 17 35 ms\ntP Page Programming Time 3 5.5 ms\ntBP Byte Programming Time 8 µs\ntPE Page Erase Time 12 35 ms\ntBE Block Erase Time 45 100 ms\ntSE Sector Erase Time 0.7 1.4 s\ntCE Chip Erase Time 45 80 s\ntSUSP Suspend TimeProgram 10 15\nµs\nErase 20 30\ntRES Resume TimeProgram 10 15\nµs\nErase 20 30\ntOTPP OTP Security Register Program Time 200 500 µs\nAC\nDriving\nLevelsAC\nMeasurement\nLevel0.1VCCVCC/20.9VCC\ntR, tF < 2ns (10% to 90%)\nDevice\nUnder\nTest\n30pF\n\n 50 AT45DB321E \n 8784M–DFLASH–02/2022\n20. Utilizing the RapidS Function\nTo take advantage of the RapidS function\'s ability to operate at higher clock frequencies, a full clock cycle must be used\nt\no transmit data back and forth across the serial bus. The DataFlash is designed to always clock its data out on the falling\nedge of the SCK signal and clock data in on the rising edge of SCK.\nFor full clock cycle operation to be achieved, when the DataFlash is clocking data out on the falling edge of SCK, the host\ncontroller should wait until the next falling edge of SCK to latch the data in. Similarly, the host controller should clock its\ndata out on the rising edge of SCK in order to give the DataFlash a full clock cycle to latch the incoming data in on the\nnext rising edge of SCK.\nFigure 20-1. RapidS Mode\nSCK\nMOSI\nMISO1\n2 3 4 5 6 78 1\n2 3 4 5 6 78\nMOSI = Master Out, Slave In\nMISO = Master In, Slave Out\nThe Master is the host controller and the Slave is the DataFlash.\nThe Master always clocks data out on the rising edge of SCK and always clocks data in on the falling edge of SCK.\nThe Slave always clocks data out on the falling edge of SCK and always clocks data in on the rising edge of SCK.\nA. Master clocks out first bit of BYTE-MOSI on the rising edge of SCK\nB. Slave clocks in first bit of BYTE-MOSI on the next rising edge of SCK\nC. Master clocks out second bit of BYTE-MOSI on the same rising edge of SCK\nD. Last bit of BYTE-MOSI is clocked out from the Master\nE. Last bit of BYTE-MOSI is clocked into the slave\nF. Slave clocks out first bit of BYTE-SO\nG. Master clocks in first bit of BYTE-SO\nH. Slave clocks out second bit of BYTE-SO\nI. Master clocks in last bit of BYTE-SOAB\nC DE\nFG1\nH BYTE-MOSIMSB LSB\nBYTE-SOMSB LSBSlave CS\nI\n\n 51 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 20-2. Command Sequence for Read/Write Operations for Page Size 512 bytes \n(E\nxcept Status Register Read, Manufacturer and Device ID Read)\nFigure 20-3. Command Sequence for Read/Write Operations for Page Size 528 bytes \n(E\nxcept Status Register Read, Manufacturer and Device ID Read)  SI (INPUT) CMD 8-bits 8-bits 8-bits\nPage Address\n(A21 - A9)LSB X X X X X X X X X X X X X X X X X X X X X X X X\nByte/Buffer Address\n(A8 - A0/BFA8 - BFA0)MSB\n2 Dummy\n Bits\nSI (INPUT) CMD 8-bits 8-bits 8-bits\nLSB X X X X X X X X X X X X X X X X X X X X X X X X MSB\nPage Address\n(PA12 - PA0)Byte/Buffer Address\n(BA9 - BA0/BFA9 - BFA0)1 Dummy\n Bit\n\n 52 AT45DB321E \n 8784M–DFLASH–02/2022\n21. AC Waveforms\nFour different timing waveforms are shown in F igure 21-1  through Figure 21-4 . Waveform 1 shows the SCK signal being\nlo\nw when CS  makes a high-to-low transition and Waveform 2 shows the SCK signal being high when CS  makes a\nhigh-to-low transition. In both cases, output SO becomes valid while the SCK signal is still low (SCK low time is specified\nas tWL). Timing Waveforms 1 and 2 conform to RapidS serial interface but for frequencies up to 85MHz. Waveforms 1\na\nnd 2 are compatible with SPI Mode 0 and SPI Mode 3, respectively.\nWaveform 3 and 4 illustrate general timing diagram for RapidS serial interface. These are similar to Waveform 1 and 2,\nexcept that output SO is not restricted to become valid during the tWL period. These timing waveforms are valid over the\nf\null frequency range (maximum frequency = 85MHz) of the RapidS serial case.\nFigure 21-1. Waveform 1 = SPI Mode 0 Compatible\nF\nigure 21-2. Waveform 2 = SPI Mode 3 CompatibleCS\nSCK\nSISOtCSS\nValid IntH tSUtWH tWL tCSHtCS\ntV\nHigh-impedance\nValid OuttHO tDIS\nHigh-impedance\nCS\nSCK\nSOtCSS\nValid IntH tSUtWL tWH tCSHtCS\ntV\nHigh ZValid OuttHO tDIS\nHigh-impedance\nSI\n\n 53 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 21-3. Waveform 3 = RapidS Mode 0\nFigure 21-4. Waveform 4 = RapidS Mode 3CS\nSCK\nSISOtCSS\nValid IntH tSUtWH tWL tCSHtCS\ntV\nHigh-impedance\nVa\nlid OuttHO tDIS\nHigh-impedance\nCS\nSCK\nSOtCSS\nValid IntH tSUtWL tWH tCSHtCS\ntV\nHigh ZValid OuttHO tDIS\nHigh-impedance\nSI\n\n 54 AT45DB321E \n 8784M–DFLASH–02/2022\n22. Write Operations\nThe following block diagram and waveforms illustrate the various write sequences available.\nFigure 22-1. Block Diagram\nF\nigure 22-2. Buffer Write\nFigure 22-3. Buffer to Main Memory Page ProgramFlash Memory Array\nBuffer 2 (512/528 bytes)\nI/O Interface\nSIBuffer 1 To\nMain Memory\nPage ProgramBuffer 2 To\nMain Memory\nPage Program\nBuffer 1\nWriteBuffer 2\nWritePage (512/528 bytes)\nBuffer 1 (512/528 bytes)\nCS\nSI (Input) CMD X X···X, BFA9-8 BFA7-0 n n + 1 Last ByteCompletes Wr\niting into Selected Buffer\nBinary Page Size\n15 Dummy Bits + BFA8-BFA0\nCS\nSI (Input) CMD  XX, PA12-6 PA5-0, XX XXXX XXStarts Self-timed Erase/Program Operation\nBinary Page Size\nA21-A9 + 11 Dummy Bits\nn  = 1st byte read\nn+1 = 2nd byte read Each transition represents eight bits\n\n 55 AT45DB321E \n 8784M–DFLASH–02/2022\n23. Read Operations\nThe following block diagram and waveforms illustrate the various read sequences available.\nFigure 23-1. Block Diagram\nF\nigure 23-2. Main Memory Page ReadFlash Memory Array\nPage (512/528 bytes)\nBuffer 2 (512/528 bytes) Buffer 1 (512/528 bytes)\nI/O InterfaceMain Memory\nPage To\nBuffer 1Main Memory\nPage To\nBuffer 2\nMain Memory\nPage ReadBuffer 1\nReadBuffer 2\nRead\nSO\nCS\nSI (Input)\nSO (Output) nCMD XX, PA12-6 PA5-0, BA9-8 BA7-0 X XAddress for Binary Page Size\nA21-A16 A15-A8 A7-A0\nn n + 14 Dummy Bytes\n\n 56 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 23-3. Main Memory Page to Buffer Transfer  \nDa\nta From the selected Flash Page is read into either SRAM Buffer\nFigure 23-4. Buffer ReadCS\nSI (Input) CMD  XX, PA12-6 PA5-0, XX XXXX XXXXStarts Reading Page Data into Buffer\nBinary Page Size\nA21-A9 + 9 Dummy Bits\nSO (Output)\nCS\nSI (Input)\nSO (Output) nCMD X\nX...X, BFA9-8 BFA7-0 XAddress for Binary Page Size\nA21-A16 A15-A8 A7-A0\nn n + 1No Dummy Byte (opcodes D1H and D3H)\n1 Dummy Byte (opcodes D4H and D6H)\nEach transition represents eight bits\n\n 57 AT45DB321E \n 8784M–DFLASH–02/2022\n24. Detailed Bit-level Read Waveforms: RapidS Mode 0/Mode 3\nFigure 24-1. Continuous Array Read (Legacy Opcode E8h)\nF\nigure 24-2. Continuous Array Read (Opcode 0Bh)\nFigure 24-3. Continuous Array Read (Opcode 01h or 03h)SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 1 0 1 0 0 0 6 7 5 4 10 11 9 8 12 63 66 67 65 64 62 33 34 31 32 29 30 68 71 72 70 69 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits 32 Dummy Bits\nData Byte 1\nHigh-impedance\nBit 4095/4223\nof Page nBit 0  of\nPage n+1\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 0 0 1 0 1 1 6 7 5 4 10 11 9 8 12 39 42 43 41 40 38 33 34 31 32 29 30 44 47 48 46 45 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits A21 - A0 Dummy Bits\nData Byte 1\nHigh-impedance36 37 35 \nX X \nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 0 0 0 0 1 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nA A A A A A A A A \nMSB MSB D D D D D D D D D D Address Bits A21-A0\nData Byte 1\nHigh-impedance\n\n 58 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 24-4. Main Memory Page Read (Opcode D2h)\nFigure 24-5. Buffer Read (Opcode D4h or D6h)\nFigure 24-6. Buffer Read – Low Frequency (Opcode D1h or D3h)SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 0 1 0 6 7 5 4 10 11 9 8 12 63 66 67 65 64 62 33 34 31 32 29 30 68 71 72 70 69 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits 32 Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 1 0 0 6 7 5 4 10 11 9 8 12 39 42 43 41 40 37 38 33 36 35 34 31 32 29 30 44 47 48 46 45 \nOpcode\nX X X X A A A X X \nMSB X X X X X X X X \nMSB MSB D D D D D D D D D D Address Bits\nBinary Page Size = 15 Dummy Bits + BFA8-BFA0\nStandard DataFlash Page Size = \n14 Dummy Bits + BFA9-BFA0Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 0 0 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X A A A X X \nMSB MSB D D D D D D D D D D Data Byte 1\nHigh-impedanceAddress Bits\nBinary P\nage Size = 15 Dummy Bits + BFA8-BFA0\nStandard DataFlash Page Size = \n14 Dummy Bits + BA9-BFA0\n\n 59 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 24-7. Read Sector Protection Register (Opcode 32h)\nFigure 24-8. Read Sector Lockdown Register (Opcode 35h)\nFigure 24-9. Read Security Register (Opcode 77h)SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 1 1 0 0 1 0 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 1 1 0 1 0 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 1 1 1 0 1 1 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\n\n 60 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 24-10. Status Register Read (Opcode D7h)\nFigure 24-11. Manufacturer and Device Read (Opcode 9Fh)\nFigure 24-12.Reset Timing\nNote: 1. The CS  signal should be in the high state before the RESET  signal is deasserted.SCK CS \nSI \nSO MSB 2 3 1 0 \n1 1 0 1 0 1 1 1 6 7 5 4 10 11 9 8 12 21 22 17 20 19 18 15 16 13 14 23 24 \nOpcode\nMSB MSB D D D D D D D D D D \nMSB D D D D D D D D Status Register Data Status Register Data\nHigh-impedance\nSCKCS\nSI\nSO6 0\n9Fh8 7 46\nOpcode\n1Fh 01h 01h 00h\nManufacturer ID Device ID\nByte 1Device ID\nByte 2EDI\nString LengthEDI\nData Byte 1High-impedance14 16 15 22 24 23 38 40 39 30 32 31\nNote:  Each transition shown for SI and SO represents one byte (8 bits)27h\nCS\nSCK\nRESET\nSO (Output)High Impedance High Impedance\nSI (Input)tRSTtREC tCSS\n\n 61 AT45DB321E \n 8784M–DFLASH–02/2022\n25. Auto Page Rewrite Flowchart\nFigure 25-1. Algorithm for Programming or Re-programming of the Entire Array Sequentially\nNotes: 1. This type of algorithm is used for applications in which the entire array is programmed sequentially, filling the \na\nrray page-by-page\n2. A page can be written using either a Main Memory Page Program operation or a buffer write operation\nfollowed by a buffer to Main Memory Page Program operation\n3. The algorithm above shows the programming of a single page. The algorithm will be repeated sequentially\nfor each page within the entire arraySTART\nMain Memory Page Program\nthrough Buffer\n(82h, 85h)\nENDProvide Address\nand Data\nBuffer Write\n(84h, 87h)\nBuffer To Main\nMemory Page Program\n(83h, 86h)\n\n 62 AT45DB321E \n 8784M–DFLASH–02/2022\nFigure 25-2. Algorithm for Programming or Re-programming of the Entire Array Randomly\nNotes: 1. To preserve data integrity, each page of an DataFlash sector must be updated/rewritten at least once within \ne\nvery 50,000 cumulative page erase and program operations\n2. A page address pointer must be maintained to indicate which page is to be rewritten. The auto page rewrite\ncommand must use the address specified by the page address pointer\n3. Other algorithms can be used to rewrite portions of the Flash array. Low-power applications may choose to\nwait until 50,000 cumulative page erase and program operations have accumulated before rewriting all\npages of the sector. See application note AN-4 (“Using Adesto’s Serial DataFlash”) for more detailsSTART\nMain Memory Page\nto Buffer Transfer\n(53h, 55h)\nIncrement Page\nAddress Pointer(2)Auto Page Rewrite(2)\n(58h, 59h)\nENDProvide Address of\nPage to Modify\nIf planning to modify multiple\nbytes currently stored within\na page of the Flash array\nMain Memory Page Program\nthrough Buffer\n(82h, 85h)Buffer Write\n(84h, 87h)\nBuffer to Main\nMemory Page Program\n(83h, 86h)\n\n 63 AT45DB321E \n 8784M–DFLASH–02/2022\n26. Ordering Information\n26.1 Ordering Detail\n2\n6.2 Ordering Codes (Standard DataFlash Page Size)\nNotes: 1. The shipping carrier suffix is not marked on the device.\n2\n.Contact Adesto for mechanical drawing or Die Sales information.Device Grade\nH = Green, NiPdAu lead finish,\nIndustrial temperature range\n(–40°C to +85°C)\nU = Green, Matte Sn or Sn alloy,\nIndustrial temperature range\n(–40°C to +85°C)Designator\nProduct Family\nDevice Density\nDevice RevisionShipping Carrier Option\nPackage Option32 = 32-Mbit\nInterface\n1 = Serial45DB = DataFlashB   =  Bulk (tubes)\nT = Tape and reel\nY = Trays\nOperating Voltage\nF = 2.3V minimum (2.3V to 3.6V)\nS  = 8-lead, 0.208” wide SOIC\nM  = 8-pad,  5 x 6 x 0.6mm UDFN\nMW = 8-pad, 6 x 8 x 1.0mm VDFN\nCC  = 9-ball,  6 x 6 x 0.6mm (1mm pitch) UBGA\nDWF = Die in Wafer FormA T 4 5 D B 3 2 1 E - S H F 2 B - B\nPage Size Option\n“  “ = Standard (528 bytes/page)\n2B = Binary (512 bytes/page)\nDWF = Die in Wafer Form\nOrdering Code Package Lead Finish Operating Voltage fSCK Device Grade\nAT45DB321E-SHF-B(1)\n8S2\nNiPdAu\n2.3V to 3.6V85MHz\nIndustrial\n(-40°C to 85 °C)AT45DB321E-SHF-T(1)\nAT45DB321E-MWHF-Y(1)\n8MW1\nAT45DB321E-MWHF-T(1)\nAT45DB321E-MHF-Y(1)\n8MA1 NiPdAu 70MHz\nAT45DB321E-MHF-T(1)\nAT45DB321E-DWF(2)DWF 85MHz\n\n 64 AT45DB321E \n 8784M–DFLASH–02/2022\n26.3 Ordering Codes (Binary Page Size)\nNotes: 1. The shipping carrier suffix is not marked on the device.\n2\n. Parts ordered with suffix code ‘2B’ are shipped in tape and reel (T&R) with the page size set to\n512 bytes. This option is only available for shipping in T&R (-T).\n26.4 Ordering Codes (Reserved)\nNotes: 1. The shipping carrier suffix is not marked on the device.\n2\n. Parts ordered with suffix code ‘HA’ are shipped in tape and reel (T&R) only with the page size set to\n528 bytes.\n3. Parts ordered with suffix code ‘HC’ are shipped in tape and reel (T&R) only with the page size set to\n512 bytes.\n4. Please contact Adesto for a description of these ‘Reserved’ codes.Ordering Code Package Lead Finish Operating Voltage fSCK Device Grade\nAT45DB321E-SHF2B-T(1)(2)8S2\nNiPdAu 2.3V to 3.6V 85MHzIndustrial\n(-40°C to 85 °C)AT45DB321E-MWHF2B-T \n(1)(2) 8MW1\nAT45DB321E-MHF2B-T(1)(2)8MA1 NiPdAu 2.3V to 3.6V 70MHzIndustrial\n(-40°C to 85 °C)\nPackage Type\n8S2 8-lead 0.208" wide, Plastic Gull Wing Small Outline (EIAJ SOIC)\n8MA1 8-pad (5 x 6 x 0.6mm body) Thermally Enhanced Plastic Ultra Thin Dual Flat No-lead (UDFN)\n8MW1 8-contact, 6 x 8mm, Very Thin Dual Flat No Lead Package (VDFN)\nDWF Die in Wafer Form\nOrdering Code Package Lead Finish Operating Voltage fSCK Device Grade\nAT45DB321E-SHFHA-T(1)(2)\n8S2 NiPdAu 2.3V to 3.6V 85MHzIndustrial\n(-40°C to 85 °C) AT45DB321E-SHFHC-T(1)(3)\nPackage Type\n8S2 8-lead 0.208" wide, Plastic Gull Wing Small Outline (EIAJ SOIC)\n\n 65 AT45DB321E \n 8784M–DFLASH–02/2022\n27. Packaging Information\n27.1 8S2 – 8-lead EIAJ SOIC\nTITLE DRAWING NO.     GPC REV.\nPackage Drawing Contact:\ncontact@adestotech.com8S2 STN F 8S2, 8-lead, 0.208” Body, Plastic Small\nOutline Package (EIAJ)4/15/08COMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX NOTE  \nNotes: 1. This drawing is for general information only; refer to EIAJ Drawing EDR-7320 for additional information. \n2. Mismatch of the upper and lower dies and resin burrs aren\'t included. \n3. Determines the true geometric position. \n4. Values b,C apply to plated terminal.  The standard thickness of the plating layer shall measure between 0.007 to .021 mm. A 1.70 2.16 \nA1 0.05 0.25 \nb 0.35 0.48  4\nC 0.15 0.35  4\nD 5.13 5.35 \nE1 5.18 5.40  2\nE 7.70 8.26 \nL 0.51 0.85 \nq   0°  8°\ne 1.27 BSC  3q1 \nN E \nTOP VIEW C \nE1 \nEND VIEW \nA b L \nA1 e \nD \nSIDE VIEW \n\n 66 AT45DB321E \n 8784M–DFLASH–02/2022\n27.2 8MA1 – 8-pad UDFN\nTITLE DRAWING NO. GPC REV.\nPackage Drawing Contact:\ncontact@adestotech.com 8MA1 YFG D 8MA1, 8-pad (5 x 6 x 0.6 mm Body), Thermally  \nEnhanced Plastic Ultra Thin Dual Flat No Lead \nPackage (UDFN) COMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX N O \nT E \nA 0.45 0.55 0.60 \nA1 0.00 \n0.02 0.05 \nb \n0.35 0.40 0.48 \nC 0.152 REF \nD 4.90 5.00 5.10 \nD2 3.80 4.00 4.20 \nE 5.90 6.00 6.10 \nE2 3.20 3.40 3.60 \ne 1.27 \nL 0.50 0.60 0.75 \ny 0.00 – 0.08 \nK \n0.20 – – \n4/15/08Pin 1 ID \nTOP VIEW E \nD \nA1 \nA SIDE VIEW \ny C \nBOTTOM VIEW E2 \nD2 \nL b e 1 \n2 \n3 \n4 8 \n7 \n6 \n5 Pin #1 Notch \n(0.20 R) 0.45 K \nPin #1  \n Cham f \ne r  \n (C 0.35) Option A \n(Option B) \n\n 67 AT45DB321E \n 8784M–DFLASH–02/2022\n27.3 8 MWH – 8-pad VDFN\nDRAWING NO. REV .  TITLE\nPackage Drawing Contact:\ncon\ntact@adestotech.com8MW1 F8/4/17\n8MW1, 8-pad (6 x 8 x 1.0 mm Body), Thermally \nEnhanced Plastic Very Thin Dual Flat No Lead\nPackage (VDFN)Bottom ViewTop ViewSide View\nCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL\nMIN NOM MAX NOTE\n0.80\n–\n0.35\n5.90\n4.25\n7.90\n3.35\n0.45A\nA1\nb\nC\nD\nD1\nE\nE1\ne\nL\nK–\n–\n0.40\n0.203 REF\n6.00\n8.00\n1.27\n0.50\n1.05 REF1.00\n0.05\n0.48\n6.10\n4.90\n8.10\n5.00\n0.55Pin 1 IDE\nD\nA1\nAC\nPin #1 IDE1\nD1\nLbe\nK1\nPin #1 \nChamfer\n(C 0.40 max)Option A\nPin #1 \nNotch\n(0.20 R)Option B2\n3\n48\n7\n6\n5\n\n8784 M 2/2022 Changed company logo to Renesas.\n 68 AT45DB321E \n 8784M–DFLASH–02/2022\n28. Revision History\nDoc. Rev. Date Comments\n8784A 08/2012 Initial document release.\n8784B 11/2012Added Legacy Commands table.\nUpdated to Adesto template.\n8784C 6/2013Updated electrical and power specifications. “Buffer 1 (or 2) Read” moved from group C to \nGr\noup A in Operation Mode Summary. Removed references to 2.5V minimum power supply.\n8784D 7/2013Updated Auto Page Rewrite cycle to 50,000 cumulative page erase/program operations. \nCo\nrrected Page Erase and Programming Time specification to 35 ms maximum. Updated DC \nco\nnditions for VOL, ICC3 and ICC4. Added reserved part order codes. Changed datasheet status \nfrom preliminary to complete.\n8784E 10/2013Updated spec in Continuous Array Read (1Bh Opcode) to fCAR4. Corrected Low Power Read\nOp\ntion (up to 15MHz). Corrected Ultra-Deep Power-Down current (400nA typical). Updated spec \nfor Input High Voltage (Max) to VCC + 0.6V.\n8784F 11/2013Corrected Product ID Values for Byte 2 in Figure 12.1, Table 12.1 and Table 12.2. Corrected \nMemory Architecture Diagram, Figure 3-1.\n8784G 7/2015Added Die in Wafer Form package option. Added explanation of Read-Modify-Write command \n(Section 6.6).Updated Table 6-4 (Main Memory to Buffer Compare). Added information on Power \nUp (Section 15.1). Added footnotes to Tables 14-6 and 14-7. Updated Tables 11-1 and 11-3. \nUpdated condition description for IUDPD, IDPD, and ISB.\n8784H 1/2017 Added patent information.\n8784I 6/2017 Added clarification of Absolute Maximum Ratings.\n8784J 8/2017 Updated 6 x 8 VDFN package drawing.\n8784K 9/2017 Updated maximum page program time specification.\n8784L 3/2019Removed 9CC, 9-ball UBGA package option.\nUpdated tVCSL time in Table 15-1 from 85 to 105 µs.\n\nCorporate Headquarters\nTOYOSU FORESIA, 3-2-24 Toyosu,\nKoto-ku, Tokyo 135-0061, Japanwww.renesas.comContact Information\nFor further information on a product, technology, the most up-to-date version of a document, or your nearest sales office, please visit:www.renesas.com/contact/\nTrademarks\nRenesas and the Renesas logo are trademarks of Renesas Electronics Corporation. All trademarks and registered trademarks are the property  of their respective owners.IMPORTANT NOTICE AND DISCLAIMER\nRENESAS ELECTRONICS CORPORATION AND ITS SUBSIDIARIES (“RENESAS”) PROVIDES TECHNICAL SPECIFICATIONS AND RELIABILITY DATA (INCLUDING DATASHEETS), DESIGN RESOURCES (INCLUDING REFERENCE DESIGNS), APPLICATION OR OTHER DESIGN ADVICE, WEB TOOLS, SAFETY INFORMATION, AND OTHER RESOURCES “AS IS” AND WITH ALL FAULTS, AND DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY RIGHTS.\nThese resources are intended for developers skilled in the art designing with Renesas products. You are solely responsible \nfor (1) selecting the appropriate products for your application, (2) designing, validating, and testing your application, and (3) ensuring your application meets applicable standards, and any other safety, security, or other requirements. These resources are subject to change without notice. Renesas grants you permission to use these resources only for development of an application that uses Renesas products. Other reproduction or use of these resources is strictly prohibited. No license is granted to any other Renesas intellectual property or to any third party intellectual property. Renesas disclaims responsibility for, and you will fully indemnify Renesas and its representatives against, any claims, damages, costs, losses, or liabilities arising out of your use of these resources. Renesas\' products are provided only subject to Renesas\' Terms and Conditions of Sale or other applicable terms agreed to in writing. No use of any Renesas resources expands or otherwise alters any applicable warranties or warranty disclaimers for these products. \n(Rev.1.0 Mar 2020)\n© 2021 Renesas Electronics Corporation. All rights reserved.\nMouser Electronics\n  \nAuthorized Distributor\n \n  \nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\n \n \n \n Adesto Technologies:   \n\xa0 AT45DB321E-SHFHC-T \n \n Dialog Semiconductor:   \n\xa0 AT45DB321E-MHF2B-T\xa0 AT45DB321E-MHF-T\xa0 AT45DB321E-MHF-Y\xa0 AT45DB321E-MWHF-T\xa0 AT45DB321E-MWHF-\nY\xa0 AT45DB321E-SHF2B-T\xa0 AT45DB321E-SHF-B\xa0 AT45DB321E-SHFHA-T\xa0 AT45DB321E-SHF-T\n'}]
!==============================================================================!
### Component Summary: AT45DB321E-SHF-T

#### Key Characteristics and Specifications:
- **Voltage Ratings**: 2.3V to 3.6V
- **Current Ratings**:
  - Active Read Current: 7mA (typical at 15MHz)
  - Standby Current: 25µA (typical)
  - Deep Power-Down Current: 3µA (typical)
  - Ultra-Deep Power-Down Current: 400nA (typical)
- **Power Consumption**:
  - Active Read: 7mA (typical at 15MHz)
  - Standby: 25µA (typical)
  - Deep Power-Down: 3µA (typical)
  - Ultra-Deep Power-Down: 400nA (typical)
- **Operating Temperature Range**: -40°C to 85°C (Industrial)
- **Package Type**: 8-lead SOIC (0.208" wide)
- **Special Features**:
  - Supports RapidS™ operation for high-speed applications.
  - Two independent SRAM data buffers (512/528 bytes).
  - Advanced data protection features including sector protection and lockdown.
  - Configurable page size (512 bytes or 528 bytes).
  - Endurance: 100,000 program/erase cycles per page minimum.
  - Data retention: 20 years.
- **Moisture Sensitive Level**: MSL 3 (JEDEC J-STD-020E)

#### Description:
The **AT45DB321E** is a 32-Mbit (4MB) serial flash memory device from Adesto Technologies, designed for high-density data storage applications. It operates on a single supply voltage ranging from 2.3V to 3.6V and features a Serial Peripheral Interface (SPI) that supports both SPI modes 0 and 3. The device is optimized for low power consumption, making it suitable for battery-operated devices.

#### Typical Applications:
The AT45DB321E is commonly used in various applications, including:
- **Digital Voice and Image Storage**: Ideal for applications requiring storage of audio and visual data.
- **Program Code Storage**: Suitable for embedded systems where firmware needs to be stored and updated.
- **Data Logging**: Used in data acquisition systems for storing sensor data.
- **Consumer Electronics**: Found in devices such as cameras, smartphones, and other portable electronics.
- **Industrial Applications**: Utilized in industrial control systems for data storage and retrieval.

This component's combination of high speed, low power consumption, and flexible programming options makes it a versatile choice for a wide range of electronic applications.