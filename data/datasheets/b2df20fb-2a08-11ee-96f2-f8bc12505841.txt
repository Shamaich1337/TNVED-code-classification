[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of AT45DB641E-SHN-T production of DIALOG from the text:DS-45DB641E-027N–DFLASH–2/2022Features\n\x01Single 1.7V - 3.6V supply\n\x01Serial Peripheral Interface (SPI) compatible\n\x01Supports SPI modes 0 and 3\n\x01Supports RapidS™ operation\n\x01Continuous read capability through entire array\n\x01Up to 85MHz\n\x01Low-power read option up to 15MHz\n\x01Clock-to-output time (tV) of 8ns maximum\n\x01User configurable page size\n\x01256 bytes per page\n\x01264 bytes per page (default)\n\x01Page size can be factory pre-configured for 256 bytes\n\x01Two fully independent SRAM data buffers (256/264 bytes)\n\x01Allows receiving data while reprogramming the main memory array\n\x01Flexible programming options\n\x01Byte/Page Program (1 to 256/264 bytes) directly into main memory\n\x01Buffer Write | Buffer to Main Memory Page Program\n\x01Flexible erase options\n\x01Page Erase (256/264 bytes)\n\x01Block Erase (2KB)\n\x01Sector Erase (256KB)\n\x01Chip Erase (64-Mbits)\n\x01Program and Erase Suspend/Resume\n\x01Advanced hardware and software data protection features\n\x01Individual sector protection\n\x01Individual sector lockdown to make any sector permanently read-only\n\x01128-byte, One-Time Programmable (OTP) Security Register\n\x0164 bytes factory programmed with a unique identifier\n\x0164 bytes user programmable\n\x01Hardware and software controlled reset options\n\x01JEDEC Standard Manufacturer and Device ID Read\n\x01Low-power dissipation\n\x01400nA Ultra-Deep Power-Down current (typical)\n\x015µA Deep Power-Down current (typical)\n\x0125µA Standby current (typical)\n\x017mA Active Read current (typical)\n\x01Endurance: 100,000 program/erase cycles per page minimum\n\x01Data retention: 20 years\n\x01Complies with full industrial temperature range\n\x01Green (Pb/Halide-free/RoHS compliant) packaging options\n\x01 8-lead SOIC (0.208" wide)\n\x01 8-pad Ultra-thin DFN (5 x 6 x 0.6mm)\n\x01 8-pad Very-thin DFN (6 x 8 x 1.0mm)\n\x01 Die in Wafer FormAT45DB641E\n64-Mbit DataFlash (with Extra 2-Mbits), 1.7V Minimum\nSPI Serial Flash Memory \n\n 2 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Description\nThe AT45DB641E is a 1.7V minimum, serial-interface sequential access Flash memory ideally suited for a wide variety of \ndigital \nvoice, image, program code, and data storage applications. The AT45DB641E also supports the RapidS serial \ninterface for applications requiring very high speed operation. Its 69,206,016 bits of memory are organized as 32,768 \npages of 256 bytes or 264 bytes each. In addition to the main memory, the AT45DB641E also contains two SRAM \nbuffers of 256/264 bytes each. Interleaving between both buffers can dramatically increase a system\'s ability to write a \ncontinuous data stream. In addition, the SRAM buffers can be used as additional system scratch pad memory, and \nE2PROM emulation (bit or byte alterability) can be easily handled with a self-contained three step read-modify-write \noperati o\nn.\nUnlike conventional Flash memories that are accessed randomly with multiple address lines and a parallel interface, the \nDataFlash® uses a serial interface to sequentially access its data. The simple sequential access dramatically reduces \nactive p\nin count, facilitates simplified hardware layout, increases system reliability, minimizes switching noise, and \nreduces package size. The device is optimized for use in many commercial and industrial applications where \nhigh-density, low-pin count, low-voltage, and low-power are essential.\nTo allow for simple in-system re-programmability, the AT45DB641E does not require high input voltages for \nprogramming. The device operates from a single 1.7V to 3.6V power supply for the erase and program and read \noperations. The AT45DB641E is enabled through the Chip Select pin (CS ) and accessed via a 3-wire interface consisting \nof the Serial Input (SI), Serial Output (SO), and the Serial Clock (SCK).\nAll programming and erase cycles are self-timed.\n1. Pin Configurations and Pinouts\nFigure 1-1. Pinouts\nNote: 1. The metal pad on the bottom of the DFN package is not internally\nconnect e\nd to a voltage potential.This pad can be a “no connect”\nor connected to GND. Care must be taken to avoid the Metal Pad\nshorting on PCB tracks.1\n2\n3\n48\n7\n6\n5SI\nSCK\nRESET\nCSSO\nGND\nVCC\nWP8-lead SOIC\nTop View\nSI\nSCK\nRESET\nCSSO\nGND\nVCC\nWP8\n7\n6\n51\n2\n3\n48-pad UDFN\nTop View\n(through package)\n\n 3 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Table 1-1. Pin Configurations\nSymbol Name and FunctionAsserted \nState Type\nCSChip Select: Asserting the CS  pin selects the device. When the CS  pin is deasserted, the \ndevice will be deselected and normally be placed in the standby mode (not Deep Power-Down \nmode) and the output pin (SO) will be in a high-impedance state. When the device is \ndeselected, data will not be accepted on the input pin (SI).\nA high-to-low transition on the CS  pin is required to start an operation and a low-to-high \ntransition is required to end an operation. When ending an internally self-timed operation such \nas a program or erase cycle, the device will not enter the standby mode until the completion of \nthe operation.Low Input\nSCKSerial Clock:  This pin is used to provide a clock to the device and is used to control the flow of \ndata to and from the device. Command, address, and input data present on the SI pin is \nalways latched on the rising edge of SCK, while output data on the SO pin is always clocked \nout on the falling edge of SCK.— Input\nSISerial Input:  The SI pin is used to shift data into the device. The SI pin is used for all data input \nincluding command and address sequences. Data on the SI pin is always latched on the rising \nedge of SCK. Data present on the SI pin will be ignored whenever the device is deselected (CS  \nis deasserted).— Input\nSOSerial Output:  The SO pin is used to shift data out from the device. Data on the SO pin is \nalways clocked out on the falling edge of SCK. The SO pin will be in a high-impedance state \nwhenever the device is deselected (CS  is deasserted).— Output\nWPWrite Protect:  When the WP  pin is asserted, all sectors specified for protection by the Sector \nProtection Register will be protected against program and erase operations regardless of \nwhether the Enable Sector Protection command has been issued or not. The WP pin functions \nindependently of the software controlled protection method. After the WP  pin goes low, the \ncontents of the Sector Protection Register cannot be modified.\nIf a program or erase command is issued to the device while the WP  pin is asserted, the device \nwill simply ignore the command and perform no operation. The device will return to the idle \nstate once the CS  pin has been deasserted. The Enable Sector Protection command and the \nSector Lockdown command, however, will be recognized by the device when the WP  pin is \nasserted.\nThe WP  pin is internally pulled-high and may be left floating if hardware controlled protection \nwill not be used. However, it is recommended that the WP  pin also be externally connected to \nVCC whenever possible.Low Input\nRESETReset:  A low state on the reset pin (RESET ) will terminate the operation in progress and reset \nthe internal state machine to an idle state. The device will remain in the reset condition as long \nas a low level is present on the RESET  pin. Normal operation can resume once the RESET  pin \nis brought back to a high level.\nThe device incorporates an internal power-on reset circuit, so there are no restrictions on the \nRESET  pin during power-on sequences. If this pin and feature is not utilized, then it is \nrecommended that the RESET  pin be driven high externally.Low Input\nVCCDevice Power Supply:  The VCC pin is used to supply the source voltage to the device. \nOperations at invalid VCC voltages may produce spurious results and should not be attempted.— Power\nGNDGround:  The ground reference for the power supply. GND should be connected to the system \nground.— Ground\n\n 4 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20222. Block Diagram\nFigure 2-1. Block Diagram\nFlash Memory Array\nI/O InterfaceSCK\nCS\nRESET\nVCC\nGNDWP\nSO SIPage (256/264 bytes)\nBuffer 1 (256/264 bytes) Buffer 2 (256/264 bytes)\n\n 5 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20223. Memory Array\nTo provide optimal flexibility, the AT45DB641E memory array is divided into three levels of granularity comprising of\nsectors, blocks, and pages. Figure 3-1, Memory Architecture Diagram  illu strates the breakdown of each level and details\nthe nu\nmber of pages per sector and block. Program operations to the DataFlash can be done at the full page level or at\nthe byte level (a variable number of bytes). The erase operations can be performed at the chip, sector, block, or page\nlevel.\nFigure 3-1. Memory Architecture Diagram\nSector 0a = 8 pages\n2,048 / 2,112 bytes\nSector 0b = 1,016 pages\n260,096 / 268,224 bytes\nBlock = 2,048 / 2,112 bytes8 Pages Sector 0a\nSector 0b\nPage = 256 / 264 bytesPage 0\nPage 1\nPage 6\nPage 7\nPage 8\nPage 9\nPage 32,766\nPage 32,767Block 0\nPage 14\nPage 15\nPage 16\nPage 17\nPage 18Block 1Sector Architecture Block Architecture Page Architecture\nBlock 0\nBlock 1\nBlock 126\nBlock 127\nBlock 128\nBlock 129\nBlock 4,094\nBlock 4,095Block 254\nBlock 255\nBlock 256\nBlock 257Sector 1\nSector 31 = 1,,024 pages\n262,144 / 270,336 bytesBlock 2\nSector 1 = 1,024 pages\n262,144 / 270,336 bytes\nSector 30 = 1,024 pages\n262,144 / 270,336 bytesSector 2 = 1,024 pages\n262,144 / 270,336 bytes\n\n 6 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20224. Device Operation\nThe device operation is controlled by instructions from the host processor. The list of instructions and their associated\nopcodes are contained in Table 15-1 on page 40  throu gh Table 15-4 on page 41 . A valid instruction starts with the falling\nedge of\n CS followed by the appropriate 8-bit opcode and the desired buffer or main memory address location. While the\nCS pin is low, toggling the SCK pin controls the loading of the opcode and the desired buffer or main memory address\nlocation through the SI (Serial Input) pin. All instructions, addresses, and data are transferred with the Most Significant\nBit (MSB) first.\nThree address bytes are used to address memory locations in either the main memory array or in one of the SRAM\nbuffers. The three address bytes will be comprised of a number of dummy bits and a number of actual device address\nbits, with the number of dummy bits varying depending on the operation being performed and the selected device page\nsize. Buffer addressing for the standard DataFlash page size (264 bytes) is referenced in the datasheet using the\nterminology BFA8 - BFA0 to denote the 9 address bits required to designate a byte address within a buffer. The main\nmemory addressing is referenced using the terminology PA14 - PA0 and BA8 - BA0, where PA14 - PA0 denotes the\n15 address bits required to designate a page address, and BA8 - BA0 denotes the 9 address bits required to designate a\nbyte address within the page. Therefore, when using the standard DataFlash page size, a total of 24 address bits are\nused.\nFor the “power of 2” binary page size (256 bytes), the buffer addressing is referenced in the datasheet using the\nconventional terminology BFA7 - BFA0 to denote the eight address bits required to designate a byte address within a\nbuffer. Main memory addressing is referenced using the terminology A22 - A0, where A22 - A8 denotes the 15 address\nbits required to designate a page address, and A7 - A0 denotes the 8 address bits required to designate a byte address\nwithin a page. Therefore, when using the binary page size, a total of 23 address bits are used.\n\n 7 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20225. Read Commands\nBy specifying the appropriate opcode, data can be read from the main memory or from either one of the two SRAM data\nbuffers. The DataFlash supports RapidS protocols for Mode 0 and Mode 3. Please see Section 25., Detailed Bit-level\nRead \nWaveforms: RapidS Mode 0/Mode 3  diagrams in this datasheet for details on the clock cycl e sequences for each\nmode.\n5.1 Continuous Array Read (Legacy Command: E8h Opcode)\nBy supplying an initial starting address for the main memory array, the Continuous Array Read command can be utilized to\nsequ e\nntially read a continuous stream of data from the device by simply providing a clock signal; no additional addressing\ninformation or control signals need to be provided. The DataFlash incorporates an internal address counter that will\nautomatically increment on every clock cycle, allowing one continuous read from memory to be performed without the\nneed for additional address sequences. To perform a Continuous Array Read using the standard DataFlash page size\n(264 bytes), an opcode of E8h must be clocked into the device followed by three address bytes (which comprise the 24-bit\npage and byte address sequence) and four dummy bytes. The first 15 bits (PA14 - PA0) of the 24-bit address sequence\nspecify which page of the main memory array to read and the last 9 (BA8 - BA0) of the 24-bit address sequence specify\nthe starting byte address within the page. To perform a Continuous Array Read using the binary page size\n(256 bytes), an opcode of E8h must be clocked into the device followed by three address bytes and four dummy bytes.\nThe first 15 bits (A22 - A8) of the 23-bit address sequence specify which page of the main memory array to read and the\nlast 8 bits (A7 - A0) of the 23-bit address sequence specify the starting byte address within the page. The dummy bytes\nthat follow the address bytes are needed to initialize the read operation. Following the dummy bytes, additional clock\npulses on the SCK pin will result in data being output on the SO (serial output) pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy bytes, and the reading of\ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue\nreading at the beginning of the next page with no delays incurred during the page boundary crossover (the crossover from\nthe end of one page to the beginning of the next page). When the last bit in the main memory array has been read, the\ndevice will continue reading back at the beginning of the first page of memory. As with crossing over page boundaries, no\ndelays will be incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum\nSCK frequency allowable for the Continuous Array Read is defined by the fCAR1 specification. The Continuous Array Read\nbypas\nses the data buffers and leaves the contents of the buffers unchanged.\nWarning: This command is not recommended for new designs.\n5.2 Continuous Array Read (High Frequency Mode: 1Bh Opcode)\nThis command can be used to read the main memory array sequentially at the highest possible operating clock\nfrequ\nency up to the maximum specified by fCAR4. To perform a Continuous Array Read using the standard DataFlash\npage \nsize (264 bytes), the CS  pin must first be asserted, and then an opcode of 1Bh must be clocked into the device\nfollowed by three address bytes and two dummy bytes. The first 15 bits (PA14 - PA0) of the 24-bit address sequence\nspecify which page of the main memory array to read and the last 9 bits (BA8 - BA0) of the 24-bit address sequence\nspecify the starting byte address within the page. To perform a Continuous Array Read using the binary page size (256\nbytes), the opcode 1Bh must be clocked into the device followed by three address bytes (A22 - A0) and two dummy\nbytes. Following the dummy bytes, additional clock pulses on the SCK pin will result in data being output on the SO\n(Serial Output) pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy bytes, and the reading of\ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue\nreading at the beginning of the next page with no delays incurred during the page boundary crossover (the crossover\nfrom the end of one page to the beginning of the next page). When the last bit in the main memory array has been read,\nthe device will continue reading back at the beginning of the first page of memory. As with crossing over page\nboundaries, no delays will be incurred when wrapping around from the end of the array to the beginning of the array.\n\n 8 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022A low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR4 specification. The Continuous Array \nRead\n bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.3 Continuous Array Read (High Frequency Mode: 0Bh Opcode)\nThis command can be used to read the main memory array sequentially at higher clock frequencies up to the maximum \nspec\nified by fCAR1. To perform a Continuous Array Read using the standard DataFlash page size (264 bytes), the CS  pin \nmust first be asserted, and then an opcode of 0Bh must be clocked into the device followed by three address bytes and \none dummy byte. The first 15 bits (PA14 - PA0) of the 24-bit address sequence specify which page of the main memory \narray to read and the last 9 bits (BA8 - BA0) of the 24-bit address sequence specify the starting byte address within the \npage. To perform a Continuous Array Read using the binary page size (256 bytes), the opcode 0Bh must be clocked into \nthe device followed by three address bytes (A22 - A0) and one dummy byte. Following the dummy byte, additional clock \npulses on the SCK pin will result in data being output on the SO pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy byte, and the reading of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no delays incurred during the page boundary crossover (the crossover \nfrom the end of one page to the beginning of the next page). When the last bit in the main memory array has been read, \nthe device will continue reading back at the beginning of the first page of memory. As with crossing over page \nboundaries, no delays will be incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR1 specification. The Continuous Array \nRead\n bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.4 Continuous Array Read (Low Frequency Mode: 03h Opcode) \nThis command can be used to read the main memory array sequentially at lower clock frequencies up to maximum \nspec\nified by fCAR2. Unlike the previously described read commands, this Continuous Array Read command for the lower \ncloc\nk frequencies does not require the clocking in of dummy bytes after the address byte sequence. To perform a \nContinuous Array Read using the standard DataFlash page size (264 bytes), the CS  pin must first be asserted, and then \nan opcode of 03h must be clocked into the device followed by three address bytes. The first 15 bits (PA14 - PA0) of the \n24-bit address sequence specify which page of the main memory array to read and the last 9 bits (BA8 - BA0) of the\naddress sequence specify the starting byte address within the page. To perform a Continuous Array Read using the\nbinary page size (256 bytes), the opcode 03h must be clocked into the device followed by three address bytes (A22 -\nA0). Following the address bytes, additional clock pulses on the SCK pin will result in data being output on the SO pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, and the reading of data. When the end \nof a page in the main memory is reached during a Continuous Array Read, the device will continue reading at the \nbeginning of the next page with no delays incurred during the page boundary crossover (the crossover from the end of \none page to the beginning of the next page). When the last bit in the main memory array has been read, the device will \ncontinue reading back at the beginning of the first page of memory. As with crossing over page boundaries, no delays will \nbe incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR2 specification. The Continuous Array \nRead\n bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.5 Continuous Array Read (Low Power Mode: 01h Opcode) \nThis command is ideal for applications that want to minimize power consumption and do not need to read the memory \narra\ny at high frequencies. Like the 03h opcode, this Continuous Array Read command allows reading the main memory \narray sequentially without the need for dummy bytes to be clocked in after the address byte sequence. The memory can \nbe read at clock frequencies up to maximum specified by fCAR3. To perform a Continuous Array Read using the standard \nData\nFlash page size (264 bytes), the CS  pin must first be asserted, and then an opcode of 01h must be clocked into the \ndevice followed by three address bytes. The first 15 bits (PA14 - PA0) of the 24-bit address sequence specify which page \n\n 9 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022of the main memory array to read and the last 9 bits (BA8 - BA0) of the 24-bit address sequence specify the starting byte \naddress within the page. To perform a Continuous Array Read using the binary page size (256 bytes), the opcode 01h \nmust be clocked into the device followed by three address bytes (A22 - A0). Following the address bytes, additional clock \npulses on the SCK pin will result in data being output on the SO pin.\nThe CS  pin must remain low during the loading of the opcode, the address bytes, and the reading of data. When the end \nof a page in the main memory is reached during a Continuous Array Read, the device will continue reading at the \nbeginning of the next page with no delays incurred during the page boundary crossover (the crossover from the end of \none page to the beginning of the next page). When the last bit in the main memory array has been read, the device will \ncontinue reading back at the beginning of the first page of memory. As with crossing over page boundaries, no delays will \nbe incurred when wrapping around from the end of the array to the beginning of the array.\nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Read is defined by the fCAR3 specification. The Continuous Array \nRead\n bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.6 Main Memory Page Read\nA Main Memory Page Read allows the reading of data directly from a single page in the main memory, bypassing both of \nthe \ndata buffers and leaving the contents of the buffers unchanged. To start a page read using the standard DataFlash \npage size (264 bytes), an opcode of D2h must be clocked into the device followed by three address bytes (which \ncomprise the 24-bit page and byte address sequence) and four dummy bytes. The first 15 bits (PA14 - PA0) of the 24-bit \naddress sequence specify the page in main memory to be read and the last 9 bits (BA8 - BA0) of the 24-bit address \nsequence specify the starting byte address within that page. To start a page read using the binary page size (256 bytes), \nthe opcode D2h must be clocked into the device followed by three address bytes and four dummy bytes. The first 15 bits \n(A22 - A8) of the 23-bit address sequence specify which page of the main memory array to read, and the last 8 bits (A7 - \nA0) of the 23-bit address sequence specify the starting byte address within that page. The dummy bytes that follow the \naddress bytes are sent to initialize the read operation. Following the dummy bytes, the additional pulses on SCK result in \ndata being output on the SO (serial output) pin. \nThe CS  pin must remain low during the loading of the opcode, the address bytes, the dummy bytes, and the reading of \ndata. Unlike the Continuous Array Read command, when the end of a page in main memory is reached, the device will \ncontinue reading back at the beginning of the same page rather than the beginning of the next page. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The maximum \nSCK frequency allowable for the Main Memory Page Read is defined by the fSCK specification. The Main Memory Page \nRead\n bypasses both data buffers and leaves the contents of the buffers unchanged.\n5.7 Buffer Read \nThe SRAM data buffers can be accessed independently from the main memory array, and utilizing the Buffer Read \ncomm\nand allows data to be sequentially read directly from either one of the buffers. Four opcodes, D4h or D1h for \nBuffer 1 and D6h or D3h for Buffer 2, can be used for the Buffer Read command. The use of each opcode depends on \nthe maximum SCK frequency that will be used to read data from the buffers. The D4h and D6h opcode can be used at \nany SCK frequency up to the maximum specified by fCAR1 while the D1h and D3h opcode can be used for lower \nfreq\nuency read operations up to the maximum specified by fCAR2.\nTo p\nerform a Buffer Read using the standard DataFlash buffer size (264 bytes), the opcode must be clocked into the \ndevice followed by three address bytes comprised of 15 dummy bits and 9 buffer address bits (BFA8 - BFA0). To perform \na Buffer Read using the binary buffer size (256 bytes), the opcode must be clocked into the device followed by three \naddress bytes comprised of 16 dummy bits and 8 buffer address bits (BFA7 - BFA0). Following the address bytes, one \ndummy byte must be clocked into the device to initialize the read operation if using opcodes D4h or D6h. The CS  pin \nmust remain low during the loading of the opcode, the address bytes, the dummy byte (if using opcodes D4h or D6h), \nand the reading of data. When the end of a buffer is reached, the device will continue reading back at the beginning of \nthe buffer. A low-to-high transition on the CS  pin will terminate the read operation and tri-state the output pin (SO).\n\n 10 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20226. Program and Erase Commands\n6.1 Buffer Write\nUtilizing the Buffer Write command allows data clocked in from the SI pin to be written directly into either one of the\nSRAM \ndata buffers.\nTo load data into a buffer using the standard DataFlash buffer size (264 bytes), an opcode of 84h for Buffer 1 or 87h for\nBuffer 2 must be clocked into the device followed by three address bytes comprised of 15 dummy bits and 9 buffer\naddress bits (BFA8 - BFA0). The 9 buffer address bits specify the first byte in the buffer to be written.\nTo load data into a buffer using the binary buffer size (256 bytes), an opcode of 84h for Buffer 1 or 87h for Buffer 2, must\nbe clocked into the device followed by 16 dummy bits and 8 buffer address bits (BFA7 - BFA0). The 8 buffer address bits\nspecify the first byte in the buffer to be written.\nAfter the last address byte has been clocked into the device, data can then be clocked in on subsequent clock cycles. If\nthe end of the data buffer is reached, the device will wrap around back to the beginning of the buffer. Data will continue to\nbe loaded into the buffer until a low-to-high transition is detected on the CS  pin.\n6.2 Buffer to Main Memory Page Program with Built-In Erase\nThe Buffer to Main Memory Page Program with Built-In Erase command allows data that is stored in one of the SRAM\nbuff\ners to be written into an erased or programmed page in the main memory array. It is not necessary to pre-erase the\npage in main memory to be written because this command will automatically erase the selected page prior to the\nprogram cycle.\nTo perform a Buffer to Main Memory Page Program with Built-In Erase using the standard DataFlash page size\n(264 bytes), an opcode of 83h for Buffer 1 or 86h for Buffer 2 must be clocked into the device followed by three address\nbytes comprised of 15 page address bits (PA14 - PA0) that specify the page in the main memory to be written, and 9\ndummy bits.\nTo perform a Buffer to Main Memory Page Program with Built-In Erase using the binary page size (256 bytes), an opcode\nof 83h for Buffer 1 or 86h for Buffer 2 must be clocked into the device followed by three address bytes comprised of 1\ndummy bit, 15 page address bits (A22 - A8) that specify the page in the main memory to be written, and 8 dummy bits.\nWhen a low-to-high transition occurs on the CS  pin, the device will first erase the selected page in main memory (the\nerased state is a Logic 1) and then program the data stored in the appropriate buffer into that same page in main\nmemory. Both the erasing and the programming of the page are internally self-timed and should take place in a\nmaximum time of tEP. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device  is busy.\nThe device also incorporates an intelligent erase and program algorithm that can detect when a byte location fails to\nerase or program properly. If an erase or programming error arises, it will be indicated by the EPE bit in the Status\nRegister.\n6.3 Buffer to Main Memory Page Program without Built-In Erase\nThe Buffer to Main Memory Page Program without Built-In Erase command allows data that is stored in one of the SRAM\nbuff\ners to be written into a pre-erased page in the main memory array. It is necessary that the page in main memory to be\nwritten be previously erased in order to avoid programming errors.\nTo perform a Buffer to Main Memory Page Program without Built-In Erase using the standard DataFlash page size\n(264 bytes), an opcode of 88h for Buffer 1 or 89h for Buffer 2 must be clocked into the device followed by three address\nbytes comprised of 15 page address bits (PA14 - PA0) that specify the page in the main memory to be written, and 9\ndummy bits.\nTo perform a Buffer to Main Memory Page Program using the binary page size (256 bytes), an opcode of 88h for Buffer\n1 or 89h for Buffer 2 must be clocked into the device followed by three address bytes comprised of 1 dummy bit,\n15 page address bits (A22 - A8) that specify the page in the main memory to be written, and 8 dummy bits.\n\n 11 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022When a low-to-high transition occurs on the CS  pin, the device will program the data stored in the appropriate buffer into \nthe specified page in the main memory. The page in main memory that is being programmed must have been previously \nerased using one of the erase commands (Page Erase, Block Erase, Sector Erase, or Chip Erase). The programming of \nthe page is internally self-timed and should take place in a maximum time of tP. During this time, the RDY/BUSY  bit in the \nStatu\ns Register will indicate that the device is busy.\nThe device also incorporates an intelligent programming algorithm that can detect when a byte location fails to program \nproperly. If a programming error arises, it will be indicated by the EPE bit in the Status Register.\n6.4 Main Memory Page Program through Buffer with Built-In Erase\nThe Main Memory Page Program through Buffer with Built-In Erase command combines the Buffer Write and Buffer to \nMain\n Memory Page Program with Built-In Erase operations into a single operation to help simplify application firmware \ndevelopment. With the Main Memory Page Program through Buffer with Built-In Erase command, data is first clocked \ninto either Buffer 1 or Buffer 2, the addressed page in memory is then automatically erased, and then the contents of the \nappropriate buffer are programmed into the just-erased main memory page.\nTo perform a Main Memory Page Program through Buffer using the standard DataFlash page size (264 bytes), an \nopcode of 82h for Buffer 1 or 85h for Buffer 2 must first be clocked into the device followed by three address bytes \ncomprised of 15 page address bits (PA14 - PA0) that specify the page in the main memory to be written, and 9 buffer \naddress bits (BFA8 - BFA0) that select the first byte in the buffer to be written.\nTo perform a Main Memory Page Program through Buffer using the binary page size (256 bytes), an opcode of 82h for \nBuffer 1 or 85h for Buffer 2 must first be clocked into the device followed by three address bytes comprised of 1 dummy \nbit, 15 page address bits (A22 - A8) that specify the page in the main memory to be written, and 8 buffer address bits \n(BFA7 - BFA0) that select the first byte in the buffer to be written.\nAfter all address bytes have been clocked in, the device will take data from the input pin (SI) and store it in the specified \ndata buffer. If the end of the buffer is reached, the device will wrap around back to the beginning of the buffer. When \nthere is a low-to-high transition on the CS  pin, the device will first erase the selected page in main memory (the erased \nstate is a Logic 1) and then program the data stored in the buffer into that main memory page. Both the erasing and the \nprogramming of the page are internally self-timed and should take place in a maximum time of tEP. During this time, the \nRDY/\nBUSY  bit in the Status Register will indicate that the device  is busy.\nThe device also incorporates an intelligent erase and programming algorithm that can detect when a byte location fails to \nerase or program properly. If an erase or program error arises, it will be indicated by the EPE bit in the Status Register.\n6.5 Main Memory Byte/Page Program through Buffer 1 without Built-In Erase\nThe Main Memory Byte/Page Program through Buffer 1 without Built-In Erase command combines both the Buffer Write \nand \nBuffer to Main Memory Program without Built-In Erase operations to allow any number of bytes (1 to 256/264 bytes) \nto be programmed directly into previously erased locations in the main memory array. With the Main Memory Byte/Page \nProgram through Buffer 1 without Built-In Erase command, data is first clocked into Buffer 1, and then only the bytes \nclocked into the buffer are programmed into the pre-erased byte locations in main memory. Multiple bytes up to the page \nsize can be entered with one command sequence.\nTo perform a Main Memory Byte/Page Program through Buffer 1 using the standard DataFlash page size (264 bytes), an \nopcode of 02h must first be clocked into the device followed by three address bytes comprised of 15 page address bits \n(PA14 - PA0) that specify the page in the main memory to be written, and 9 buffer address bits (BFA8 - BFA0) that select \nthe first byte in the buffer to be written. After all address bytes are clocked in, the device will take data from the input pin \n(SI) and store it in Buffer 1. Any number of bytes (1 to 264) can be entered. If the end of the buffer is reached, then the \ndevice will wrap around back to the beginning of the buffer.\nTo perform a Main Memory Byte/Page Program through Buffer 1 using the binary page size (256 bytes), an opcode of \n02h for Buffer 1 using must first be clocked into the device followed by three address bytes comprised of 1 dummy bit, 15 \npage address bits (A22 - A8) that specify the page in the main memory to be written, and 8 buffer address bits (BFA7 - \nBFA0) that selects the first byte in the buffer to be written. After all address bytes are clocked in, the device will take data \nfrom the input pin (SI) and store it in Buffer 1. Any number of bytes (1 to 256) can be entered. If the end of the buffer is \n\n 12 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022reached, then the device will wrap around back to the beginning of the buffer. When using the binary page size, the page \nand buffer address bits correspond to a 23-bit logical address (A22-A0) in the main memory.\nAfter all data bytes have been clocked into the device, a low-to-high transition on the CS  pin will start the program \noperation in which the device will program the data stored in Buffer 1 into the main memory array. Only the data bytes \nthat were clocked into the device will be programmed into the main memory. \nExample: If only two data bytes were clocked into the device, then only two bytes will be programmed into main \nmemory and the remaining bytes in the memory page will remain in their previous state. \nThe CS  pin must be deasserted on a byte boundary (multiples of eight bits); otherwise, the operation will be aborted and \nno data will be programmed. The programming of the data bytes is internally self-timed and should take place in a \nmaximum time of tP (the program time will be a multiple of the tBP time depending on the number of bytes being \nprog\nrammed). During this time, the RDY/BUSY  bit in the Status Register will indicate that the device  is busy.\nThe device also incorporates an intelligent programming algorithm that can detect when a byte location fails to program \nproperly. If a programming error arises, it will be indicated by the EPE bit in the Status Register.\n6.6 Read-Modify-Write\nA completely self-contained read-modify-write operation can be performed to reprogram any number of sequential bytes \nin a\n page in the main memory array without affecting the rest of the bytes in the same page. This command allows the \ndevice to easily emulate an EEPROM by providing a method to modify a single byte or more in the main memory in a \nsingle operation, without the need for pre-erasing the memory or the need for any external RAM buffers. The \nRead-Modify-Write command is essentially a combination of the Main Memory Page to Buffer Transfer, Buffer Write, and \nBuffer to Main Memory Page Program with Built-in Erase commands. \nTo perform a Read-Modify-Write using the standard DataFlash page size (264 bytes), an opcode of 58h for Buffer 1 or \n59h for Buffer 2 must be clocked into the device followed by three address bytes comprised of 15 page address bits \n(PA14 - PA0) that specify the page in the main memory to be written, and 9 byte address bits (BA8 - BA0) that designate \nthe starting byte address within the page to reprogram. \nTo perform a Read-Modify-Write using the binary page size (256 bytes), an opcode of 58h for Buffer 1 or 59h for Buffer 2 \nmust be clocked into the device followed by three address bytes comprised of 1 dummy bit, 15 page address bits (A22 - \nA8) that specify the page in the main memory to be written, and 8 byte address bits (A7 - A0) designate the starting byte \naddress within the page to reprogram. \nAfter the address bytes have been clocked in, any number of sequential data bytes from one to 256/264 bytes can be \nclocked into the device. If the end of the buffer is reached when clocking in the data, then the device will wrap around \nback to the beginning of the buffer. After all data bytes have been clocked into the device, a low-to-high transition on the \nCS pin will start the self-contained, internal read-modify-write operation. Only the data bytes that were clocked into the \ndevice will be reprogrammed in the main memory.\nExample: If only one data byte was clocked into the device, then only one byte in main memory will be reprogrammed \nand the remaining bytes in the main memory page will remain in their previous state. \nThe CS  pin must be deasserted on a byte boundary (multiples of eight bits); otherwise, the operation will be aborted and \nno data will be programmed. The reprogramming of the data bytes is internally self-timed and should take place in a \nmaximum time of tP. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device is busy.\nThe device also incorporates an intelligent erase and programming algorithm that can detect when a byte location fails to \nerase or program properly. If an erase or program error arises, it will be indicated by the EPE bit in the Status Register.\nNote: The Read-Modify-Write command uses the same opcodes as the Auto Page Rewrite command. If no data \nbytes are clocked into the device, then the device will perform an Auto Page Rewrite operation. See the \nAuto Page Rewrite command description on page 27  for more details.\n\n 13 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20226.7 Page Erase\nThe Page Erase command can be used to individually erase any page in the main memory array allowing the Buffer to \nMain\n Memory Page Program without Built-In Erase command or the Main Memory Byte/Page Program through Buffer 1 \ncommand to be utilized at a later time.\nTo perform a Page Erase with the standard DataFlash page size (264 bytes), an opcode of 81h must be clocked into the \ndevice followed by three address bytes comprised of 15 page address bits (PA14 - PA0) that specify the page in the main \nmemory to be erased, and 9 dummy bits.\nTo perform a Page Erase with the binary page size (256 bytes), an opcode of 81h must be clocked into the device \nfollowed by three address bytes comprised of 1 dummy bit, 15 page address bits (A22 - A8) that specify the page in the \nmain memory to be erased, and 8 dummy bits.\nWhen a low-to-high transition occurs on the CS  pin, the device will erase the selected page (the erased state is a \nLogic 1). The erase operation is internally self-timed and should take place in a maximum time of tPE. During this time, the \nRDY/\nBUSY  bit in the Status Register will indicate that the device  is busy.\nThe device also incorporates an intelligent erase algorithm that can detect when a byte location fails to erase properly. If \nan erase error arises, it will be indicated by the EPE bit in the Status Register.\n6.8 Block Erase\nThe Block Erase command can be used to erase a block of eight pages at one time. This command is useful when \nneed\ning to pre-erase larger amounts of memory and is more efficient than issuing eight separate Page Erase \ncommands.\nTo perform a Block Erase with the standard DataFlash page size (264 bytes), an opcode of 50h must be clocked into the \ndevice followed by three address bytes comprised of 12 page address bits (PA14 - PA3), and \n12 dummy bits. The 12 page address bits are used to specify which block of 8 pages is to be erased.\nTo perform a Block Erase with the binary page size (256 bytes), an opcode of 50h must be clocked into the device \nfollowed by three address bytes comprised of 1 dummy bit, 12 page address bits (A22 - A11), and 11 dummy bits. The 12 \npage address bits are used to specify which block of 8 pages is to be erased.\nWhen a low-to-high transition occurs on the CS  pin, the device will erase the selected block of eight pages. The erase \noperation is internally self-timed and should take place in a maximum time of tBE. During this time, the RDY/BUSY  bit in \nthe S\ntatus Register will indicate that the device is busy. \nThe device also incorporates an intelligent erase algorithm that can detect when a byte location fails to erase properly. If \nan erase error arises, it will be indicated by the EPE bit in the Status Register.\nTable 6-1. Block Erase Addressing\nPA14\n/A22PA13\n/A21PA12\n/A20PA11/\nA19PA10\n/A18PA9/\nA17PA8/\nA16PA7/\nA15PA6/\nA14PA5/\nA13PA4/\nA12PA3/\nA11PA2/\nA10PA1/\nA9PA0/\nA8 Block\n0 0 0 0 0 0 0 0 0 0 0 0 X X X 0\n0 0 0 0 0 0 0 0 0 0 0 1 X X X 1\n0 0 0 0 0 0 0 0 0 0 1 0 X X X 2\n0 0 0 0 0 0 0 0 0 0 1 1 X X X 3\n•\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n•\n1 1 1 1 1 1 1 1 1 1 0 0 X X X 4092\n1 1 1 1 1 1 1 1 1 1 0 1 X X X 4093\n1 1 1 1 1 1 1 1 1 1 1 0 X X X 4094\n1 1 1 1 1 1 1 1 1 1 1 1 X X X 4095\n\n 14 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20226.9 Sector Erase\nThe Sector Erase command can be used to individually erase any sector in the main memory.\nThe \nmain memory array is comprised of thirty-three sectors, and only one sector can be erased at a time. To perform an \nerase of Sector 0a or Sector 0b with the standard DataFlash page size (264 bytes), an opcode of 7Ch must be clocked \ninto the device followed by three address bytes comprised of 12 page address bits (PA14 - PA3), and \n12 dummy bits. To perform a Sector 1-31 erase, an opcode of 7Ch must be clocked into the device followed by three \naddress bytes comprised of 5 page address bits (PA14 - PA10), and 19 dummy bits.\nTo perform a Sector 0a or Sector 0b erase with the binary page size (256 bytes), an opcode of 7Ch must be clocked into \nthe device followed by three address bytes comprised of 1 dummy bit, 12 page address bits (A22 - A11), and \n11 dummy bits. To perform a Sector 1-31 erase, an opcode of 7Ch must be clocked into the device followed by 1 dummy \nbit, 5 page address bits (A22 - A18), and 18 dummy bits. \nThe page address bits are used to specify any valid address location within the sector to be erased. When a \nlow-to high transition occurs on the CS  pin, the device will erase the selected sector. The erase operation is internally \nself-timed and should take place in a maximum time of tSE. During this time, the RDY/BUSY  bit in the Status Register will \nindic\nate that the device is busy.\nThe device also incorporates an intelligent algorithm that can detect when a byte location fails to erase properly. If an \nerase error arises, it will be indicated by the EPE bit in the Status Register.\nTable 6-2. Sector Erase Addressing\n6.10 Chip Erase\nThe Chip Erase command allows the entire main memory array to be erased can be erased at one time.\nTo e\nxecute the Chip Erase command, a 4-byte command sequence of C7h, 94h, 80h, and 9Ah must be clocked into the \ndevice. Since the entire memory array is to be erased, no address bytes need to be clocked into the device, and any data \nclocked in after the opcode will be ignored. After the last bit of the opcode sequence has been clocked in, the CS  pin \nmust be deasserted to start the erase process. The erase operation is internally self-timed and should take place in a \ntime of tCE. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device is busy.\nThe Chip Erase command will not affect sectors that are protected or locked down; the contents of those sectors will \nremain unchanged. Only those sectors that are not protected or locked down will be erased.PA14\n/A22PA13\n/A21PA12\n/A20PA11/\nA19PA10\n/A18PA9/\nA17PA8/\nA16PA7/\nA15PA6/\nA14PA5/\nA13PA4/\nA12PA3/\nA11PA2/\nA10PA1/\nA9PA0/\nA8 Sector\n0 0 0 0 0 0 0 0 0 0 0 0 X X X 0a\n0 0 0 0 0 0 0 0 0 0 0 1 X X X 0b\n0 0 0 0 1 X X X X X X X X X X 1\n0 0 0 1 0 X X X X X X X X X X 2\n•\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n•\n1 1 1 0 0 X X X X X X X X X X 28\n1 1 1 0 1 X X X X X X X X X X 29\n1 1 1 1 0 X X X X X X X X X X 30\n1 1 1 1 1 X X X X X X X X X X 31\n\n 15 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022The WP  pin can be asserted while the device is erasing, but protection will not be activated until the internal erase cycle \ncompletes.\nThe device also incorporates an intelligent algorithm that can detect when a byte location fails to erase properly. If an \nerase error arises, it will be indicated by the EPE bit in the Status Register.\nTable 6-3. Chip Erase Command\nFigu\nre 6-1. Chip Erase\n6.11 Program/Erase Suspend\nIn some code and data storage applications, it may not be possible for the system to wait the milliseconds required for \nthe \nFlash memory to complete a program or erase cycle. The Program/Erase Suspend command allows a program or \nerase operation in progress to a particular 256KB sector of the main memory array to be suspended so that other device \noperations can be performed. \nExample: By suspending an erase operation to a particular sector, the system can perform functions such as a \nprogram or read operation within a different 256KB sector. Other device operations, such as Read Status \nRegister, can also be performed while a program or erase operation is suspended.\nTo perform a Program/Erase Suspend, an opcode of B0h must be clocked into the device. No address bytes need to be \nclocked into the device, and any data clocked in after the opcode will be ignored. When the CS  pin is deasserted, the \nprogram or erase operation currently in progress will be suspended within a time of tSUSP. One of the Program Suspend \nbits\n (PS1 or PS2) or the Erase Suspend bit (ES) in the Status Register will then be set to the Logic 1 state. In addition, \nthe RDY/BUSY  bit in the Status Register will indicate that the device is ready for another operation. \nRead operations are not allowed to a 256KB sector that has had its program or erase operation suspended. If a read is \nattempted to a suspended sector, then the device will output undefined data. Therefore, when performing a Continuous \nArray Read operation and the device\'s internal address counter increments and crosses the sector boundary to a \nsuspended sector, the device will then start outputting undefined data continuously until the address counter increments \nand crosses a sector boundary to an unsuspended sector.\nA program operation is not allowed to a sector that has been erase suspended. If a program operation is attempted to an \nerase suspended sector, then the program operation will abort. \nDuring an Erase Suspend, a program operation to a different 256KB sector can be started and subsequently suspended. \nThis results in a simultaneous Erase Suspend/Program Suspend condition and will be indicated by the states of both the \nES and PS1 or PS2 bits in the Status Register being set to a Logic 1.\nIf a Reset command is performed, or if the RESET  pin is asserted while a sector is erase suspended, then the suspend \noperation will be aborted and the contents of the sector will be left in an undefined state. However, if a reset is performed \nwhile a page is program or erase suspended, the suspend operation will abort but only the contents of the page that was \nbeing programmed or erased will be undefined; the remaining pages in the 256KB sector will retain their previous \ncontents.Command Byte 1 Byte 2 Byte 3 Byte 4\nChip Erase C7h 94h 80h 9Ah\nC7h 94h 80h 9AhCS\nEach transition represents eight bits\n\n 16 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Table 6-4. Operations Allowed and Not Allowed During Suspend\nCommandOperation During \nProgram Suspend in \nBuffer 1 (PS1)Operation During \nProgram Suspend in \nBuffer 2 (PS2)Operation During \nErase Suspend (ES)\nRead Commands\nRead Array (All Opcodes) Allowed Allowed Allowed\nRead Buffer 1 (All Opcodes) Allowed Allowed Allowed\nRead Buffer 2 (All Opcodes) Allowed Allowed Allowed\nProgram and Erase Commands\nBuffer 1 Write Not Allowed Allowed Allowed\nBuffer 2 Write Allowed Not Allowed Allowed\nBuffer 1 to Memory Program w/ Erase Not Allowed Not Allowed Not Allowed\nBuffer 2 to Memory Program w/ Erase Not Allowed Not Allowed Not Allowed\nBuffer 1 to Memory Program w/o Erase Not Allowed Not Allowed Allowed\nBuffer 2 to Memory Program w/o Erase Not Allowed Not Allowed Allowed\nMemory Program through Buffer 1 w/ Erase Not Allowed Not Allowed Not Allowed\nMemory Program through Buffer 2 w/ Erase Not Allowed Not Allowed Not Allowed\nMemory Program through Buffer 1 w/o Erase Not Allowed Not Allowed Allowed\nAuto Page Rewrite through Buffer 1 Not Allowed Not Allowed Not Allowed\nAuto Page Rewrite through Buffer 2 Not Allowed Not Allowed Not Allowed\nRead-Modify-Write through Buffer 1 Not Allowed Not Allowed Not Allowed\nRead-Modify-Write through Buffer 2 Not Allowed Not Allowed Not Allowed\nPage Erase Not Allowed Not Allowed Not Allowed\nBlock Erase Not Allowed Not Allowed Not Allowed\nSector Erase Not Allowed Not Allowed Not Allowed\nChip Erase Not Allowed Not Allowed Not Allowed\nProtection and Security Commands\nEnable Sector Protection Not Allowed Not Allowed Not Allowed\nDisable Sector Protection Not Allowed Not Allowed Not Allowed\nErase Sector Protection Register Not Allowed Not Allowed Not Allowed\nProgram Sector Protection Register Not Allowed Not Allowed Not Allowed\nRead Sector Protection Register Allowed Allowed Allowed\nSector Lockdown Not Allowed Not Allowed Not Allowed\nRead Sector Lockdown Allowed Allowed Allowed\nFreeze Sector Lockdown State Not Allowed Not Allowed Not Allowed\nProgram Security Register Not Allowed Not Allowed Not Allowed\nRead Security Register Allowed Allowed Allowed\nAdditional Commands\nMain Memory to Buffer 1 Transfer Not Allowed  Allowed  Allowed\nMain Memory to Buffer 2 Transfer Allowed Not Allowed Allowed\nMain Memory to Buffer 1 Compare Not Allowed Allowed Allowed\nMain Memory to Buffer 2 Compare Allowed Not Allowed Allowed\nEnter Deep Power-Down Not Allowed Not Allowed Not Allowed\nResume from Deep Power-Down Not Allowed Not Allowed Not Allowed\nEnter Ultra-Deep Power-Down mode Not Allowed Not Allowed Not Allowed\nRead Configuration Register Allowed Allowed Allowed\nRead Status Register Allowed Allowed Allowed\nRead Manufacturer and Device ID Allowed Allowed Allowed\nReset (via Hardware or Software) Allowed Allowed Allowed\n\n 17 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20226.12 Program/Erase Resume\nThe Program/Erase Resume command allows a suspended program or erase operation to be resumed and continue \nwher\ne it left off.\nTo perform a Program/Erase Resume, an opcode of D0h must be clocked into the device. No address bytes need to be \nclocked into the device, and any data clocked in after the opcode will be ignored. When the CS  pin is deasserted, the \nprogram or erase operation currently suspended will be resumed within a time of tRES. The PS1 bit, PS2 bit, or ES bit in \nthe \nStatus Register will then be reset back to a Logic 0 state to indicate that the program or erase operation is no longer \nsuspended. In addition, the RDY/BUSY  bit in the Status Register will indicate that the device  is busy performing a \nprogram or erase operation. \nDuring a simultaneous Erase Suspend/Program Suspend condition, issuing the Program/Erase Resume command will \nresult in the program operation resuming first. After the program operation has been completed, the Program/Erase \nResume command must be issued again in order for the erase operation to be resumed.\nWhile the device is busy resuming a program or erase operation, any attempts at issuing the Program/Erase Suspend \ncommand will be ignored. Therefore, if a resumed program or erase operation needs to be subsequently suspended \nagain, the system must either wait the entire tRES time before issuing the Program/Erase Suspend command, or it must \nchec\nk the status of the RDY/BUSY  bit or the appropriate PS1, PS2, or ES bit in the Status Register to determine if the \npreviously suspended program or erase operation has resumed.\n\n 18 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20227. Sector Protection\nTwo protection methods, hardware and software controlled, are provided for protection against inadvertent or erroneous\nprogram and erase cycles. The software controlled method relies on the use of software commands to enable and\ndisable sector protection while the hardware controlled method employs the use of the Write Protect (WP ) pin. The\nselection of which sectors that are to be protected or unprotected against program and erase operations is specified in\nthe Nonvolatile Sector Protection Register. The status of whether or not sector protection has been enabled or disabled\nby either the software or the hardware controlled methods can be determined by checking the Status Register.\n7.1 Software Sector Protection\nSoftware controlled protection is useful in applications in which the WP  pin is not or cannot be controlled by a host\nprocessor. In such instances, the WP  pin may be left floating (the WP  pin is internally pulled high) and sector protection\ncan be controlled using the Enable Sector Protection and Disable Sector Protection commands.\nIf the device is power cycled, then the software controlled protection will be disabled. Once the device is powered up, the\nEnable Sector Protection command should be reissued if sector protection is desired and if the WP  pin is not used.\n7.1.1 Enable Sector Protection\nSectors specified for protection in the Sector Protection Register can be protected from program and erase operations by\nissui\nng the Enable Sector Protection command. To enable the sector protection, a 4-byte command sequence of 3Dh,\n2Ah, 7Fh, and A9h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the\nCS pin must be deasserted to enable the Sector Protection.\nTable 7-1. Enable Sector Protection Command\nFigur\ne 7-1. Enable Sector Protection \n7.1.2 Disable Sector Protection \nTo disable the sector protection, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and 9Ah must be clocked into the \ndevic\ne. After the last bit of the opcode sequence has been clocked in, the CS  pin must be deasserted to disable the \nsector protection.\nTable 7-2. Disable Sector Protection CommandCommand Byte 1 Byte 2 Byte 3 Byte 4\nEnable Sector Protection 3Dh 2Ah 7Fh A9h\n3Dh 2Ah 7Fh A9hCS\nEach transition represents eight bitsSI\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nDisable Sector Protection 3Dh 2Ah 7Fh 9Ah\n\n 19 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Figure 7-2. Disable Sector Protection \n7.2 Hardware Controlled Protection\nSectors specified for protection in the Sector Protection Register and the Sector Protection Register itself can be \nprot\nected from program and erase operations by asserting the WP  pin and keeping the pin in its asserted state. The \nSector Protection Register and any sector specified for protection cannot be erased or programmed as long as the WP  \npin is asserted. In order to modify the Sector Protection Register, the WP  pin must be deasserted. If the WP  pin is \npermanently connected to GND, then the contents of the Sector Protection Register cannot be changed. If the WP  pin is \ndeasserted or permanently connected to VCC, then the contents of the Sector Protection Register can be modified.\nThe \nWP pin will override the software controlled protection method but only for protecting the sectors. \nExample: If the sectors were not previously protected by the Enable Sector Protection command, then simply \nasserting the WP  pin would enable the sector protection within the maximum specified tWPE time. When the \nWP pin is deasserted, however, the sector protection would no longer be enabled (after the maximum \nspecified tWPD time) as long as the Enable Sector Protection command was not issued while the WP  pin was \nasserted. If the Enable Sector Protection command was issued before or while the WP  pin was asserted, \nthen simply deasserting the WP  pin would not disable the sector protection. In this case, the Disable Sector \nProtection command would need to be issued while the WP  pin is deasserted to disable the sector \nprotection. The Disable Sector Protection command is also ignored whenever the WP  pin is asserted.\nA noise filter is incorporated to help protect against spurious noise that may inadvertently assert or deassert the WP  pin.\nFigures 7-3 and  Table 7-3  detail the sector protection status for various scenari os of the WP  pin, the Enable Sector \nProtection command, and the Disable Sector Protection command. \nFigure 7-3. WP  Pin and Protection Status\nTable 7-3. WP  Pin and Protection Status3Dh 2Ah 7Fh 9AhCS\nEach transition represents eight bitsSI\nTime \nPeriod WP Pin Enable Sector Protection CommandDisable Sector \nProtection CommandSector \nProtection \nStatusSector \nProtection \nRegister\n1 HighCommand Not Issued Previously X Disabled Read/Write\n— Issue Command Disabled Read/Write\nIssue Command — Enabled Read/Write\n2 Low X X Enabled Read\n3 HighCommand Issued During Period 1 or 2 Not Issued Yet Enabled Read/Write\n— Issue Command Disabled Read/Write\nIssue Command — Enabled Read/WriteWP1 2 3\n\n 20 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20227.3 Sector Protection Register\nThe nonvolatile Sector Protection Register specifies which sectors are to be protected or unprotected with either the \nsoft\nware or hardware controlled protection methods. The Sector Protection Register contains thirty two bytes of data, of \nwhich byte locations zero through thirty one contain values that specify whether Sectors 0 through 31 will be protected or \nunprotected. The Sector Protection Register is user modifiable and must be erased before it can be reprogrammed. \nTable 7-4  illustrates the format of the Sector Protection Registe r.\nTable 7-4. Sector Protection Register\nNote: 1. The default values for bytes 0 through 31 are 00h when shipped from Adesto.\nTable 7-5. Sector 0 (0a, 0b) Sector Protection Register Byte Value\nNote: 1. x = Don’t care\n7.3.1 Erase Sector Protection Register \nIn order to modify and change the values of the Sector Protection Register, it must first be erased using the Erase Sector \nProt\nection Register command.\nTo erase the Sector Protection Register, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and CFh must be clocked into \nthe device. After the last bit of the opcode sequence has been clocked in, the CS  pin must be deasserted to initiate the \ninternally self-timed erase cycle. The erasing of the Sector Protection Register should take place in a maximum time of \ntPE. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device  is busy. If the device is \npowered-down before the completion of the erase cycle, then the contents of the Sector Protection Register cannot be \nguaranteed.\nThe Sector Protection Register can be erased with sector protection enabled or disabled. Since the erased state (FFh) of \neach byte in the Sector Protection Register is used to indicate that a sector is specified for protection, leaving the sector \nprotection enabled during the erasing of the register allows the protection scheme to be more effective in the prevention \nof accidental programming or erasing of the device. If for some reason an erroneous program or erase command is sent \nto the device immediately after erasing the Sector Protection Register and before the register can be reprogrammed, \nthen the erroneous program or erase command will not be processed because all sectors would be protected.\nTable 7-6. Erase Sector Protection Register CommandSector Number 0 (0a, 0b) 1 to 31\nProtected\nSee Table 7-5FFh\nUnprotected 00h\nBit 7:6 Bit 5:4 Bit 3:2 Bit 1:0\nData \nValueSector 0a\n(Page 0-7)Sector 0b\n(Page 8-1023) N/A N/A\nSectors 0a and 0b Unprotected 00 00 XX XX 0xh\nProtect Sector 0a 11 00 XX XX Cxh\nProtect Sector 0b 00 11 XX XX 3xh\nProtect Sectors 0a and 0b 11 11 XX XX Fxh\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nErase Sector Protection Register 3Dh 2Ah 7Fh CFh\n\n 21 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Figure 7-4. Erase Sector Protection Register \n7.3.2 Program Sector Protection Register \nOnce\n the Sector Protection Register has been erased, it can be reprogrammed using the Program Sector Protection \nRegister command.\nTo program the Sector Protection Register, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and FCh must be clocked \ninto the device followed by thirty two bytes of data corresponding to Sectors 0 through 31. After the last bit of the opcode \nsequence and data have been clocked in, the CS  pin must be deasserted to initiate the internally self-timed program \ncycle. The programming of the Sector Protection Register should take place in a maximum time of tP. During this time, \nthe \nRDY/BUSY  bit in the Status Register will indicate that the device  is busy. If the device is powered-down before the \ncompletion of the erase cycle, then the contents of the Sector Protection Register cannot be guaranteed.\nIf the proper number of data bytes is not clocked in before the CS  pin is deasserted, then the protection status of the \nsectors corresponding to the bytes not clocked in cannot be guaranteed. \nExample: If only the first two bytes are clocked in instead of the complete thirty two bytes, then the protection status of \nthe last thirty sectors cannot be guaranteed. Furthermore, if more than thirty two bytes of data is clocked into \nthe device, then the data will wrap back around to the beginning of the register. For instance, if thirty three \nbytes of data are clocked in, then the thirty third byte will be stored at  byte location 0 of the Sector Protection \nRegis\nter.\nThe data bytes clocked into the Sector Protection Register need to be valid values (0xh, 3xh, Cxh, and Fxh for Sector 0a \nor Sector 0b, and 00h or FFh for other sectors) in order for the protection to function correctly. If a non-valid value is \nclocked into a byte location of the Sector Protection Register, then the protection status of the sector corresponding to \nthat byte location cannot be guaranteed. \nExample: If a value of 17h is clocked into byte location 2 of the Sector Protection Register, then the protection status \nof Sector 2 cannot be guaranteed.\nThe Sector Protection Register can be reprogrammed while the sector protection is enabled or disabled. Being able to \nreprogram the Sector Protection Register with the sector protection enabled allows the user to temporarily disable the \nsector protection to an individual sector rather than disabling sector protection completely.\nThe Program Sector Protection Register command utilizes Buffer 1 for processing. Therefore, the contents of Buffer 1 \nwill be altered from its previous state when this command is issued.\nTable 7-7. Program Sector Protection Register Command3Dh 2Ah 7Fh CFhCS\nEach transition represents eight bitsSI\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nProgram Sector Protection Register 3Dh 2Ah 7Fh FCh\n\n 22 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Figure 7-5. Program Sector Protection Register \n7.3.3 Read Sector Protection Register\nTo r\nead the Sector Protection Register, an opcode of 32h and three dummy bytes must be clocked into the device. After \nthe last bit of the opcode and dummy bytes have been clocked in, any additional clock pulses on the SCK pin will result \nin the Sector Protection Register contents being output on the SO pin. The first byte (byte location 0) corresponds to \nSector 0 (0a and 0b), the second byte corresponds to Sector 1, and the last byte (byte location 31) corresponds to \nSector 31. Once the last byte of the Sector Protection Register has been clocked out, any additional clock pulses will \nresult in undefined data being output on the SO pin. The CS  pin must be deasserted to terminate the Read Sector \nProtection Register operation and put the output into a high-impedance state.\nTable 7-8. Read Sector Protection Register Command\nNote: 1. XX = Dummy byte\nFigure 7-6. Read Sector Protection Register\n7.3.4 About the Sector Protection Register\nThe Sector Protection Register is subject to a limit of 10,000 erase/program cycles. Users are encouraged to carefully \neval\nuate the number of times the Sector Protection Register will be modified during the course of the application’s life \ncycle. If the application requires that the Security Protection Register be modified more than the specified limit of 10,000 \ncycles because the application needs to temporarily unprotect individual sectors (sector protection remains enabled \nwhile the Sector Protection Register is reprogrammed), then the application will need to limit this practice. Instead, a \ncombination of temporarily unprotecting individual sectors along with disabling sector protection completely will need to \nbe implemented by the application to ensure that the limit of 10,000 cycles is not exceeded.Data Byte\nn3Dh 2Ah 7Fh FChData Byte\nn + 1Data Byte\nn + 31CS\nEach transition represents eight bitsSI\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nRead Sector Protection Register 32h XXh XXh XXh\n32h XX XX XX\nData\nnData\nn + 1CS\nData\nn + 31SI\nSO\nEach transition represents eight bits\n\n 23 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20228. Security Features\n8.1 Sector Lockdown\nThe device incorporates a sector lockdown mechanism that allows each individual sector to be permanently locked so\nthat \nit becomes read-only (ROM). This is useful for applications that require the ability to permanently protect a number of\nsectors against malicious attempts at altering program code or security information.\nWarning: Once a sector is locked down, it can never be erased or programmed, and it can never be unlocked.\nTo is\nsue the sector lockdown command, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and 30h must be clocked into\nthe device followed by three address bytes specifying any address within the sector to be locked down. After the last\naddress bit has been clocked in, the CS  pin must be deasserted to initiate the internally self-timed lockdown sequence.\nThe lockdown sequence should take place in a maximum time of tP. During this time, the RDY/BUSY  bit in the Status\nRegist\ner will indicate that the device is busy. If the device is powered-down before the completion of the lockdown\nsequence, then the lockdown status of the sector cannot be guaranteed. In this case, it is recommended that the user\nread the Sector Lockdown Register to determine the status of the appropriate sector lockdown bits or bytes and re-issue\nthe Sector Lockdown command if necessary.\nTable 8-1. Sector Lockdown Command\nFigur\ne 8-1. Sector Lockdown\n8.1.1 Read Sector Lockdown Register\nThe nonvolatile Sector Lockdown Register specifies which sectors in the main memory are currently unlocked or have \nbeen  \npermanently locked down. The Sector Lockdown Register is a read-only register and contains thirty two bytes of \ndata which correspond to Sectors 0 through 31. To read the Sector Lockdown Register, an opcode of 35h must be \nclocked into the device followed by three dummy bytes. After the last bit of the opcode and dummy bytes have been \nclocked in, the data for the contents of the Sector Lockdown Register will be clocked out on the SO pin. The first byte \n(byte location 0) corresponds to Sector 0 (0a and 0b), the second byte corresponds to Sector 1, and the last byte (byte \nlocation 31) corresponds to Sector 31. After the last byte of the Sector Lockdown Register has been read, additional \npulses on the SCK pin will result in undefined data being output on the SO pin.\nDeasserting the CS  pin will terminate the Read Sector Lockdown Register operation and put the SO pin into a \nhigh-impedance state. Table 8-2  details the format the Sector Lockdown Register.\nTable 8-2. Sector Lockdown Register Command Byte 1 Byte 2 Byte 3 Byte 4\nSector Lockdown 3Dh 2Ah 7Fh 30h\n3Dh 2Ah 7Fh 30hCS\nAddress\nbyteAddress\nbyteAddress\nbyteSI\nEach transition represents eight bits\nSector Number 0 (0a, 0b) 1 to 31\nLocked\nSee Table 8-3FFh\nUnlocked 00h\n\n 24 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Table 8-3. Sector 0 (0a and 0b) Sector Lockdown Register Byte Value\nTable 8-4. Read Sector Lockdown Register Command\nFigure 8-2. Read Sector Lockdown Register\n8.1.2 Freeze Sector Lockdown \nThe \nSector Lockdown command can be permanently disabled, and the current sector lockdown state can be \npermanently frozen so that no additional sectors can be locked down aside from those already locked down. Any \nattempts to issue the Sector Lockdown command after the Sector Lockdown State has been frozen will be ignored.\nTo issue the Freeze Sector Lockdown command, the CS  pin must be asserted and the opcode sequence of 34h, 55h, \nAAh, and 40h must be clocked into the device. Any additional data clocked into the device will be ignored. When the CS  \npin is deasserted, the current sector lockdown state will be permanently frozen within a time of tLOCK. In addition, the SLE \nbit \nin the Status Register will be permanently reset to a Logic 0 to indicate that the Sector Lockdown command is \npermanently disabled.\nTable 8-5. Freeze Sector Lockdown \nFigu\nre 8-3. Freeze Sector Lockdown Bit 7:6 Bit 5:4 Bit 3:2 Bit 1:0\nData \nValueSector 0a\n(Page 0-7)Sector 0b\n(Page 8-1023) N/A N/A\nSectors 0a and 0b Unlocked 00 00 00 00 00h\nSector 0a Locked 11 00 00 00 C0h\nSector 0b Locked 00 11 00 00 30h\nSectors 0a and 0b Locked 11 11 00 00 F0h\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nRead Sector Lockdown Register 35h XXh XXh XXh\n32h XX XX XX\nData\nnData\nn + 1CS\nData\nn + 31SI\nSO\nEach transition represents eight bits\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nFreeze Sector Lockdown 34h 55h AAh 40h\n34h 55h AAh 40hCS\nSI\nEach transition represents eight bits\n\n 25 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20228.2 Security Register\nThe device contains a specialized Security Register that can be used for purposes such as unique device serialization or \nlock\ned key storage. The register is comprised of a total of 128 bytes that is divided into two portions. The first 64 bytes \n(byte locations 0 through 63) of the Security Register are allocated as a One-Time Programmable space. Once these \n64 bytes have been programmed, they cannot be erased or reprogrammed. The remaining 64 bytes of the register (byte \nlocations 64 through 127) are factory programmed by Adesto and will contain a unique value for each device. The factory \nprogrammed data is fixed and cannot be changed.\nTable 8-6. Security Register\n8.2.1 Programming the Security Register\nThe \nuser programmable portion of the Security Register does not need to be erased before it is programmed.\nTo program the Security Register, a 4-byte opcode sequence of 9Bh, 00h, 00h, and 00h must be clocked into the device. \nAfter the last bit of the opcode sequence has been clocked into the device, the data for the contents of the 64-byte user \nprogrammable portion of the Security Register must be clocked in.\nAfter the last data byte has been clocked in, the CS  pin must be deasserted to initiate the internally self-timed program \ncycle. The programming of the Security Register should take place in a time of tP, during which time the RDY/BUSY  bit in \nthe S\ntatus Register will indicate that the device is busy. If the device is powered-down during the program cycle, then the \ncontents of the 64-byte user programmable portion of the Security Register cannot be guaranteed.\nIf the full 64 bytes of data are not clocked in before the CS  pin is deasserted, then the values of the byte locations not \nclocked in cannot be guaranteed. \nExample: If only the first two bytes are clocked in instead of the complete 64 bytes, then the remaining 62 bytes of the \nuser programmable portion of the Security Register cannot be guaranteed. Furthermore, if more than \n64 bytes of data is clocked into the device, then the data will wrap back around to the beginning of the \nregister. For example, if 65 bytes of data are clocked in, then the 65th byte will be stored at byte location 0 of \nthe Security Register.\nWarning: The user programmable portion of the Security Register can only be programmed one time.  \nTher\nefore, it is not possible, for example, to only program the first two bytes of the register and then program \nthe remaining 62 bytes at a later time.\nThe Program Security Register command utilizes Buffer 1 for processing. Therefore, the contents of \nBuffer 1 will be altered from its previous state when this command is issued.\nFigure 8-4. Program Security RegisterSecurity Register Byte Number\n0 1 · · · 63 64 65 · · · 127\nData Type One-Time User Programmable Factory Programmed by Adesto\nData\nn9Bh 00h 00h 00hData\nn + 1Data\nn + 63CS\nSI\nEach transition represents eight bits\n\n 26 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20228.2.2 Reading the Security Register\nTo read the Security Register, an opcode of 77h and three dummy bytes must be clocked into the device. After the last \ndummy bit has been clocked in, the contents of the Security Register can be clocked out on the SO pin. After the last \nbyte of the Security Register has been read, additional pulses on the SCK pin will result in undefined data being output \non the SO pin.\nDeasserting the CS  pin will terminate the Read Security Register operation and put the SO pin into a high-impedance \nstate.\nFigure 8-5. Read Security Register\n77h XX XX XX\nData\nnData \nn + 1CS\nData\nn + xSI\nSO\nEach transition represents eight bits\n\n 27 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/20229. Additional Commands\n9.1 Main Memory Page to Buffer Transfer\nA page of data can be transferred from the main memory to either Buffer 1 or Buffer 2. To transfer a page of data using\nthe \nstandard DataFlash page size (264 bytes), an opcode of 53h for Buffer 1 or 55h for Buffer 2 must be clocked into the\ndevice followed by three address bytes comprised of 15 page address bits (PA14 - PA0) which specify the page in main\nmemory to be transferred, and 9 dummy bits. To transfer a page of data using the binary page size (256 bytes), an\nopcode of 53h for Buffer 1 and 55h for Buffer 2 must be clocked into the device followed by three address bytes\ncomprised of 1 dummy bit, 15 page address bits (A22 - A8) which specify the page in the main memory to be transferred,\nand 8 dummy bits.\nThe CS  pin must be low while toggling the SCK pin to load the opcode and the three address bytes from the input pin\n(SI). The transfer of the page of data from the main memory to the buffer will begin when the CS  pin transitions from a\nlow to a high state. During the page transfer time (tXFR), the RDY/BUSY  bit in the Status Register can be read to\ndetermine whether or not the transfer has been completed.\n9.2 Main Memory Page to Buffer Compare\nA page of data in main memory can be compared to the data in Buffer 1 or Buffer 2 as a method to ensure that data was\nsucc\nessfully programmed after a Buffer to Main Memory Page Program command. To compare a page of data with the\nstandard DataFlash page size (264 bytes), an opcode of 60h for Buffer 1 or 61h for Buffer 2 must be clocked into the\ndevice followed by three address bytes comprised of 15 page address bits (PA14 - PA0) which specify the page in the\nmain memory to be compared to the buffer, and 9 dummy bits. To compare a page of data with the binary page size (256\nbytes), an opcode of 60h for Buffer 1 or 61h for Buffer 2 must be clocked into the device followed by three address bytes\ncomprised of 1 dummy bit, 15 page address bits (A22 - A8) which specify the page in the main memory to be compared\nto the buffer, and 8 dummy bits.\nThe CS  pin must be low while toggling the SCK pin to load the opcode and the address bytes from the input pin (SI). On\nthe low-to-high transition of the CS  pin, the data bytes in the selected Main Memory Page will be compared with the data\nbytes in Buffer 1 or Buffer 2. During the compare time (tCOMP ), the RDY/BUSY  bit in the Status Register will indicate that\nthe part is busy. On completion of the compare operation, bit 6 of the Status Register will be updated with the result of the\ncompare.\n9.3 Auto Page Rewrite\nThis command only needs to be used if the possibility exists that static (non-changing) data may be stored in a page or\npage\ns of a sector and the other pages of the same sector are erased and programmed a large number of times.\nApplications that modify data in a random fashion within a sector may fall into this category. To preserve data integrity of\na sector, each page within a sector must be updated/rewritten at least once within every 50,000 cumulative page\nerase/program operations within that sector. The Auto Page Rewrite command provides a simple and efficient method to\n“refresh” a page in the main memory array in a single operation.\nThe Auto Page Rewrite command is a combination of the Main Memory Page to Buffer Transfer and Buffer to Main\nMemory Page Program with Built-In Erase commands. With the Auto Page Rewrite command, a page of data is first\ntransferred from the main memory to Buffer 1 or Buffer 2 and then the same data (from Buffer 1 or Buffer 2) is\nprogrammed back into the same page of main memory, essentially “refreshing” the contents of that page. To start the\nAuto Page Rewrite operation with the standard DataFlash page size (264 bytes), a 1-byte opcode, 58H for Buffer 1 or\n59H for Buffer 2, must be clocked into the device followed by three address bytes comprised of 15 page address bits\n(PA14-PA0) that specify the page in main memory to be rewritten, and 9 dummy bits.\n\n 28 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022To initiate an Auto Page Rewrite with the a binary page size (256 bytes), the opcode 58H for Buffer 1 or 59H for Buffer 2, \nmust be clocked into the device followed by three address bytes consisting of 1 dummy bit, 15 page address bits \n(A22 - A8) that specify the page in the main memory that is to be rewritten, and 8 dummy bits. When a low-to-high \ntransition occurs on the CS  pin, the part will first transfer data from the page in main memory to a buffer and then \nprogram the data from the buffer back into same page of main memory. The operation is internally self-timed and should \ntake place in a maximum time of tEP. During this time, the RDY/BUSY  Status Register will indicate that the part is busy.\nIf a sector is programmed or reprogrammed sequentially page by page and the possibility does not exist that there will be \na page or pages of static data, then the programming algorithm shown in Figure 26-1 on page 61  is recommended. \nOther\nwise, if there is a chance that there may be a page or pages of a sector that will contain static data, then the \nprogramming algorithm shown in Figure 26-2 on page 62  is recommended. Please contact Adesto for availability  of \ndevices that are specified to exceed the 50,000 cycle cumulative limit.\nNote: The Auto Page Rewrite command uses the same opcodes as the Read-Modify-Write command. If data \nbytes are clocked into the device, then the device will perform a Read-Modify-Write operation. See the \nRead-Modify-Write command description on page 12  for more details.\n9.4 Status Register Read\nThe 2-byte Status Register can be used to determine the device\'s ready/busy status, page size, a Main Memory Page to \nBuff\ner Compare operation result, the sector protection status, Freeze Sector Lockdown status, erase/program error \nstatus, Program/Erase Suspend status, and the device density. The Status Register can be read at any time, including \nduring an internally self-timed program or erase operation. \nTo read the Status Register, the CS  pin must first be asserted and then the opcode D7h must be clocked into the device. \nAfter the opcode has been clocked in, the device will begin outputting Status Register data on the SO pin during every \nsubsequent clock cycle. After the second byte of the Status Register has been clocked out, the sequence will repeat \nitself, starting again with the first byte of the Status Register, as long as the CS  pin remains asserted and the clock pin is \nbeing pulsed. The data in the Status Register is constantly being updated, so each repeating sequence may output new \ndata. The RDY/BUSY  status is available for both bytes of the Status Register and is updated for each byte.\nDeasserting the CS  pin will terminate the Status Register Read operation and put the SO pin into a high-impedance \nstate. The CS  pin can be deasserted at any time and does not require that a full byte of data be read.\nTable 9-1. Status Register Format – Byte 1\nNote: 1. R = Readable onlyBit Name Type(1)Description\n7 RDY/BUSY Ready/Busy Status R0 Device is busy with an internal operation.\n1 Device is ready.\n6 COMP Compare Result R0 Main memory page data matches buffer data.\n1 Main memory page data does not match buffer data.\n5:2 DENSITY Density Code R 1111 64-Mbit\n1 PROTECT Sector Protection Status R0 Sector protection is disabled.\n1 Sector protection is enabled.\n0 PAGE SIZE Page Size Configuration R0 Device is configured for standard DataFlash page size (264 bytes).\n1 Device is configured for “power of 2” binary page size (256 bytes).\n\n 29 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Table 9-2. Status Register Format – Byte 2\nNote: 1. R = Readable only\n9.4.1 R\nDY/BUSY  Bit\nThe RDY/BUSY  bit is used to determine whether or not an internal operation, such as a program or erase, is in progress. \nTo poll the RDY/BUSY  bit to detect the completion of an internally timed operation, new Status Register data must be \ncontinually clocked out of the device until the state of the RDY/BUSY  bit changes from a Logic 0 to a Logic 1.\n9.4.2 COMP Bit\nThe result of the most recent Main Memory Page to Buffer Compare operation is indicated using the COMP bit. If the \nCOMP\n bit is a Logic 1, then at least one bit of the data in the Main Memory Page does not match the data in the buffer.\n9.4.3 DENSITY Bits\nThe device density is indicated using the DENSITY bits. For the AT45DB641E, the four bit binary value is 1111. The \ndeci\nmal value of these four binary bits does not actually equate to the device density; the four bits represent a \ncombinational code relating to differing densities of DataFlash devices. The DENSITY bits are not the same as the \ndensity code indicated in the JEDEC Device ID information. The DENSITY bits are provided only for backward \ncompatibility to older generation DataFlash devices.\n9.4.4 PROTECT Bit\nThe PROTECT bit provides information to the user on whether or not the sector protection has been enabled or disabled, \neith\ner by the software-controlled method or the hardware-controlled method. \n9.4.5 PAGE SIZE Bit\nThe PAGE SIZE bit indicates whether the buffer size and the page size of the main memory array is configured for the \n“pow\ner of 2” binary page size (256 bytes) or the standard DataFlash page size (264 bytes). Bit Name Type(1)Description\n7 RDY/BUSY Ready/Busy Status R0 Device is busy with an internal operation.\n1 Device is ready.\n6 RES Reserved for Future Use R 0 Reserved for future use.\n5 EPE Erase/Program Error R0 Erase or program operation was successful.\n1 Erase or program error detected.\n4 RES Reserved for Future Use R 0 Reserved for future use.\n3 SLE Sector Lockdown Enabled R0 Sector Lockdown command is disabled.\n1 Sector Lockdown command is enabled.\n2 PS2Program Suspend Status \n(Buffer 2)R0 No program operation has been suspended while using Buffer 2.\n1 A sector is program suspended while using Buffer 2.\n1 PS1Program Suspend Status \n(Buffer 1)R0 No program operation has been suspended while using Buffer 1.\n1 A sector is program suspended while using Buffer 1.\n0 ES Erase Suspend R0 No sectors are erase suspended.\n1 A sector is erase suspended.\n\n 30 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/20229.4.6 EPE Bit \nThe EPE bit indicates whether the last erase or program operation completed successfully or not. If at least one byte \nduring the erase or program operation did not erase or program properly, then the EPE bit will be set to the Logic 1 state. \nThe EPE bit will not be set if an erase or program operation aborts for any reason, such as an attempt to erase or \nprogram a protected region or a locked down sector or an attempt to erase or program a suspended sector. The EPE bit \nis updated after every erase and program operation.\n9.4.7 SLE Bit\nThe SLE bit indicates whether or not the Sector Lockdown command is enabled or disabled. If the SLE bit is a Logic 1, \nthen the Sector Lockdown command is still enabled and sectors can be locked down. If the SLE bit is a Logic 0, then the \nSector Lockdown command has been disabled and no further sectors can be locked down.\n9.4.8 PS2 Bit\nThe PS2 bit indicates if a program operation has been suspended while using Buffer 2. If the PS2 bit is a Logic 1, then a \nprogram operation has been suspended while Buffer 2 was being used, and any command attempts that would modify \nthe contents of Buffer 2 will be ignored.\n9.4.9 PS1 Bit\nThe PS1 bit indicates if a program operation has been suspended while using Buffer 1. If the PS1 bit is a Logic 1, then a \nprogram operation has been suspended while Buffer 1 was being used, and any command attempts that would modify \nthe contents of Buffer 1 will be ignored.\n9.4.10 The ES bit\nThe ES bit indicates whether or not an erase has been suspended. If the ES bit is a Logic 1, then an erase operation \n(page, block, sector, or chip) has been suspended.\n\n 31 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202210. Deep Power-Down\nDuring normal operation, the device will be placed in the standby mode to consume less power as long as the CS  pin\nremains deasserted and no internal operation is in progress. The Deep Power-Down command offers the ability to place\nthe device into an even lower power consumption state called the Deep Power-Down mode.\nWhen the device is in the Deep Power-Down mode, all commands including the Status Register Read command will be\nignored with the exception of the Resume from Deep Power-Down command. Since all commands will be ignored, the\nmode can be used as an extra protection mechanism against program and erase operations.\nEntering the Deep Power-Down mode is accomplished by simply asserting the CS  pin, clocking in the opcode B9h, and\nthen deasserting the CS  pin. Any additional data clocked into the device after the opcode will be ignored. When the CS\npin i\ns deasserted, the device will enter the Deep Power-Down mode within the maximum time of tEDPD.\nThe \ncomplete opcode must be clocked in before the CS  pin is deasserted, and the CS  pin must be deasserted on an\neven byte boundary (multiples of eight bits); otherwise, the device will abort the operation and return to the standby mode\nonce the CS  pin is deasserted. In addition, the device will default to the standby mode after a power cycle.\nThe Deep Power-Down command will be ignored if an internally self-timed operation such as a program or erase cycle is\nin progress. The Deep Power-Down command must be reissued after the internally self-timed operation has been\ncompleted in order for the device to enter the Deep Power-Down mode.\nFigure 10-1. Deep Power-Down\nSCKCS\nSI\nSOMSB\nICC2 3 1 0\n1 0 1 1 1 0 0 16 7 5 4\nOpcode\nHigh-impedance\nStandby Mode CurrentActive Current\nDeep Power-Down Mode CurrenttEDPD\n\n 32 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202210.1 Resume from Deep Power-Down\nIn order to exit the Deep Power-Down mode and resume normal device operation, the Resume from Deep Power-Down \ncomm\nand must be issued. The Resume from Deep Power-Down command is the only command that the device will \nrecognize while in the Deep Power-Down mode.\nTo resume from the Deep Power-Down mode, the CS  pin must first be asserted and then the opcode ABh must be \nclocked into the device. Any additional data clocked into the device after the opcode will be ignored. When the CS  pin is \ndeasserted, the device will exit the Deep Power-Down mode and return to the standby mode within the maximum time of \ntRDPD. After the device has returned to the standby mode, normal command operations such as Continuous Array Read \ncan \nbe resumed.\nIf the complete opcode is not clocked in before the CS  pin is deasserted, or if the CS  pin is not deasserted on an even \nbyte boundary (multiples of eight bits), then the device will abort the operation and return to the Deep Power-Down \nmode.\nFigure 10-2. Resume from Deep Power-Down\nSCKCS\nSI\nSOMSB\nICC2 3 1 0\n1 0 1 0 1 0 1 16 7 5 4\nOpcode\nHigh-impedance\nDeep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttRDPD\n\n 33 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202210.2 Ultra-Deep Power-Down\nThe Ultra-Deep Power-Down mode allows the device to consume far less power compared to the standby and Deep \nPowe\nr-Down modes by shutting down additional internal circuitry. Since almost all active circuitry is shutdown in this \nmode to conserve power, the contents of the SRAM buffers cannot be maintained. Therefore, any data stored in the \nSRAM buffers will be lost once the device enters the Ultra-Deep Power-Down mode.\nWhen the device is in the Ultra-Deep Power-Down mode, all commands including the Status Register Read and Resume \nfrom Deep Power-Down commands will be ignored. Since all commands will be ignored, the mode can be used as an \nextra protection mechanism against program and erase operations.\nEntering the Ultra-Deep Power-Down mode is accomplished by simply asserting the CS  pin, clocking in the opcode 79h, \nand then deasserting the CS  pin. Any additional data clocked into the device after the opcode will be ignored. When the \nCS pin is deasserted, the device will enter the Ultra-Deep Power-Down mode within the maximum time of tEUDPD .\nThe \ncomplete opcode must be clocked in before the CS  pin is deasserted, and the CS  pin must be deasserted on an \neven byte boundary (multiples of eight bits); otherwise, the device will abort the operation and return to the standby mode \nonce the CS  pin is deasserted. In addition, the device will default to the standby mode after a power cycle.\nThe Ultra-Deep Power-Down command will be ignored if an internally self-timed operation such as a program or erase \ncycle is in progress. The Ultra-Deep Power-Down command must be reissued after the internally self-timed operation \nhas been completed in order for the device to enter the Ultra-Deep Power-Down mode.\nFigure 10-3. Ultra-Deep Power-Down\nSCKCS\nSI\nSOMSB\nICC2 3 1 0\n06 7 5 4\nOpcode\nHigh-impedance\nUltra-Deep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttEUDPD\n1 1 1 1 0 0 1\n\n 34 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202210.2.1 Exit Ultra-Deep Power-Down\nTo exit from the Ultra-Deep Power-Down mode, the CS  pin must simply be pulsed by asserting the CS  pin, waiting the \nminimum necessary tCSLU time, and then deasserting the CS  pin again. To facilitate simple software development, a \ndummy byte opcode can also be entered while the CS  pin is being pulsed just as in a normal operation like the Program \nSuspend operation; the dummy byte opcode is simply ignored by the device in this case. After the CS  pin has been \ndeasserted, the device will exit from the Ultra-Deep Power-Down mode and return to the standby mode within a \nmaximum time of tXUDPD . If the CS  pin is reasserted before the tXUDPD  time has elapsed in an attempt to start a new \noper\nation, then that operation will be ignored and nothing will be performed. The system must wait for the device to return \nto the standby mode before normal command operations such as Continuous Array Read can be resumed.\nSince the contents of the SRAM buffers cannot be maintained while in the Ultra-Deep Power-Down mode, the SRAM \nbuffers will contain undefined data when the device returns to the standby mode.\nFigure 10-4. Exit Ultra-Deep Power-Down\nChip Select Low\nBy a\nsserting the CS pin, waiting the minimum necessary tXUDPD time, and then clocking in the first bit of the next \nOpco\nde command cycle.  If the first bit of the next command is clocked in before the tXUDPD time has elapsed, the \ndevi\nce will exit Ultra Deep Power Down, however the intended operation will be ignored.\nFigure 10-5. Exit Ultra-Deep Power-Down (Chip Select Low)CS\nSO\nICCHigh-impedance\nUltra-Deep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttXUDPDtCSLU\n\n 35 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202211. Buffer and Page Size Configuration\nThe memory array of DataFlash devices is actually larger than other Serial Flash devices in that extra user-accessible\nbytes are provided in each page of the memory array. For the AT45DB641E, there are an extra eight bytes of memory in\neach page for a total of an extra 256KB (2-Mbits) of user-accessible memory.\nSome applications, however, may not want to take advantage of this extra memory and instead architect their software to\noperate on a “power of 2” binary, logical addressing scheme. To allow this, the DataFlash can be configured so that the\nbuffer and page sizes are 256 bytes instead of the standard 264 bytes. In addition, the configuration of the buffer and\npage sizes is reversible and can be changed from 264 bytes to 256 bytes or from 256 bytes to 264 bytes. The configured\nsetting is stored in an internal nonvolatile register so that the buffer and page size configuration is not affected by power\ncycles. The nonvolatile register has a limit of 10,000 erase/program cycles; therefore, care should be taken to not switch\nbetween the size options more than 10,000 times.\nDevices are initially shipped from Adesto with the buffer and page sizes set to 264 bytes. Devices can be ordered from\nAdesto pre-configured for the “power of 2” binary size of 256 bytes. For details, see Section 27., Ordering Information\n(Sta\nndard DataFlash Page Size) on page 63 .\nTo co\nnfigure the device for “power of 2” binary page size (256 bytes), a 4-byte opcode sequence of 3Dh, 2Ah, 80h, and\nA6h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the CS  pin must be\ndeasserted to initiate the internally self-timed configuration process and nonvolatile register program cycle. The\nprogramming of the nonvolatile register should take place in a time of tEP, during which time the RDY/BUSY  bit in the\nStatu\ns Register will indicate that the device is busy. The device does not need to be power cycled after the completion of\nthe configuration process and register program cycle in order for the buffer and page size to be configured to 256 bytes.\nTo configure the device for standard DataFlash page size (264 bytes), a 4-byte opcode sequence of 3Dh, 2Ah, 80h, and\nA7h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the CS  pin must be\ndeasserted to initiate the internally self-timed configuration process and nonvolatile register program cycle. The\nprogramming of the nonvolatile register should take place in a time of tEP, during which time the RDY/BUSY  bit in the\nStatu\ns Register will indicate that the device is busy. The device does not need to be power cycled after the completion of\nthe configuration process and register program cycle in order for the buffer and page size to be configured to 264 bytes.\nTable 11-1. Buffer and Page Size Configuration Commands\nFigu\nre 11-1. Buffer and Page Size ConfigurationCommand Byte 1 Byte 2 Byte 3 Byte 4\n“Power of 2” binary page size (256 bytes) 3Dh 2Ah 80h A6h\nDataFlash page size (264 bytes) 3Dh 2Ah 80h A7h\nCS\nSI 3Dh 2Ah 80hOpcode\nByte 4\nEach transition represents eight bits\n\n 36 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202212. Manufacturer and Device ID Read\nIdentification information can be read from the device to enable systems to electronically query and identify the device\nwhile it is in the system. The identification method and the command opcode comply with the JEDEC Standard for\n“Manufacturer and Device ID Read Methodology for SPI Compatible Serial Interface Memory Devices”. The type of\ninformation that can be read from the device includes the JEDEC-defined Manufacturer ID, the vendor-specific\nDevice ID, and the vendor-specific Extended Device Information.\nThe Read Manufacturer and Device ID command is limited to a maximum clock frequency of fCLK. Since not all Flash\ndevi\nces are capable of operating at very high clock frequencies, applications should be designed to read the\nidentification information from the devices at a reasonably low clock frequency to ensure that all devices to be used in the\napplication can be identified properly. Once the identification process is complete, the application can then increase the\nclock frequency to accommodate specific Flash devices that are capable of operating at the higher clock frequencies.\nTo read the identification information, the CS  pin must first be asserted and then the opcode 9Fh must be clocked into\nthe device. After the opcode has been clocked in, the device will begin outputting the identification data on the SO pin\nduring the subsequent clock cycles. The first byte to be output will be the Manufacturer ID, followed by two bytes of the\nDevice ID information. The fourth byte output will be the Extended Device Information (EDI) String Length, which will be\n01h indicating that one byte of EDI data follows. After the one byte of EDI data is output, the SO pin will go into a\nhigh-impedance state; therefore, additional clock cycles will have no affect on the SO pin and no data will be output. As\nindicated in the JEDEC Standard, reading the EDI String Length and any subsequent data is optional.\nDeasserting the CS  pin will terminate the Manufacturer and Device ID Read operation and put the SO pin into a\nhigh-impedance state. The CS  pin can be deasserted at any time and does not require that a full byte of data be read.\nTable 12-1. Manufacturer and Device ID Information\nTabl\ne 12-2. Manufacturer and Device ID DetailsByte No. Data Type Value\n1 Manufacturer ID 1Fh\n2 Device ID (Byte 1) 28h\n3 Device ID (Byte 2) 00h\n4 [Optional to Read] Extended Device Information (EDI) String Length 01h\n5 [Optional to Read] EDI Byte 1 00h\nData Type Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0Hex\nValue Details\nManufacturer IDJEDEC Assigned Code\n1Fh JEDEC code: 0001 1111 (1Fh for Adesto)\n0 0 0 1 1 1 1 1\nDevice ID (Byte 1)Family Code Density Code\n28hFamily code: 001 (AT45Dxxx Family)\nDensity code: 01000 (64-Mbit)0 0 1 0 1 0 0 0\nDevice ID (Byte 2)Sub Code Product Variant\n00hSub code: 000 (Standard Series)\nProduct variant: 000000 0 0 0 0 0 0 0\n\n 37 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Table 12-3. EDI Data\nFigure 12-1. Read Manufacturer and Device IDByte Number Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0Hex\nValue Details\n1RFU Device Revision\n00hRFU: Reserved for Future Use\nDevice revision: 00000 (Initial Version)0 0 0 0 0 0 0 0\nSCKCS\nSI\nSO6 0\n9Fh8 7 46\nOpcode\n1Fh 00h 01h 00h\nManufacturer ID Device ID\nByte 1Device ID\nByte 2EDI\nString LengthEDI\nData Byte 1High-impedance14 16 15 22 24 23 38 40 39 30 32 31\nNote:  Each transition shown for SI and SO represents one byte (8 bits)28h\n\n 38 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202213. Software Reset\nIn some applications, it may be necessary to prematurely terminate a program or erase cycle early rather than wait the\nhundreds of microseconds or milliseconds necessary for the program or erase operation to complete normally. The\nSoftware Reset command allows a program or erase operation in progress to be ended abruptly and returns the device\nto an idle state.\nTo perform a Software Reset, the CS  pin must be asserted and a 4-byte command sequence of F0h, 00h, 00h, and 00h\nmust be clocked into the device. Any additional data clocked into the device after the last byte will be ignored. When the\nCS pin is deasserted, the program or erase operation currently in progress will be terminated within a time tSWRST . Since\nthe \nprogram or erase operation may not complete before the device is reset, the contents of the page being programmed\nor erased cannot be guaranteed to be valid.\nThe Software Reset command has no effect on the states of the Sector Protection Register, the Sector Lockdown\nRegister, or the buffer and page size configuration. The PS2, PS1, and ES bits of the Status Register, however, will be\nreset back to their default states. If a Software Reset operation is performed while a sector is erase suspended, the\nsuspend operation will abort and the contents of the page or block being erased in the suspended sector will be left in an\nundefined state. If a Software Reset is performed while a sector is program suspended, the suspend operation will abort\nand the contents of the page that was being programmed and subsequently suspended will be undefined. The remaining\npages in the sector will retain their previous contents.\nThe complete 4-byte opcode must be clocked into the device before the CS  pin is deasserted, and the CS  pin must be\ndeasserted on a byte boundary (multiples of eight bits); otherwise, no reset operation will be performed.\nTable 13-1. Software Reset\nFigu\nre 13-1. Software ResetCommand Byte 1 Byte 2 Byte 3 Byte 4\nSoftware Reset F0h 00h 00h 00h\nCS\nSI F0h 00h 00h 00h\nEach transition represents eight bits\n\n 39 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202214. Operation Mode Summary\nThe commands described previously can be grouped into four different categories to better describe which commands\ncan be executed at what times.\nGroup A commands consist of:\n1. Main Memory Page Read\n2. Co\nntinuous Array Read (SPI)\n3. Read Sector Protection Register\n4. Read Sector Lockdown Register\n5. Read Security Register\n6. Buffer 1 (or 2) Read\nGroup B commands consist of:\n1. Page Erase\n2. B l\nock Erase\n3. Sector Erase\n4. Chip Erase\n5. Main Memory Page to Buffer 1 (or 2) Transfer\n6. Main Memory Page to Buffer 1 (or 2) Compare\n7. Buffer 1 (or 2) to Main Memory Page Program with Built-In Erase\n8. Buffer 1 (or 2) to Main Memory Page Program without Built-In Erase\n9. Main Memory Page Program through Buffer 1 (or 2) with Built-In Erase\n10. Main Memory Byte/Page Program through Buffer 1 without Built-In Erase\n11. Auto Page Rewrite\n12. Read-Modify-Write\nGroup C commands consist of:\n1. Buffer 1 (or 2) Write\n2. S t\natus Register Read\n3. Manufacturer and Device ID Read\nGroup D commands consist of:\n1. Erase Sector Protection Register\n2. Pr\nogram Sector Protection Register\n3. Sector Lockdown\n4. Program Security Register\n5. Buffer and Page Size Configuration\n6. Freeze Sector Lockdown\nIf a Group A command is in progress (not fully completed), then another command in Group A, B, C, or D should not be \nstarted. However, during the internally self-timed portion of Group B commands, any command in Group C can be \nexecuted. The Group B commands using Buffer 1 should use Group C commands using Buffer 2 and vice versa. Finally, \nduring the internally self-timed portion of a Group D command, only the Status Register Read command should be \nexecuted.\nMost of the commands in Group B can be suspended and resumed, except the Buffer Transfer, Buffer Compare, Auto \nPage Rewrite and Read-Modify-Write operations. If a Group B command is suspended, all of the Group A commands \ncan be executed. See Table 6-4  to determine which of the Group B, Group C, and Group D  commands are allowed.\n\n 40 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202215. Command Tables\nTable 15-1. Read Commands\nTabl\ne 15-2. Program and Erase CommandsCommand Opcode\nMain Memory Page Read D2h\nContinuous Array Read (Low Power Mode) 01h\nContinuous Array Read (Low Frequency) 03h\nContinuous Array Read (High Frequency) 0Bh\nContinuous Array Read (High Frequency) 1Bh\nContinuous Array Read (Legacy Command – Not Recommended for New Designs) E8h\nBuffer 1 Read (Low Frequency) D1h\nBuffer 2 Read (Low Frequency) D3h\nBuffer 1 Read (High Frequency) D4h\nBuffer 2 Read (High Frequency) D6h\nCommand Opcode\nBuffer 1 Write 84h\nBuffer 2 Write 87h\nBuffer 1 to Main Memory Page Program with Built-In Erase 83h\nBuffer 2 to Main Memory Page Program with Built-In Erase 86h\nBuffer 1 to Main Memory Page Program without Built-In Erase 88h\nBuffer 2 to Main Memory Page Program without Built-In Erase 89h\nMain Memory Page Program through Buffer 1 with Built-In Erase 82h\nMain Memory Page Program through Buffer 2 with Built-In Erase 85h\nMain Memory Byte/Page Program through Buffer 1 without Built-In Erase 02h\nPage Erase 81h\nBlock Erase 50h\nSector Erase 7Ch\nChip Erase C7h + 94h + 80h + 9Ah\nProgram/Erase Suspend B0h\nProgram/Erase Resume D0h\nRead-Modify-Write through Buffer 1 58h\nRead-Modify-Write through Buffer 2 59h\n\n 41 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Table 15-3. Protection and Security Commands\nTable 15-4. Additional Commands\nTable 15-5. Legacy Commands(1)(2)\nNotes: 1. Legacy commands are not recommended for new designs.\n2. Legacy commands operate from 2.30V to 3.60V Vcc only.Command Opcode\nEnable Sector Protection 3Dh + 2Ah + 7Fh + A9h\nDisable Sector Protection 3Dh + 2Ah + 7Fh + 9Ah\nErase Sector Protection Register 3Dh + 2Ah + 7Fh + CFh\nProgram Sector Protection Register 3Dh + 2Ah + 7Fh + FCh\nRead Sector Protection Register 32h\nSector Lockdown 3Dh + 2Ah + 7Fh + 30h\nRead Sector Lockdown Register 35h\nFreeze Sector Lockdown 34h + 55h + AAh + 40h\nProgram Security Register 9Bh + 00h + 00h + 00h\nRead Security Register 77h\nCommand Opcode\nMain Memory Page to Buffer 1 Transfer 53h\nMain Memory Page to Buffer 2 Transfer 55h\nMain Memory Page to Buffer 1 Compare 60h\nMain Memory Page to Buffer 2 Compare 61h\nAuto Page Rewrite 58h\nAuto Page Rewrite 59h\nDeep Power-Down B9h\nResume from Deep Power-Down ABh\nUltra-Deep Power-Down 79h\nStatus Register Read D7h\nManufacturer and Device ID Read 9Fh\nConfigure “Power of 2” (Binary) Page Size 3Dh + 2Ah + 80h + A6h\nConfigure Standard DataFlash Page Size 3Dh + 2Ah + 80h + A7h\nSoftware Reset F0h + 00h + 00h + 00h\nCommand Opcode\nBuffer 1 Read 54H\nBuffer 2 Read 56H\nMain Memory Page Read 52H\nContinuous Array Read 68H\nStatus Register Read 57H\n\n 42 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Table 15-6. Detailed Bit-level Addressing Sequence for Binary Page Size (256 bytes)\nNote: 1. Shown to indicate when the Auto Page Rewrite operation is executed.\n2. S h\nown to indicate when the Read-Modify-Write operation is executed.\n3. X = Dummy BitPage Size = 256 bytes Address Byte Address Byte Address Byte\nAdditional \nDummy \nBytes Opcode Opcode\nReserved \nA22\nA21 \nA20\nA19 \nA18 \nA17 \nA16 \nA15 \nA14 \nA13 \nA12 \nA11 \nA10 \nA9 \nA8 \nA7 \nA6 \nA5\nA4 \nA3\nA2 \nA1\nA0 \n01h 00000001XAAAAAAAAAAAAAAAAAAAAAAA N/A\n02h 00000010XAAAAAAAAAAAAAAAAAAAAAAA N/A\n03h 00000011XAAAAAAAAAAAAAAAAAAAAAAA N/A\n0Bh 00001011XAAAAAAAAAAAAAAAAAAAAAAA 1\n1Bh 00011011XAAAAAAAAAAAAAAAAAAAAAAA 2\n32h 00110010XXXXXXXXXXXXXXXXXXXXXXXX N/A\n35h 00110101XXXXXXXXXXXXXXXXXXXXXXXX N/A\n50h 01010000XAAAAAAAAAAAAXXXXXXXXXXX N/A\n53h 01010011XAAAAAAAAAAAAAAAXXXXXXXX N/A\n55h 01010101XAAAAAAAAAAAAAAAXXXXXXXX N/A\n58h(1)01011000XAAAAAAAAAAAAAAAXXXXXXXX N/A\n59h(1)01011001XAAAAAAAAAAAAAAAXXXXXXXX N/A\n58h(2)01011000XAAAAAAAAAAAAAAAAAAAAAAA N/A\n59h(2)01011001XAAAAAAAAAAAAAAAAAAAAAAA N/A\n60h 01100000XAAAAAAAAAAAAAAAXXXXXXXX N/A\n61h 01100001XAAAAAAAAAAAAAAAXXXXXXXX N/A\n77h 01110111XXXXXXXXXXXXXXXXXXXXXXXX N/A\n79h 01111001 N/A N/A N/A N/A\n7Ch 01111100XAAAAAXXXXXXXXXXXXXXXXXX N/A\n81h 10000001XAAAAAAAAAAAAAAAXXXXXXXX N/A\n82h 10000010XAAAAAAAAAAAAAAAAAAAAAAA N/A\n83h 10000011XAAAAAAAAAAAAAAAXXXXXXXX N/A\n84h 10000100XXXXXXXXXXXXXXXXAAAAAAAA N/A\n85h 10000101XAAAAAAAAAAAAAAAAAAAAAAA N/A\n86h 10000110XAAAAAAAAAAAAAAAXXXXXXXX N/A\n87h 10000111XXXXXXXXXXXXXXXXAAAAAAAA N/A\n88h 10001000XAAAAAAAAAAAAAAAXXXXXXXX N/A\n89h 10001001XAAAAAAAAAAAAAAAXXXXXXXX N/A\n9Fh 10011111 N/A N/A N/A N/A\nB9h 10111001 N/A N/A N/A N/A\nABh 10101011 N/A N/A N/A N/A\nB0h 10110000 N/A N/A N/A N/A\nD0h 11010000 N/A N/A N/A N/A\nD1h 11010001XXXXXXXXXXXXXXXXAAAAAAAA N/A\nD2h 11010010XAAAAAAAAAAAAAAAAAAAAAAA 4 \nD3h 11010011XXXXXXXXXXXXXXXXAAAAAAAA N/A\nD4h 11010100XXXXXXXXXXXXXXXXAAAAAAAA 1\nD6h 11010110XXXXXXXXXXXXXXXXAAAAAAAA 1\nD7h 11010111 N/A N/A N/A N/A\n\n 43 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Table 15-7. Detailed Bit-level Addressing Sequence for Standard DataFlash Page Size (264 bytes)\nNotes: 1. Shown to indicate when the Auto Page Rewrite operation is executed.\n2. S h\nown to indicate when the Read-Modify-Write operation is executed.\n3. P = Page Address Bit,  B = Byte/Buffer Address Bit,   X = Dummy BitPage Size = 264 bytes Address Byte Address Byte Address ByteAdditional \nDummy \nBytes Opcode Opcode\nPA14\nPA13\nPA12\nPA11\nPA10\nPA9\nPA8\nPA7\nPA6 \nPA5\nPA4 \nPA3 \nPA2\nPA1 \nPA0 \nBA8 \nBA7 \nBA6 \nBA5\nBA4 \nBA3\nBA2 \nBA1\nBA0 \n01h 00000001PPPPPPPPPPPPPPPBBBBBBBBB N/A\n02h 00000010PPPPPPPPPPPPPPPBBBBBBBBB N/A\n03h 00000011PPPPPPPPPPPPPPPBBBBBBBBB N/A\n0Bh 00001011PPPPPPPPPPPPPPPBBBBBBBBB 1\n1Bh 00011011PPPPPPPPPPPPPPPBBBBBBBBB 2\n32h 00110010XXXXXXXXXXXXXXXXXXXXXXXX N/A\n35h 00110101XXXXXXXXXXXXXXXXXXXXXXXX N/A\n50h 01010000PPPPPPPPPPPPXXXXXXXXXXXX N/A\n53h 01010011PPPPPPPPPPPPPPP XXXXXXXXX N/A\n55h 01010101PPPPPPPPPPPPPPPXXXXXXXXX N/A\n58h(1)01011000PPPPPPPPPPPPPPPXXXXXXXXX N/A\n59h(1)01011001PPPPPPPPPPPPPPPXXXXXXXXX N/A\n58h(2)01011000PPPPPPPPPPPPPPPBBBBBBBBB N/A\n59h(2)01011001PPPPPPPPPPPPPPPBBBBBBBBB N/A\n60h 01100000PPPPPPPPPPPPPPPXXXXXXXXX N/A\n61h 01100001PPPPPPPPPPPPPPPXXXXXXXXX N/A\n77h 01110111XXXXXXXXXXXXXXXXXXXXXXXX N/A\n79h 01111001 N/A N/A N/A N/A\n7Ch 01111100PPPPPXXXXXXXXXXXXXXXXXXX N/A\n81h 10000001PPPPPPPPPPPPPPPXXXXXXXXX N/A\n82h 10000010PPPPPPPPPPPPPPPBBBBBBBBB N/A\n83h 10000011PPPPPPPPPPPPPPPXXXXXXXXX N/A\n84h 10000100XXXXXXXXXXXXXXXBBBBBBBBB N/A\n85h 10000101PPPPPPPPPPPPPPPBBBBBBBBB N/A\n86h 10000110PPPPPPPPPPPPPPPXXXXXXXXX N/A\n87h 10000111XXXXXXXXXXXXXXXBBBBBBBBB N/A\n88h 10001000PPPPPPPPPPPPPPPXXXXXXXXX N/A\n89h 10001001PPPPPPPPPPPPPPPXXXXXXXXX N/A\n9Fh 10011111 N/A N/A N/A N/A\nB9h 10111001 N/A N/A N/A N/A\nABh 10101011 N/A N/A N/A N/A\nB0h 10110000 N/A N/A N/A N/A\nD0h 11010000 N/A N/A N/A N/A\nD1h 11010001XXXXXXXXXXXXXXXBBBBBBBBB N/A\nD2h 11010010PPPPPPPPPPPPPPPBBBBBBBBB 4\nD3h 11010001XXXXXXXXXXXXXXXBBBBBBBBB N/A\nD4h 11010100XXXXXXXXXXXXXXXBBBBBBBBB 1\nD6h 11010110XXXXXXXXXXXXXXXBBBBBBBBB 1\nD7h 11010111 N/A N/A N/A N/A\n\n 44 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202216. Power-On/Reset State\nWhen power is first applied to the device, or when recovering from a reset condition, the output pin (SO) will be in a high\nimpedance state, and a high-to-low transition on the CSB pin will be required to start a valid instruction. The SPI mode\n(Mode 3 or Mode 0) will be automatically selected on every falling edge of CSB by sampling the inactive clock state.\n16.1 Power-Up/Power-Down Voltage and Timing Requirements\nDuring power-up, the device must not be READ for at least the minimum tVCSL time after the supply voltage reaches the \nmini\nmum VPOR level (VPOR min). While the device is being powered-up, the internal Power-On Reset (POR) circuitry \nkeep\ns the device in a reset mode until the supply voltage rises above the minimum Vcc. During this time, all operations \nare \ndisabled and the device will not respond to any commands.\nIf the first operation to the device after power-up will be a program or erase operation, then the operation cannot be \nstarted until the supply voltage reaches the minimum VCC  level and an internal device delay has elapsed. This delay will \nbe a\n maximum time of tPUW. After the tPUW time, the device will be in the standby mode if CSB is at logic high or active \nmode\n if CSB is at logic low. For the case of Power-down then Power-up operation, or if a power interruption occurs (such \nthat VCC drops below VPOR max), the Vcc of the Flash device must be maintained below VPWD for at least the minimum \nspec\nified TPWD time. This is to ensure the Flash device will reset properly after a power interruption. \nTable 16-1. Voltage and Timing Requirements for Power-Up/Power-Down\nFigu\nre 16-1. Power-Up TimingSymbol Parameter Min Max Units\nVPWD (1)\n1. Not 100% tested (value guaranteed by design and characterization).VCC for device initialization 1.0 V\ntPWD(1)Minimum duration for device initialization 300 µs\ntVCSL Minimum VCC to chip select low time for Read command 70 µs\ntVR(1)VCC rise time 1 500000 µs/V\nVPOR Power on reset voltage 1.45 1.6 V\ntPUW Power up delay time before Program or Erase is allowed 3 ms\nVCC\n VPOR max\nMax VPWDChip Select Not P\nermitted\nTimetPWDtPUW Full Operation P\nermitted\ntVRtVCSLRead Operation\nPermitted\n\n 45 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202217. System Considerations\nThe serial interface is controlled by the Serial Clock (SCK), Serial Input (SI), and Chip Select (CS ) pins. These signals\nmust rise and fall monotonically and be free from noise. Excessive noise or ringing on these pins can be misinterpreted\nas multiple edges and cause improper operation of the device. PCB traces must be kept to a minimum distance or\nappropriately terminated to ensure proper operation. If necessary, decoupling capacitors can be added on these pins to\nprovide filtering against noise glitches.\nAs system complexity continues to increase, voltage regulation is becoming more important. A key element of any\nvoltage regulation scheme is its current sourcing capability. Like all Flash memories, the peak current for DataFlash\ndevices occurs during the programming and erasing operations. The supply voltage regulator needs to be able to supply\nthis peak current requirement. An under specified regulator can cause current starvation. Besides increasing system\nnoise, current starvation during programming or erasing can lead to improper operation and possible data corruption.\n\n 46 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202218. Electrical Specifications\n18.1 Absolute Maximum Ratings*\n18.2\nDC and AC Operating RangeTemperature under Bias  . . . . . . . -55°C to +125°C\nStorage Temperature. . . . . . . . . . -65°C to +150°C\nAll Input Voltages \n(except VCC but including NC pins)\nwith Respect to Ground. . . . . . -0.6V to VCC + 0.6V\nAll Output Voltages\nwith Respect to Ground. . . . . . -0.6V to VCC + 0.6V*Notice: Stresses beyond those listed under “Absolute Maximum\nRatin\ngs” may cause permanent damage to the device. The \n“Absolute Maximum Ratings” are stress ratings only and \nfunctional operation of the device at these or any other \nconditions beyond those indicated in the operational \nsections of this specification is not implied. Exposure to \nabsolute maximum rating conditions for extended periods \nmay affect device reliability. Voltage extremes referenced in \nthe “Absolute Maximum Ratings” are intended to \naccommodate short duration undershoot/overshoot \nconditions and does not imply or guarantee functional device \noperation at these levels for any extended period of time.\nAT45DB641E\nOperating Temperature (Case) Industrial -40°C to 85 °C\nVCC Power Supply 1.7V to 3.6V\n\n 47 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202218.3 DC Characteristics \nNotes: 1. Typical values measured at 3.0V at 25 °C.\n2.IC\nC2 during a Buffer Read is 20mA maximum @ 20MHz.Symbol Parameter Condition1.7V to 3.6V 2.3V to 3.6V\nMin Typ Max Min Typ MaxUnit\ns\nIUDPDUltra-Deep Power-\nDown CurrentCS = VCC. All other \ninputs at 0V or VCC.0.3 1 0.4 1 µA\nIDPDDeep Power-Down \nCurrent CS = VCC. All other \ninputs at 0V or VCC.5 25 6 25 µA\nISB Standby CurrentCS = VCC. All other \ninputs at 0V or VCC.25 45 25 45 µA\nICC1Active Current, \nLow \nPower Read (01h) \nOperationf = 1MHz; IOUT = 0mA 6 9 6 9 mA\nf = 15MHz; IOUT = 0mA 7 11 7 11 mA\nICC2(1)(2) Active Current,\nRead Operationf = 50MHz; IOUT = 0mA 12 17 12 17 mA\nf = 85MHz; IOUT = 0mA 16 22 16 22 mA\nICC3Active Current, \nProgram OperationCS = VCC 14 16 14 16 mA\nICC4Active Current, \nErase OperationCS = VCC 8 12 8 12 mA\nILI Input Load CurrentAll inputs at CMOS\nlevels1 1 µA\nILOOutput Leakage \nCurrentAll inputs at CMOS \nlevels1 1 µA\nVIL Input Low Voltage VCC x 0.3 VCC x 0.3 V\nVIH Input High Voltage VCC x 0.7 VCC + 0.6 VCC x 0.7 VCC + 0.6 V\nVOLOutput Low \nVoltageIOL = 100µA 0.4 0.4 V\nVOHOutput High \nVoltageIOH = -100µA VCC - 0.2V VCC - 0.2V V\n\n 48 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202218.4 AC Characteristics\nNote: 1. Values are based on device characterization, not 100% tested in production. 1.7V to 3.6V 2.3V to 3.6V\nSymbol Parameter Min Max Min Max Units\nfSCK SCK Frequency 50 85 MHz\nfCAR1 SCK Frequency for Continuous Read (0x0B) 50 85 MHz\nfCAR2 SCK Frequency for Continuous Read (Low Frequency)(0x03) 40 50 MHz\nfCAR3SCK Frequency for Continuous Read (Low Power Mode \n– 01h Opcode)15 15 MHz\nfCAR4 SCK Frequency for Continuous Read (0x1B) 66 104 MHz\ntWH SCK High Time 4.5 4.5 ns\ntWL SCK Low Time 4.5 4.5 ns\ntSCKR(1)SCK Rise Time, Peak-to-peak 0.1 0.1 V/ns\ntSCKF(1)SCK Fall Time, Peak-to-peak 0.1 0.1 V/ns\ntCS Minimum CS  High Time 30 30 ns\ntCSS CS Setup Time 6 5 ns\ntCSH CS Hold Time 5 5 ns\ntSU Data In Setup Time 2 2 ns\ntH Data In Hold Time 1 1 ns\ntHO Output Hold Time 0 0 ns\ntDIS(1)Output Disable Time 8 6 ns\ntV Output Valid 7 6 ns\ntWPE WP Low to Protection Enabled 1 1 µs\ntWPD WP High to Protection Disabled 1 1 µs\ntLOCK Freeze Sector Lockdown Time (from CS  High) 200 200 µs\ntEUDPD(1)CS High to Ultra-Deep Power-Down 3 3 µs\ntCSLU Minimum CS  Low Time to Exit Ultra-Deep Power-Down 20 20 ns\ntXUDPD Exit Ultra-Deep Power-Down Time 100 100 µs\ntEDPD(1)CS High to Deep Power-Down 2 2 µs\ntRDPD Resume from Deep Power-Down Time 35 35 µs\ntXFR Page to Buffer Transfer Time 180 180 µs\ntCOMP Page to Buffer Compare Time 180 180 µs\ntRST RESET  Pulse Width 10 10 µs\ntREC RESET  Recovery Time 1 1 µs\ntSWRST  Software Reset Time 35 35 µs\n\n 49 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202218.5 Program and Erase Characteristics\nNotes: 1. Values are based on device characterization, not 100% tested in production.\n2. N o\nt 100% tested (value guaranteed by design and characterization).\n19. Input Test Waveforms and Measurement Levels\n20. Output Test Load1.7V to 3.6V 2.3V to 3.6V\nSymbol Parameter Min Typ Max Min Typ Max Units\ntEPPage Erase and Programming \nTime (256/264 bytes)10 35 8 35 ms\ntP Page Programming Time 1.5 5 1.5 3 ms\ntBP Byte Programming Time 8 8 µs\ntPE Page Erase Time 7 35 7 35 ms\ntBE Block Erase Time 25 50 25 50 ms\ntSE Sector Erase Time 2.5 6.5 2.5 6.5 s\ntCE Chip Erase Time 80 208 80 208 s\ntSUSP Suspend TimeProgram 8 12 8 12\nµs\nErase 20 30 20 30\ntRES Resume TimeProgram 3 5 3 5\nµs\nErase 3 5 3 5\ntOTPP OTP Security Register Program Time 200 500 200 500 µs\nAC\nDriving\nLevelsAC\nMeasurement\nLevel0.1VCCVCC/20.9VCC\ntR, tF < 2ns (10% to 90%)\nDevice\nUnder\nTest\n30pF\n\n 50 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202221. Utilizing the RapidS Function\nTo take advantage of the RapidS function\'s ability to operate at higher clock frequencies, a full clock cycle must be used\nto transmit data back and forth across the serial bus. The DataFlash is designed to always clock its data out on the falling\nedge of the SCK signal and clock data in on the rising edge of SCK.\nFor full clock cycle operation to be achieved, when the DataFlash is clocking data out on the falling edge of SCK, the host\ncontroller should wait until the next falling edge of SCK to latch the data in. Similarly, the host controller should clock its\ndata out on the rising edge of SCK in order to give the DataFlash a full clock cycle to latch the incoming data in on the\nnext rising edge of SCK.\nFigure 21-1. RapidS Mode\nSCK\nMOSI\nMISO1\n2 3 4 5 6 78 1\n2 3 4 5 6 78\nMOSI = Master Out, Slave In\nMISO = Master In, Slave Out\nThe Master is the host controller and the Slave is the DataFlash.\nThe Master always clocks data out on the rising edge of SCK and always clocks data in on the falling edge of SCK.\nThe Slave always clocks data out on the falling edge of SCK and always clocks data in on the rising edge of SCK.\nA. Master clocks out first bit of BYTE-MOSI on the rising edge of SCK\nB. Slave clocks in first bit of BYTE-MOSI on the next rising edge of SCK\nC. Master clocks out second bit of BYTE-MOSI on the same rising edge of SCK\nD. Last bit of BYTE-MOSI is clocked out from the Master\nE. Last bit of BYTE-MOSI is clocked into the slave\nF. Slave clocks out first bit of BYTE-SO\nG. Master clocks in first bit of BYTE-SO\nH. Slave clocks out second bit of BYTE-SO\nI. Master clocks in last bit of BYTE-SOAB\nC DE\nFG1\nH BYTE-MOSIMSB LSB\nBYTE-SOMSB LSBSlave CS\nI\n\n 51 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Figure 21-2. Command Sequence for Read/Write Operations for Page Size 256 bytes \n(Exce\npt Status Register Read, Manufacturer and Device ID Read)\nFigure 21-3. Command Sequence for Read/Write Operations for Page Size 264 bytes \n(Exce\npt Status Register Read, Manufacturer and Device ID Read)SI (INPUT) CMD 8-bits 8-bits 8-bits\nPage Address\n(A22 - A8)X X X X X X X X   X X X X X X X X LSB X X X X X X X X\nByte/Buffer Address\n(A7 - A0/BFA7 - BFA0)MSB\n1 Dummy Bit\nPage Address\n(PA14 - PA0)Byte/Buffer Address\n(BA8 - BA0/BFA8 - BFA0)SI (INPUT) CMD 8-bits 8-bits 8-bits\nX X X X X X X X X X X X LSB X X X X X X X X MSB X X X X\n\n 52 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202222. AC Waveforms\nFour different timing waveforms are shown in Figure 22-1  thr ough Figure 22-4 . Waveform 1 shows the SCK signal being\nlow w\nhen CS  makes a high-to-low transition and Waveform 2 shows the SCK signal being high when CS  makes a\nhigh-to-low transition. In both cases, output SO becomes valid while the SCK signal is still low (SCK low time is specified\nas tWL). Timing Waveforms 1 and 2 conform to RapidS serial interface but for frequencies up to 85MHz. Waveforms 1\nand \n2 are compatible with SPI Mode 0 and SPI Mode 3, respectively.\nWaveform 3 and 4 illustrate general timing diagram for RapidS serial interface. These are similar to Waveform 1 and 2,\nexcept that output SO is not restricted to become valid during the tWL period. These timing waveforms are valid over the\nfull\n frequency range (maximum frequency = 85MHz) of the RapidS serial case.\nFigure 22-1. Waveform 1 = SPI Mode 0 Compatible\nFigu\nre 22-2. Waveform 2 = SPI Mode 3 CompatibleCS\nSCK\nSISOtCSS\nValid IntH tSUtWH tWL tCSHtCS\ntV\nHigh-impedance\nValid OuttHO tDIS\nHigh-impedance\nCS\nSCK\nSOtCSS\nValid IntH tSUtWL tWH tCSHtCS\ntV\nHigh ZValid OuttHO tDIS\nHigh-impedance\nSI\n\n 53 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Figure 22-3. Waveform 3 = RapidS Mode 0\nFigure 22-4. Waveform 4 = RapidS Mode 3CS\nSCK\nSISOtCSS\nValid IntH tSUtWH tWL tCSHtCS\ntV\nHigh-impedance\nValid\n OuttHO tDIS\nHigh-impedance\nCS\nSCK\nSOtCSS\nValid IntH tSUtWL tWH tCSHtCS\ntV\nHigh ZValid OuttHO tDIS\nHigh-impedance\nSI\n\n 54 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202223. Write Operations\nThe following block diagram and waveforms illustrate the various write sequences available.\nFigure 23-1. Block Diagram\nFigu\nre 23-2. Buffer Write\nFigure 23-3. Buffer to Main Memory Page ProgramFlash Memory Array\nI/O InterfaceSCK\nCS\nRESET\nVCC\nGNDWP\nSO SIPage (256/264 bytes)\nBuffer 1 (256/264 bytes) Buffer 2 (256/264 bytes)\nCS\nSI (Input) CMD X X BFA7-0 n n + 1 Last ByteCompletes Writing into Selected Buffer\nBinary Page Size\n16 Dummy Bits + BFA7-BFA0\nn  = 1st byte read\nn+1 = 2nd byte read Each transition represents eight bits\nCS\nSI (Input) CMD A15-A8 XXXX XXXX X,A22-A16Starts Self-timed Erase/Program Operation\nBinary Page Size\nA22-A8 + 8 Dummy Bits\nEach transition represents eight bits\n\n 55 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202224. Read Operations\nThe following block diagram and waveforms illustrate the various read sequences available.\nFigure 24-1. Block Diagram\nFigu\nre 24-2. Main Memory Page ReadFlash Memory Array\nPage (256/264 bytes)\nBuffer 2 (256/264 bytes) Buffer 1 (256/264 bytes)\nI/O InterfaceMain Memory\nPage To\nBuffer 1Main Memory\nPage To\nBuffer 2\nMain Memory\nPage ReadBuffer 1\nReadBuffer 2\nRead\nSO\nCS\nSI (Input)\nSO (Output) nCMD PA14-7 PA6-0, BA8 BA7-0 X XAddress for Binary Page Size\nX,A22-A16 A15-A8 A7-A0\nn n + 14 Dummy Bytes\n\n 56 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Figure 24-3. Main Memory Page to Buffer Transfer\nData \nFrom the selected Flash Page is read into either SRAM Buffer\nFigure 24-4. Buffer ReadCS\nSI (Input) CMD PA14-7 PA6-0, XX XXXX XXXXStarts Reading Page Data into Buﬀer\nBinary Page Size\n      X, A22-A16   +      A15- A8   +  8 Dummy Bits\nSO (Output)\nCS\nSI (Input)\nSO (Output) nCMD XXXX XXXX XXX\nX XXXX BFA7-0 XAddress for Binary Page Size\n16 Dummy Bits +                             BFA7-BFA0\nn n + 1No Dummy Byte (opcodes D1H and D3H)\n1 Dummy Byte (opcodes D4H and D6H)\nEach transition represents eight bits\n\n 57 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202225. Detailed Bit-level Read Waveforms: RapidS Mode 0/Mode 3\nFigure 25-1. Continuous Array Read (Legacy Opcode E8h)\nFigu\nre 25-2. Continuous Array Read (Opcode 0Bh)\nFigure 25-3. Continuous Array Read (Opcode 01h or 03h)SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 1 0 1 0 0 0 6 7 5 4 10 11 9 8 12 63 66 67 65 64 62 33 34 31 32 29 30 68 71 72 70 69 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits 32 Dummy Bits\nData Byte 1\nHigh-impedance\nBit 2048/2112\nof Page nBit 0  of\nPage n+1\nSCKCS\nSI\nSOMSB MSB2 3 1 0\n0 0 0 0 1 0 1 16 7 5 4 10 11 9 8 12 39 42 43 41 40 38 33 34 31 32 29 30 44 47 48 46 45\nOpcode\nA A A A A A A A A\nMSBX X X X X X\nMSB MSBD D D D D D D D D DAddress Bits A22 - A0 Dummy Bits\nData Byte 1\nHigh-impedance36 37 35\nX X\nSCKCS\nSI\nSOMSB MSB2 3 1 0\n0 0 0 0 0 0 1 16 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40\nOpcode\nA A A A A A A A A\nMSB MSBD D D D D D D D D DAddress Bits A22-A0\nData Byte 1\nHigh-impedance\n\n 58 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Figure 25-4. Main Memory Page Read (Opcode D2h)\nFigure 25-5. Buffer Read (Opcode D4h or D6h)\nFigure 25-6. Buffer Read – Low Frequency (Opcode D1h or D3h)SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 0 1 0 6 7 5 4 10 11 9 8 12 63 66 67 65 64 62 33 34 31 32 29 30 68 71 72 70 69 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits 32 Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 1 0 0 6 7 5 4 10 11 9 8 12 39 42 43 41 40 37 38 33 36 35 34 31 32 29 30 44 47 48 46 45 \nOpcode\nX X X X A A A X X \nMSB X X X X X X X X \nMSB MSB D D D D D D D D D D Address Bits\nBinary Page Size = 16 Dummy Bits + BFA7-BFA0\nStandard DataFlash Page Size = \n15 Dummy Bits + BFA8-BFA0Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 0 0 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X A A A X X \nMSB MSB D D D D D D D D D D Data Byte 1\nHigh-impedanceAddress Bits\nBinary Page Size = 16 Dummy Bits + BF\nA7-BFA0\nStandard DataFlashPage Size = \n15 Dummy Bits + BFA8-BFA0\n\n 59 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/2022Figure 25-7. Read Sector Protection Register (Opcode 32h)\nFigure 25-8. Read Sector Lockdown Register (Opcode 35h)\nFigure 25-9. Read Security Register (Opcode 77h)SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 1 1 0 0 1 0 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 1 1 0 1 0 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 1 1 1 0 1 1 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\n\n 60 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Figure 25-10. Status Register Read (Opcode D7h)\nFigure 25-11. Manufacturer and Device Read (Opcode 9Fh)\nFigure 25-12.Reset Timing\nNote: 1. The CS  signal should be in the high state before the RESET  signal is deasserted.SCK CS \nSI \nSO MSB 2 3 1 0 \n1 1 0 1 0 1 1 1 6 7 5 4 10 11 9 8 12 21 22 17 20 19 18 15 16 13 14 23 24 \nOpcode\nMSB MSB D D D D D D D D D D \nMSB D D D D D D D D Status Register Data Status Register Data\nHigh-impedance\nSCKCS\nSI\nSO6 0\n9Fh8 7 46\nOpcode\n1Fh 00h 01h 00h\nManufacturer ID Device ID\nByte 1Device ID\nByte 2EDI\nString LengthEDI\nData Byte 1High-impedance14 16 15 22 24 23 38 40 39 30 32 31\nNote:  Each transition shown for SI and SO represents one byte (8 bits)28h\nCS\nSCK\nRESET\nSO (Output)High Impedance High Impedance\nSI (Input)tRSTtREC tCSS\n\n 61 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202226. Auto Page Rewrite Flowchart\nFigure 26-1. Algorithm for Programming or Re-programming of the Entire Array Sequentially\nNotes: 1. This type of algorithm is used for applications in which the entire array is programmed sequentially, filling the \narra\ny page-by-page.\n2. A page can be written using either a Main Memory Page Program operation or a buffer write operation\nfollowed by a buffer to Main Memory Page Program operation.\n3. The algorithm above shows the programming of a single page. The algorithm will be repeated sequentially\nfor each page within the entire array.START\nMain Memory Page Program\nthrough Buffer\n(82h, 85h)\nENDProvide Address\nand Data\nBuffer Write\n(84h, 87h)\nBuffer To Main\nMemory Page Program\n(83h, 86h)\n\n 62 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/2022Figure 26-2. Algorithm for Programming or Re-programming of the Entire Array Randomly\nNotes: 1. To preserve data integrity, each page of an DataFlash sector must be updated/rewritten at least once within \never\ny 50,000 cumulative page erase and program operations.\n2. A page address pointer must be maintained to indicate which page is to be rewritten. The Auto Page\nRewrite command must use the address specified by the page address pointer.\n3. Other algorithms can be used to rewrite portions of the Flash array. Low-power applications may choose to\nwait until 50,000 cumulative page erase and program operations have accumulated before rewriting all\npages of the sector.START\nMain Memory Page\nto Buffer Transfer\n(53h, 55h)\nIncrement Page\nAddress Pointer(2)Auto Page Rewrite(2)\n(58h, 59h)\nENDProvide Address of\nPage to Modify\nIf planning to modify multiple\nbytes currently stored within\na page of the Flash array\nMain Memory Page Program\nthrough Buffer\n(82h, 85h)Buffer Write\n(84h, 87h)\nBuffer to Main\nMemory Page Program\n(83h, 86h)\n\n 63 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202227. Ordering Information (Standard DataFlash Page Size)\n27.1 Ordering Detail\n27.2 Ordering Codes (Standard DataFlash Page Size)\nNotes: 1. The shipping carrier suffix is not marked on the device.\n2.Contac t\n Adesto for mechanical drawing or Die Sales information.Device Grade\nH = Green, NiPdAu lead finish,\nIndustrial temperature range\n (–40°C to +85°C)\nU = Green, Matte Sn or Sn alloy,\nIndustrial temperature range\n(–40°C to +85°C)Designator\nProduct Family\nDevice RevisionShipping Carrier Option\nPackage OptionDevice Density\n64 = 64-Mbit\nInterface\n1 = Serial45DB = DataFlashB   =  Bulk (tubes)\nT = Tape and reel\nY = Trays\nOperating Voltage\nN = 1.7V minimum (1.7V to 3.6V)\nS  = 8-lead, 0.208” wide SOIC\nM  = 8-pad, 5 x 6 x 0.6mm UDFN\nMW = 8-pad, 6 x 8 x 1.0mm VDFNA T 4 5 D B 6 4 1 E - S H N 2 B - B\nPage Size Option\n“  ” = Standard (264 bytes/page)\n2B = Binary (256 bytes/page)\nDWF = Die in Wafer Form\nOrdering Code Package Lead Finish Operating Voltage fSCK Device Grade\nAT45DB641E-SHN-B(1)\n8S2\nNiPdAu\n1.7V to 3.6V 85MHzIndustrial\n(-40°C to 85 °C)AT45DB641E-SHN-T(1)\nAT45DB641E-MHN-Y(1)\n8MA1\nAT45DB641E-MHN-T(1)\nAT45DB641E-MWHN-Y(1)\n8MW1\nAT45DB641E-MWHN-T(1)\nAT45DB641E-DWF(1)DWF\n\n 64 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202227.3 Ordering Codes (Binary Page Size)\nNotes: 1. The shipping carrier suffix is not marked on the device.\n2.Pa\nrts ordered with suffix code ‘2B’ are shipped in tape and reel (T&R) with the page size set to\n256 bytes. This option is only available for shipping in T&R (-T).Package Type\n8S2 8-lead 0.208" wide, Plastic Gull Wing Small Outline (EIAJ SOIC)\n8MA1 8-pad (5 x 6 x 0.6mm body), Thermally Enhanced Plastic Ultra Thin Dual Flat No-lead (UDFN)\n8MW1 8-pad (6 x 8 x 1.0mm body), Thermally Enhanced Plastic Very Thin Dual Flat No-lead (VDFN)\nDWF Die in Wafer Form\nOrdering Code Package Lead Finish Operating Voltage fSCK Device Grade\nAT45DB641E-SHN2B-T(1)(2)8S2\nNiPdAu\n1.7V to 3.6V 85MHzIndustrial\n(-40°C to 85 °C)AT45DB641E-MHN2B-T (1)(2)8MA1\nAT45DB641E-MWHN2B-T (1)(2)8MW1\nPackage Type\n8S2 8-lead 0.208" wide, Plastic Gull Wing Small Outline (EIAJ SOIC)\n8MA1 8-pad (5 x 6 x 0.6mm body), Thermally Enhanced Plastic Ultra Thin Dual Flat No-lead (UDFN)\n8MW1 8-pad (6 x 8 x 1.0mm body), Thermally Enhanced Plastic Very Thin Dual Flat No-lead (VDFN)\n\n 65 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202228. Packaging Information\n28.1 8S2 – 8-lead EIAJ SOIC\nTITLE DRAWING NO.     GPC REV.\nPackage Drawing Contact:\ncontact@adestotech.com8S2 STN F 8S2, 8-lead, 0.208” Body, Plastic Small\nOutline Package (EIAJ)4/15/08COMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX NOTE  \nNotes: 1. This drawing is for general information only; refer to EIAJ Drawing EDR-7320 for additional information. \n2. Mismatch of the upper and lower dies and resin burrs aren\'t included. \n3. Determines the true geometric position. \n4. Values b,C apply to plated terminal.  The standard thickness of the plating layer shall measure between 0.007 to .021 mm. A 1.70 2.16 \nA1 0.05 0.25 \nb 0.35 0.48  4\nC 0.15 0.35  4\nD 5.13 5.35 \nE1 5.18 5.40  2\nE 7.70 8.26 \nL 0.51 0.85 \nq   0°  8°\ne 1.27 BSC  3q1 \nN E \nTOP VIEW C \nE1 \nEND VIEW \nA b L \nA1 e \nD \nSIDE VIEW \n\n 66 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202228.2 8MA1 – 8-pad UDFN\nTITLE DRAWING NO. GPC REV.\nPackage Drawing Contact:\ncontact@adestotech.com 8MA1 YFG D 8MA1, 8-pad (5 x 6 x 0.6 mm Body), Thermally  \nEnhanced Plastic Ultra Thin Dual Flat No Lead \nPackage (UDFN) COMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX N O T E \nA 0.45 0.55 0.60 \nA1 0.00 0.02 0.05 \nb 0.35 \n0.40 0.48 \nC 0.152 REF \nD 4.90 \n5.00 5.10 \nD2 3.80 4.00 4.20 \nE 5.90 6.00 6.10 \nE2 3.20 3.40 3.60 \ne 1.27 \nL 0.50 0.60 0.75 \ny 0.00 – 0.08 \nK 0.20 – – \n4/15/08Pin 1 ID \nTOP VIEW E \nD \nA1 \nA SIDE VIEW \ny C \nBOTTOM VIEW E2 \nD2 \nL b e 1 \n2 \n3 \n4 8 \n7 \n6 \n5 Pin #1 Notch \n(0.20 R) 0.45 K \nPin #1  \n Cham f e r  \n (C 0.35) Option A \n(Option B) \n\n 67 AT45DB641E \nDS-45DB641E-027N–DFLASH–2/202228.3 8MW1 - 8-pad VDFN\nDRAWING NO. REV .  TITLE\nPackage Drawing Contact:\ncontact@adestot ech.c\nom8MW1 F8/4/17\n8MW1, 8-pad (6 x 8 x 1.0 mm Body), Thermally \nEnhanced P\nlastic Very Thin Dual Flat No Lead\nPackage (VDFN)Bottom ViewTop ViewSide View\nCOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\n0.80\n–\n0.35\n5.90\n4.25\n7.90\n3.35\n0.45A\nA1\nb\nC\nD\nD1\nE\nE1\ne\nL\nK–\n–\n0.40\n0.203 REF\n6.00\n8.00\n1.27\n0.50\n1.05 REF1.00\n0.05\n0.48\n6.10\n4.90\n8.10\n5.00\n0.55Pin 1 IDE\nD\nA1\nAC\nPin #1 IDE1\nD1\nLbe\nK1\nPin #1 \nChamfer\n(C 0.40 max)Option A\nPin #1 \nNotch\n(0.20 R)Option B2\n3\n48\n7\n6\n5\n\nDS-45DB641E-027 N 2/2022 Changed company logo to Renesas.\n 68 AT45DB641E\nDS-45DB641E-027N–DFLASH–2/202229. Revision History\nDoc. Rev. Date Comments\nDS-45DB641E-027A 8/2013 Initial document release.\nDS-45DB641E-027B 10/2013Updated spec in Continuous Array Read (1Bh Opcode) to fCAR4. Corrected Low Power\nRead Option (\nup to 15MHz). Corrected Ultra-Deep Power-Down current (400nA typical). \nUpdated spec for Input High Voltage (Max) to VCC + 0.6V. Updated DC and AC \nparameters, and Program and Erase Characteristics. Updated datasheet status to \nPreliminary.\nDS-45DB641E-027C 11/2013 Corrected Memory Architecture Diagram, Figure 3.1.\nDS-45DB641E-027D 1/2014 Added Exit Ultra-Deep Power-Down (Chip Select Low). \nDS-45DB641E-027E 1/2014 Updated specifications for IDPD, ISB, ICC2, fCAR2, and tXUDPD . Removed Preliminary status.\nDS-45DB641E-027F 4/2015Added WLCSP package. Expanded explanation of Power up/Power down (Section 16).\nCorrected Table 6-4 (Additional Commands, “Main Memory to Buffer”). Corrected \nOrdering Code Detail Diagram (voltage range).\nDS-45DB641E-027G 6/2015 Added Die in Wafer Form package option. Updated 44-WLCSP package title.\nDS-45DB641E-027H 1/2016Corrected page size reference in Ordering Detail Diagram. Updated UUN package \ndiagram.\nDS-45DB641E-027I 1/2017 Added patent information.\nDS-45DB641E-027J 8/2017 Updated 6 x 8 VDFN package drawing.\nDS-45DB641E-027K 2/2019 Removed 9CC, 9-ball UBGA package option.\nDS-45DB641E-027 L 8/2021 Corrected Ordering Detail figure (Section 27.1).\nDS-45DB641E-027 M 9/2021 Removed WLCSP package option.\n\nCorporate Headquarters\nTOYOSU FORESIA, 3-2-24 Toyosu,\nKoto-ku, Tokyo 135-0061, Japanwww.renesas.comContact Information\nFor further information on a product, technology, the most up-to-date version of a document, or your nearest sales office, please visit:www.renesas.com/contact/\nTrademarks\nRenesas and the Renesas logo are trademarks of Renesas Electronics Corporation. All trademarks and registered trademarks are the property  of their respective owners.IMPORTANT NOTICE AND DISCLAIMER\nRENESAS ELECTRONICS CORPORATION AND ITS SUBSIDIARIES (“RENESAS”) PROVIDES TECHNICAL SPECIFICATIONS AND RELIABILITY DATA (INCLUDING DATASHEETS), DESIGN RESOURCES (INCLUDING REFERENCE DESIGNS), APPLICATION OR OTHER DESIGN ADVICE, WEB TOOLS, SAFETY INFORMATION, AND OTHER RESOURCES “AS IS” AND WITH ALL FAULTS, AND DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY RIGHTS.\nThese resources are intended for developers skilled in the art designing with Renesas products. You are solely responsible \nfor (1) selecting the appropriate products for your application, (2) designing, validating, and testing your application, and (3) ensuring your application meets applicable standards, and any other safety, security, or other requirements. These resources are subject to change without notice. Renesas grants you permission to use these resources only for development of an application that uses Renesas products. Other reproduction or use of these resources is strictly prohibited. No license is granted to any other Renesas intellectual property or to any third party intellectual property. Renesas disclaims responsibility for, and you will fully indemnify Renesas and its representatives against, any claims, damages, costs, losses, or liabilities arising out of your use of these resources. Renesas\' products are provided only subject to Renesas\' Terms and Conditions of Sale or other applicable terms agreed to in writing. No use of any Renesas resources expands or otherwise alters any applicable warranties or warranty disclaimers for these products. \n(Rev.1.0 Mar 2020)\n© 2021 Renesas Electronics Corporation. All rights reserved.\nMouser Electronics\n  \nAuthorized Distributor\n \n  \nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\n \n \n \n Adesto Technologies:   \n\xa0 AT45DB641E-SHN2B-T \n \n Dialog Semiconductor:   \n\xa0 AT45DB641E-MHN2B-T\xa0 AT45DB641E-MHN-T\xa0 AT45DB641E-MHN-Y\xa0 AT45DB641E-MWHN2B-T\xa0 AT45DB641E-\nMWHN-T\xa0 AT45DB641E-MWHN-Y\xa0 AT45DB641E-SHN-B\xa0 AT45DB641E-SHN-T\xa0 AT45DB641E-UUN2B-T\n'}]
!==============================================================================!
### Component Summary: AT45DB641E-SHN-T

#### Key Characteristics and Specifications:
- **Voltage Ratings**: 1.7V to 3.6V
- **Current Ratings**:
  - Active Read Current: 7mA (typical at 15MHz)
  - Standby Current: 25µA (typical)
  - Deep Power-Down Current: 5µA (typical)
  - Ultra-Deep Power-Down Current: 400nA (typical)
- **Power Consumption**:
  - Active Read: 7mA (typical at 15MHz)
  - Standby: 25µA
  - Deep Power-Down: 5µA
  - Ultra-Deep Power-Down: 400nA
- **Operating Temperature Range**: -40°C to 85°C (Industrial)
- **Package Type**: 
  - 8-lead SOIC (0.208" wide)
  - 8-pad Ultra-thin DFN (5 x 6 x 0.6mm)
  - 8-pad Very-thin DFN (6 x 8 x 1.0mm)
- **Special Features**:
  - Supports RapidS™ operation for high-speed applications.
  - Two independent SRAM data buffers for continuous data streaming.
  - Advanced data protection features including sector protection and lockdown.
  - Configurable page size (256 or 264 bytes).
  - Endurance: 100,000 program/erase cycles per page minimum.
  - Data retention: 20 years.
- **Moisture Sensitive Level**: MSL 3 (JEDEC J-STD-020E)

#### Description:
The **AT45DB641E** is a 64-Mbit (8MB) serial flash memory device designed for high-density data storage applications. It operates on a single supply voltage ranging from 1.7V to 3.6V and features a Serial Peripheral Interface (SPI) that supports both SPI modes 0 and 3. The device is optimized for low power consumption, making it suitable for battery-operated devices.

#### Typical Applications:
The AT45DB641E is commonly used in various applications, including:
- **Digital Voice and Image Storage**: Ideal for devices that require storage for audio and visual data.
- **Program Code Storage**: Suitable for embedded systems where firmware needs to be stored and updated.
- **Data Logging**: Used in applications that require continuous data recording, such as environmental monitoring systems.
- **Consumer Electronics**: Found in devices like cameras, smartphones, and other portable electronics that require efficient data storage solutions.
- **Industrial Applications**: Utilized in industrial control systems where reliability and data integrity are critical.

This component is particularly advantageous in applications that demand high-speed data access and low power consumption, making it a versatile choice for modern electronic designs.