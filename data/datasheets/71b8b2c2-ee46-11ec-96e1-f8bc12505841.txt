[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of S25FL512SAGMFI010 production of SPANSION from the text:www.infineon.comPlease note that Cypress is an Infineon Technologies Company.\nThe document following this cover page is marked as “Cypress” document as this is the \ncompany that originally developed the product. Please note that Infineon will continue \nto offer the product to new and existing customers as part of the Infineon product \nportfolio.\nContinuity of document content\nThe fact that Infineon offers the following product as part of the Infineon product \nportfolio does not lead to any changes to this document. Future revisions will occur \nwhen appropriate, and any changes will be set out on the document history page.\nContinuity of ordering part numbers\nInfineon continues to support existing part numbers. Please continue to use the \nordering part numbers listed in the datasheet for ordering.\nS25FL512S\n512 Mb (64 MB), 3.0 V SPI Flash Memory\nCypress Semiconductor Corporation • 198 Champion Court • San Jose ,CA 95134-1709 • 408-943-2600\nDocument Number: 001-98284 Re v. *R  Revised  April 30, 2019S25FL512S, 512 Mb (64 MB), 3.0 V SPI Flash Memory\nFeatures\n\uf06eCMOS 3.0 V Core with versatile I/O\n\uf06eSPI with Multi-I/O\n\uf06eDensity\n❐512 Mb (64 MB)\n\uf06eSPI\n❐SPI Clock polarity a nd phase modes 0 and 3\n❐DDR option\n❐Extended Addressing: 32-bit address\n❐Serial Command set and fo otprint compatible with \nS25FL-A, S25FL-K, and S25FL-P SPI families\n❐Multi I/O Command se t and footprint compatible with the\nS25FL-P SPI family\n\uf06eREAD Commands\n❐Normal, Fast, Dual, Quad,  Fast DDR, Dual DDR, Quad DDR\n❐AutoBoot - power up or reset and execute a Normal or Quad \nread command automatically  at a preselected address\n❐Common Flash Interface (CFI) data for configuration infor-\nmation.\n\uf06eProgramming (1.5 MBps)\n❐512-byte Page Programming buffer\n❐Quad-Input P age Programming (QPP)  for slow clock sys-\ntems\n❐Automatic ECC -internal hardw are Error Correction Code \ngeneration with single bit error correction\n\uf06eErase (0.5 to 0.65 MBps)\n❐Uniform 256-KB sectors\n\uf06eCycling Endurance\n❐100,000 Program-Erase Cycles, minimum\uf06eData Retention\n❐20-Year Data Retention, minimum\n\uf06eSecurity Features\n❐OTP array of 1024 bytes\n❐Block Protection:\n• Status Register bits to contr ol protection against program \nor erase of a contiguous range of sectors.\n• Hardware and software control options\n❐Advanced Sector Protection (ASP)\n• Individual sector protection controlled by boot code or \npassword\n\uf06eCypress 65 nm MirrorBit® Technology with Eclipse™ \nArchitecture\n\uf06eCore supply voltage: 2.7 V to 3.6 V\n\uf06eI/O supply voltage: 1.65 V to 3.6 V \n❐SO16 and FBGA packages\n\uf06eTemperature range:\n❐Industrial (–40 °C to +85 °C)\n❐Industrial Plus (–40 °C to +105 °C)\n❐Automotive, AEC-Q100 Grade 3 (–40 °C to +85 °C)\n❐Automotive, AEC-Q100 Gr ade 2 (–40 °C to +105 °C)\n❐Automotive, AEC-Q100 Gr ade 1 (–40 °C to +125 °C)\n\uf06ePackages (all Pb-free)\n❐16-pin SOIC (300 mil)\n❐24-BGA (6 × 8 mm)\n• 5 × 5 ball (FAB024) and 4 ×  6 ball (FAC024) footprint \noptions \n❐Known Good Die and Known Tested Die\nLogic Block Diagram\nSRAM\nMirrorBit Array\nControl \nLogic\nData PathX DecodersCS#\nSCK\nSI/IO0\nSO/IO1\nHOLD#/IO3WP#/IO2\nRESET#I/OY Decoders\nData Latch\nDocument Number: 001-98284 Rev. *R Page 2 of 136S25FL512S\nPerformance Summary\nMaximum Read Rates with the Same Core and I/O Voltage (VIO = VCC = 2.7 V to 3.6 V)\nCommand Clock Rate (MHz) MBps\nRead 50 6.25\nFast Read 133 16.6\nDual Read 104 26\nQuad Read 104 52\nMaximum Read Rates with Lower I/O Voltage (VIO = 1.65 V to 2.7 V, VCC = 2.7 V to 3.6 V)\nCommand Clock Rate (MHz) MBps\nRead 50 6.25\nFast Read 66 8.25\nDual Read 66 16.5\nQuad Read 66 33\nMaximum Read Rates DDR (VIO = VCC = 3 V to 3.6 V)\nCommand Clock Rate (MHz) MBps\nFast Read DDR 80 20\nDual Read DDR 80 40\nQuad Read DDR 80 80\nTypical Program and Erase Rates\nOperation KBps\nPage Programming (512-byte page buffer - Uniform Sector Option) 1500\n256-KB Logical Sector Erase (Uniform Sector Option) 500\nCurrent Consumption\nOperation Clock Rate (MHz)\nSerial Read 50 MHz 16 (max)\nSerial Read 133 MHz 33 (max)\nQuad Read 104 MHz 61 (max)\nProgram 100 (max)\nErase 100 (max)\nStandby 0.07 (typ)\nDocument Number: 001-98284 Rev. *R Page 3 of 136S25FL512S\nContents\n1. Overview ............................................................... ........  4\n1.1 General Description ......................................... ..............  4\n1.2 Migration Notes............................................. .................  4\n1.3 Glossary.................................................... .....................  6\n1.4 Other Resources............................................. ...............  7\nHardware Interface\n2. Signal Descriptions .....................................................  8\n2.1 Input/Output Summary........................................ ...........  8\n2.2 Address and Data Configuration.............................. ......  9\n2.3 RESET#........... ........... ........... ........... .......... ...................  9\n2.4 Serial Clock (SCK).......................................... ...............  9\n2.5 Chip Select (CS#) ........................................... ...............  9\n2.6 Serial Input (SI) / I/O0 .................................... ................  9\n2.7 Serial Output (SO) / I/O1................................... ...........  10\n2.8 Write Protect (WP#) / I/O2 .................................. .........  10\n2.9 Hold (HOLD#) / I/O3 ......................................... ...........  10\n2.10 Core Voltage Supply (VCC)..........................................  11\n2.11 Versatile I/O Power Supply (VIO) .................................  11\n2.12 Supply and Signal Ground (VSS) .................................  11\n2.13 Not Connected (NC) ......................................... ...........  11\n2.14 Reserved for Fu ture Use (RFU).............................. .....  11\n2.15 Do Not Use (DNU) ............ ........... ........... ......... ............  11\n2.16 Block Diagrams............................................. ...............  12\n3. Signal Protocols .........................................................  13\n3.1 SPI Clock Modes ............................................. ............  13\n3.2 Command Protocol ............................................ ..........  14\n3.3 Interface States............................................ ................  18\n3.4 Configuration Register Effects on the Interface ...........  2 3\n3.5 Data Protection ............................................. ...............  23\n4. Electrical Specifications ............................................  24\n4.1 Absolute Maximum Ratings .................................... .....  24\n4.2 Thermal Resistance.......................................... ...........  24\n4.3 Operating Ranges............................................ ............  24\n4.4 Power-Up and Power-Down ..................................... ...  25\n4.5 DC Characteristics.......................................... .............  27\n5. Timing Specifications ................................................  28\n5.1 Key to Switching Waveforms .................................. .....  28\n5.2 AC Test Conditions.......................................... ............  29\n5.3 Reset....................................................... .....................  30\n5.4 SDR AC Characteristics...................................... .........  32\n5.5 DDR AC Characteristics ...................................... ........  36\n6. Physical Interface ......................................................  38\n6.1 SOIC 16-Lead Package........................................ .......  38\n6.2 FAB024 24-Ball BGA Package .................................. ..  40\n6.3 FAC024 24-Ball BGA Package.................................. ..  42Software Interface\n7. Address Space Maps .................................................. 44\n7.1 Overview.................................................... ................... 44\n7.2 Flash Memory Array.......................................... ............ 44\n7.3 ID-CFI Address Space........................................ .......... 44\n7.4 JEDEC JESD216 Serial Flash Discoverable \nParameters (SFDP) Space. .... ................................... ... 45\n7.5 OTP Address Space ........................................... .......... 45\n7.6 Registers................................................... .................... 47\n8. Data Protection ........................................................... 56\n8.1 Secure Silicon Region (OT P)........... ........... ........... ....... 56\n8.2 Write Enable Command........ ........... ........... .......... ........ 56\n8.3 Block Protection............................................ ................ 57\n8.4 Advanced Sector Protection .................................. ....... 58\n9. Commands ............................................................... ... 62\n9.1 Command Set Summary......................................... ...... 63\n9.2 Identification Commands ..................................... ......... 68\n9.3 Register Access Commands.................................... ..... 70\n9.4 Read Memory Array Commands . ............ ............ .........  78\n9.5 Program Flash Array Commands ................................ . 92\n9.6 Erase Flash Array Commands.................................. .... 95\n9.7 One Time Program Array Commands .......................... 98\n9.8 Advanced Sector Protection Commands...................... 999.9 Reset Commands .............................................. ......... 103\n9.10 Embedded Algorithm Performance Tables................. 104\n10. Data Integrity ............................................................. 1 05\n10.1 Erase Endurance ............................................ ............ 105\n10.2 Data Retention............................................. ............... 105\n11. Software Inte rface Reference .................................. 106\n11.1 Command Summary............................................ ....... 106\n11.2 Serial Flash Disco verable Parameters \n(SFDP) Address Map............................................. ..... 108\n11.3 Device ID and Common Flash Interface \n(ID-CFI) Address Map........................................... ...... 111\n11.4 Device ID and Common Flash Interface \n(ID-CFI) ASO Map — Automotive Only ...................... 127\n11.5 Registers.................................................. ................... 127\n11.6 Initial Delive ry State ..................................... ............... 130\n12 Ordering Information ................................................ 131\n12.1 Valid Combinations — Standard.............................. ... 132\n12.2 Valid Combinations —  Automotive Grade / \nAEC-Q100 ....................................................... ........... 132\n13. Revision History ........................................................ 133\nDocument History Page ......................................... ...........133\nSales, Solutions, and Legal Information ....................... ..136\nWorldwide Sales and Design Supp ort ............ ..............13 6\nProducts ...................................................... .................136\nPSoC® Solutions ...............................................\n..........136\nCypress Developer Community . .................................. .136\nTechnical Support ........... .................................. ...........136\nDocument Number: 001-98284 Rev. *R Page 4 of 136S25FL512S\n1. Overview\n1.1 General Description\nThe Cypress S25FL512S device is a  flash nonvolatile memory prod uct using: \n■MirrorBit technology - that stor es two data bits in each memory  array transistor\n■Eclipse architecture - that dram atically improves program and e rase performance\n■65 nm process lithography\nThis device connects to a host system via an SPI. Traditional S PI single bit serial input and output (Single I/O or SIO) is su pported as\nwell as optional two bit (Dual I/O or DIO) and four bit (Quad I /O or QIO) serial commands. This  multiple width interface is ca lled SPI\nMulti-I/O or MI O. In addition, the FL-S family adds support for  Double Data Rate (DDR) read commands for SIO, DIO, and QIO tha t\ntransfer address and read data  on both edges of the clock.\nThe Eclipse architecture features a Page Programming Buffer tha t allows up to 256 words (512 bytes) to be programmed in one\noperation, resulting in faster e ffective programming and erase than prior generation SPI pr ogram or erase algorithms. \nExecuting code directly from flash memory is often called Execu te-In-Place or XIP. By using FL- S devices at the higher clock r ates\nsupported, with QIO or DDR-QIO co mmands, the instruction read t ransfer rate can match or exceed traditional parallel interface ,\nasynchronous, NOR flas h memories while reducing signal count dr amatically.\nThe S25FL512S product offers high densities coupled with the fl exibility and fast performance r equired by a variety of embedde d\napplications. It is ideal for c ode shadowing, XIP , and data sto rage.\n1.2 Migration Notes\n1.2.1 Features Comparison\nThe S25FL512S device is command s et and footprint  compatible wi th prior generation FL-K and FL-P families.\nTable 1.  FL Generations Comparison\nParameter FL-K FL-P FL-S \nTechnology Node 90 nm 90 nm 65 nm Architecture Floating Gate Mi rrorBit MirrorBit Eclipse \nRelease Date In Production In Production In Production\nDensity 4 Mb–128 M b 32 Mb–256 Mb 512 Mb\nBus Width x1, x2, x4 x1, x2, x4 x1, x2, x4 Supply Voltage 2.7 V–3.6 V 2.7 V–3. 6 V 2.7 V–3.6 V / 1.65 V–3.6 V V\nIO \nNormal Read Speed (SDR) 6 MBps (5 0 MHz) 5 MBps (40 MHz) 6 MBps ( 50 MHz) \nFast Read Speed (SDR) 13 MBps (10 4 MHz) 13 MBps (104 MHz) 17 MBp s (133 MHz) \nDual Read Speed (SDR) 26 MBps (1 04 MHz) 20 MBps (80 MHz) 26 MBps  (104 MHz) \nQuad Read Speed (SDR) 52 MBps (10 4 MHz) 40 MBps (80 MHz) 52 MBps  (104 MHz) \nFast Read Speed (DDR) – – 20 MBps (80 MHz) Dual Read Speed (DDR)  – – 40 MBps (80 MHz) \nQuad Read Speed (DDR) – – 80 MBps (80 MHz) Program Buffer Size 256B 256B 512BErase Sector Size 4 KB / 32 KB / 64 KB 64 KB / 256 KB 256 KB\nParameter Sector Size 4 KB 4 KB –Sector Erase Time (typ.) 30 ms  (4 KB), 150 ms (64 kB) 500 ms (64  kB) 520 ms (256 kB) \nNotes\n1. 256B program page option only for 128-Mb and 256-Mb density F L-S devices.\n2. FL-P column indicates FL129P MIO SPI device (for 128-Mb densi ty).\n3. 64 kB sector erase option only for 128-Mb/256-Mb density FL-P  and FL-S devices.\n4. FL-K family devices can erase  4-kB sectors in groups of 32 kB  or 64 kB.\n5. Refer to individual datasheets for further details.\nDocument Number: 001-98284 Rev. *R Page 5 of 136S25FL512S\n1.2.2 Known Differences from Prior Generations\n1.2.2.1 Error Reporting\nPrior generation FL memories eith er do not have error status bi ts or do not set them if program o r erase is attempted on a pro tected\nsector. The FL-S family does have error reporting status bits f or program and erase operations. These can be set when there is  an\ninternal failure to program or erase or when there is an attemp t to program or erase a protected sector. In either case the pr ogram or\nerase operation did not complete  as requested by the command.\n1.2.2.2 Secure Silicon Region (OTP)\nThe size and format (address map) of the One Time Program area is different from prior generations. The method for protecting each\nportion of the OTP a rea is different. Fo r additional details se e Section 8.1 Secure Silicon Region (OTP) on page 56 .\n1.2.2.3 Configuration Register Freeze Bit\nThe configuration regi ster Freeze bit CR1[0 ], locks the state o f the Block Protection bits as in prior generations. In the FL- S family it\nalso locks the state of the configuration register TBPARM bit C R1[2], TBPROT bit CR1[5], and the Secure Silicon Region (OTP) a rea. \n1.2.2.4 Sector Erase Commands\nThe command for erasing an 8-KB area (two 4-KB se ctors) is not supported. \nThe command for erasing a 4-KB sector is not supported in the 5 12-Mb density FL-S device.\nThe erase command for 64-KB sect ors is not supported in the 512 -Mb density FL-S device.\n1.2.2.5 Deep Power-Down\nThe Deep Power Down (DPD) functi on is not supported in FL-S fam ily devices. \nThe legacy DPD (B9h) command code is instead used to enable leg acy SPI memory controllers, that can issue the former DPD\ncommand, to access a new bank address register. The bank addres s register allows SPI memory controllers that do not support mo re\nthan 24 bits of address, the ability to provide higher order ad dress bits for commands, as needed to access the larger address  space\nof the 512-Mb density FL-S device. For additional information s ee Section 7.1.1 Extended Address on page 44 .Page Programming Time (typ.) 700 µs (256B) 1500 µs (256B) 340 µs (512B) \nOTP 768B (3 x 256B) 506B 1024B Advanced Sector Protection No No YesAuto Boot Mode No No YesErase Suspend/Resume Yes No YesProgram Suspend/Resume Yes No YesOperating Temperature –40 °C to +8 5 °C –40 °C to +85 °C / +105 °C –40 °C  to +85 °C / +105 °CTable 1.  FL Generations Comparison (Continued)\nParameter FL-K FL-P FL-S \nNotes\n1. 256B program page option only for 128-Mb and 256-Mb density F L-S devices.\n2. FL-P column indicates FL129P MIO SPI device (for 128-Mb densi ty).\n3. 64 kB sector erase option only for 128-Mb/256-Mb density FL-P  and FL-S devices.\n4. FL-K family devices can erase  4-kB sectors in groups of 32 kB  or 64 kB.\n5. Refer to individual datasheets for further details.\nDocument Number: 001-98284 Rev. *R Page 6 of 136S25FL512S\n1.2.2.6 New Features\nThe FL-S family introduces seve ral new features to SPI category  memories:\n■Extended address for access  to higher memory density.\n■AutoBoot for simpler access to  boot code following power up.\n■Enhanced High Performance read c ommands using mode bits to elim inate the overhead of SIO instructions when repeating the\nsame type of read command.\n■Multiple options for initial read latency (number of dummy cycl es) for faster initial access time or higher clock rate read co mmands.\n■DDR read commands for SIO, DIO, and QIO.\n■Automatic ECC for enhanced data integrity.\n■Advanced Sector Protection for individually controlling the pro tection of each sector. This is very similar to the Advanced Se ctor\nProtection feature found in sev eral other Cypress parallel inte rface NOR memo ry families.\n1.3 Glossary\nCommandAll information transferred between the host system and memory during one period while CS# is low.\nThis includes the instruction (sometimes called an operation co de or opcode) and any required\naddress, mode bits, l atency cycles, or data.\nDDP\n(Dual Die Package)Two die stacked within the same package to increase the memory capacity of a single package.\nOften also referred to as a Multi-Chip Package (MCP).\nDDR\n(Double Data Rate)When input and outpu t are latched on every edge of SCK.\nECCECC Unit = 16 byte aligned and length data groups in the main F lash array and OTP array, each of\nwhich has its own hidden ECC sy ndrome to enable  error correctio n on each group.\nFlash The name for a type of Electrical Erase Programmable Read Only  Memory (EEPROM) that erases\nlarge blocks of memory bits in pa rallel, making the erase opera tion much faster than early EEPROM.\nHigh  A signal voltage level ≥ VIH or a logic level repres enting a binary one (1).\nInstructionThe 8 bit code indicating the function to be performed by a com mand (sometimes called an\noperation code or opcode). The in struction is always the first 8 bits transferred from host system to\nthe memory in any command.\nLow A signal voltage level \uf0a3 VIL or a logic level repres enting a binary zero (0).\nLSb\n(Least Significant Bit)Generally the right most bit, wit h the lowest order of magnitud e value, within a group of bits of a\nregister or data value.\nMSb\n(Most Significant Bit)Generally the left most bit, wit h the highest order of magnitud e value, within a group of bits of a\nregister or data value.\nLSB\n(Least Significant Byte)The right most byte, wi thin a group of bytes.\nMSB\n(Most Significant Byte)The left most bit, wit hin a group of bytes.\nNonvolatile No power is needed to maintai n data stored in the memory.\nOPN\n(Ordering Part Number)The alphanumeric string specifying the memory device type, dens ity, package, factory nonvolatile\nconfiguration, etc. used to select the desired device.\nPage 512 bytes aligned and l ength group of data.\nPCB Printed Circuit Board.\nRegister Bit References  Are in the format: Register_nam e[bit_number] or Register_name[ bit_range_MSb: bit_range_LSb].\nSDR\n(Single Data Rate)When input is latched on the ri sing edge and out put on the fall ing edge of SCK.\nDocument Number: 001-98284 Rev. *R Page 7 of 136S25FL512S\n1.4 Other Resources\n1.4.1 Cypress Flash Memory Roadmap\nwww.cypress.com/product-roadmaps /cypress-flash-memory-roadmap\n1.4.2 Links to Software\nwww.cypress.com/software-and-d rivers-cypress-flash-memory\n1.4.3 Links to Application Notes\nwww.cypress.com/cypressappnotesSector Erase unit size 256 KB.\nWriteAn operation that changes data within volatile or nonvolatile r egisters bits or nonvolatile flash\nmemory. When changing nonvolatile  data, an erase and reprogramm ing of any unchanged\nnonvolatile data is done, as par t of the operation, such that t he nonvolatile data is modified by the\nwrite operation, in the same way  that volatile data is modified  –  a s  a  s i n g l e  o p e r a t i o n .  T h e\nnonvolatile data appears to the host system to be updated by th e single write command, without the\nneed for separate commands for e rase and reprogram of adjacent,  but unaffected data.\nDocument Number: 001-98284 Rev. *R Page 8 of 136S25FL512S\nHardware Interface\nSerial Peripheral Interface with  Multiple Input / Output (SPI-M IO)\nMany memory devices connect to t heir host system with separate parallel control, address, and d ata signals that require a larg e \nnumber of signal connections and larger package size. The large  number of connections increase power consumption due to so man y \nsignals switching and  the larger package  increases cost. \nThe S25FL512S device reduces the number of signals for connecti on to the host system by serial ly transferring all control, add ress, \nand data information ove r 4 to 6 signals. Th is reduces the cost  of the memory package, reduces s ignal switching power, and eit her \nreduces the host connection count or frees host connectors for use in providing other features.\nThe S25FL512S device uses  the industry standard  single bit Serial Peripheral Int erface (SPI) and also supports optional extension \ncommands for two bit (Dual) and four bit (Quad) wide serial tra nsfers. This multiple width inter face is called SPI Multi-I/O o r SPI-MIO.\n2. Signal Descriptions\n2.1 Input/Output Summary\nTable 2.  Signal List\nSignal Name Type Description\nRESET# InputHardware Reset:  Low = device resets and returns  to standby state, ready to rec eive a \ncommand. The signal has an intern al pull-up resistor and may be  left unconnected in the host \nsystem if not used.\nSCK Input Serial Clock.\nCS# Input Chip Select.\nSI / IO0 I/O Serial Input  for single bit data commands or IO0 for Dual or Quad commands.\nSO / IO1 I/O Serial Output  for single bit data commands.  IO1 for Dual or Quad commands.\nWP# / IO2 I/OWrite Protect  when not in Quad mode.  IO2 in Quad mode. T he signal has an int ernal pull-up \nresistor and may  be left unconne cted in the host  system if not used for Quad commands.\nHOLD# / IO3 I/OHold  (pause) serial transfer in si ngle bit or Dual data commands. I O3 in Quad-I/O mode. The \nsignal has an internal pull-up resistor and may be left unconne cted in the host system if not used \nfor Quad commands.\nVCC Supply Core Power Supply.\nVIO Supply Versatile I/O Power Supply.\nVSS Supply Ground.\nNC UnusedNot Connected.  No device internal signal is co nnected to the package connecto r nor is there \nany future plan to use the connector for a signal. The connecti on may safely be us ed for routing \nspace for a signal on a Printed Circuit Board (PCB). However, a ny signal connected to an NC \nmust not have voltag e levels higher than VIO. \nRFU ReservedReserved for Future Use.  No device internal signal is c urrently connected to the packag e \nconnector but there is potential future use of the connector fo r a signal. It is recommended to not \nuse RFU connectors for PCB rou ting channels so t hat the PCB may  take advantage of future \nenhanced features in comp atible footprint devices.\nDNU ReservedDo Not Use.  A device internal signal may be connected to the package conne ctor. The \nconnection may be used by Cypress for test or other purposes an d is not intended for connection \nto any host system signal. Any DNU signal related function will  be inactive when the signal is at \nVIL. The signal has an internal pull-down resistor and may be left  unconnected in the host system \nor may be tied to VSS. Do not use these connections for  PCB signal routing channels.  Do not \nconnect any host system si gnal to this connection. \nDocument Number: 001-98284 Rev. *R Page 9 of 136S25FL512S\n2.2 Address and Data Configuration\nTraditional SPI single bit wide commands (Single or SIO) send i nformation from the host to the memory only on the SI signal. D ata \nmay be sent back to the host seri ally on the Seri al Output (SO)  signal.\nDual or Quad Output commands send information from the host to the memory only on the SI signal. Data will be returned to the host \nas a sequence of bit pairs on IO0 and IO1 or four bit (nibble) groups on IO0, IO1, IO2, and IO3. \nDual or Quad Input/Output (I/O) c ommands send information from the host to the memory as bit pairs on IO0 and IO1 or four bit \n(nibble) groups on IO0, IO1, IO2 , and IO3. Data is returned to the host similarly as bit pairs on IO0 and IO1 or four bit (nib ble) groups \non IO0, IO1, IO2, and IO3.\n2.3 RESET#\nThe RESET# input provides a hardwa re method of res etting the de vice to standby sta te, ready for receiving a command. When \nRESET# is driven  to logic low (VIL) for at least a period of tRP, the device:\n■terminates any oper ation in progress,\n■tristates all outputs,\n■resets the volatile bits in t he Configuration Register,\n■resets the volatile bits in the Status Registers,\n■resets the Bank Addre ss Register to zero,\n■loads the Program Bu ffer with all ones,\n■reloads all internal configurati on information necessary to bri ng the device to standby mode,\n■and resets the internal Contro l Unit to standby state.\nRESET# causes the same initialization proce ss as is performed w hen power comes up and requires tPU time.\nRESET# may be asserted low at any  time. To ensure data integrit y any operation that was interrupted by a hardware reset should  be \nreinitiated once the device is  ready to accept a command sequen ce.\nWhen RESET# is first  asserted Low, the device draws ICC1 (50 MHz value) during tPU. If RESET# continues to be held at VSS the \ndevice draws CMOS standby current (ISB).\nRESET# has an inte rnal pull-up resistor and may be le ft unconne cted in the host sys tem if not used.\nThe RESET# input is not availabl e on all packages options. When  not available the RESET# input of the device is tied to the in active \nstate, inside the package.\n2.4 Serial Clock (SCK)\nThis input signal provides the syn chronization re ference for th e SPI interface. Instructions, addresses, or data input are lat ched on \nthe rising edge of the SCK signal . Data output changes after th e falling edge of SCK, in SDR commands, and after every edge in  DDR \ncommands.\n2.5 Chip Select (CS#)\nThe chip select signal indicates when a command for the device is in process and the other signals are relevant for the memory  device. \nWhen the CS# signal is at the logic high st ate, the device is n ot selected and all input signa ls are ignored and all output si gnals are \nhigh impedance. Unless an internal Program, Erase or Write Regi sters (WRR) embedded operation i s in progress, the device will be \nin the Standby Power mode. Driving  the CS# input to logic low s tate enables the device, placing it in the Active Power mode. A fter \nPower-up, a falling edge on CS# is required prior to the start of any command.\n2.6 Serial Input (SI) / I/O0\nThis input signal is used to trans fer data serially into the de vice. It receives instructions, a ddresses, and data to be progr ammed. \nValues are latched on the risi ng edge of serial SCK clock signa l.\nSI becomes I/O0 - an input and o utput during Dual and Quad comm ands for receiving instructio ns, addresses, and data to be \nprogrammed (values latched on rising edge of serial SCK clock s ignal) as well as shifting out data (on the falling edge of SCK , in SDR \ncommands, and on every edge of SCK, in DDR commands).\nDocument Number: 001-98284 Rev. *R Page 10 of 136S25FL512S\n2.7 Serial Output (SO) / I/O1\nThis output signal is used to transfer data serially out of the  device. Data is shifted out on the falling edge of the serial SCK clock signal.\nSO becomes IO1 - an input and output during Dual and Quad comma nds for receiving addresses, and data to be programmed (values \nlatched on rising edge of serial SCK clock signal) as well as s hifting out data (on the falling edge of SCK, in SDR commands, and on \nevery edge of SCK, in DDR commands).\n2.8 Write Protect (WP#) / I/O2\nWhen WP# is driven Low (VIL), during a WRR command and while the Status Register Write Dis able (SRWD) bit of the Status Register \nis set to a 1, it is not possible to write to the Status and Co nfiguration Registers. This pr events any alteration of the Bloc k Protect (BP2, \nBP1, BP0) and TBPROT bits of the Status Register. As a conseque nce, all the data bytes in the memory area  that are pr otected b y \nthe Block Protect and TBPROT bit s, are also hard ware protected against data modificat ion if WP# is Low during a WRR command.\nThe WP# function is not availabl e when the Quad mode is enabled  (CR[1]=1). The WP# function is replaced by IO2 for input and \noutput during Quad mode for receiving addresses, and data to be  programmed (values are latched on rising edge of the SCK signa l) \nas well as shifting out data ( on the falling edge  of SCK, in SD R commands, and on every edg e of SCK, in DDR commands).\nWP# has an internal pull-up resi stor; when unconnected, WP# is at VIH and may be left unc onnected in the host system i f not used \nfor Quad mode.\n2.9 Hold (HOLD#) / I/O3\nThe Hold (HOLD#) signal is used to pause any serial communicati ons with the device without deselecting the device or stopping the \nserial clock.\nTo enter the Hold condition, the d evice must be selected by dri ving the CS# input to the logic low state. It is recommended th at the \nuser keep the CS# input low state during the entire duration of  the Hold condition. This is to ensure that the state of the in terface logic \nremains unchanged from the moment of entering the Hold conditio n. If the CS# input is driven to  the logic high state while the  device \nis in the Hold condition, the interface logic of the device wil l be reset. To restart communication with the device, it is nec essary to drive \nHOLD# to the logic high state while driving the CS# signal into  the logic low state. This prevents the device from going back into the \nHold condition.\nThe Hold condition starts on the falling edge of the Hold (HOLD #) signal, provided that this coincides with SCK being at the l ogic low \nstate. If the falling edge does not coincide with the SCK signa l being at the logic low state, t he Hold condition starts whene ver the \nSCK signal reaches the logic low state. Taking the HOLD# signal  to the logic low state does not terminate any Write, Program o r Erase \noperation that is currently in progress.\nDuring the Hold condition, SO is in high impedance and both the  SI and SCK input are Don\'t Care.\nThe Hold condition ends on the rising edge of the Hold (HOLD#) signal, provided that this coincides with the SCK signal being at the \nlogic low state. If the rising edge does not coincide with the SCK signal being at the logic low state, the Hold condition end s whenever \nthe SCK signal reaches the logic low state.\nThe HOLD# function is not available when the Quad mode is enabl ed (CR1[1] =1). The Hold function is replaced by I/O3 for input  and \noutput during Quad mode for receiving addresses, and data to be  programmed (values are latched on rising edge of the SCK signa l) \nas well as shifting out data ( on the falling edge  of SCK, in SD R commands, and on every edg e of SCK, in DDR commands).\nThe HOLD# signal has an internal  pull-up resisto r and may be le ft unconnected in the host syst em if not used for Quad mode.\nFigure 1.  HOLD Mode Operation\nCS#\nSCK\nHOLD#\nSI_or_IO_(during_input)\nSO_or_IO_(internal)\nSO_or_IO_(external)Valid Input Don\'t Care Valid Input Don\'t Care Valid Input\nAB C D E\nAB B C D EHold Condition \nStandard UseHold Condition \nNon-standard Use\nDocument Number: 001-98284 Rev. *R Page 11 of 136S25FL512S\n2.10 Core Voltage Supply (VCC)\nVCC is the voltage source for all de vice internal logic. It is the  single voltage used for all dev ice internal functions includin g read, \nprogram, and erase. T he voltage may vary from 2.7V to 3.6V.\n2.11 Versatile I/O  Power Supply (VIO)\nThe Versatile I/O (VIO) supply is the voltage source for all device input receivers a nd output drivers and allo ws the host system to set \nthe voltage levels that the dev ice tolerates on all inputs and drives on outputs (a ddress, control, and I/O signals). The VIO range is \n1.65V to VCC. VIO cannot be gr eater than VCC.\nFor example, a VIO of 1.65 V - 3.6 V allows for I/O  at the 1.8 V, 2 .5 V or 3 V le vels, driving and receiving signals to and from other \n1.8 V, 2.5 V or 3 V devices on the same data bus. VIO may be tied to VCC so that interface signals oper ate at the same voltage as the \ncore of the device. VIO is not available in all package options, when not available th e VIO supply is tied to VCC internal to the package.\nDuring the rise of power supplies the VIO supply voltage must remain l ess than or equal to the VCC supply voltage. \nThis supply is not available in all package options. For a back ward compatible with th e SO16 package, the VIO supply is tied to VCC \ninside the package; thus,  the I/O will function at VCC level.\n2.12 Supply and Signal Ground (VSS)\nVSS is the common voltage drain a nd ground reference for the devic e core, input signal receivers, and output drivers.\n2.13 Not Connected (NC)\nNo device internal signal is co nnected to the package connector  nor is there any future plan to  use the connector for a signal . The \nconnection may safely be used for routing space for a signal on  a Printed Circuit Board (PCB). However, any signal connected t o an \nNC must not have voltage levels higher than VIO. \n2.14 Reserved for Future Use (RFU)\nNo device internal signal is cur rently connected to the package  connector but is th ere potential future u se of the connector. It is \nrecommended to not use RFU connectors for PCB routing channels so that the PCB may take advantage of future enhanced features \nin compatible footprint devices.\n2.15 Do Not Use (DNU)\nA device internal signal may be connected to the package connec tor. The connection may be used by Cypress for test or other \npurposes and is not intended for connecti on to any host system signal. Any DNU signal related f unction will be inactive when t he \nsignal is at VIL. The signal has an internal pull-down resistor and may be left  unconnected in the host s ystem or may be tied to VSS. \nDo not use these connections fo r PCB signal routing channels. D o not connect any host system si gnal to these connections. \nDocument Number: 001-98284 Rev. *R Page 12 of 136S25FL512S\n2.16 Block Diagrams\nFigure 2.  Bus Master and Memory  Devices on the SPI Bus — Singl e Bit Data Path\nFigure 3.  Bus Master and Memory Devices on the SPI Bus — Dual Bit Data Path\nFigure 4.  Bus Master and Memory Devices on the SPI Bus — Quad Bit Data PathSPI\nBus MasterHOLD#\nWP#\nSO\nSI\nSCK\nCS2#\nCS1#\nFL-S\nFlashFL-S\nFlashHOLD#\nWP#\nSOSI\nSCK\nCS2#\nCS1#\nSPI\nBus MasterHOLD#\nWP#\nIO1\nIO0\nSCK\nCS2#\nCS1#\nFL-S\nFlashFL-S\nFlashHOLD#\nWP#\nIO0IO1\nSCK\nCS2#\nCS1#\nSPI\nBus MasterIO3\nIO2\nIO1\nIO0\nSCK\nCS2#\nCS1#\nFL-S\nFlashFL-S\nFlashIO3\nIO2\nIO0IO1\nSCK\nCS2#\nCS1#\nDocument Number: 001-98284 Rev. *R Page 13 of 136S25FL512S\n3. Signal Protocols\n3.1 SPI Clock Modes\n3.1.1 Single Data Rate (SDR)\nThe S25FL512S device can be dri ven by an embedded microcontroll er (bus master) in either of the  two following clocking modes.\n■Mode 0  with Clock Polarity (CPOL) = 0 and, Clock Phase (CPHA) = 0\n■Mode 3  with CPOL = 1 and, CPHA = 1\nFor these two modes, input data into the device is always latch ed in on the rising edge of the SCK signal and the output data is always \navailable from the falling edge of the SCK clock signal.\nThe difference between the two m odes is the clock polarity when  the bus master is in standby mo de and not trans ferring any dat a.\n■SCK will stay at logic low state with CPOL = 0, CPHA = 0\n■SCK will stay at logic high st ate with CPOL = 1, CPHA = 1\nFigure 5.  SPI SDR Modes Supported\nTiming diagrams throughout the remainder of the document are ge nerally shown as both mode 0 and 3 by showing SCK as both high \nand low at the fall of CS#. In s ome cases a timing diagram may show only mode 0 with SCK low at  the fall of CS#. In such a cas e, \nmode 3 timing simply means clock is high at the fall of CS# so no SCK rising edge set  up or hold time to the falling edge of C S# is \nneeded for mode 3.\nSCK cycles are measured (counted) from one falling edge of SCK to the next falling edge of SCK. In mode 0 the beginning of the  first \nSCK cycle in a command is measured from the falling edge of CS#  to the first falling edge of SCK because SCK is already low at  the \nbeginning of a command.\n3.1.2 Double Data Rate (DDR)\nMode 0 and Mode 3 are also supported for DDR commands. In DDR c ommands, the instruction bits are always latched on the rising \nedge of clock, the same as in S DR commands. However, the addres s and input data that f ollow the instructi on are latched on bot h \nthe rising and falling edges of SCK. The first address bit is l atched on the first rising edge of SCK following the falling ed ge at the end \nof the last instruction bit. The first bit of output data is dr iven on the falling edge at the  end of the last access latency (dummy) cycle.\nSCK cycles are measured (counted) in the same way as in SDR com mands, from one falling edge of SCK to the next falling edge of  \nSCK. In mode 0 th e beginning of th e first SCK cycle in a comman d is measured from the falling edge of CS# to the first falling  edge \nof SCK because SCK is already lo w at the beginning of a command .\nFigure 6.  SPI DDR Modes SupportedCPOL=0_CPHA=0_SCK\nCPOL=1_CPHA=1_SCK\nCS#\nSI\nSOMSB\nMSB\nCPOL=0_CPHA=0_SCK\nCPOL=1_CPHA=1_SCK\nCS#\nTransfer_Phase\nSI\nSOInst. 7 Inst. 0 A31 A0\nDLP7D0 D1Dummy / DLP Address Mode Instruction\nA30 M7 M6 M0\nDLP0Read\nData\nDocument Number: 001-98284 Rev. *R Page 14 of 136S25FL512S\n3.2 Command Protocol\nAll communication between the ho st system and S25FL512S memory device is in the form of units called commands.\nAll commands begin with an instruction that selects the type of  information transfer or device operation to be performed. Comm ands \nmay also have an address, instruc tion modifier, latency period,  data transfer to the memory, or data transf er from the memory.  All \ninstruction, address,  and data information is transferred seria lly between the host system and me mory device.\nAll instructions are  transferred from hos t to memory as a singl e bit serial sequence on the SI signal.\nSingle bit wide commands may pro vide an address or data sent on ly on the SI signal. Data may be sent back to the host serially  on \nthe SO signal.\nDual or Quad Output commands provide an address sent to the mem ory only on the SI signal. Data will be returned to the host as  a \nsequence of bit pairs on I/O0 and I/O1 or four bit (nibble) gro ups on I/O0, I/O1, I/O2, and I/O3. \nDual or Quad Input/Output (I/O) c ommands provide an address sen t from the host as bit pairs on I/O0 and I/O1 or, four-bit (nib ble) \ngroups on I/O0, I/O1, I/O2, and I/O3. Data is returned to the h ost similarly as bit pairs on I/O0 and I/O1 or, four bit (nibbl e) groups on \nI/O0, I/O1, I/O2, and I/O3.\nCommands are structured as follows:\n■Each command begins with CS# going low and ends with CS# return ing high. The memory device is selected by the host driving\nthe Chip Select (CS#) sign al low throughout a command. \n■The serial clock (SCK) marks th e transfer of each bit or group of bits between the host and memory.\n■Each command begins with an 8-bit (byte) instruction. The instr uction is always presented only as a single bit serial sequence  on\nthe Serial Input (SI) signal with one bit transferred to the me mory device on each SCK rising edge. The instruction selects th e type\nof information transfer or devi ce operation to be performed.\n■The instruction may be stand alone or may be followed by addres s bits to select a location with in one of several address space s in\nthe device. The instruction dete rmines the address space used. The address may be either a 24-bit or a 32-bit byte boundary,\naddress. The address transfers oc cur on SCK rising edge, in SDR  commands, or on every SC K edge, in DDR commands.\n■The width of all transfers follo wing the instruction are determ ined by the instruction sent. Fo llowing transfers may continue to be\nsingle bit serial on only the SI or Serial Output (SO) signals,  they may be done in 2-bit groups per (dual) transfer on the I/ O0 and\nI/O1 signals, or they may be d one in 4-bit groups per (quad) tr ansfer on the I/O0-I/O3 signal s. Within the dual or quad groups  the\nleast significant bit is on I/O0. More significant bits are pla ced in significance order on each higher numbered I/O signal. S ingle bits\nor parallel bit groups are transferred in most to least signifi cant bit order.\n■Some instructions send an instruction modifier called mode bits , following the address, to indicate that the next command will  be of\nthe same type with an implied, rather than an explicit, instruc tion. The next command thus does not provide an instruction byt e, only\na new address and mode bits. This reduces the time needed to se nd each command when the same command type is repeated in\na sequence of commands. The mode bit transfers occur on SCK ris ing edge, in SDR commands, or on every SCK edge, in DDR\ncommands.\n■The address or mode bits may be followed by write data to be st ored in the memory device or by a read latency period before re ad\ndata is returned to the host. \n■Write data bit transfers occur o n SCK rising edge, in SDR comma nds, or on every SCK e dge, in DDR commands.\n■SCK continues to toggle during any read access latency period. The latency may be zero to sever al SCK cycles (also referred to\nas dummy cycles). At the end of  the read latency cycles, the fi rst read data bits are driven fr om the outputs on SCK falling e dge at\nthe end of the last r ead latency cycle. The  first read data bit s are considered transferred to the host on the following SCK r ising\nedge. Each following transfer occurs on the next SCK rising edg e, in SDR commands, or on every SCK edge, in DDR commands.\n■If the command returns read data to the host, the device contin ues sending data transfers until the host takes the CS# signal high.\nThe CS# signal can be driven high after any transfer in the rea d data sequence. This will terminate the command.\n■At the end of a command that does not return data, the host dri ves the CS# input high. The CS# signal must go high after the e ighth \nbit, of a stand a lone instruction or, of the last write data by te that is transferred. That is,  the CS# signal m ust be driven high when \nthe number o f clock cycles after CS# s ignal was dri ven low is a n exact multiple of e ight cycles. If the CS # signal does not go  high \nexactly at the eight SCK cycle bou ndary of the instruction or w rite data, the command is re jected and not executed. \n■All instruction, address, and mode bits are shifted into the de vice with the Most Significant B its (MSb) first. The data bits are shifted \nin and out of the device MSb firs t. All data is transferred in byte units with the lowest address byte sent first. Following b ytes of data \nare sent in lowest to highest byte address order i.e. the byte address increments.\n■All attempts to read the flash memory arra y during a program, e rase, or a write cycle (embedded operations) are ignored. The \nembedded operation will continue to execute without any affect.  A very limited set of commands are accepted during an embedded  \noperation. These are discussed in the individual command descri ptions.\nDocument Number: 001-98284 Rev. *R Page 15 of 136S25FL512S\n■Depending on the command, the tim e for execution varies. A comm and to read status information  from an executin g command is \navailable to determine when the command completes execution and  whether the command was successful.\n3.2.1 Command Sequence Examples\nFigure 7.  Stand Alone Instruction Command\nFigure 8.  Single Bit Wide Input Command\nFigure 9.  Single Bit Wide Output Command\nFigure 10.  Single Bit Wide  I/O Command without Latency\nFigure 11.  Single Bit Wid e I/O Command with LatencyCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Data\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data 2\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n7654321076543210  \nInstruction Address Data 1 Data 2\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n76543210  \nInstruction Dummy Cycles Data 1 Address\nDocument Number: 001-98284 Rev. *R Page 16 of 136S25FL512S\nFigure 12.  Dual Output Command\nFigure 13.  Quad Output Command without Latency\nFigure 14.  Dual I/O Command\nFigure 15.  Quad I/O Command\nFigure 16.  DDR Fast Read with EHPLC = 00bCS#\nSCK\nIO0\nIO1\nPhase765432103028260 64206420\n3129271 75317531\nInstruction 6 Dummy Data 1 Data 2 Address\nCS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                               \n7654321031 1040404040404\n51515151515\n62626262626\n73737373737\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nCS#\nSCK\nIO0\nIO1\nPhase \n                                                     \n7654321030  20 64206420  \n31  31 75317531  \nInstruction Address Dummy Data 1 Data 2\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                     \n7654321028  404 40404040  \n29  515 51515151  \n30  626 62626262  \n31  737 73737373  \nInstruction Address Mode Dummy D1 D2 D3 D4\nCS#\nSCK\nSI\nSO\nPhase \n                                               \n7 6 5 4 3 2 1 03130 076543210  \n7654321076543210\nInstruction Address Mode Dummy Data 1 Data 2\nDocument Number: 001-98284 Rev. *R Page 17 of 136S25FL512S\nFigure 17.  DDR Dual I/O Read  with EHPLC = 01b and DLP\nFigure 18.  DDR Quad I/O Read\nAdditional sequence diagrams, sp ecific to each co mmand, are pro vided in Section 9. Commands on page 62 .CS#\nSCK\nIO0\nIO1\nPhase \n                                        \n7 6 5 4 3 2 1 0 3028 06420 7  6 5  4 321  0 64206 \n3129 17531 7  6 5  4 321  0 75317 \nInstruction Mode Dum DLP Data 1 Address\nCS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                             \n76543210282420161284040 765432104040\n292521171395151 765432105151\n3026221814106262 765432106262\n3127231915117373 765432107373\nInstruction Address Dummy DLP D1D2 Mode\nDocument Number: 001-98284 Rev. *R Page 18 of 136S25FL512S\n3.3 Interface States\nThis section describes the input and output signal levels as re lated to the SPI interface behavior.\nTable 3.  Interface States Summary\nInterface State VCC VIO RESET# SCK CS#HOLD# /\nI/O3WP# / z\nI/O2SO / \nI/O1SI / \nI/O0\nPower-Off < VCC (low) \uf0a3VCC XX X X X Z X\nLow Power \nHardware Data \nProtection<VCC (cut-off) \uf0a3VCC XX X X X Z X\nPower-On (Cold) Reset ≥ VCC (min)≥VIO (min) \n≤VCCXX X X X Z X\nHardware (Warm) Reset ≥ VCC (min)≥VIO (min) \n≤VCCHL X X X X Z X\nInterface Standby ≥ VCC (min)≥VIO (min) \n≤VCCHH X HH X X Z X\nInstruction Cycle ≥ VCC (min)≥VIO (min) \n≤VCCHH HT HL HH HV Z HV\nHold Cycle ≥ VCC (min)≥VIO (min) \n≤VCCHH HV or HT HL HL X X X\nSingle Input Cycle\nHost to Memory Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HH X Z HV\nSingle Latency (Dummy) \nCycle≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HH X Z X\nSingle Output Cycle\nMemory to Host Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HH X MV X\nDual Input Cycle\nHost to Memory Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HH X HV HV\nDual Latency (Dummy) \nCycle≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HH X X X\nDual Output Cycle\nMemory to Host Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HH X MV MV\nQPP Address Input \nCycleHost to Memory Transfer≥V\nCC (min)≥VIO (min) \n≤VCCHH HT HL X X X HV\nQuad Input Cycle\nHost to Memory Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HV HV HV HV\nQuad Latency (Dummy) \nCycle≥VCC (min)≥VIO (min) \n≤VCCHH HT HL X X X X\nQuad Output Cycle\nMemory to Host Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL MV MV MV MV\nDDR Single Input Cycle\nHost to Memory Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL X X X HV\nDDR Dual Input Cycle\nHost to Memory Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL X X HV HV\nDDR Quad Input Cycle\nHost to Memory Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL HV HV HV HV\nDDR Latency (Dummy) \nCycle≥VCC (min)≥VIO (min) \n≤VCCHH HT HL MV or Z MV or ZMV or \nZMV or \nZ\nDDR Single Output \nCycleMemory to Host Transfer≥V\nCC (min)≥VIO (min) \n≤VCCHH HT HL Z Z MV X\nDocument Number: 001-98284 Rev. *R Page 19 of 136S25FL512S\nLegend:\nZ = no driver - floating signal\nHL = Host driving VIL\nHH = Host driving VIH\nHV = either HL or HHX = HL or HH or Z\nHT = Toggling between HL and HH\nML = Memory driving V\nIL\nMH = Memory driving VIH\nMV = either ML or MH\n3.3.1 Power-Off\nWhen the core supply voltage is at or below the VCC (low) voltage, the device is considered to be powered off. The device does not\nreact to external signals, and is prevented fro m performing any  program or er ase operation. \n3.3.2 Low Power Hardware Data Protection\nWhen VCC is less than VCC (cut-off) the memory device wi ll ignore commands to ensure tha t program and erase o perations can not\nstart when the core supply volta ge is out of the operating rang e.\n3.3.3 Power-On (Cold) Reset\nWhen the core voltage supply remains at or below the VCC (low) voltage for \uf0b3 tPD time, then rises to \uf0b3 VCC (Minimum)  the device will\nbegin its Power-On Reset (POR) p rocess. POR continues until the  end of tPU. During tPU the device does not react to external input\nsignals nor drive any outputs. Following the end of tPU the device transitions to the Interface Standby state and can accept\ncommands. For additional information on POR, see Section 5.3.1 Power-On (Cold) Reset on page 30 .\n3.3.4 Hardware (Warm) Reset\nSome of the device package options provide a RESET# input. When  RESET# is driven low for tRP time the device starts the\nhardware reset process. The process continues for tRPH time. Following the end of both tRPH and the reset hold time following the\nrise of RESET# (tRH) the device transitions to the Interface Standby state and can  accept commands. For additional information on\nhardware reset, see Section 28 POR followed by Hardware Reset on page 30 .\n3.3.5 Interface Standby\nWhen CS# is high the SPI interface is in standby state. Inputs other than RESET# are ignored. T he interface waits for the begi nning\nof a new command. The next interfa ce state is Instruction Cycle  when CS# goes low to begin a new command. \nWhile in interface standby state the memory device draws standb y current (ISB) if no embedded algorithm is in progress. If an\nembedded algorithm is in progress, the related current is drawn  until the end of the algorithm when the entire device returns to\nstandby current draw.DDR Dual Output Cycle\nMemory to Host Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL Z Z MV MV\nDDR Quad Output Cycle\nMemory to Host Transfer≥VCC (min)≥VIO (min) \n≤VCCHH HT HL MV MV MV MVTable 3.  Interface States Summary (Continued)\nInterface State VCC VIO RESET# SCK CS#HOLD# /\nI/O3WP# / z\nI/O2SO / \nI/O1SI / \nI/O0\nDocument Number: 001-98284 Rev. *R Page 20 of 136S25FL512S\n3.3.6 Instruction Cycle\nWhen the host drives the MSb of an instruction and CS# goes low , on the next rising edge of SCK the device captures the MSb of\nthe instruction that begins the new command. On each following rising edge of SCK the device captures the next lower significa nce\nbit of the 8 bit instruction. The host keeps RESET# high, CS# l ow, HOLD# high, and drives Writ e Protect (WP#) signal as needed  for\nthe instruction. However, WP# is  only relevant d uring instructi on cycles of a WRR command a nd is otherwise ignored.\nEach instruction selects the address space that is operated on and the transfer format used during the remainder of the comman d.\nThe transfer format may be Single, Dual output, Quad output, Du al I/O, Quad I/O, DDR Single I/O, DDR Dual I/O, or DDR Quad I/O .\nThe expected next interface stat e depends on the instruction re ceived.\nSome commands are stand alone, needing no address or data trans fer to or from the memory. The host returns CS# high after the\nrising edge of SCK for  the eighth bit of the instruction in suc h commands. The next interface s tate in this case is Interface Standby.\n3.3.7 Hold\nWhen Quad mode is not enabled (CR[1]=0) the HOLD# / I/O3 signal  is used as the HOLD# input. The host keeps RESET# high,\nHOLD# low, SCK may be at a valid level or continue toggling, an d CS# is low. When HOLD# is low a command is paused, as though\nSCK were held low. S I / I/O0 and SO / I/O1 ignor e the input level w hen acting as inputs and are high impedance when acting as\noutputs during hold state. Wheth er these signals are input or o utput depends on the command and the point in the command\nsequence when HOLD# is asserted low.\nWhen HOLD# returns high the next state is the sam e state the in terface was in just before HOLD# was asserted low. \nWhen Quad mode is enabl ed the HOLD# / I/O3 s ignal is used as I/ O3. \nDuring DDR commands the HOLD# and WP# inputs are ignored.\n3.3.8 Single Input Cycle - Host to Memory Transfer\nSeveral commands transfer information after the instruction on the single serial input (SI) signal from host to the memory dev ice. The\ndual output, and quad output commands send address to the memor y using only SI but return read data using the I/O signals. The\nhost keeps RESET# high, CS# low, HOLD# high, and drives SI as n eeded for the command. The memory does not drive the Serial\nOutput (SO) signal.\nThe expected next interface st ate depends on the instruction. S ome instructions continue sending address or data to the memory\nusing additional Single Input C ycles. Others may transition to Single Latency, or directly to Single, Dual, or Quad Output.\n3.3.9 Single Laten cy (Dummy) Cycle\nRead commands may have zero to se veral latency cycles during wh ich read data is read from the main flash memory array before\ntransfer to the host. The number of latency cycles are determin ed by the Latency Code in the conf iguration register (CR[7:6]).  During\nthe latency cycles, the host keeps RESET# high, CS# low, and HO LD# high. The Write Protect (WP#) signal is ignored. The host\nmay drive the SI signal during t hese cycles or the host may lea ve SI floating. The memory does n ot use any data driven on SI / I /O0\nor other I/O signals during the latency cycles. In dual or quad  read commands, the host must st op driving the I/O signals on t he\nfalling edge at the end of the last latency cycle. It is recomm ended that the host stop driving I/O signals during latency cyc les so that\nthere is sufficient time for the host drivers to turn off befor e the memory begins to drive a t the end of the latency cycles. This prevents\ndriver conflict between host and memory when the signal directi on changes. The memory does not drive the Serial Output (SO) or\nI/O signals during the latency cycles.\nThe next interface state depends  on the command structure, that  is the number of latency cycles, and whether the read is singl e,\ndual, or quad width.\n3.3.10 Single Output Cycle - Memory to Host Transfer\nSeveral commands transfer information back to the host on the s ingle Serial Output (SO) signa l. The host keeps RESET# high, CS #\nlow, and HOLD# high. The Write Protect (WP#) signal is ignored.  The memory ignores the Serial Input (SI) signal. The memory\ndrives SO with data.\nThe next interface state continue s to be Single Output Cycle un til the host returns CS# to  high ending the command.\nDocument Number: 001-98284 Rev. *R Page 21 of 136S25FL512S\n3.3.11 Dual Input Cycle - Ho st to Memory Transfer\nThe Read Dual I/O command transfers two address or mode bits to  the memory in each cycle. The  host keeps RESET# high, CS#\nlow, HOLD# high. The Write Prote ct (WP#) signal is ignored. The  host drives address on SI / I/O0 and SO / I/O1. \nThe next interface state following the delivery of address and mode bits is a Dual Latency Cycl e if there are latency cycles n eeded or\nDual Output Cycle if no latency is required.\n3.3.12 Dual Latency (Dummy) Cycle\nRead commands may have zero to se veral latency cycles during wh ich read data is read from the main flash memory array before\ntransfer to the host. The number of latency cycles are determin ed by the Latency Code in the conf iguration register (CR[7:6]).  During\nthe latency cycles, the host keeps RESET# high, CS# low, and HO LD# high. The Write Protect (WP#) signal is ignored. The host\nmay drive the SI / I/O0 and SO / I /O1 signals during these cycles o r the host may leave SI / I/O0 an d SO / I/O1 floating. The memory\ndoes not use any data driven on SI / I/O0 and SO / I/O1 during the latency cycles. The host must st op driving SI / I/O0 and SO / I/O1\non the falling ed ge at the end of  the last lat ency cycle. It is  recommended that the host stop dr iving them during all latency  cycles so\nthat there is sufficient time fo r the host drivers to turn off before the memory begins to drive at the end of the latency cyc les. This\nprevents driver conflict between host and memory when the signa l direction changes. The memory does not drive the SI / I/O0 and\nSO / I/O1 signals during the latency cycles.\nThe next interface s tate following the last laten cy cycle is a Dual Output Cycle.\n3.3.13 Dual Output Cycle - Memory to Host Transfer\nThe Read Dual Output and Read Dual  I/O return data to the host two bits in each cycle. The host  keeps RESET# high, CS# low, an d\nHOLD# high. The Write Protect (WP#) signal is ignored. The memo ry drives data on the SI / I/O0 and SO / I/O1 signals during the\ndual output cycles.\nThe next interface state continue s to be Dual Out put Cycle unti l the host returns CS# to high ending the command.\n3.3.14 QPP or QOR Address Input Cycle\nThe Quad Page Program and Quad Output Read commands send addres s to the memory only on I/O0. The other I/O signals are\nignored because the device must be in Quad mode for these comma nds thus the Hold and Write Protec t features are not active. Th e\nhost keeps RESET# high, CS # low, and d rives I/O0.\nFor QPP the next interface sta te following the delivery of addr ess is the Quad Input Cycle.\nFor QOR the next interface state following address is a Quad La tency Cycle if there are latency cycles needed or Quad Output\nCycle if no late ncy is required.\n3.3.15 Quad Input Cycle -  Host to Memory Transfer\nThe Quad I/O Read command transfers four address or mode bits t o the memory in each cycle. T he Quad Page Program command\ntransfers four data b its to the memory in  each cycle.  The host keeps RESET# high, CS# low, and drive s the I/O signals.\nFor Quad I/O Read the next interface state following the delive ry of address and mode bits is a Quad Latency Cycle if there ar e\nlatency cycles needed or Quad Output Cycle if no latency is req uired. For Quad Page Program the host returns CS# high followin g\nthe delivery of d ata to be programmed and the interface returns  to standby state.\n3.3.16 Quad Latency (Dummy) Cycle\nRead commands may have zero to se veral latency cycles during wh ich read data is read from the main flash memory array before\ntransfer to the host. The number of latency cycles are determin ed by the Latency Code in the conf iguration register (CR[7:6]).  During\nthe latency cycles, the host kee ps RESET# high, CS# low. The ho st may drive the I/O signals duri ng these cycles or the host ma y\nleave the I/O floating. The memo ry does not use any data driven  on I/O during the latency cycl es. The host must stop driving t he I/O\nsignals on the falling edge at the end of the last latency cycl e. It is recommended that the host stop driving them during all  latency\ncycles so that there is sufficient time for the host drivers to  turn off before the memory begins to drive at the end of the l atency\ncycles. This prevent s driver conflict between host and memory w hen the signal direction changes . The memory does not drive the  \nI/O signals during the latency cycles.\nThe next interface s tate following the last laten cy cycle is a Quad Output Cycle.\nDocument Number: 001-98284 Rev. *R Page 22 of 136S25FL512S\n3.3.17 Quad Output Cycle - Memory to Host Transfer\nThe Quad Output Read and Quad I/O Read return data to the host four bits in each cycle. The host keeps RESET# high, and CS#\nlow. The memory drives data on I/ O0-I/O3 signals during the Qua d output cycles.\nThe next interface state conti nues to be Quad Output Cycle unti l the host returns CS# to  high ending the command.\n3.3.18 DDR Single I nput Cycle - Host to Memory Transfer\nThe DDR Fast Read command sends address, and mode bits to the m emory only on the I/O0 signal.  One bit is transferred on the\nrising edge of SCK and  one bit on the fal ling edge in each cycl e. The host keeps RESET# high, and CS# low. The other I/O signa ls\nare ignored by the memory.\nThe next interface state follo wing the delivery of address and mode bits is a D DR Latency Cycle.\n3.3.19 DDR Dual Input Cycle - Host to Memory Transfer\nThe DDR Dual I/O Read command sends address, and mode bits to t he memory only on the I/O0 and  I/O1 signals. Two bits are\ntransferred on the rising edge of SCK and two bits on the falli ng edge in each cycle. The host keeps RESET# high, and CS# low.\nThe I/O2 and I/O3 signals are ignored by the memory.\nThe next interface state follo wing the delivery of address and mode bits is a D DR Latency Cycle.\n3.3.20 DDR Quad Input  Cycle - Host to Memory Transfer\nThe DDR Quad I/O Read command sends address,  and mode bits to t he memory on all the I/O signal s. Four bits are transferred on\nthe rising edge of SCK and f our bits on the falling edge in eac h cycle. The host keeps RESET# high , and CS# low.\nThe next interface state follo wing the delivery of address and mode bits is a D DR Latency Cycle.\n3.3.21 DDR Latency Cycle\nDDR Read commands may have one t o several latency cycles during  which read data is read from the main flash memory array\nbefore transfer to the host. T he number of latency cycles are d etermined by the Latency Code in the configuration register (CR [7:6]).\nDuring the latency cycles, the host keeps RESET# high and CS# l ow. The host may not drive the I/O signals during these cycles.  So\nthat there is sufficient time fo r the host drivers to turn off before the memory begins to driv e. This prevents driver conflic t between\nhost and memory when the signal direction changes. The memory h as an option to driv e all the I/O signals with a Data Learning\nPattern (DLP) during the last 4 latency cycles. The DLP option should not be enabled when there are fewer than five latency cy cles\nso that there is at least one cycle of high impedance for turn around of the I/O signals before the memory begins driving the DLP.\nWhen there are more t han 4 cycles of latency the memory does no t drive the I/O signals until t he last four cycles of latency.\nThe next interface s tate following the last laten cy cycle is a DDR Single, Dual, or Quad Output  Cycle, depending on the instru ction.\n3.3.22 DDR Single Ou tput Cycle - Memory to Host Transfer\nThe DDR Fast Read command retu rns bits to the host only on the SO / I/O1 signal. One bit is trans ferred on the rising edge of SCK\nand one bit on the falling edge in each cycle. The host keeps R ESET# high, and CS# low. The other I/O signals are not driven b y the\nmemory.\nThe next interface state conti nues to be DDR Single Output Cycl e until the host returns CS# to high ending the command.\n3.3.23 DDR Dual Output Cycle - Memory to Host Transfer\nThe DDR Dual I/O Read command returns bits to the host only on the I/O0 and I/O1 signals. Two bit s are transferred on the risi ng\nedge of SCK and two bits on the falling edge in each cycle. The  host keeps RESET# high, and CS# low. The I/O2 and I/O3 signals\nare not driven by the memory.\nThe next interface state conti nues to be DDR Dual Output Cycle until the host returns CS# to high ending the command.\n3.3.24 DDR Quad Out put Cycle - Memory to Host Transfer\nThe DDR Quad I/O Read command returns bits to the host on all t he I/O signals. Four bits are tr ansferred on the rising edge of  SCK\nand four bits on the falling edge in each cy cle. The host keeps  RESET# high, and CS# low.\nThe next interface state conti nues to be DDR Quad Output Cycle until the host returns CS # to high ending the command.\nDocument Number: 001-98284 Rev. *R Page 23 of 136S25FL512S\n3.4 Configuration Register  Effects on the Interface\nThe configuration register bits 7 and 6 (CR1[7:6]) select the l atency code for all read commands. The latency code selects the\nnumber of mode bit a nd latency cycles for ea ch type of instruct ion.\nThe configuration register bit 1 (CR1[1]) selects whether Quad mode is enabled to ignore HOLD# and WP# and allow Quad Page\nProgram, Quad Output Read, and Quad I/O Read commands. Quad mod e must also be selected to allow Read DDR Quad I/O\ncommands.\n3.5 Data Protection\nSome basic protection against unintended changes to stored data  are provided and controlled purely by the hardware design. The se\nare described below. Other software managed protection methods are discussed in the software section ( page 44 ) of this document.\n3.5.1 Power-Up\nWhen the core supply voltage is at or below the VCC (low) voltage, the device is considered to be powered off. The device does not\nreact to external signals, and is prevented from performing any  program or erase operation. Program and erase operations conti nue\nto be prevented during the Power-on Reset (POR) because no comm and is accepted until the exit from POR to the Interface\nStandby state.\n3.5.2 Low Power\nWhen VCC is less than VCC (cut-off) the memory device will ignore commands to ensure that  program and erase operations can not\nstart when the core supply volta ge is out of the operating rang e.\n3.5.3 Clock Pulse Count\nThe device verifies that all pro gram, erase, and Write Register s (WRR) commands consist of a clock pulse count that is a multi ple of\neight before executing them. A command not having a multiple of  8 clock pulse counts is ignored and no error status is set for  the\ncommand. \nDocument Number: 001-98284 Rev. *R Page 24 of 136S25FL512S\n4. Electrical Specifications\n4.1 Absolute Maximum Ratings\n4.2 Thermal Resistance\n4.3 Operating Ranges\nOperating ranges defi ne those limits between  which the function ality of the device is guaranteed.\n4.3.1 Power Supply Voltages\nSome package options provide access to a separate input and out put buffer power supply called VIO. Packages which do not provide\nthe separate VIO connection, internally connect the device VIO to VCC. For these packages, the references to VIO are then also\nreferences to VCC.\n4.3.2 Temperature RangesTable 4.  Absolute Maximum Ratings\nStorage Temperature Plastic Packages –65°C to +150°C\nAmbient Temperature with Pow er Applied –65°C to +125°C\nVCC –0.5 V to +4.0 V\nVIO[6]–0.5 V to +4.0 V\nInput Voltage with Respect to Ground (VSS)[7]–0.5 V to +(VIO + 0.5 V)\nOutput Short Circuit Current[8]100 mA\nNotes\n6. VIO must always be less than or equal VCC + 200 mV.\n7. See Section 4.3.3 Input Signal Overshoot on page 25  for allowed maximums during signal transition. \n8. No more than one output may be shorted to ground at a time. D uration of the short circuit should not be greater than one sec ond.\n9. Stresses above those listed under Section 4 Absolute Maximum Ratings on page 24  may cause permanent damage to the device. This is a stress rat ing only; \nfunctional operation of the device at these or any other condit ions above those indicated in the operational sections of this data sheet is not implied. Exposure of the \ndevice to absolute maximum rati ng conditions for extended perio ds may affect dev ice reliability.\nTable 5.  Thermal Resistance\nParameter Description SO3016 FAB024 FAC024 Unit\nTheta JAThermal resistance \n(junction to ambient)29.6 33.6 33.6 °C/W\nVCC 2.7V to 3.6V\nVIO 1.65V to VCC +200 mV\nParameter Symbol DeviceSpec\nUnit\nMin Max\nAmbient Temperature TAIndustrial (I) –40 +85\n°CIndustrial Plus (V) –40 +105\nAutomotive, AEC-Q100 Grade 3 (A) –40 +85Automotive, AEC-Q100 Grade 2 (B) –40 +105\nAutomotive, AEC-Q100 Grade 1 (M) –40 +125\nNote\n10. Industrial Plus operating and performance parameters will be  determined by device characte rization and may vary from standa rd industrial temperature range devices \nas currently shown in this specification.\nDocument Number: 001-98284 Rev. *R Page 25 of 136S25FL512S\n4.3.3 Input Signal Overshoot\nDuring DC conditions, input or I/O signals should remain equal to or between VSS and VIO. During voltage transitions, inputs or I/Os\nmay overshoot VSS to –2.0V or overshoot to VIO +2.0V, for perio ds up to 20 ns.\nFigure 19.  Maximum Negative Overshoot Waveform\nFigure 20.  Maximum Posi tive Overshoot Waveform\n4.4 Power-Up and Power-Down\nThe device must not be selected at  power-up or power-down (that  is, CS# must follow the voltage applied on VCC) until VCC reaches\nthe correct value as follows:\n■VCC (min) at power-up, and th en for a further delay of tPU\n■VSS at power-down\nA simple pull-up resistor (generally of the order of 100 k \uf057) on Chip Select (CS#) can usually be used to insure safe and p roper\npower-up and power-down.\nThe device ignores all instructions until a time delay of tPU has elapsed after the moment that VCC rises above the minimum VCC\nthreshold. See Figure 21 . However, correct operation of  the device is not guaranteed if  VCC returns below VCC (min) during tPU. No\ncommand should be sent to t he device until the end of tPU.\nAfter power-up (tPU), the device is in Standby mode (not Deep Power Down mode), dr aws CMOS standby current (ISB), and the WEL\nbit is reset.\nDuring power-down or voltage drops below VCC (cut-off), the voltage must drop below VCC (low) for a period of tPD for the part to\ninitialize correctly on power-up. See Figure 22 . If during a voltage drop the VCC stays above VCC (cut-off) the part will stay initialized\nand will work correctly when VCC is again above VCC (min). In the event Power-on Reset (POR) did not complete corr ectly after power\nup, the assertio n of the RESET# signal wil l restart the POR pro cess.\nNormal precautions must be taken for supply rail decoupling to stabilize the VCC supply at the device. Each device in a system should\nhave the VCC rail decoupled by a suitable capacitor close to the package su pply connection (this capacitor is generally of the order\nof 0.1 µf).VIL\n- 2.0V\n20 ns20 ns 20 ns\nVIHVIO + 2.0V20 ns\n20 ns 20 ns\nDocument Number: 001-98284 Rev. *R Page 26 of 136S25FL512S\nFigure 21.  Power-Up\nFigure 22.  Power-Down and Voltage DropTable 6.  Power-Up / Power-Down Voltage and Timing\nSymbol Parameter Min Max Unit\nVCC (min) VCC (minimum operation voltage) 2.7  – V \nVCC (cut-off) VCC (Cut 0ff where re-initialization is needed) 2.4 – V \nVCC (low) VCC (low voltage for initi alization to occur) \nVCC (Low voltage for initializ ation to occur at embedded) 1.6 \n2.3  – V \ntPU VCC (min) to Read operation  – 300 µs \ntPD VCC (low) time 10.0 – µs \n(max)\n(min)VCC\ntPU Full Device Access\nTimeVCCVCC\ntPD(max)\n(min)VCC\ntPU Device Access\n     Allowed\nTimeVCCVCC\nNo Device Access Allowed\n(cut-off)VCC\n(low)VCC\nDocument Number: 001-98284 Rev. *R Page 27 of 136S25FL512S\n4.5 DC Characteristics\nApplicable within operating ranges.\n4.5.1 Active Power and Standby Power Modes\nThe device is enabled and in the Active Power mode when Chip Se lect (CS#) is Low. When CS# is high, the device is disabled, bu t\nmay still be in an Active Power mode until all program, erase, and write operations have complet ed. The device then goes into the\nStandby Power mode, and powe r consumption drops to ISB.Table 7.  DC Characteristics\nSymbol Parameter Test Conditions Min Typ[11] Max Unit\nVIL Input Low Voltage  -0.5  – 0.2 x VIO V\nVIH Input High Voltage  0.7 x VIO –  VIO+0.4 V\nVOL Output Low Voltage IOL = 1.6 mA, VCC = VCC min  – 0.15 x VIO V\nVOH Output High Voltage IOH = –0.1 mA 0.85 x VIO –  V\nILI Input Leakage \nCurrent VCC = VCC Max, VIN = VIH or VIL – – ±2 µA \nILO Output Leakage \nCurrent VCC = VCC Max, VIN = VIH or VIL – – ±2 µA \nICC1 Active Power Supply \nCurrent (READ) Serial SDR@50 MHz\nSerial SDR@133 MHz Quad SDR @ 80 MHz \nQuad SDR @104 MHz \nQuad DDR @ 66 MHz Quad DDR @80 MHz \nOutputs unconnect ed during read data \nreturn\n[12] –  –16\n33/35[13]\n50 \n61 \n75 90mA \nI\nCC2Active Power Supply \nCurrent \n(Page Program) CS# = VIO – – 100 mA \nICC3 Active Power Supply \nCurrent (WRR) CS# = VIO – – 100 mA \nICC4Active Power Supply \nCurrent (SE) CS# = VIO – – 100 mA \nICC5Active Power Supply \nCurrent (BE) CS# = VIO – – 100 mA \nISB (Industrial) Standby Current RESET#, CS# = VIO; SI, SCK = VIO or \nVSS, Industrial Temp– 70 100 µA\nISB \n(Industrial Plus)Standby Current RESET#, CS# = VIO; SI, SCK = VIO or \nVSS, Industrial Plus Temp– 70 300 µA\nNotes\n11. Typical values are at TAI = 25°C and VCC = VIO = 3V.\n12. Output switching current is not included.13. Industrial temperature range / Industrial Plus temperature r ange.\nDocument Number: 001-98284 Rev. *R Page 28 of 136S25FL512S\n5. Timing Specifications\n5.1 Key to Switching Waveforms\nFigure 23.  Waveform Element Meanings\nFigure 24.  Input, Output, and Timing Reference LevelsInput\nSymbol\nOutputValid at logic high or low High Impedance Any change permitted Logic High Logic Low\nChanging, state unknown Valid at logic high or low High Impedance Logic High Logic Low\nVIO + 0.4V\n0.7 x VIO\n0.2 x VIO\n- 0.5VTiming Reference Level0.5 x VIO 0.85 x VIO\n0.15 x VIOInput LevelsOutput Levels\nDocument Number: 001-98284 Rev. *R Page 29 of 136S25FL512S\n5.2 AC Test Conditions\nFigure 25.  Test Setup\n5.2.1 Capacitance CharacteristicsTable 8.  AC Measurement Conditions\nSymbol Parameter Min Max Unit\nCLLoad Capacitance30\n15[17]pF\nInput Rise and Fall \nTimes– 2.4 ns\nInput Pulse Voltage 0.2 x VIO to 0.8 VIO V\nInput Timing Ref Voltage 0.5 VIO V\nOutput Timing Ref \nVoltage0.5 VIO V\nNotes\n14. Output High-Z is defined as the point where data is no longe r driven.\n15. Input slew rate: 1.5 V/ns.\n16. AC characteristics tables assume clock and data signals have  the same slew rate (slope).\n17. DDR Operation.\nTable 9.  Capacitance\nParameter Test Conditions Min Max Unit\nCIN Input Capacitance (applies to SCK, CS#, RESET#) 1 MHz, TA = 25°C – 8 pF \nCOUT Output Capacitance (applies to All I/O) 1 MHz, TA = 25°C – 8 pF\nNote\n18. For more information on capac itance, please consult the IBIS  models.Device \nUnder \nTest\nCL\nDocument Number: 001-98284 Rev. *R Page 30 of 136S25FL512S\n5.3 Reset\n5.3.1 Power-On (Cold) Reset\nThe device executes a Power-On Reset (POR) process until a time  delay of tPU has elapsed after the moment  that VCC rises above\nthe minimum VCC threshold. See Figure 21 on page 26 , Table 6 on page 26 , and Table 10 on page 31 . The device must not be\nselected (CS# to go high with VIO) during power-up (tPU), i.e. no commands may be sent to  the device unt il the end of tPU. RESET#\nis ignored during POR. If RESET# is low during POR and remains low through and beyond the end of tPU, CS# must remain high\nuntil tRH after RESET# returns high. RESET# must ret urn high for greater than tRS before returning low to i nitiate a hardware reset.\nFigure 26.  Reset Low at the End of POR\nFigure 27.  Reset High at the End of POR\nFigure 28.  POR follow ed by Hardware ResetVCC\nVIO\nRESET#\nCS#If RESET# is low at tPU end\nCS# must be high at tPU endtPU\ntRH\nVCC\nVIO\nRESET#\nCS#If RESET# is high at tPU end\nCS# may stay high or go low at tPU endtPU\ntPU\nVCC\nVIO\nRESET#\nCS#tRS tPU\ntPU\nDocument Number: 001-98284 Rev. *R Page 31 of 136S25FL512S\n5.3.2 Hardware (Warm) Reset\nWhen the RESET# input transitions from VIH to VIL the device will reset register states in the same manner as po wer-on reset but,\ndoes not go through the full reset process that is performed du ring POR. The hardware reset process requires a period of tRPH to\ncomplete. If the POR process di d not complete correctly for any  reason during power-up (tPU), RESET# going low will initiate the full\nPOR process instead of the hardw are reset process and will requ ire tPU to complete the POR process.\nThe RESET# input provides a hardwa re method of res etting the fl ash memory device to standby state.\n■RESET# must be high for tRS following tPU or tRPH, before going low again to initiate a hardware reset.\n■When RESET# is driven low for at least a minimum period of time  (tRP), the device terminates any oper ation in progress, tri-states\nall outputs, and ignores all re ad/write commands  for the durati on of tRPH. The device resets the in terface to standby state.\n■If CS# is low at the  time RESET# is asserted , CS# must return h igh during tRPH before it can be asse rted low again after tRH.\n■Hardware Reset is only offered in  16-lead SOIC and BGA packages .\nFigure 29.  Hardware Reset\nTable 10.  Hardware Reset Parameters\nParameter Description Limit Time Unit\ntRS Reset Setup - Prior Reset end and R ESET# high befor e RESET# low Min 50 ns\ntRPH Reset Pulse Hold - RESET# low to CS# low Min 35 µs\ntRP RESET# Pulse Width Min 200 ns \ntRH Reset Hold - RESET# high b efore CS# low Min 50 ns \nNotes\n19. RESET# Low is optional and ignored during Power-up (tPU). If Reset# is asserted during the end of tPU, the device will remain in the reset state and tRH will determine \nwhen CS# may go Low.\n20. Sum of tRP and tRH must be equal to or greater than tRPH.RESET#\nCS#Any prior reset\ntRStRP\ntRH tRH\ntRPH tRPH\nDocument Number: 001-98284 Rev. *R Page 32 of 136S25FL512S\n5.4 SDR AC Characteristics\nTable 11.  AC Characteristi cs (Single Die Package, VIO = VCC 2.7V to 3.6V)\nSymbol Parameter Min Typ Max Unit\nFSCK, R  SCK Clock Frequency for READ and 4READ instructions DC – 50 MHz\nFSCK, C  SCK Clock Frequency for single commands as shown in Table 39 \non page 64[24] DC – 133 MHz\nFSCK, C  SCK Clock Frequency for the following dual and quad commands: \nDOR, 4DOR, QOR, 4QOR, DIOR, 4DIOR, QIOR, 4QIORDC – 104 MHz\nFSCK, QPP  SCK Clock Frequency for the QP P, 4QPP commands DC – 80 MHz\nPSCK SCK Clock Period 1/ FSCK –  \uf0a5  \ntWH, tCH Clock High Time[25]45% PSCK – – ns \ntWL, tCL Clock Low Time[25]45% PSCK – – ns \ntCRT, tCLCH  Clock Rise Time (slew rate) 0.1 – – V/ns\ntCFT, tCHCL Clock Fall Time (slew rate) 0.1 – – V/ns\ntCS CS# High Time (Read Instructions) \nCS# High Time (Program/Erase) 10 \n50 – – ns \ntCSS CS# Active Setup Time (re lative to SCK) 3 – – ns \ntCSH CS# Active Hold Time (relative to SCK) 3 – – ns \ntSU Data in Setup Time 1.5 –  3000[26]ns \ntHD Data in Hold Time 2 –  ns \ntV Clock Low to Output Valid – – 8.0[22] \n7.65[23] \n6.5[24] ns \ntHO Output Hold Time 2 –  ns \ntDIS Output Disable Time 0 – 8 ns \n tWPS WP# Setup Time 20[21] – – ns \n tWPH WP# Hold Time 100[21] – – ns \ntHLCH  HOLD# Active Setup Time (relative to SCK) 3 – – ns \ntCHHH  HOLD# Active Hold Time (relative to SCK) 3 – – ns \ntHHCH  HOLD# Non Active Setup Time (relative to SCK) 3 – – ns \ntCHHL  HOLD# Non Active Hold Time (relative to SCK) 3 – – ns \ntHZ HOLD# enable to Output Invalid – – 8 ns \ntLZ HOLD# disable to Output Valid – – 8 ns \nNotes\n21. Only applicable as a constraint for WRR instruction when SRW D is set to a 1.\n22. Full VCC range (2.7 - 3.6V) and CL = 30 pF.\n23. Regulated VCC range (3.0 - 3.6V) and CL = 30 pF.\n24. Regulated VCC range (3.0 - 3.6V) and CL = 15 pF.\n25. ±10% duty cycle is supported for frequencies \uf0a3 50 MHz.\n26. Maximum value only applies during Program/Erase Suspend/Resu me commands.\nDocument Number: 001-98284 Rev. *R Page 33 of 136S25FL512S\nTable 12.  AC Characteristi cs (Single Die Package, VIO 1.65V to 2.7V, VCC 2.7V to 3.6V)\nSymbol Parameter Min Typ Max Unit\nFSCK, R  SCK Clock Frequency for READ, 4READ instructions DC – 50 MHz\nFSCK, C  SCK Clock Frequency for all others[29]DC – 66 MHz\nPSCK SCK Clock Period 1/ FSCK –  \uf0a5  \ntWH, tCH Clock High Time[30]45% PSCK – – ns \ntWL, tCL Clock Low Time[30]45% PSCK – – ns \ntCRT, tCLCH  Clock Rise Time (slew rate) 0.1 – – V/ns\ntCFT, tCHCL Clock Fall Time (slew rate) 0.1 – – V/ns\ntCS CS# High Time (Read Instructions) \nCS# High Time (Program/Erase) 10 \n50 – – ns \ntCSS CS# Active Setup Time (relative to SCK) 10 – – ns \ntCSH CS# Active Hold Time (re lative to SCK) 3 – – ns \ntSU Data in Setup Time 5 – 3000[31]ns \ntHD Data in Hold Time 4 –  ns \ntV Clock Low to Output Valid – – 14.5[28] \n12.0[29] ns \ntHO Output Hold Time 2 – ns \ntDIS Output Disable Time 0 – 14 ns \n tWPS WP# Setup Time 20[27] – – ns \n tWPH WP# Hold Time 100[27] – – ns \ntHLCH  HOLD# Active Setup Time ( relative to SCK) 5 – – ns \ntCHHH  HOLD# Active Hold Time (relative to SCK) 5 – – ns \ntHHCH  HOLD# Non Active Setup Time  (relative to SCK) 5 – – ns \ntCHHL  HOLD# Non Active Hold Time (relative to SCK) 5 – – ns \ntHZ HOLD# enable to Outpu t Invalid – – 14 ns \ntLZ HOLD# disable to Output Valid – – 14 ns \nNotes\n27. Only applicable as a constraint for WRR instruction when SRW D is set to a 1.\n28. CL = 30 pF.\n29. CL = 15 pF.30. ±10% duty cycle is supported for frequencies \uf0a3 50 MHz.\n31. Maximum value only applies during Program/Erase Suspend/Resu me commands.\nDocument Number: 001-98284 Rev. *R Page 34 of 136S25FL512S\n5.4.1 Clock Timing\nFigure 30.  Clock Timing\n5.4.2 Input / Output Timing\nFigure 31.  SPI Single Bit Input Timing\nFigure 32.  SPI Single Bit Output TimingVIL maxVIH mintCH\ntCRT tCFTtCL\nVIO / 2PSCK\nCS#\nSCK\nSI\nSOMSB IN LSB INtCSS tCSStCSH tCSHtCS\ntSU\ntHD\nCS#\nSCK\nSI\nSO MSB OUT LSB OUTtCS\ntHO tV tDIS tLZ\nDocument Number: 001-98284 Rev. *R Page 35 of 136S25FL512S\nFigure 33.  SPI SDR MIO Timing\nFigure 34.  Hold Timing\nFigure 35.  WP# Input TimingCS#\nSCK\nIO MSB IN LSB IN MSB OUT . LSB OUTtCSH\ntCSStCSS\ntSU\ntHD tLZ tHOtCS\ntDIS tV\nCS#\nSCK\nHOLD#\nSI_or_IO_(during_input)\nSO_or_IO_(during_output) A B B C DEtHZ tHZ tLZ tLZtCHHL tCHHLtHLCHtHLCH tCHHH\ntCHHH tHHCH\nHold Condition \nStandard UseHold Condition \nNon-standard Use\nCS#\nWP#\nSCK\nSI\nSO\nPhase7654321076543210\nWRR Instruction Input DatatWPS tWPH\nDocument Number: 001-98284 Rev. *R Page 36 of 136S25FL512S\n5.5 DDR AC Characteristics\n5.5.1 DDR Input Timing\nFigure 36.  SPI DDR Input TimingTable 13.  AC Character istics DDR Operation\nSymbol Parameter 66 MHz 80 MHz\nUnit \nMin Typ Max Min Typ Max \nFSCK, R  SCK Clock Frequency for DDR READ \ninstruction DC – 66 DC – 80 MHz\nPSCK, R  SCK Clock Period for DDR READ \ninstruction 15 – \uf0a5 12.5 – \uf0a5 ns \ntWH, tCH Clock High Time 45% PSCK – – 45% PSCK – – ns \ntWL, tCLClock Low Time 45% PSCK – – 45% PSCK – – ns \ntCS CS# High Time (Read Instructions) 10 – – 10 – – ns \ntCSS CS# Active Setup Time (relative to SCK) 3 – – 3 – – ns \ntCSH CS# Active Hold Time (relative to SCK) 3 – – 3 – – ns \ntSU I/O in Setup Time 2 –  3000[33]1.5 –  3000[33]ns \ntHD I/O in Hold Time 2 –  1.5 –  ns \ntV Clock Low to Output Valid –  6.5[32]–  6.5[32] ns \ntHO Output Hold Time 1.5 –  1.5 –  ns \ntDIS Output Disable Time  – 8  – 8 ns \ntLZ Clock to Output Low Impedance 0 – 8 0 – 8 ns \ntIO_SKEW  First Output to last Output data valid \ntime – – 600 – – 600 ps \nNotes\n32. Regulated VCC range (3.0 - 3.6V) and CL =15 pF.\n33. Maximum value only applies during Program/Erase Suspend/Resu me commands.\nCS#\nSCK\nSI_or_IO\nSOMSB IN LSB INtCSS tCSStCSH tCSHtCS\ntSU\ntSUtHD\ntHD\nDocument Number: 001-98284 Rev. *R Page 37 of 136S25FL512S\n5.5.2 DDR Output Timing\nFigure 37.  SPI DDR Output Timing\n5.5.3 DDR Data Valid  Timing Using DLP\nFigure 38.  SPI DDR Data Valid Window\nThe minimum data valid window (tDV) and tV minimum can be calculated as follows:\ntDV = Minimum half cl ock cycle time (tCLH)[34]- tOTT[36] - tIO_SKEW[35]\ntV _min = tHO + tIO_SKEW + tOTT\nExample: \n80 MHz clock frequency = 12.5 n s clock period, DDR operations a nd duty cycle o f 45% or higher\ntCLH = 0.45 x PSCK = 0.45 x 12.5 ns = 5.625 ns\nBus impedance of 45 ohm and capac itance of 22 pf, with timing r eference of 0.75VCC, the rise time from 0 to 1 or fall time 1 to 0 is\n1.4[39] x RC time constant (Tau)[38] = 1.4 x 0.99 ns = 1.39 ns\ntOTT = rise time or fal l time = 1.39 ns.\nData Valid Window\ntDV = tCLH - tIO_SKEW - tOTT = 5.625 ns - 600 ps - 1.39 ns = 3.635 ns\ntV Minimum\ntV _min = tHO + tIO_SKEW + tOTT = 1.0 ns + 600 ps + 1 .39 ns = 2.99 nsCS#\nSCK\nSI\nSO_or_IO MSB LSBtCS\ntHO tV tV tDIS tLZ\nNotes\n34. tCLH is the shorter duration of tCL or tCH.\n35. tIO_SKEW  is the maximum difference (delta) between the minimum and maxi mum tV (output valid) across all IO signals.\n36. tOTT is the maximum Output Transition Time from one valid data valu e to the next valid data value on each IO. tOTT is dependent on system l evel considerations \nincluding:\na. Memory device output impedance (drive strength).\nb. System level parasitics on the IOs (primarily bus capacitance ).\nc. Host memory controller input VIH and VIL levels at which 0 to 1 and 1 to 0 transitions are recognized.\nd. tOTT is not a specification tested b y Cypress, it is system depende nt and must be deriv ed by the system designer based on the abov e considerations.\n37. tDV is the data valid window.\n38. Tau = R (Output Impedance) x C (Load capacitance).\n39. Multiplier of Tau time for voltage to rise to 75% of VCC.SCK\nIO Slow\nIO Fast\nIO_validSlow D1 S. Slow D2\nFast D1 Fast D2\nD1 D2tVtIO_SKEW\ntDVtCLtCH\ntOTTpSCK\ntHOtV_mintV\nDocument Number: 001-98284 Rev. *R Page 38 of 136S25FL512S\n6. Physical Interface\n6.1 SOIC 16-Lead Package\n6.1.1 SOIC 16 Conne ction Diagram\nFigure 39.  16-Lead SOIC Package, Top ViewTable 14.  Model Specific Connections\nVIO / RFUVersatile I/O or RFU — Some devi ce models bond this connector t o the device I/O power supply, \nother models bond the device I/O s upply to Vcc within the packa ge leaving this package connector \nunconnected.\nRESET# / RFURESET# or RFU — Some device mode ls bond this con nector to the d evice RESET# signal, other \nmodels bond the RESET# signal to V cc within the package leaving  this package connector \nunconnected.\nNote\n40. Refer to Table 2 on page 8  for signal descriptions.\n1\n2\n3\n416\n15\n14\n13HOLD#/IO3\nVCC\nRESET#/RFU\nDNU NCVIO/RFUSI/IO0SCK\n5\n6\n7\n812\n11\n10\n9 WP#/IO2VSSDNUDNU DNU\nRFU\nCS#\nSO/IO1\nDocument Number: 001-98284 Rev. *R Page 39 of 136S25FL512S\n6.1.2 SOIC 16 Physical Diagram\nFigure 40.  SOIC 16-Lead, 300-mil Body Width (SO3016)\n0.33  C\n0.25  M D CA - B0.20  C A-B\n0.10  C\n0.10  C0.10  C D\n2X\n2.  DIMENSIONING AND TOLERANCING PER ASME Y14.5M - 1994.\n3.  DIMENSION D DOES NOT INCLUDE MOLD FLASH, PROTRUSIONS OR GATE BURRS. \n END. DIMENSION E1 DOES NOT INCLUDE INTERLEAD FLASH OR PROTRUSION.\nINTERLEAD FLASH OR PROTRUSION SHALL NOT EXCEED 0.25 mm PER SIDE. 1.  ALL DIMENSIONS ARE IN MILLIMETERS.NOTES: \nD AND E1 DIMENSIONS ARE DETERMINED AT DATUM H.\n FLASH, BUT INCLUSIVE OF ANY MISMATCH BETWEEN THE TOP AND BOTTOM OFEXCLUSIVE OF MOLD FLASH, TIE BAR BURRS, GATE BURRS AND INTERLEAD4.  THE PACKAGE TOP MAY BE SMALLER THAN THE PACKAGE BOTTOM. DIMENSIONS\n5.  DATUMS A AND B TO BE DETERMINED AT DATUM H.\n6.  "N" IS THE MAXIMUM NUMBER OF TERMINAL POSITIONS FOR THE SPECIFIED \n7.  THE DIMENSIONS APPLY TO THE FLAT SECTION OF THE LEAD BETWEEN 0.10 TO\n   MAXIMUM MATERIAL CONDITION. THE DAMBAR CANNOT BE LOCATED ON THE8.  DIMENSION "b" DOES NOT INCLUDE DAMBAR PROTRUSION. ALLOWABLE DAMBAR\n  LOWER RADIUS OF THE LEAD FOOT.\nIDENTIFIER MUST BE LOCATED WITHIN THE INDEX AREA INDICATED.9.  THIS CHAMFER FEATURE IS OPTIONAL. IF IT IS NOT PRESENT, THEN A PIN 1 \n10.  LEAD COPLANARITY SHALL BE WITHIN 0.10 mm AS MEASURED FROM THE \nh\n0D\nL2\nNeA1\nb\nc\nE\nE1A\n0.7510.30 BSC\n1.27 BSC0.30\n10.30 BSC0.33\n0°0.25160.20\n7.50 BSC0.10\n0.31\n8°0.512.65 2.35\nA2 2.05 2.55\nb1 0.27 0.48\n0.30 0.20 c1\nL10.40 L 1.27\n1.40 REF\n0.25 BSC\n0 5° 15°\n0 0°1\n2 -DIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n-----------\n-MOLD FLASH, PROTRUSIONS OR GATE BURRS SHALL NOT EXCEED 0.15 mm PER\n D AND E1 ARE DETERMINED AT THE OUTMOST EXTREMES OF THE PLASTIC BODY \n 0.25 mm FROM THE LEAD TIP.\n PROTRUSION SHALL BE 0.10 mm TOTAL IN EXCESS OF THE "b" DIMENSION AT THE PLASTIC BODY.\nPACKAGE LENGTH.\nSEATING PLANE.\n002-15547 *A\nDocument Number: 001-98284 Rev. *R Page 40 of 136S25FL512S\n6.2 FAB024 24-Ball BGA Package\n6.2.1 Connection Diagram\nFigure 41.  24-Ball BGA, 5 x 5 B all Footprint (FAB024), Top Vie w[41]\nNote\n41. Signal connections are in the same relative positions as FAC 024 BGA, allowing a single PCB footprint to use either package.3 25 4 1\nNC NC NC RESET#/\nRFU\nB\nD\nEA\nCVSS SCK NC VCC DNU\nRFU CS# NC WP#/IO2 DNU\nSI/IO0 SO/IO1 NC HOLD#/IO3 DNU\nNC NC NC VIO/RFU NC\nDocument Number: 001-98284 Rev. *R Page 41 of 136S25FL512S\n6.2.2 FAB024 Physical Diagram\nFigure 42.  Ball Grid Array 24-Ball 6x8 mm (FAB024)\nMETALLIZED MARK INDENTATION OR OTHER MEANS.A1 CORNER TO BE IDENTIFIED BY CHAMFER, LASER OR INK MARK,N IS THE NUMBER OF POPULATED SOLDER BALL POSITIONS FOR MATRIX SIZE MD X ME.\nWHEN THERE IS AN EVEN NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" = eD/2 ANDWHEN THERE IS AN ODD NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" OR "SE" = 0.POSITION OF THE CENTER SOLDER BALL IN THE OUTER ROW. "SD" AND "SE" ARE MEASURED WITH RESPECT TO DATUMS A AND B AND DEFINE THESYMBOL "ME" IS THE BALL MATRIX SIZE IN THE "E" DIRECTION. SYMBOL "MD" IS THE BALL MATRIX SIZE IN THE "D" DIRECTION. e REPRESENTS THE SOLDER BALL GRID PITCH.\nDIMENSION "b" IS MEASURED AT THE MAXIMUM BALL DIAMETER IN A PLANE     BALL POSITION DESIGNATION PER JEP95, SECTION 3, SPP-020.    DIMENSIONING AND TOLERANCING METHODS PER ASME Y14.5M-1994.\n"+" INDICATES THE THEORETICAL CENTER OF DEPOPULATED BALLS. 8.\n9.7    ALL DIMENSIONS ARE IN MILLIMETERS.\nPARALLEL TO DATUM C.5.\n64.3.2.1.NOTES:\nSDb\neDeEME\nN\n0.35\n0.00 BSC1.00 BSC1.00 BSC0.40245\n0.45D1\nMDE1EDA\nA1 0.20-\n4.00 BSC\n4.00 BSC\n56.00 BSC8.00 BSC-- 1.20\n-\nSE 0.00 BSCDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n"SE" = eE/2.\n002-15534 **\nDocument Number: 001-98284 Rev. *R Page 42 of 136S25FL512S\n6.3 FAC024 24-Ball BGA Package\n6.3.1 Connection Diagram\nFigure 43.  24-Ball BGA, 4 x 6 B all Footprint (FAC024), Top Vie w[42]\nNote\n42. Signal connections are in the same relative positions as FAC 024 BGA, allowing a single PCB footprint to use either package.3 24 1\nNC NC RESET#/\nRFU\nB\nD\nEA\nCVSS SCK VCC DNU\nRFU CS# WP#/IO2 DNU\nSI/IO0 SO/IO1 HOLD#/IO3 DNU\nNC NC VIO/RFU NCNC\nNC NC NC NCF\nDocument Number: 001-98284 Rev. *R Page 43 of 136S25FL512S\n6.3.2 FAC024 Physical Diagram\nFigure 44.  Ball Grid Array 24-Ball 6x8 mm (FAC024)\n6.3.3 Special Handling Inst ructions for FBGA Packages\nFlash memory devices in BGA packages may be damaged if exposed to ultrasonic cleaning methods. The package and/or data\nintegrity may be compr omised if the package body is exposed to temperatures above 150°C for prolonged periods of time.METALLIZED MARK INDENTATION OR OTHER MEANS.A1 CORNER TO BE IDENTIFIED BY CHAMFER, LASER OR INK MARK,N IS THE NUMBER OF POPULATED SOLDER BALL POSITIONS FOR MATRIX SIZE MD X ME.\nWHEN THERE IS AN EVEN NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" = eD/2 ANDWHEN THERE IS AN ODD NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" OR "SE" = 0.POSITION OF THE CENTER SOLDER BALL IN THE OUTER ROW. "SD" AND "SE" ARE MEASURED WITH RESPECT TO DATUMS A AND B AND DEFINE THESYMBOL "ME" IS THE BALL MATRIX SIZE IN THE "E" DIRECTION. SYMBOL "MD" IS THE BALL MATRIX SIZE IN THE "D" DIRECTION. e    REPRESENTS THE SOLDER BALL GRID PITCH.\nDIMENSION "b" IS MEASURED AT THE MAXIMUM BALL DIAMETER IN A PLANE     BALL POSITION DESIGNATION PER JEP95, SECTION 3, SPP-020.    DIMENSIONING AND TOLERANCING METHODS PER ASME Y14.5M-1994.\n"+" INDICATES THE THEORETICAL CENTER OF DEPOPULATED BALLS. 8.\n9.7    ALL DIMENSIONS ARE IN MILLIMETERS.\nPARALLEL TO DATUM C.5.\n64.3.2.1.NOTES:\nSDb\neDeEME\nN\n0.35\n0.50 BSC1.00 BSC1.00 BSC0.40244\n0.45D1\nMDE1EDA\nA1 0.25-\n5.00 BSC\n3.00 BSC\n66.00 BSC8.00 BSC-- 1.20\n-\nSE 0.50 BSCDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n "SE" = eE/2.\n002-15535 **\nDocument Number: 001-98284 Rev. *R Page 44 of 136S25FL512S\nSoftware Interface\nThis section discusses the features and behaviors most relevant  to host system software that int eracts with the S25FL512S memo ry\ndevice.\n7. Address Space Maps\n7.1 Overview\n7.1.1 Extended Address\nThe S25FL512S device supports 32-bit addresses to enable higher  density devices than allowed by previous generation (legacy) S PI\ndevices that supported only 24-bi t addresses. A 24-bit byte res olution address can access only 16 MB (128 Mb) of maximum densi ty.\nA 32-bit byte resolution address  allows direct addressing of up  to a 4 Gbytes (32 Gbit s) of address space.\nLegacy commands continue to support 24-bit addresses for backwa rd software compatibility. Ext ended 32-bit addresses are enable d\nin three ways:\n■Bank address register — a softw are (command) loadable internal register that supplies the high order bits of address when lega cy\n24-bit addresses are in use.\n■Extended address mode — a bank address register bit that change s all legacy commands to expect 32 bits of address supplied\nfrom the host system.\n■New commands — that pe rform both legacy and new functions, whic h expect 32-bit address.\nThe default condition at power-up and after reset, is the Bank address register loaded with zeros and the extended address mod e set\nfor 24-bit addresses. This enabl es legacy software compatible a ccess to the first 128 Mb of a device. \n7.1.2 Multiple Address Spaces\nMany commands operate on the main flash memory array. Some comm ands operate on address spaces separate from the main flash\narray. Each separate address s pace uses the full 32-bit address  but may only define a small port ion of the availa ble address s pace.\n7.2 Flash Memory Array\nThe main flash array is divided i nto erase units called sectors . The sectors are organized as uniform 256-KB sectors. \nNote  This is a condensed table that u ses a sector as a reference. T here are address ranges that are not explicitly listed. All 256 -kB\nsectors have the patt ern XXXX0000h-XXXXFFFFh.\n7.3 ID-CFI Address Space\nThe RDIDJ command (9Fh) reads info rmation from a separate flash  memory address space for device identification (ID) and Common\nFlash Interface (CFI ) information. See Section 11.3 Device ID and Common Flash Interface (ID-CFI) Addre ss Map on page 111  for\nthe tables defining the content s of the ID-CFI address space. T he ID-CFI address space is programmed by Cypress and read-only\nfor the host system.Table 15.  S25FL512S Sector and M emory Address Map, Uniform 256 -KB Sectors\nSector Size (KB) Sector Count Sector Range Address Range (8-bit) Notes \n256 256SA00 00000000h-0003FFFFh Sector Starting Address\n—\nSector Ending Address: : \nSA255 03FC0000h-03FFFFFFh\nDocument Number: 001-98284 Rev. *R Page 45 of 136S25FL512S\n7.4 JEDEC JESD216 Serial Flash Dis coverable Parameters (SFDP) Sp ace.\nThe RSFDP command (5Ah) reads information from a separate Flash  memory address space for devic e identification, feature, and\nconfiguration information, in accord with the JEDEC JESD216B st andard for Serial Flash Discove rable Parameters. The ID-CFI\naddress space is incorporated as one of the SF DP parameters.\nSee Section 11.2 Serial Fla sh Discoverable Parameters (SFDP) Address  Map on page 108  for the table defini ng the contents of the\nSFDP address space. The SFDP add ress space is programmed by Cyp ress and is read-only  for the ho st system\n7.5 OTP Address Space\nEach S25FL512S memory device has a 1024-byte One Time Program ( OTP) address space that is separate from the main flash\narray. The OTP area is divided in to 32, individually lockable, 32-byte aligned and length regions.\nIn the 32-byte region star ting at address zero:\n■The 16 lowest address bytes are programmed by Cypress with a 12 8-bit random number. Only Cypre ss is able to program these byte s.\n■The next 4 higher address bytes (OTP Lock Bytes) are used to pr ovide one bit per OTP region to permanently protect each region\nfrom programming. The bytes are erased when shipped from Cypres s. After an OTP region is pr ogrammed, it can be locked to\nprevent further programming, by p rogramming the related protect ion bit in the OTP Lock Bytes.\n■The next higher 12 bytes of the lowest address region are Reser ved for Future Use (RFU). The bits in these RFU bytes may be\nprogrammed by the host system but  it must be understood that a future device may use those bits for protection of a larger OTP\nspace. The bytes are erased when shipped from Cypress.\nThe remaining regions are eras ed when shipped from Cypress, and  are available for pr ogramming of additional permanent data.\nRefer to Figure 45 on page 45  for a pictorial representat ion of the OTP memory space.\nThe OTP memory space  is intended for incr eased system security.  OTP values, such as the random number programmed by Cypress,\ncan be used to “mate ” a flash component with the system CPU/ASI C to prevent devic e substitution.\nThe configuration register FREEZE (CR1[0]) bit protects the ent ire OTP memory space from programming when set to 1. This allow s\ntrusted boot code to control programming of OTP regions then se t the FREEZE bit to prevent further OTP memory space programmin g\nduring the remainder of normal power-on system operation.\nFigure 45.  OTP Address Space\n32 Byte OTP Region 3 1\n32 Byte OTP Region 3 0\n32 Byte OTP Region 2 9\n.\n.\n.\n32 Byte OTP Region 3\n32 Byte OTP Region 2\n32 Byte OTP Region 1\n32 Byte OTP Region 0\n16 Byte Random Numbe r Reserve d Lock Byte sLock Bits 31 to 0...When programmed to\n“0” each lock bit \nprotects its related 32\nbyte region from any\nfurther programming\nContents of Region 0 {\nByte 0 Byte 10 Byte 1 F\n \n \nDocument Number: 001-98284 Rev. *R Page 46 of 136S25FL512S\nTable 16.  OTP Address Map\nRegion Byte Address Range (Hex) Contents Initial Delivery State (Hex)\nRegion 0000Least Significant Byte (LSB) of \nSpansion Programmed \nRandom Number\nSpansion Programmed \nRandom Number... ...\n00FMost Significant Byte (MSB) of \nSpansion Programmed \nRandom Number\n010 to 013Region Locking Bits\nByte 10 [bit 0] locks region 0 \nfrom programming when = 0\n...\nByte 13 [bit 7] l ocks region 31 \nfrom programming when = 0All bytes = FF\n014 to 01F Reserved for Futu re Use (RFU) All bytes = FF\nRegion 1 020 to 03FAvailable for User \nProgrammingAll bytes = FF\nRegion 2 040 to 05FAvailable for User \nProgrammingAll bytes = FF\n... ...Available for User \nProgrammingAll bytes = FF\nRegion 31 3E0 to 3FFAvailable for User \nProgrammingAll bytes = FF\nDocument Number: 001-98284 Rev. *R Page 47 of 136S25FL512S\n7.6 Registers\nRegisters are small groups of memory cells used to configure ho w the S25FL512-S memory device operates or to report the status\nof device operations. The registers are accessed by specific co mmands. The commands (and hexadecimal instruction codes) used\nfor each register are noted in each register description. The i ndividual register bits may be v olatile, nonvolatile, or One Ti me Program-\nmable (OTP). The type for each b it is noted in each register de scription. The default state shown  for each bit refers to the s tate after\npower-on reset, hardware reset, or software reset if the bit is  volatile. If the bit is nonvol atile or OTP, the default state is the value of\nthe bit when the device is shipped from Cypress. Nonvolatile bi ts have the same cycling (erase and program) endurance as the m ain\nflash array.\nTable 17.  Register Descriptions\nRegister Abbreviation Type Bit Location\nStatus Register 1 SR1[7:0] Volatile 7:0Configuration Register  1 CR1[7:0] Volatile 7:0\nStatus Register 2 SR2[7:0] RFU 7:0AutoBoot Register ABRD [31:0] Nonvolatile 31:0\nBank Address Register BRAC[7:0] Volatile 7:0ECC Status Register ECCSR[7:0] Volatile 7:0ASP Register ASPR[15:1] OTP 15:1ASP Register ASPR[0] RFU 0Password Register PASS[63: 0] Nonvolatile OTP 63:0\nPPB Lock Register PPBL[7:1] Volatile 7:1\nPPB Lock Register PPBL[0]Volatile \nRead Only0\nPPB Access Register PPBAR[7:0] Nonvolatile 7:0\nDYB Access Register D YBAR[7:0] Volatile 7:0\nSPI DDR Data Learning Regist ers NVDLR[7:0] Nonvolatile 7:0\nSPI DDR Data Learning Regist ers VDLR[7:0] Volatile 7:0\nDocument Number: 001-98284 Rev. *R Page 48 of 136S25FL512S\n7.6.1 Status Register 1 (SR1)\nRelated Commands: Read Status Register (RDSR1 05h), Write Regis ters (WRR 01h), Write Enable (WREN 06h), Write Disable\n(WRDI 04h), Clear Status Register (CLSR 30h). \nThe Status Register contains both status  and control bits:\nStatus Register Write Disable (SRWD) SR1[7] : Places the device in the Hardware Protected mode when this bi t is set to 1 and the\nWP# input is driven low. In this mode, the SRWD, BP2, BP1, and BP0 bits of the Status Register become read-only bits and the W rite\nRegisters (WRR) command is no lo nger accepted for execution. If  WP# is high the SRWD bit and BP bits may be changed by the\nWRR command. If SRWD is 0, WP# has no effect and the SRWD bit a nd BP bits may be changed by the WRR command. The SRWD\nbit has the same non volatile endurance as  the main flash array.\nProgram Error (P_ERR) SR1[6] : The Program Error Bit is used as a program operation success or failure indication. When the\nProgram Error bit is set to a 1 it indicates that there was an error in the last program operation. This bit will also be set when the user\nattempts to program within a pro tected main memory sector or lo cked OTP region. When the Program Error bit is set to a 1 this bit\ncan be reset to 0 with the Clear  Status Register  (CLSR) command . This is a read-only bit and is not affected by the WRR comman d.\nErase Error (E_ERR) SR1[5] : The Erase Error Bit is used as an Erase operation success or failure indication. When the Erase Error\nbit is set to a 1 it indicates t hat there was an error in the l ast erase operation. This bit will also be set when the user at tempts to erase\nan individual protected main memory sector. The Bulk Erase comm and will not set E_ERR if a protected sector is found during th e\ncommand execution. When the Erase Error bit is set to a 1 this bit can be reset to 0 with the Clear Status Register (CLSR) com mand.\nThis is a read-only bit and is not affected by the WRR command.\nBlock Protection (BP2, BP1, BP0) SR1[4:2] : These bits define the main flas h array area to be software-pr otected against program\nand erase commands. The BP bits are either volatile or nonvolat ile, depending on the state of the BP nonvolatile bit (BPNV) in  the\nconfiguration register. When one or more of the BP bits is set to 1, the relevant memory area is protected against program and  erase.\nThe Bulk Erase (BE) command can be executed only when the BP bi ts are cleared to 0’s. See Block Protection on page 57  for a\ndescription of how the BP bit values select the memory array ar ea protected. The BP bits have t he same nonvolatile endurance a s\nthe main flash array.Table 18.  Status Register-1 (SR1) \nBits Field \nName Function Type Default State Description \n7 SRWD Status Register \nWrite Disable Nonvolatile 0 1 = Locks state of SRWD , BP, and configuration \nregister bits when WP# is low by ignoring WRR \ncommand\n0 = No protection, e ven when WP# is low\n6 P_ERR Programming \nError Occurred Volatile, Read only 0 1 = Error occurred.\n0 = No Error\n5 E_ERR Erase Error \nOccurred Volatile, Read only 0 1 = Error occurred \n0 = No Error \n4 BP2 \nBlock \nProtection Volatile if CR1[3]=1, \nNonvolatile if \nCR1[3]=0 1 if CR1[3]=1, \n0 when \nshipped from \nCypress Protects selected range of sectors (Block) from \nProgram or Erase 3 BP1 \n2 BP0 \n1 WEL Write Enable \nLatch Volatile 0 1 = Device a ccepts Write Regist ers (WRR), program \nor erase commands \n0 = Device ignores Write R egisters (WRR), program \nor erase commands \nThis bit is not affected by WRR, only WREN and \nWRDI commands affect this bit\n0 WIP Write in \nProgress Volatile, Read only 0 1 = Device Busy, a Write Registers (WRR), program, \nerase or other operat ion is in progress \n0 = Ready Device is in stand by mode and can accept \ncommands \nDocument Number: 001-98284 Rev. *R Page 49 of 136S25FL512S\nWrite Enable Latch (WEL) SR1[1] : The WEL bit must be set to 1 to enable program, write, or era se operations as a means to provide\nprotection against inadvertent changes to memory or register va lues. The Write Enable (WREN) c ommand execution sets the Write\nEnable Latch to a 1 to allow any program, erase, or write comma nds to execute afterwards. The Write Disable (WRDI) command can\nbe used to set the Write Enable Latch to a 0 to prevent all pro gram, erase, and write commands from execution. The WEL bit is cleared\nto 0 at the end of any successful program, write, or erase oper ation. Following a failed operation the WEL bit may remain set and\nshould be cleared with a WRDI command following a CLSR command.  After a power down/power up sequence, hardware reset, or\nsoftware reset, the Write Enable Latch is set to a 0 The WRR co mmand does not affect this bit.\nWrite In Progress (WIP) SR1[0] : Indicates whether the device is performing a program, write, erase operation, or any other operation,\nduring which a new operation c ommand will be ignored. When the bit is set to a 1 the device is  busy performing an operation. W hile\nWIP is 1, only Read Status (RDSR1 or RDSR2), Erase Suspend (ERS P), Program Suspend (PGSP), Clear Status Register (CLSR),\nand Software Reset (RESET) commands may be accepted. ERSP and P GSP will only be accepted if memory array erase or program\noperations are in progress. The status register E_ERR and P_ERR  bits are updated while WIP = 1. When P_ERR or E_ERR bits are\nset to one, the WIP bit will remain set to one indicating the d evice remains busy and unable to receive new operation commands . A\nClear Status Register (CLSR) command must be received to return  the device to standby mode. When the WIP bit is cleared to 0 n o\noperation is in progress. This is a read-only bit.\n7.6.2 Configuration Register 1 (CR1)\nRelated Commands: Read Configur ation Register (RDCR 35h), Write  Registers (WRR 01h). The Config uration Register bits can be\nchanged using the WRR command with sixteen input cycles.\nThe configuration regi ster controls certai n interface and data protection functions.\nLatency Code (LC) CR1[7:6]:  The Latency Code selects the number of mode and dummy cycles b etween the end of address and\nthe start of read da ta output for all read commands. \nSome read commands send mode bits following the address to indi cate that the next command will be of the same type with an\nimplied, rather than an explicit, instruction. The next command  thus does not provide an instruction byte, only a new address and\nmode bits. This reduces the time needed to send each command wh en the same command type is repeated in a sequence of\ncommands. \nDummy cycles provide a dditional latency tha t is needed to compl ete the initial read access of t he flash array before data can be\nreturned to the  host system. Some read co mmands require additio nal latency cycles as the SC K frequency is increased.\nThe following latency code tables provide different latency set tings that are configured by Cypress. The High Performance vers us the\nEnhanced High Performance settings  are selected by the ordering  part number. Table 19.  Configuration Register (CR1)\nBits Field Name Function Type Default \nState Description \n7 LC1 \nLatency Code Nonvolatile 0 Selects number of initial read \nlatency cycles\nSee Latency Code Tables 6 LC0 0 \n5 TBPROT Configures Start of Block Protection OTP 0 1 = BP starts at  bottom (Low \naddress)\n0 = BP starts at top (High address) \n4 DNU DNU  DNU 0 Do not Use \n3 BPNV Configures BP2-0 in Status Register OTP 0 1 = Volatile \n0 = Nonvolatile \n2 RFU RFU RFU 0 Reserved for Future Use \n1 QUAD Puts the device into Quad I/O \noperation Nonvolatile 0 1 = Quad \n0 = Dual or Serial \n0 FREEZE Lock current state of BP2-0 bits in \nStatus Register, TBPROT in \nConfiguration Re gister, and OTP \nregions Volatile 0 1 = Block Prot ection and OTP \nlocked0 = Block Prot ection and OTP \nun-locked \nDocument Number: 001-98284 Rev. *R Page 50 of 136S25FL512S\nWhere mode or latency (dummy) cycles are shown in the tables as  a dash, that read command is not supported at the frequency\nshown. Read is supported only up to 50 MHz but the same latency  value is assigned in each latency code and the command may be\nused when the device is operated at \uf0a3 50 MHz with any latency code set ting. Similarly, only the Fast  Read command is supported\nup to 133 MHz but the same 10b latency code is used for Fast Re ad up to 133 MHz and for the other dual and quad read commands\nup to 104 MHz. It is not necessary to change the latency code f rom a higher to a lower frequency when operating at lower frequ encies\nwhere a particular command is supported. The latency code value s for a higher frequency can be used for accesses at lower\nfrequencies.\nThe High Performance settings p rovide latency options that are the same or faster than alternat e source SPI memories. These se ttings\nprovide mode bits only for the Quad I/O Read command. \nThe Enhanced High Performance settings similarly provide latenc y options the same or faster than additional alternate source S PI\nmemories and adds mode bits for the Dual I/O Read, DDR Fast Rea d, and DDR \nDual I/O Read commands.\nRead DDR Data Learning Pattern (DLP) bits may be placed within the dummy cycles immediately befor e the start of read data, if there\nare 5 or more dummy cycles. See Section 9.4 Read Memory  Array Commands on page 78  for more information on the DLP.\nTable 20.  Latency Codes for SDR High Performance \nFreq. \n(MHz)LCRead Fast Read Read Dual Out Read Quad Out Dual I/O Read Quad I/O Read \n(03h, 13h) (0Bh, 0Ch) (3Bh, 3Ch)  (6Bh, 6Ch) (BBh, BCh) (EBh, ECh)\nMode Dummy Mode Dummy Mode Dummy Mode Dummy Mode Dummy Mode Dummy\n≤  5 0 1 1 0000000004 2 1≤  8 0 0 0 –  –  08080804 2 4≤  9 0 0 1 –  –  08080805 2 4\n≤ 1 0 4 1 0 –  –  08080806 2 5≤133 10 – – 0 8 – – – – – – – – \nTable 21.  Latency Codes for DDR High Performance \nFreq. \n(MHz)LCDDR Fast Read DDR Dual I/O Read Read DDR Quad I/O\n(0Dh, 0Eh) (BDh, BEh) (EDh, EEh)\nMode Dummy Mode Dummy Mode Dummy\n≤  5 0 1 1 040413≤  6 6 0 0 050616≤  6 6 0 1 060717≤  6 6 1 0 070818\nTable 22.  Latency Codes for S DR Enhanced Hig h Performance \nFreq. \n(MHz)LCRead Fast Read Read Dual Out Read Quad Out Dual I/O Read Quad I/O Read \n(03h, 13h) (0Bh, 0Ch) (3Bh, 3Ch)  (6Bh, 6Ch) (BBh, BCh) (EBh, ECh)\nMode Dummy Mode Dummy Mode Dummy Mode Dummy Mode Dummy Mode Dummy\n≤  5 0 1 1 00000000 4 0 2 1≤ 80 00 – – 0 8 0 8 0 8 4 0 2 4≤ 90 01 – – 0 8 0 8 0 8 4 1 2 4\n≤104 10 – – 0 8 0 8 0 8 4 2 2 5\n≤133 10 – – 0 8 – – – – – – – – \nDocument Number: 001-98284 Rev. *R Page 51 of 136S25FL512S\nTop or Bottom Protection (TBPROT) CR1[5]:  This bit defines the operation of the Block Protection bits BP 2, BP1, and BP0 in the\nStatus Register. As described in the status register section, t he BP2-0 bits allow the user to optionally protect a portion of  the array,\nranging from 1/64, 1/4, 1/2, etc., up to the entire array. When  TBPROT is set to a 0 the Block Protection is defined to start from the\ntop (maximum address) of the array. When TBPROT is set to a 1 t he Block Protection is defined to start from the bottom (zero a ddress)\nof the array. The TBPROT bit is OTP and set to a 0 when shipped  from Cypress. If TBPROT is programmed to 1, an attempt to chan ge\nit back to 0 will fail and set t he Program Error bit (P_ERR in SR1[6]). \nThe desired state of TBPROT must be selected during the initial  configuration of the device duri ng system manufacture; before the\nfirst program or erase operation on the main flash array. TBPRO T must not be programmed after pr ogramming or erasing is done i n\nthe main flash array. \nCR1[4]:  Reserved for Future Use\nBlock Protection Nonvolatile (BPNV) CR1[3] : The BPNV bit defines whether or not the BP2-0 bits in the Sta tus Register are volatile\nor nonvolatile. The BPNV bit is OTP and cleared to a0 with the BP bits cleared to 000 when shipped from Cypress. When BPNV is\nset to a 0 the BP2-0 bits in t he Status Register  are nonvolatil e. When BPNV is set to a 1 the BP2-0 bits in the Status Registe r are\nvolatile and will be reset to binary 111 after POR, hardware re set, or command reset. If BPNV is programmed to 1, an attempt t o\nchange it back to 0 will fail an d set the Program Error bit (P_ ERR in SR1[6]). \nCR1[2] : Reserved for Future Use.\nQuad Data Width (QUAD) CR1[1] : When set to 1, this bit switc hes the data width of the device  to 4 bit - Quad mode. That is, WP#\nbecomes I/O2 and HOLD# becomes I/O3. The WP# and HOLD# inputs a re not monitored for their normal functions and are internally\nset to high (inactive). The co mmands for Serial, Dual Output, a nd Dual I/O Read still function normally but, there is no need to drive\nWP# and Hold# inputs for those commands when switching between commands using different data path widths. The QUAD bit must\nbe set to one when using Read Quad Out, Quad I/O Read, Read DDR  Quad I/O, and Quad Page Program commands. The QUAD\nbit is nonvolatile.\nFreeze Protection (FREEZE) CR1[0] : The Freeze Bit, when set to 1,  locks the current state of the  BP2-0 bits in Status Register, the\nTBPROT and TBPARM bits in the Configuration Register, and the O TP address space. This prevents writing, programming, or erasin g\nthese areas. As long as the FREEZE bit remains cleared to logic  0 the other bits of the Configur ation Register, including FREE ZE,\nare writable, and the OTP address space is programmable. Once t he FREEZE bit has been written to a logic 1 it can only be clea red\nto a logic 0 by a power-off to power-on cycle or a hardware res et. Software reset will not affec t the state of the FREEZE bit.  The\nFREEZE bit is volatile and the default state of FREEZE after po wer-on is 0. The FREEZE bit can be set in parallel with updatin g other\nvalues in CR1 by a single WRR command. Table 23.  Latency Codes for DDR Enhanced High Performance\nFreq. \n(MHz)LCDDR Fast Read DDR Dual I/O Read Read DDR Quad I/O\n(0Dh, 0Eh) (BDh, BEh) (EDh, EEh)\nMode Dummy Mode Dummy Mode Dummy\n≤  5 0 1 1 412213≤  6 6 0 0 422416≤  6 6 0 1 442517≤  6 6 1 0 452618≤  8 0 0 0 422416≤  8 0 0 1 442517≤  8 0 1 0 452618\nNote\n43. When using DDR I/O commands with the Data Learning Pattern ( DLP) enabled, a Latency Code that provides 5 or more dummy cycl es should be selected to allow \n1 cycle of additional time for the host to stop driving before the memory starts driving the 4 cycle DLP. It is recommended to  use LC 10 for DDR Fast Read, LC 01 for \nDDR Dual I/O Read, and LC 00 for DDR Quad I/O Read, if the Data  Learning Pattern (DLP ) for DDR is used. \nDocument Number: 001-98284 Rev. *R Page 52 of 136S25FL512S\n7.6.3 Status Register 2 (SR2)\nRelated Commands: Read Stat us Register 2 (RDSR2 07h).\nErase Suspend (ES) SR2[1] : The Erase Suspend bit is used to determine when the device is  in Erase Suspend mode. This is a\nstatus bit that canno t be written. When Erase Suspend bit is se t to 1, the device is in erase suspend mode. When Erase Suspend  bit\nis cleared to 0, the device is not in erase suspend mode. Refer  to Erase Suspend and Resume Commands (75h) (7Ah) for details\nabout the Erase Suspend/Resume commands.\nProgram Suspend (PS) SR2[0]:  The Program Suspend bit is used to determine when the device i s in Program Suspend mode. This\nis a status bit that cannot be written. When Program Suspend bi t is set to 1, the device is in program suspend mode. When the Program\nSuspend bit is cleared to 0, the device is not in program suspe nd mode. Refer to Section 9.5.4 Program Suspend (PGSP 85h) and\nResume (PGRS 8Ah) on page 94  for details.\n7.6.4 AutoBoot Register\nRelated Commands: AutoBoot Read (ABRD 14h) and AutoBoot Write ( ABWR 15h).\nThe AutoBoot Register provides a  means to automat ically read bo ot code as part of the power on reset, hardware reset, or softw are\nreset process.Table 24.  Status Register-2 (SR2)\nBits Field Name Function Type Default State Description \n7 RFU Reserved – 0 Res erved for Future Use \n6 RFU Reserved – 0 Res erved for Future Use \n5 RFU Reserved – 0 Res erved for Future Use \n4 RFU Reserved – 0 Res erved for Future Use \n3 RFU Reserved – 0 Res erved for Future Use \n2 RFU Reserved – 0 Res erved for Future Use \n1 ES Erase Suspend Volatile, Read only 0 1 = In erase suspend mode\n0 = Not in erase suspend mode\n0 PS Program \nSuspend Volatile, Read only 0 1 = In program suspend mode\n0 = Not in program suspend mode\nTable 25.  AutoBoot Register\nBits Field Name Function Type Default State Description \n31 to 9 ABSA AutoBoot Start \nAddress Nonvolatile 000000h 512 byte boundary addre ss for the start of \nboot code access\n8 to 1 ABSD AutoBoot Start \nDelay Nonvolatile 00h Number of initial de lay cycles between \nCS# going low and the first bit of boot code being transferred\n0 ABE AutoBoot Enable Nonvolatile 0 1 = AutoBoot is enabled\n0 = AutoBoot is not enabled\nDocument Number: 001-98284 Rev. *R Page 53 of 136S25FL512S\n7.6.5 Bank Address Register\nRelated Commands: Bank Register Access (BRAC B9h), Write Regist er (WRR 01h), Bank Register Read (BRRD 16h) and Bank\nRegister Write (BRWR 17h).\nThe Bank Address register supplies additional high order bits o f the main flash array byte boundary address for legacy command s\nthat supply only the low order 24 bits of address. The Bank Add ress is used as the high bits of address (above A23) for all 3- byte\naddress commands when EXTADD=0. The Bank Address is not used wh en EXTADD = 1 and traditional 3-byte address commands\nare instead required to provide all four bytes of address.\nExtended Address (EXTADD) BAR[7]:  EXTADD controls the address f ield size for legacy SPI commands. By default (power up reset,\nhardware reset, and software reset), it is cleared to 0 for 3 b ytes (24 bits) of address. When set to 1, the legacy commands w ill require\n4 bytes (32 bits) for  the address field. This is a volatile bit .\n7.6.6 ECC Status R egister (ECCSR)\nRelated Commands: ECC Read (ECCRD 18h). ECCSR does not have use r programmable nonvolatile bits. All defined bits are volatile\nread only status. The default st ate of these bit s are set by ha rdware. See Section 9.5.1.1 Aut omatic ECC on page 92 .\nThe status of ECC in each ECC unit is provided by the 8-bit ECC  Status Register (ECCSR). The ECC Register Read command is\nwritten followed by an ECC uni t address. The contents of the st atus register then ind icates, for the sele cted ECC unit, whethe r there\nis an error in the ECC unit eight bit error correction code, th e ECC unit of 16 Bytes of data, or that ECC is disabled for tha t ECC unit.\nECCSR[2] = 1 indicates an error was corrected in the ECC. ECCSR [1] = 1 indicates an error was corrected in the ECC unit data.\nECCSR[0] = 1 indicates  the ECC is disabled . The default state o f “0” for all these bits indicat es no failures and ECC is enabl ed.\nECCSR[7:3] are reserved. These have undefined high or low value s that can change from one ECC st atus read to another. These\nbits should be treated as “don’t c are” and ignored by any softw are reading status.Table 26.  Bank Address Register (BAR)\nBits Field Name Function Type Default State Description \n7 EXTADD Extended Address \nEnable Volatile 0b 1 = 4-byte (32-bits) addre ssing required from command.\n0 = 3-byte (24-bits) addre ssing from command + Bank \nAddress \n6 to 2 RFU Reserved Volatile 00000b Reserved for Future Use \n1 BA25 Bank Address Volatile 0 A25 for 512 Mb device0 BA24 Bank Address Volatile  0 A24 for 512 Mb device\nTable 27.  ECC Status Register (ECCSR)\nBits Field Name Function Type Default \nState Description \n7 to 3 RFU Reserved 0 Reserved for Future Use \n2 EECC Error in ECC Volatile, Read only 0 1 = Single Bit Error found in the ECC unit eight \nbit error correction code 0 = No error. \n1 EECCD Error in ECC unit \ndata Volatile, Read only 0 1 = Single Bit Error corrected in ECC unit \ndata. \n0 = No error. \n0 ECCDI ECC Disabled Volatile, Read only 0 1 = ECC is disabled in  the selected ECC unit. \n0 = ECC is enabled in t he selected ECC unit. \nDocument Number: 001-98284 Rev. *R Page 54 of 136S25FL512S\n7.6.7 ASP Reg ister (ASPR)\nRelated Commands: ASP Read (ASPRD 2Bh) and ASP Program (ASPP 2F h).\nThe ASP register is a 16-bit OTP  memory location used to perman ently configure the behavior of Advanced Sector Protection (ASP )\nfeatures.\nReserved for Future Use (RFU) ASPR[15:3, 0] .\nPassword Protection Mode L ock Bit (PWDMLB) ASPR[2]:  When programmed to 0, the Password Protection Mode is permanen tly\nselected.\nPersistent Protect ion Mode Lock Bit (PSTMLB) ASPR[1]:  When programmed to 0, the Persis tent Protection Mode is perman ently\nselected. PWDMLB and PSTMLB are mu tually exclusiv e, only one ma y be programmed to zero.\n7.6.8 Password Register (PASS)\nRelated Commands: Password Read (PASSRD E7h) and Password Progr am (PASSP E8h).\n7.6.9 PPB Lock Register (PPBL)\nRelated Commands: PPB Lock Read (PLBRD A7h, PLBWR A6h)Table 28.  ASP Register (ASPR)\nBits Field Name Function Type Default \nState Description \n15 to 9 RFU Reserved OTP 1 Reserved for Future Use \n8 RFU Reserved OTP \nNote [44] Reserved for Future Use \n7 RFU Reserved OTP Reserved for Future Use 6 RFU Reserved OTP 1 Reserved for Future Use 5 RFU Reserved OTP \nNote [44]Reserved for Future Use \n4 RFU Reserved OTP Reserved for Future Use 3 RFU Reserved OTP Reserved for Future Use \n2 PWDMLB Password \nProtection Mode \nLock Bit OTP 1 0 = Password Protection Mode permanently enabled. \n1 = Password Protection M ode not permanently enabled.\n1 PSTMLB Persistent \nProtection Mode \nLock Bit OTP 1 0 = Persistent Protection Mode permanently enabled. \n1 = Persistent Protection Mode not permanently enabled.\n0 RFU Reserved OTP 1 Reserved for Future Use \nNote\n44. Default value depends on ordering part number, see Section 11.6 Initial Delivery State on page 130 .\nTable 29.  Password Register (PASS)\nBits Field \nName Function Type Default State Description \n63 to 0 PWD Hidden \nPassword OTP FFFFFFFF-FFFFFF\nFFh Nonvolatile OTP storage of 64-bit password. The password \nis no longer readable after the password protection mode is \nselected by programming ASP register bit 2 to zero. \nTable 30.  PPB Lock Register (PPBL)\nBits Field Name Function Type Default State Description \n7 to 1 RFU Reserved Volatile 00h Reserved for Future Use \n0 PPBLOCK Protect PPB Array Volatile Persistent Protection Mode = 1 \nPassword Protection Mode = 0 0 = PPB array protecte d until next power \ncycle or hardware reset \n1 = PPB array may be  programmed or \nerased. \nDocument Number: 001-98284 Rev. *R Page 55 of 136S25FL512S\n7.6.10 PPB Access Register (PPBAR)\nRelated Commands: PPB Read (PPBRD E2h)\n7.6.11 DYB Access Register (DYBAR)\nRelated Commands: DYB Read (DYBR D E0h) and DYB Program (DYBP E1 h).\n7.6.12 SPI DDR Data Learning Registers\nRelated Commands: Pr ogram NVDLR (PNVDLR 43h), Write VDLR (WVDLR  4Ah), Data Learning Pattern Read (DLPRD 41h).\nThe Data Learning Pattern (DLP) resides in an 8-bit Nonvolatile  Data Learning Register (NVDLR) as well as an 8-bit Volatile Da ta\nLearning Register (VD LR). When shipped from  Cypress, the NVDLR value is 00h. Once programmed, the NVDLR cannot be repro-\ngrammed or erased; a copy of t he data pattern in the NVDLR will  also be written to the VDLR. The VDLR can be written to at any\ntime, but on reset or power cycles the data pattern will revert  back to what is in the NVDLR. During the learning phase descri bed in\nthe SPI DDR modes, the DLP will co me from the VDLR. Each I/O wi ll output the same DLP value for every clock edge. For example,\nif the DLP is 34h (or binary 00110100) then during the first cl ock edge all I/O’s will output 0 ; subsequently, the 2nd clock e dge all I/O’s\nwill output 0, the 3rd  will output 1, etc.\nWhen the VDLR value is  00h, no preamble dat a pattern is present ed during the dummy pha se in the DDR commands.Table 31.  PPB Access Register (PPBAR)\nBits Field Name Function Type Default \nState Description \n7 to 0 PPB Read or Program \nper sector PPB Nonvolatile FFh 00h = PPB for the sector addressed by the PPBRD or \nPPBP command is programmed to 0, protecting that \nsector from program or erase operations. \nFFh = PPB for the sector addressed by the PPBRD or \nPPBP command is erased to 1, not protecting that \nsector from program or erase operations. \nTable 32.  DYB Access Register (DYBAR)\nBits Field Name Function Type Default State Description \n7 to 0 DYB Read or Write \nper sector DYB Volatile FFh 00h = DYB for the sector add ressed by the DYBRD or DYBP \ncommand is cleared to 0, protectin g that sector from program or  \nerase operations. \nFFh = DYB for the sector addressed by the DYBRD or DYBP \ncommand is set to 1, not  protecting that sec tor from program or  \nerase operations. \nTable 33.  Nonvolatile Data Learning Register (NVDLR)\nBits Field Name Function Type Default State Description \n7 to 0 NVDLP Nonvolatile \nData Learning \nPatternOTP 00h OTP value that may be transferred to the host during \nDDR read command latency (dummy) cycles to provide a training pattern to help the host more \naccurately center the dat a capture point in the \nreceived data bits.\nTable 34.  Volatile Data L earning Register (NVDLR)\nBits Field Name Function Type Default State Description \n7 to 0 VDLP Volatile Data \nLearning \nPattern Volatile Takes the value of \nNVDLR during POR or \nResetVolatile copy of the NVDLP used to enable and deliver \nthe Data Learning Pattern (D LP) to the outputs. The \nVDLP may be changed by t he host during system \noperation.\nDocument Number: 001-98284 Rev. *R Page 56 of 136S25FL512S\n8. Data Protection\n8.1 Secure Silicon Region (OTP)\nThe device has a 1024-byte One Time Program (OTP) address space  that is separate from the main flash array. The OTP area is\ndivided into 32, individually lockable, 32-byte aligned and len gth regions.\nThe OTP memory space is intended for increased system security.  OTP values can “mate” a fl ash component with the system\nCPU/ASIC to prevent device substitution. See Section 7.5 OTP Address Space on page 45 , Section 9.7 One Time Program Array\nCommands on page 98 , and Section 9.7.2 OTP Read (OTPR 4Bh) on page 98 .\n8.1.1 Reading OTP Memory Space\nThe OTP Read command uses the same protocol as Fast Read. OTP R ead operations outside the valid 1-kB OTP address range\nwill yield indeterminate data.\n8.1.2 Programming OTP Memory Space\nThe protocol of the OTP programming command is the same as Page  Program. The OTP Program command can be issued multiple\ntimes to any given OTP address,  but this address space can neve r be erased. \nAutomatic ECC is programmed on the first programming operation to each 16-byte region. Programming within a 16-byte region mor e\nthan once disables the ECC. It is recommended to program each 1 6-byte portion of each 32-byte region once so that ECC remains\nenabled to provide the  best data integrity.\nThe valid address range for OTP Program is depicted in Figure 45 on page 45 . OTP Program operations outside the valid OTP\naddress range will be ignored and the WEL in SR1 will remain hi gh (set to 1). OTP Program operations while FREEZE = 1 will fai l\nwith P_ERR in SR1 set to 1.\n8.1.3 Cypress Program med Random Number\nCypress standard practice is to program the low order 16 bytes of the OTP memory space (locations 0x0 to 0xF) with a 128-bit r andom\nnumber using the Linear Congru ential Random Number Method. The seed value for the algorithm is a random number concatenated\nwith the day and time of tester insertion.\n8.1.4 Lock Bytes\nThe LSb of each Lock byte protects the lowest address region re lated to the byte, the MSb protects the highest address region related\nto the byte. The next higher address byte similarly protects th e next higher 8 regions. The LSb bit of the lowest address Lock  Byte\nprotects the higher address 16 bytes of the lowest address regi on. In other words, the LSb of l ocation 0x10 protects all the L ock Bytes\nand RFU bytes in the lowest address region from further program ming. See Section 7.5 OTP Address Space on page 45 .\n8.2 Write Enable Command\nThe Write Enable (WREN) command must be written prior to any co mmand that modifies nonvolatile data. The WREN command sets\nthe Write Enable Latch (WEL) bit. The WEL bit is cleared to 0 ( disables writes) during power-up, hardware reset, or after the device\ncompletes the following commands:\n■Reset\n■Page Program (PP)\n■Sector Erase (SE)\n■Bulk Erase (BE)\n■Write Disable (WRDI)\n■Write Registers (WRR)\n■Quad-input Page Programming (QPP)\n■OTP Byte Programming (OTPP)\nDocument Number: 001-98284 Rev. *R Page 57 of 136S25FL512S\n8.3 Block Protection\nThe Block Protect bits (Status Register bits BP2, BP1, BP0) in combination with the Configurat ion Register TBPROT bit can be u sed\nto protect an address range of the main flash array from progra m and erase operations. The size of the range is determined by the\nvalue of the BP bits and the u pper or lower starting point of t he range is selected by the TBPR OT bit of the configuration reg ister.\nWhen Block Protection is enabled (i.e., any BP2-0 are set to 1) , Advanced Sector Protection (ASP) can still be used to protect  sectors\nnot protected by the Block Protection scheme. In the case that both ASP and Block Protection are used on the same sector the l ogical\nOR of ASP and Block Protection related to the sector is used. R ecommendation: ASP and Block Protection should not be used\nconcurrently. Use one or t he other, but not both. \n8.3.1 Freeze Bit\nBit 0 of the Configuration Regi ster is the FREEZE bit. The FREE ZE bit locks the BP2-0 bits in Status Register 1 and the TBPROT  bit\nin the Configuration Register to their value at the time the FR EEZE bit is set to 1. Once the F REEZE bit has been written to a  logic 1\nit cannot be cleared to a logic 0 until a power-on-reset is exe cuted. As long as the FREEZE bit is cleared to logic 0 the stat us register\nBP bits and the TBPROT bit of the Configuration Register are wr itable. The FREEZE bit also prot ects the entire OTP memory spac e\nfrom programming when set to 1. Any attempt to change the BP bi ts with the WRR command while FREEZE = 1 is ignored and no\nerror status is set.\n8.3.2 Write Protect Signal\nThe Write Protect (WP#) input in  combination with the Status Re gister Write Disable (SRWD) bit provide hardware input signal\ncontrolled protection. When WP# is Low and SRWD is set to 1 the  Status and Configuration regist er is protected from alteration . This\nprevents disabling or changing t he protection defined by the Bl ock Protect bits.Table 35.  Upper Array Start of Protection (TBPROT = 0)\nStatus Register Content\nProtected Fraction of Memory ArrayProtected Memory (KB)\nFL512S\n512 MbBP2 BP1 BP0\n0 0 0 None 0\n0 0 1 Upper 64th 10240 1 0 Upper 32nd 20480 1 1 Upper 16th 40961 0 0 Upper 8th 81921 0 1 Upper 4th 163841 1 0 Upper Half 327681 1 1 All Sectors 65536\nTable 36.  Lower Array Start of Protection (TBPROT = 1)\nStatus Register Content\nProtected Fraction of Memory ArrayProtected Memory (KB)\nFL512S\n512 MbBP2 BP1 BP0\n0 0 0 None 0\n0 0 1 Lower 64th 10240 1 0 Lower 32nd 20480 1 1 Lower 16th 40961 0 0 Lower 8th 81921 0 1 Lower 4th 163841 1 0 Lower Half 327681 1 1 All Sectors 65536\nDocument Number: 001-98284 Rev. *R Page 58 of 136S25FL512S\n8.4 Advanced Sector Protection\nAdvanced Sector Protect ion (ASP) is the name used for a set of independent hardware and softwa re methods used to disable or\nenable programming or erase operations, individually, in any or  all sectors. An overview of these methods is shown in Figure 46\non page 58 .\nBlock Protection and ASP protection settings for each sector ar e logically OR’d to define the protection for each sector, i.e.  if either\nmechanism is protecting a sector  the sector cannot be programme d or erased. Refer to Section 8.3 Block Protection on page 57  for\nfull details of the BP2-0 bits.\nFigure 46.  Advanced Sec tor Protection Overview\nEvery main flash array sector has a nonvolatile (PPB) and a vol atile (DYB) protection bit associ ated with it. Wh en either bit is 0, the\nsector is protected from pro gram and erase operations.\nThe PPB bits are protected from  program and erase when the PPB Lock bit is 0. There are two methods for managing the state of\nthe PPB Lock bit, Persistent Prote ction and Password Protection .\nThe Persistent Prote ction method sets the PPB Lock bit to 1 dur ing POR, or Hardware Reset so t hat the PPB bits are unprotected  by\na device reset. There is a command to clear the PPB Lock bit to  0 to protect the PPB. There is no command in the Persistent Pr otection\nmethod to set the PPB Lock bit to  1, therefore the PPB Lock bit  will remain at 0 until the next power-off or hardware reset. T he\nPersistent Protection method allows boot code the option of cha nging sector protection by pro gramming or erasing the PPB, then\nprotecting the PPB from further change for the remainder of nor mal system operation by cleari ng the PPB Lock bit to 0. This is\nsometimes called Boot-code con trolled sector protection.\nThe Password method clears the PPB Lock bit to 0 during POR, or  Hardware Reset to protect the PPB. A 64-bit password may be\npermanently programmed and hidden for the password method. A co mmand can be used to provide a password for comparison with\nthe hidden password. If the pass word matches, the PPB Lock bit is set to 1 to unprotect the PPB. A command can be used to clea r\nthe PPB Lock bit to 0. This metho d requires use of a password t o control PPB protection.\nThe selection of the PPB Lock bit management method is made by programming OTP bits in the ASP Register so as to permanently\nselect the method used.ASP Register  \nOne Time Programmable  \nPassword Method  \n(ASPR[2]=0) Persistent Method  \n(ASPR[1]=0) \n64 - bit Password  \n(One Time Protect)  \nPBB Lock Bit  \n“0” = PPBs locked  \nSector 0  Memory Array  \nSector N  - 2 Sector 1  \nSector 2  \nSector N  - 1 \nSector N  \n1.) N = Highest Address Sector  PPB 0 Persistent \nProtection Bit  \n(PPB) \nPPB N  - 2 PPB 1 \nPPB 2 \nPPB N  - 1 \nPPB N  DYB 0  Dynamic \nProtection Bit  \n(DYB) \nDYB N  - 2 DYB 1  \nDYB 2  \nDYB N  - 1 \nDYB N  \n2.) 3.) DYB are volatile bits“1”=PPBs unlocked  64 - bit Password  \n(One Time Protect)  \nSector 0  Memory Array  \nSector N  - 2 Sector 1  \nSector 2  \nSector N  - 1 \nSector N  \n1.) N = Highest Address Sector,  \na sector is protected if its PPB =”0”  or its DYB = “0” PPB 0 Persistent \nProtection Bits  \n(PPB) \nPPB N  - 2 PPB 1 \nPPB 2 \nPPB N  - 1 \nPPB N  DYB 0  Dynamic \nProtection Bits\n(DYB) \nDYB N  - 2 DYB 1  \nDYB 2  \nDYB N  - 1 \nDYB N  \nPPB are programmed individually \nbut erased as a group 3.) DYB are volatile bits4.) PPB Lock bit is volatile and \ndefaults to “1” (persistent mode).or “0” (password mode) upon reset \n5.) PPB Lock = “0” locks all PPBs \nto their current state\n 6.) Password Method requires a \npassword to set PPB Lock to “1” to enable program or erase of PPB bits 7.) Persistent  Method only allows \nPPB Lock to be cleared to “0” to prevent program or erase of PPB bits. Power off or hardware reset required to  set PPB Lock to “1” \nDocument Number: 001-98284 Rev. *R Page 59 of 136S25FL512S\n8.4.1 ASP Register\nThe ASP register is used to permanently configure the behavior of Advanced Sector Protection (ASP) features. See Table 28\non page 54 .\nAs shipped from the factory, all devices default ASP to the Per sistent Protection mode, with all sectors unprotected, when pow er is\napplied. The device p rogrammer or host system must then choose which sector protection method to use. Programming either of th e,\none-time programmable, Protect ion Mode Lock Bi ts, locks the par t permanently in t he selected mode:\n■ASPR[2:1] = 11 = No ASP mode sele cted, Persisten t Protection Mo de is the default.\n■ASPR[2:1] = 10 = Persistent Pro tection Mode permanently selecte d.\n■ASPR[2:1] = 01 = Password Protec tion Mode permanently selected.\n■ASPR[2:1] = 00 = Illegal conditi on, attempting to  program both bits to zero results in a programming failure.\nASP register programming rules:\n■If the password mode is chosen, the password must be programmed  prior to setting the Pr otection Mode Lock Bits.\n■Once the Protection Mode is selected, the Protection Mode Lock Bits are permanently pr otected from programming and no further\nchanges to the ASP register is allowed.\nThe programming time of the ASP Register is the same as the typ ical page programming time. The system can determine the status\nof the ASP register programming operation by reading the WIP bi t in the Status Register. See Status Register 1 (SR1) on page 48  for\ninformation on WIP.\nAfter selecting a sector prote ction method, each sector can ope rate in each of the following states:\n■Dynamically Locked — A sector is protected and can be changed b y a simple command.\n■Persistently Locked — A sector is protected and cannot be chang ed if its PPB Bit is 0.\n■Unlocked — The sector is unprot ected and can be changed by a si mple command.\n8.4.2 Persistent Protection Bits\nThe Persistent Protection Bits  (PPB) are located in a separate nonvolatile flash array. One of the PPB bits is related to each  sector.\nWhen a PPB is 0, its related sect or is protected from program a nd erase operations. The PPB are programmed individually but mu st\nbe erased as a group, similar to the way individual words may b e programmed in the main array but an entire sector must be era sed\nat the same time. The PPB have the same program and erase endur ance as the main flash memory array. Preprogramming and\nverification prior to erasure are handled by the device.\nProgramming a PPB bit requires t he typical page pr ogramming tim e. Erasing all the PPBs requires  typical sector e rase time. Dur ing\nPPB bit programming and PPB bit er asing, status is  available by  reading the Status register. R eading of a PPB bit requires the  initial\naccess time of the device.\nNotes\nEach PPB is indivi dually programmed to 0 and all are erased to 1 in parallel.\nIf the PPB Lock bit is 0, the PPB Program or PPB Erase command does not execute and fails without  programming or erasing the P PB.\nThe state of the PPB fo r a given sector can be verifie d by usin g the PPB Read command.\n8.4.3 Dynamic Protection Bits\nDynamic Protection Bits are vola tile and unique for each sector  and can be individually modified.  DYB only control the protect ion for\nsectors that have t heir PPB set to 1. By i ssuing the DYB Write command, a DYB is cleared to 0 or set to 1, thus placing each s ector\nin the protected or unprotected state respectively. This featur e allows software to easily protect sectors against inadvertent  changes,\nyet does not prevent the easy removal of protection when change s are needed. The DYBs can be set or cleared as often as needed\nas they are volatile bits.\nDocument Number: 001-98284 Rev. *R Page 60 of 136S25FL512S\n8.4.4 PPB Lock Bit (PPBL[0])\nThe PPB Lock Bit is a volatile bi t for protecting all PPB bits.  When cleared to 0, it locks a ll PPBs and when set to 1, it all ows the PPBs\nto be changed.\nThe PLBWR command is used to cl ear the PPB Lock bit to 0. The P PB Lock Bit must be cleared to 0 only after all the PPBs are\nconfigured to the desired settings.\nIn Persistent Protection mode, the PPB Lock is set to 1 during POR or a hardware reset. When cleared to 0, no software command\nsequence can set the PPB Lock bit  to 1, only another hardware r eset or power-up can set the PPB Lock bit.\nIn the Password Protection mode , the PPB Lock bit is cleared to  0 during POR or a hardware reset. The PPB Lock bit can only be\nset to 1 by the Passw ord Unlock command.\n8.4.5 Sector Protection States Summary\nEach sector can be in one of t he following prot ection states:\n■Unlocked — The sector is unprotec ted and protection can be chan ged by a simple command. The protection state defaults to\nunprotected after a power cycle, s oftware reset, or hardware re set.\n■Dynamically Locked — A sector is protected and protection can b e changed by a simple command. The  protection state is not save d\nacross a power cycle or reset.\n■Persistently Locked — A sector is protected and protection can only be changed if the PPB Lock Bit is set to 1. The protection  state\nis nonvolatile and saved across a power cycle or reset. Changin g the protection state requires programming and or erase of the\nPPB bits\n8.4.6 Persistent Protection Mode\nThe Persistent Protection met hod sets the PPB Lo ck bit to 1 dur ing POR or Hardware Reset so that  the PPB bits are unprotected by\na device hardware reset. Softw are reset does not affect the PPB  Lock bit. The PLBWR command can clear th e PPB Lock bit to 0 to\nprotect the PPB. There is no co mmand to set the PPB Lock bit th erefore the PPB Lock bi t will remain at 0 un til the next power- off or\nhardware reset.Table 37.  Sector Protection States\nProtection Bit Values \n Sector State\nPPB Lock PPB DYB\n1 1 1 Unprotected – PPB and DYB are changeable 1 1 0 Protected – PPB and DYB are changeable \n1 0 1 Protected – PPB and DYB are changeable \n1 0 0 Protected – PPB and DYB are changeable \n0 1 1 Unprotected – PPB not changeable, DYB is changeable0 1 0 Protected – PPB not changeable, DYB is changeable \n0 0 1 Protected – PPB not changeable, DYB is changeable \n0 0 0 Protected – PPB not changeable, DYB is changeable \nDocument Number: 001-98284 Rev. *R Page 61 of 136S25FL512S\n8.4.7 Password Protection Mode\nPassword Protection Mode allows an even higher level of securit y than the Persistent Sector Protection Mode, by requiring a 64 -bit\npassword for unlocking the PPB Lock bit. In addition to this pa ssword requirement, after powe r up and hardware reset, the PPB Lock\nbit is cleared to 0 to ensure protection at power-up. Successfu l execution of the Password Unlock command by entering the enti re\npassword clears the PPB Lock bit, allo wing for sector PPB modif ications.\nPassword Protection Notes\n■Once the Password is programmed and verified, the Password Mode  (ASPR[2]=0) must be set in order to prevent reading the\npassword.\n■The Password Program Command is only capable of programming ‘0’ s. Programming a 1 after a cell is programmed as a 0 results\nin the cell left as a 0 with no programming error set.\n■The password is all 1’s when shipped from Cypress. It is locate d in its own memory space and is accessible through the use of the\nPassword Program and Password Read commands.\n■All 64-bit password combinati ons are valid as a password.\n■The Password Mode, once programmed, prevents reading the 64-bit  password and further password programming. All further\nprogram and read commands to the password region are disabled a nd these commands are ignored.  There is no means to verify\nwhat the password is after the Password Mode Lock Bit is select ed. Password verification is only allowed before selecting the\nPassword Protection mode.\n■The Protection Mode Lock Bits are not erasable.\n■The exact password must be entered in order for the unlocking f unction to occur. If the password unlock command provided passw ord\ndoes not match the hidden internal password, the unlock operati on fails in the same manner as a programming operation on a\nprotected sector. The P_ERR bit is set to one and the WIP Bit r emains set. In this case it is a failure to change the state of  the PPB\nLock bit because it is still protected by the lack of a valid p assword.\n■The Password Unlock command cannot be accepted any faster than once every 100 µs ± 20 µs. This makes it take an unreasonably\nlong time (58 million years) for a hacker to run through all th e 64-bit combinations in an attempt to correctly match a passwo rd. The\nRead Status Register 1 command may be used to read the WIP bit to determine when the device has completed the password\nunlock command or is ready to accept a new password command. Wh en a valid password is provided the password unlock command\ndoes not insert the 100 µs delay before returning the WIP bit t o zero.\n■If the password is lost after sel ecting the Password Mode, ther e is no way to set the PPB Lock bit.\n■ECC status may only be read from  sectors that are readable. In read protection mode the addresses are forced to the boot secto r\naddress. ECC status is shown in t hat sector while  read protecti on mode is active.\nDocument Number: 001-98284 Rev. *R Page 62 of 136S25FL512S\n9. Commands\nAll communication between the ho st system and the S25FL512S mem ory device is in the form o f units called commands. \nAll commands begin with an instruction that selects the type of  information transfer or device operation to be performed. Comm ands\nmay also have an address, instruction modifier, latency period,  data transfer to the memory, or data transfer from the memory.  All\ninstruction, address,  and data information is transferred seria lly between the host system and me mory device.\nAll instructions are  transferred from hos t to memory as a singl e bit serial sequence on the SI signal.\nSingle bit wide commands may provide an address or data sent on ly on the SI signal. Data may be sent back to the host serially  on\nSO signal.\nDual or Quad Output commands pro vide an address sent to the mem ory only on the SI signal. Dat a will be returned to the host as  a\nsequence of bit pairs on I/O0 and I/O1 or four bit (nibble) gro ups on I/O0, I/O1, I/O2, and I/O3. \nDual or Quad Input/Output (I/O) commands provide an address sen t from the host as bit pairs on I/O0 and I/O1 or, four bit (nib ble)\ngroups on I/O0, I/O1, I/O2, and I/O3. Data is returned to the h ost similarly as bit pairs on I/O0 and I/O1 or, four bit (nibbl e) groups on\nI/O0, I/O1, I/O2, and I/O3.\nCommands are structured as follows:\n■Each command begins with an eight b it (byte) instruction.\n■The instruction may be stand alone or may be followed by addres s bits to select a location with in one of several address space s in\nthe device. The address may be ei ther a 24-bit or  32-bit byte b oundary address. \n■The Serial Peripheral Interface with Multiple I/O provides the option for each transfer of address and data information to be done\none, two, or four bits in parallel. This enables a trade off be tween the number of signal connections (I/O bus width) and the speed\nof information transfer. If t he host system can support a two o r four bit wide I/O bus the memor y performance can be increased  by\nusing the instructions that pr ovide parallel two bit (dual) or parallel four bit (quad) transfers.\n■The width of all transfers follo wing the instruction are determ ined by the inst ruction sent. \n■All sIngle bits or parallel bit groups are transferred in most to least significant bit order.\n■Some instructions send instruction modifier (mode) bits followi ng the address to indicate that  the next command will be of the  same\ntype with an implied, rather th an an explicit, instruction. The  next command thus does not prov ide an instruction byte, only a  new\naddress and mode bits. This reduces the time needed to send eac h command when the same command type is repeated in a\nsequence of commands.\n■The address or mode bits may be followed by write data to be st ored in the memory device or by a read latency period before re ad\ndata is returned to the host. \n■Read latency may be zero to several SCK cycles (also referred t o as dummy cycles). \n■All instruction, address, mode, and data information is transfe rred in byte granularity. Addresses are shifted into the device  with the\nMSB first. All data is transfe rred with the lowest address byte  sent first. Following bytes of data are sent in lowest to high est byte\naddress order i.e. the byte address increments.\n■All attempts to read the flash me mory array during a program, e rase, or a write cycle (embedded operations) are ignored. The\nembedded operation will continue to execute without any affect.  A very limited set of commands are accepted during an embedded\noperation. These are discussed in the individual command descri ptions. While a program, erase, o r write operation is in progre ss,\nit is recommended to check that the Write-In Progress (WIP) bit  is 0 before issuing most commands to the device, to ensure the\nnew command can be accepted. \n■Depending on the command, the time for execution varies. A comm and to read status information from an executing command is\navailable to determine when the command completes execution and  whether the command was successful.\n■Although host software in some cases is used to directly contro l the SPI interface signals, the hardware interfaces of the hos t system\nand the memory device generally handle the details of signal re lationships and timing. For this reason, signal relationships a nd\ntiming are not covered in detail within this software interface  focused section of the document . Instead, the focus is on the logical\nsequence of bits transferred in each command rather than the si gnal timing and relationships. Following are some general signa l\nrelationship descriptions to keep in mind. For additional infor mation on the bit level format and signal timing relationships of\ncommands, see Section 3.2 Command Protocol on page 14 .\n❐The host always controls the Chip  Select (CS#), Serial Clock (S CK), and Serial Input  (SI) - SI for single bit wide transfers. The \nmemory drives Serial Output (SO) for single bit read transfers.  The host and memory alternately drive the I/O0-I/O3 signals du ring \nDual and Quad transfers. \n❐All commands begin with the host s electing the memory by drivin g CS# low before the first rising  edge of SCK. CS# is kept low \nthroughout a command and when CS# is returned high the command ends. Generally, CS# remains low for eight bit transfer \nmultiples to transfer byte granul arity information. Some comman ds will not be accepted if CS# is  returned high not at an 8 bit  \nboundary.\nDocument Number: 001-98284 Rev. *R Page 63 of 136S25FL512S\n9.1 Command Set Summary\n9.1.1  Extended Addressing\nTo accommodate addressing above 128 Mb, there are three options :\n1. New instructions are provided with 4-byte address, used to ac cess up to 32 Gb of memory.\n2. For backward compatibility to the 3-byte address instructions , the standard instructions can be used in conjunction with the  EXTADD \nBit in the Bank Address Register  (BAR[7]). By default BAR[7] is  cleared to 0 (following power up and hardware reset), to enabl e \n3-byte (24-bit) addressing. When set to 1, the legacy commands are changed to require 4 bytes (32 bits) for the address field.  The \nfollowing instructions can be us ed in conjunction with EXTADD b it to switch from 3 bytes t o 4 bytes of address field.Instruction Name Description Code (Hex)\n4FAST_READ Read Fast (4-byte Address) 0C\n4READ Read (4-byte Address) 13\n4DOR Read Dual Out (4-byte Address) 3C\n4QOR Read Quad Out (4-byte Address) 6C\n4DIOR Dual I/O Read (4-byte Address) BC\n4QIOR Quad I/O Read (4-byte Address) EC\n4DDRFR Read DDR Fast (4-byte Address) 0E\n4DDRDIOR DDR Dual I/O Read (4-byte Address) BE\n4DDRQIOR DDR Quad I/O Read (4-byte Address) EE\n4PP Page Program (4-byte Address) 12\n4QPP Quad Page Program (4-byte Address) 34\n4SE Erase 256 kB (4-byte Address) DC\nInstruction Name Description Code (Hex)\nREAD Read (3-byte Address) 03\nFAST_READ Read Fast (3-byte Address) 0B\nDOR Read Dual Out (3-byte Address) 3B\nQOR Read Quad Out (3-byte Address) 6B\nDIOR Dual I/O Read (3-byte Address) BB\nQIOR Quad I/O Read (3-byte Address) EB\nDDRFR Read DDR Fast (3-byte Address) 0D\nDDRDIOR DDR Dual I/O Read (3-byte Address) BD\nDDRQIOR DDR Quad I/O Read (3-byte Address) ED\nPP Page Program (3-byte Address) 02\nQPP Quad Page Program (3-byte Address) 32\nSE Erase 256 kB (3-byte Address) D8\nDocument Number: 001-98284 Rev. *R Page 64 of 136S25FL512S\n3. For backward compatibility to  the 3-byte addressing, the stan dard instructions can be used in conjunction with the Bank Addr ess \nRegister:\na. The Bank Address Register is us ed to switch bet ween 128-Mb (1 6-MB) banks of memory, The standard 3-byte \naddress selects an address within  the bank selected by the Bank  Address Register.\ni. The host system writes the Bank  Address Register to access b eyond the first 128 Mb of memory.\nii. This applies to read, erase, and program commands.\nb. The Bank Register provides the high order (4th) byte of addre ss, which is used to address the available memory at \naddresses greater than 16 MB.\nc. Bank Register bits are volatile.\ni. On power up, the default is B ank0 (the lowest address 16 MB) .\nd. For Read, the device will c ontinuously transfe r out data unti l the end of the array.\ni. There is no bank  to bank delay.\nii. The Bank Address Register is not updated.\niii. The Bank Address Register val ue is used only for the initi al address of an access.\nTable 38.  Bank Address Map\nBank Address Register Bits\nBank Memory Array Address Range (Hex)\nBit 1 Bit 0\n0 0 0 00000000 00FFFFFF0 1 1 01000000 01FFFFFF1 0 2 02000000 02FFFFFF1 1 3 03000000 03FFFFFF\nTable 39.  S25FL512S Command Set (sorted by function)\nFunctionCommand \nName Command Description Instruction \nValue (Hex)Maximum \nFrequency \n(MHz)\nRead Device \nIdentificationREAD_ID \n(REMS) Read Electronic Manufacturer Signature 90 133\nRDID Read ID (JEDEC  Manufacturer ID and JEDEC CFI) 9F 133\nRES Read Electronic Signature AB 50\nRSFDP Read Serial Flash Discoverable Parameters 5A 133\nRegister AccessRDSR1 Read Status Register-1 05 133\nRDSR2 Read Status Register-2 07 133\nRDCR Read Configuration Register-1 35 133\nWRR Write Register (Status-1 , Configuration-1) 01 133\nWRDI Write Disable 04 133\nWREN Write Enable 06 133\nCLSR Clear Status R egister-1 - Erase/Pro g. Fail Reset 30 133\nECCRD ECC Read (4-byte address 18 133\nABRD AutoBoot Register Read 14 133 \n(QUAD=0)\n104 \n(QUAD=1)\nDocument Number: 001-98284 Rev. *R Page 65 of 136S25FL512S\nRegister AccessABWR AutoBoot Register Write 15 133\nBRRD Bank Register Read 16 133\nBRWR Bank Register Write 17 133\nBRACBank Register Access \n(Legacy Command formerly used for Deep Power Down)B9 133\nDLPRD Data Learning Pattern Read 41 133\nPNVDLR Program NV Data Learning Register 43 133\nWVDLR Write Volatile Dat a Learning Register 4A 133\nRead Flash ArrayREAD Read (3- or 4-byte address) 03 50\n4READ Read (4-byte address) 13 50\nFAST_READ Fast Read (3- or 4-byte address) 0B 133\n4FAST_READ Fast Read (4-byte address) 0C 133\nDDRFR DDR Fast Read (3- or 4-byte address) 0D 80\n4DDRFR DDR Fast Read (4-byte address) 0E 80\nDOR Read Dual Out (3- or  4-byte address) 3B 104\n4DOR Read Dual Out (4-byte address) 3C 104\nQOR Read Quad Out (3- o r 4-byte address) 6B 104\n4QOR Read Quad Out (4- byte address) 6C 104\nDIOR Dual I/O Read (3- or 4-byte address) BB 104\n4DIOR Dual I/O Read (4-byte address) BC 104\nDDRDIOR DDR Dual I/O Read (3 - or 4-byte address) BD 80\n4DDRDIOR DDR Dual I/O Read (4-byte address) BE 80\nQIOR Quad I/O Read (3- or  4-byte address) EB 104\n4QIOR Quad I/O Read (4-byte address) EC 104\nDDRQIOR DDR Quad I/O Read (3- or 4-byte address) ED 80\n4DDRQIOR DDR Quad I/O Re ad (4-byte address) EE 80\nProgram Flash \nArrayPP Page Program (3- or 4-byte address) 02 133\n4PP Page Program (4-byte address) 12 133\nQPP Quad Page Program (3- or 4-byte address) 32 80QPP Quad Page Program - Alternate  instruction (3- or 4-byte add ress) 38 80\n4QPP Quad Page Program (4-byte address) 34 80\nPGSP Program Suspend 85 133\nPGRS Program Resume 8A 133\nErase Flash \nArrayBE Bulk Erase 60 133\nBE Bulk Erase (alternate command) C7 133SE Erase 256 kB (3- or 4-byte address) D8 133\n4SE Erase 256 kB (4- byte address) DC 133\nERSP Erase Suspend 75 133\nERRS Erase Resume 7A 133Table 39.  S25FL512S Command Set (sorted by function) (Continue d)\nFunctionCommand \nName Command Description Instruction \nValue (Hex)Maximum \nFrequency \n(MHz)\nDocument Number: 001-98284 Rev. *R Page 66 of 136S25FL512S\n9.1.2 Read Device Identification\nThere are multiple commands to read information about the devic e manufacturer, device type, and  device features. SPI memories\nfrom different vendors have used different commands and formats  for reading information about the memories. The S25FL512S\ndevice supports the three most co mmon device information comman ds.\n9.1.3 Register Read or Write\nThere are multiple registers for  reporting embedded operation s tatus or controlling device configuration options. There are co mmands\nfor reading or writing these registers. Registers contain both volatile and nonvolatile bits. Nonvolatile bits in registers ar e automatically\nerased and programmed as a s ingle (write) operation.\n9.1.3.1 Monitoring Operation Status\nThe host system can determine when a write, program, erase, sus pend or other embedded operation is complete by monitoring the\nWrite in Progress (WIP) bit in t he Status Register. The Read fr om Status Register-1 command pro vides the state of the WIP bit.  The\nprogram error (P_ERR) and erase error (E_ERR) bits in the statu s register indicate whether t he most recent program or erase\ncommand has not completed successfully. When P_ERR or E_ERR bit s are set to one, the WIP bit will remain set to one indicating\nthe device remains busy. Under this condition, only the CLSR, W RDI, RDSR1, RDSR2, and soft ware RESET commands are valid\ncommands. A Clear Statu s Register (CLSR) followed by a Write Di sable (WRDI) command must be sent  to return the device to stand by\nstate. CLSR clears the WIP, P_E RR, and E_ERR bits. WRDI clears the WEL bit. Alternatively, Har dware Reset, or Software Reset\n(RESET) may be used to return t he device to standby state.One Time \nProgram ArrayOTPP OTP Program 42 133\nOTPR OTP Read 4B 133\nAdvanced Sector \nProtectionDYBRD DYB Read E0 133\nDYBWR DYB Write E1 133\nPPBRD PPB Read E2 133\nPPBP PPB Program E3 133PPBE PPB Erase E4 133\nASPRD ASP Read 2B 133\nASPP ASP Program 2F 133\nPLBRD PPB Lock Bit Read A7 133\nPLBWR PPB Lock Bit Write A6 133\nPASSRD Password Read E7 133\nPASSP Password Program E8 133\nPASSU Password Unlock E9 133\nResetRESET Software Reset F0 133\nMBR Mode Bit Reset FF 133\nReserved for \nFuture UseMPM Reserved for Multi-I/O- High Perf Mode (MPM) A3 133\nRFU Reserved-18 Reserved 18\nRFU Reserved-E5 Reserved E5RFU Reserved-E6 Reserved E6Table 39.  S25FL512S Command Set (sorted by function) (Continue d)\nFunctionCommand \nName Command Description Instruction \nValue (Hex)Maximum \nFrequency \n(MHz)\nDocument Number: 001-98284 Rev. *R Page 67 of 136S25FL512S\n9.1.3.2 Configuration\nThere are commands to read, wri te, and protect registers that c ontrol interface path width, int erface timing, interface addres s length,\nand some aspects of data protection.\n9.1.4 Read Flash Array\nData may be read from the memory starting at any byte boundary.  Data bytes are sequentially re ad from incrementally higher byt e\naddresses until the host ends the data transfer by driving CS# input High. If the byte address reaches the maximum address of the\nmemory array, the read will cont inue at address zero of the arr ay.\nThere are several different read  commands to specify different access latency and data path widths. Double Data Rate (DDR)\ncommands also define the addre ss and data bit relationship to b oth SCK edges:\n■The Read command provides a single address bit per SCK rising e dge on the SI signal with read data returning a single bit per SCK\nfalling edge on the SO signal. This command has zero latency be tween the address and the returning data but is limited to a ma ximum\nSCK rate of 50 MHz.\n■Other read commands hav e a latency period between the address a nd returning data but can operat e at higher SCK frequencies.\nThe latency depends on  the configuration re gister latency code.\n■The Fast Read command provides a single address bit per SCK ris ing edge on the SI signal with read data returning a single bit\nper SCK falling edge on  the SO signal and m ay operate up to 133  MHz.\n■Dual or Quad Output read commands provide address a single bit per SCK rising edge on the SI / I/O0 signal with read data retu rning\ntwo bits, or four bits of data per SCK falling edge on the I/O0 -I/O3 signals.\n■Dual or Quad I/O Read commands provide address two bits or four  bits per SCK rising edge with read data returning two bits, or\nfour bits of dat a per SCK falling edge on the I/O0-I/O3 signals .\n■Fast (Single), Dual, or Quad Double Data Rate read commands pro vide address one bit, two bits o r four bits per every SCK edge\nwith read data returning one bit,  two bits, or four bits of dat a per every SCK edge on the I/O0 -I/O3 signals. Double Data Rate  (DDR)\noperation is only supp orted for core and I/O voltages of 3 to 3. 6V.\n9.1.5 Program Flash Array\nProgramming data requires two commands: Write Enable (WREN), an d Page Program (PP or QPP). The Page Program command\naccepts from 1 byte up to 512 co nsecutive bytes of data (page) to be programmed in one operation. Programming means that bits\ncan either be left at 1, or prog rammed from 1 to 0. Changing bi ts from 0 to 1 requires an erase operation.\n9.1.6 Erase Flash Array\nThe Sector Erase (SE) and Bulk Erase (BE) commands set all the bits in a sector or the entire memory array to 1. A bit needs t o be\nfirst erased to 1 before programming can change it to a 0. Whil e bits can be individually programmed from a 1 to 0, erasing bi ts from\n0 to 1 must be done on a sector- wide (SE) or array-wide (BE) le vel.\n9.1.7 OTP, Block Prot ection, and Advanced Sector Protection\nThere are commands to read and program a separate One TIme Prog rammable (OTP) array for permanent data such as a serial\nnumber. There are commands to control a contiguous group (block ) of flash memory array sectors that are protect ed from program\nand erase operations. There are commands to control which indiv idual flash memory array sectors are protected from program and\nerase operations.\n9.1.8 Reset\nThere is a command to reset to the default conditions present a fter power on to the device. There is a command to reset (exit from)\nthe Enhanced Performance Read Modes. \nDocument Number: 001-98284 Rev. *R Page 68 of 136S25FL512S\n9.1.9 Reserved\nSome instructions are reserved for future use. In this generati on of the S25FL512S some of thes e command instructions may be\nunused and not affect device oper ation, some may have undefined  results. \nSome commands are reserved to ens ure that a legacy or alternate  source device command is allowed without affect. This allows\nlegacy software to issue some commands that are not relevant fo r the current generation S25FL51 2S device with the assurance th ese\ncommands do not cause s ome unexpect ed action. \nSome commands are reserved for use in special versions of the F L-S not addressed by this document or for a future generation. This\nallows new host memory controller designs to plan the flexibili ty to issue these command instructions. The command format is d efined\nif known at the time this docu ment revision is published.\n9.2 Identification Commands\n9.2.1 Read Identification - REMS (Read_ID or REMS 90h)\nThe READ_ID command identifies t he Device Manufacturer ID and t he Device ID. The command is also referred to as Read Electroni c\nManufacturer and device Signatu re (REMS). READ-ID (REMS) is onl y supported for backward compat ibility and should not be used\nfor new software designs. New soft ware designs should instead m ake use of the RDID command. \nThe command is initiated by shifting on SI the instruction code  “90h” followed by a 24-bit address of 00000h. Following this, the\nManufacturer ID and the Device  ID are shifted out on SO startin g at the falling edge of SCK afte r address. The Manufacturer ID  and\nthe Device ID are always shifted  out with the MSb first. If the  24-bit address is set to 000001h, then the Device ID is read o ut first\nfollowed by the Manufacturer ID. The Manufacturer ID and Device  ID output data toggles between address 000000H and 000001H\nuntil terminated by a low to hig h transition on CS# input. The maximum clock frequency fo r the READ_ID command is \n133 MHz.\nFigure 47.  READ_ID (90h) Command Sequence\nTable 40.  Read_ID Values\nDevice Manufacturer ID (hex) Device ID (hex)\nS25FL512S 01 19CS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321023  10  \n7654321076543210 \nInstruction (90h) Manufacturer ID Device ID Address\nDocument Number: 001-98284 Rev. *R Page 69 of 136S25FL512S\n9.2.2 Read Identification (RDID 9Fh)\nThe Read Identification (RDID) command provides read access to manufacturer identification, device identification, and Common\nFlash Interface (CFI) information. The manufacturer identificat ion is assigned by JEDEC. The CFI structure is defined by JEDEC\nstandard. The device identification and CFI values are assigned  by Cypress.\nThe JEDEC Common Flash Interface  (CFI) specification defines a device information structure, which allows a vendor-specified\nsoftware flash management program (driver) to be used for entir e families of flash devices. Software support can then be\ndevice-independent, JEDEC manufacturer ID independent, forward and backward-compatible for the s pecified flash device families .\nSystem vendors can standardize t heir flash drivers for long-ter m software compa tibility by using the CF I values to configure a  family\ndriver from the CFI informa tion of the device in use.\nAny RDID command issued while a program, erase, or write cycle is in progress is ignored and has no effect on execution of the\nprogram, erase, or  write cycle that  is in progress.\nThe RDID instruction is shifted on SI. After the last bit of th e RDID instruction is shifted in to the device, a byte of manufa cturer\nidentification, two bytes of de vice identification, extended de vice identification, and CFI information will be shifted sequen tially out on\nSO. As a whole this information  is referred to as ID-CFI. See Section 7.3 ID-CFI Address Space on page 44  for the detail description\nof the ID-CFI contents. \nContinued shifting of output bey ond the end of the defined ID-C FI address space will provide u ndefined data. The RDID command\nsequence is terminated by driving CS# to the logic high state a nytime during data output.\nThe maximum clock frequency for the RDID command is 133 MHz.\nFigure 48.  Read Identification (RDID 9Fh) Command Sequence\n9.2.3 Read Electronic Signature (RES) (ABh)\nThe RES command is used to read a single byte Electronic Signat ure from SO. RES is only supporte d for backward compatibility a nd\nshould not be used for new software designs. New software desig ns should instead make u se of the RDID command.\nThe RES instruction is shifted in followed by three dummy bytes  onto SI. After the last bit of the three dummy bytes are shift ed into\nthe device, a byte of Electronic  Signature will be shifted out of SO. Each bit is shifted out by the falling edge of SCK. The maximum\nclock frequency for the RES command is 50 MHz.\nThe Electronic Signature can be  read repeatedly by applying mul tiples of eight clock cycles.\nThe RES command sequence is ter minated by driving CS# to the lo gic high state anytime  during data output.\nFigure 49.  Read Electronic Sign ature (RES ABh) Command Sequenc e\nTable 41.  RES Values\nDevice Device ID (hex)\nS25FL512S 19CS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nCS#\nSCK\nSI\nSO\nPhase \n                                \n7654321023 10  \n76543210 \nInstruction (ABh)        Dummy Device ID\nDocument Number: 001-98284 Rev. *R Page 70 of 136S25FL512S\n9.2.4 Read Serial Flash Discover able Parameters (RSFDP 5Ah)\nThe command is initiated by shifting on SI the instruction code  ‘5Ah’, followed by a 24-bit address of 000000h, followed by ei ght dummy\ncycles. The SFDP bytes are then s hifted out on SO starting at t he falling edge of SCK after the eight dummy cycles. The SFDP b ytes\nare always shifted out with the MSb first. If the 24-bit addres s is set to any other value, the selected location in the SFDP space is the\nstarting point of the data read. This enables random access to any parameter in the SFDP space.  The maximum clock frequency fo r\nthe RSFDP command is 133 MHz.\nFigure 50.  RSFDP Command Sequence\n9.3 Register Access Commands\n9.3.1 Read Status Regi ster-1 (RDSR1 05h)\nThe Read Status Register-1 (RDSR1) command allows the Status Re gister-1 contents to be read from SO. The Status Register-1\ncontents may be read at any time, even while a program, erase, or write operation is in progress. It is possible to read the S tatus\nRegister-1 continuously by providing multiples of eight clock c ycles. The status is updated for each eight cycle read. The max imum\nclock frequency for  the RDSR1 (05h) command is 133 MHz.\nFigure 51.  Read Status Register -1 (RDSR1 05h) Command Sequence\n9.3.2 Read Status Regi ster-2 (RDSR2 07h)\nThe Read Status Register (RDSR2) command allows the Status Regi ster-2 contents to be read from SO. The Status Register-2\ncontents may be read at any time, even while a program, erase, or write operation is in progress. It is possible to read the S tatus\nRegister-2 continuously by providing multiples of eight clock c ycles. The status is updated for each eight cycle read. The max imum\nclock frequency for the RDSR2 command is 133 MHz.\nFigure 52.  Read Status Register -2 (RDSR2 07h) Command SequenceCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321023  10  \n76543 210 \nInstruction Address Dummy Cycles Data 1\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Status    Updated Status\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Status    Updated Status\nDocument Number: 001-98284 Rev. *R Page 71 of 136S25FL512S\n9.3.3 Read Configuration Register (RDCR 35h)\nThe Read Configuration Register  (RDCR) command allows the Confi guration Register contents to b e read from SO. It is possible t o\nread the Configuration Register continuously by providing multi ples of eight clock cycles. The Configuration Register contents  may\nbe read at any time, even while  a program, erase, or write oper ation is in progress.\nFigure 53.  Read Configuration R egister (RDCR 35h) Command Sequ ence\n9.3.4 Bank Register  Read (BRRD 16h)\nThe Read the Bank Register (BRRD) command allows the Bank addre ss Register contents to be read f rom SO. The instruction is fir st\nshifted in from SI. Then the 8-bit Bank Register is shifted out  on SO. It is possible to read the Bank Register continuously b y providing\nmultiples of eight c lock cycles. The maximum operating clock fr equency for the BRRD command is 133 MHz.\nFigure 54.  Read Bank Register (BRRD 16h) Command\n9.3.5 Bank Register Write (BRWR 17h)\nThe Bank Register Write (BRWR) command is used to write address  bits above A23, into the Bank Address Register (BAR). The\ncommand is also used to write the Extended address control bit (EXTADD) that is also in BAR[7]. BAR provides the high order\naddresses needed by devices having more than 128 Mb (16 MB), wh en using 3-byte address commands without extended addressing\nenabled (BAR[7] EXTADD = 0). Because this command is part of th e addressing method and is not changing data in the flash memor y,\nthis command does not require t he WREN command to precede it.\nThe BRWR instruction is  entered, followed by  the data byte on S I. The Bank Register is one  data byte in length.\nThe BRWR command has no effect on the P_ERR, E_ERR or WIP bits of the Status and Configuratio n Registers. Any bank address\nbit reserved for the future sh ould always be written as a 0.\nFigure 55.  Bank Register Write (BRWR 17h) CommandCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\n7 6 5 43 2 1 0 7 6 5 4 3 2 1 0\nInstruction Register Read Repeat Register Read\nCS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Data\nDocument Number: 001-98284 Rev. *R Page 72 of 136S25FL512S\n9.3.6 Bank Register  Access (BRAC B9h)\nThe Bank Register Read and Write commands provide full access t o the Bank Address Register (BA R) but they are both commands\nthat are not presen t in legacy SPI memory devices. Host system SPI memory controller interface s may not be able  to easily supp ort\nsuch new commands. The Bank Regis ter Access (BRAC) command uses  the same command code and format as the Deep Power\nDown (DPD) command that is available in legacy SPI memories. Th e FL-S family does not support a DPD feature but assigns this\nlegacy command code to the BRAC command to enable write access to the Bank Address Register for legacy systems that are able\nto send the legacy DP D (B9h) command.\nWhen the BRAC command is sent, the FL-S family device will then  interpret an immediately followi ng Write Register (WRR) comman d\nas a write to the lower address bits of the BAR. A WREN command  is not used between the BRAC and WRR commands. Only the\nlower two bits of the first data byte following the WRR command  code are used to load BAR[1:0].  The upper bits of that byte an d the\ncontent of the optional WRR command second data byte are ignore d. Following the WRR command the access to BAR is closed and\nthe device interface returns to the standby state. The combined  BRAC followed by WRR command sequence has no affect on the\nvalue of the ExtA dd bit (BAR[7]). \nCommands other than WRR may immedi ately follow BRAC and execute  normally. However, any command other than WRR, or any\nother sequence in which CS# goes low and returns high, followin g a BRAC command, will close the access to BAR and return to th e\nnormal interpretation of a WRR command as a write to Status Reg ister-1 and the Confi guration Register. \nThe BRAC + WRR sequence is allowed only when the device is in s tandby, program suspend, or era se suspend states. This command\nsequence is illegal when the device is performing an embedded a lgorithm or when the program (P_ ERR) or erase (E_ERR) status\nbits are set to 1. \nFigure 56.  BRAC (B9h ) Command Sequence\n9.3.7 Write Registers (WRR 01h)\nThe Write Registers (WRR) command allows new values to be writt en to both the Status Register-1 and Configuration Register. Be fore\nthe Write Registers (WRR) command  can be accepted  by the device , a Write Enable (WREN) command  must be received. After the\nWrite Enable (WREN) command has been decoded successfully, the device will set the Write Enable Latch (WEL) in the Status\nRegister to enable any write operations.\nThe Write Registers (WRR) command is entered by shifting the in struction and the data bytes on SI. The Status Register is one data\nbyte in length.\nThe Write Registers (WRR) command will set the P_ERR or E_ERR b its if there is a failure in the WRR operation. Any Status or\nConfiguration Register bit reser ved for the future must be writ ten as a 0.\nCS# must be driven to the logic high state after the eighth or sixteenth bit of data has been latched. If not, the Write Regis ters (WRR)\ncommand is not executed. If CS# is driven high after the eighth  cycle then only the Status Regis ter-1 is written; otherwise, a fter the\nsixteenth cycle both the Status a nd Configuration Registers are  written. When the configuration register QUAD bit CR[1] is 1, only the\nWRR command format with 16  data bits may be used. \nAs soon as CS# is driven to the logic high state, the self-time d Write Registers (WRR) operation is initiated. While the Write  Registers\n(WRR) operation is in progress, t he Status Register may still b e read to check the value of the Write-In Progress (WIP) bit. T he Write-In\nProgress (WIP) bit is a 1 during the self-timed Write Registers  (WRR) operation, and is a 0 when it is completed. When the Wri te\nRegisters (WRR) operation is com pleted, the Write Enable Latch (WEL) is set to a 0. The WRR command must be executed under\ncontinuous power. The maximum clock frequency for the WRR comma nd is 133 MHz.\nFigure 57.  Write Registers (WRR 01h) Command Sequence – 8 data  bitsCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Status Register- 1\nDocument Number: 001-98284 Rev. *R Page 73 of 136S25FL512S\nFigure 58.  Write Registers (W RR 01h) Command Sequence – 16 dat a bits\nThe Write Registers (WRR) command allows the user to change the  values of the Block Protect (BP2, BP1, and BP0) bits to define\nthe size of the area that is to be treated as read-only. The Wr ite Registers (WRR) command also allows the user to set the Sta tus\nRegister Write Disable (SRWD) bit  to a 1 or a 0. The Status Reg ister Write Disable (SRWD) bit and Write Protect (WP#) signal a llow\nthe BP bits to be hardware protected. \nWhen the Status Register Write Disable (SRWD) bit of the Status  Register is a 0 (its initial delivery state), it is possible t o write to the\nStatus Register provided that t he Write Enable Latch (WEL) bit has previously been set by a Write Enable (WREN) command,\nregardless of the whether Write Protect (WP#) signal is driven to the logic high or  logic low state.\nWhen the Status Register Write Disable (SRWD) bit of the Status  Register is set to a 1, two cas es need to be considered, depen ding\non the state of Write Protect (WP#):\n■If Write Protect (WP#) signal is driven to the logic high state , it is possible to write to the Status and Configuration Regis ters provided\nthat the Write Enable Latch (WEL ) bit has previously been set t o a “1” by initiating a Wr ite Enable (WREN) command.\n■If Write Protect (WP#) signal is driven to the logic low state,  it is not possible to write to the Status and Configuration Re gisters even\nif the Write Enable Latch (WEL) bit has previously been set to a 1 by a Write Enable (WREN) command. Attempts to write to the\nStatus and Configuration Registers are rejected, and are not ac cepted for execution. As a cons equence, all the data bytes in t he\nmemory area that are protected by the Block Protect (BP2, BP1, BP0) bits of the Status Register, are also hardware protected b y WP#.\nThe WP# hardware prote ction can be provided:\n■by setting the Status Register W rite Disable (SRWD) bit after d riving Write Protect (WP#) si gnal to the logic low state;\n■or by driving Write Protect (WP#)  signal to the lo gic low state  after setting th e Status Register Write Disable (SRWD) bit to a 1.\nThe only way to release the hardware protection is to pull the Write Protect (WP#) signal to the logic high state. If WP# is p ermanently\ntied high, hardware protection o f the BP bits can never be acti vated.\nThe WRR command has an alternat e function of loading the Bank A ddress Register if the command immediately follows a BRAC\ncommand. See Section 9.3.6 Bank Register A ccess (BRAC B9h) on page 72 .Table 42.  Block Protection Modes\nWP#SRWD \nBitMode Write Protection of RegistersMemory Content\nProtected Area Unprotected Area\n11\nSoftware \nProtected Status and Configuration Registers are Writable \n(if WREN command has s et the WEL bit). The \nvalues in the SRWD, BP2 , BP1, and BP0 bits \nand those in the Configur ation Register can be \nchangedProtected against \nPage Program, \nQuad Input Program, Sector \nErase, and Bulk \nEraseReady to accept \nPage Program, \nQuad Input Program \nand Sector Erase commands10\n00\n01Hardware \nProtected Status and Configura tion Registers are \nHardware Write Protect ed. The values in the \nSRWD, BP2, BP1, and BP0 b its and those in the \nConfiguration Regist er cannot be changedProtected against \nPage Program, \nSector Erase, and \nBulk EraseReady to accept \nPage Program or Erase commands\nNotes\n45. The Status Register originally  shows 00h when the device is first shipped from Cypress to the customer.\n46. Hardware protection is disabled  when Quad Mode is enabled (Q UAD bit = 1 in Configuration Register). WP# becomes I/O2; there fore, it cannot be utilized.CS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input Status Register-1 Input Configuration Register\nDocument Number: 001-98284 Rev. *R Page 74 of 136S25FL512S\n9.3.8 Write Enable (WREN 06h)\nThe Write Enable (WREN) command sets the Write Enable Latch (WE L) bit of the Status Register 1 (SR1[1]) to a 1. The Write Enab le\nLatch (WEL) bit must be set to a  1 by issuing the Write Enable (WREN) command to enable writ e, program and erase commands.\nCS# must be driven into the logi c high state after the eighth b it of the instruction byte has been latched in on SI. Without C S# being\ndriven to the logic high state after the eighth bit of the inst ruction byte has been latched in  on SI, the write enable operat ion will not\nbe executed.\nFigure 59.  Write Enable (WREN 06h) Command Sequence\n9.3.9 Write Disable (WRDI 04h)\nThe Write Disable (WRDI) command s ets the Write Enable Latch (W EL) bit of the Status Register-1 (SR1[1]) to a 0.\nThe Write Enable Latch (WEL) bit may be set to a 0 by issuing t he Write Disable (WRDI) command  to disable Page Program (PP),\nSector Erase (SE), Bulk Erase ( BE), Write Registers (WRR), OTP Program (OTPP), and other commands, that require WEL be set\nto 1 for execution. The WRDI command can be used by the user to  protect memory areas against inadvertent writes that can possi bly\ncorrupt the contents of the memory . The WRDI command is ignored  during an embedded operat ion while WIP bit =1.\nCS# must be driven into the logi c high state after the eighth b it of the instruction byte has been latched in on SI. Without C S# being\ndriven to the logic high state after the eighth bit of the inst ruction byte has been latched in  on SI, the write disable opera tion will not\nbe executed.\nFigure 60.  Write Disable (WRDI 04h) Command Sequence\n9.3.10 Clear Status Register (CLSR 30h):\nThe Clear Status Register command resets bit SR1[5] (Erase Fail  Flag) and bit SR1[6] (Program F ail Flag). It is not necessary to set\nthe WEL bit before the Clear SR command is executed. The Clear SR command will be accepted even when the device remains busy\nwith WIP set to 1, as the device does remain bu sy when either e rror bit is set. The WEL bit will be unchanged after this comma nd is\nexecuted.\nFigure 61.  Clear Status Registe r (CLSR 30h) Command SequenceCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDocument Number: 001-98284 Rev. *R Page 75 of 136S25FL512S\n9.3.11 ECC Status Regis ter Read (ECCRD 18h)\nTo read the ECC Status Register, the command is followed by the  ECC unit (16 Bytes) address, the four least significant bits ( LSb) of\naddress must be set to zero. This is followed by the number of dummy cycles selected by the read  latency value in  CR2V[3:0]. T hen\nthe 8-bit contents of the ECC Register, for the ECC unit select ed, are shifted out on SO 16 times, once for each byte in the E CC Unit.\nIf CS# remains low the next ECC unit status is sent through SO/ I/O1 16 times, once for each byt e in the ECC Unit, this continu es until\nCS# goes high. The maximum operating clock frequency for the EC C READ command is 133 MHz. See Section 9.5.1.1 Automatic\nECC on page 92  for details o n ECC unit.\nFigure 62.  ECC Status Register Read Command Sequence\n9.3.12 AutoBoot\nSPI devices normally require 32 or more cycles of command and a ddress shifting to initiate a read command. And, in order to re ad\nboot code from an SPI device, the host memory controller or pro cessor must supply the read command from a hardwired state mach ine\nor from some host processor internal ROM code.\nParallel NOR devices need only an initial address, supplied in parallel in a single cycle, and initial access time to start re ading boot\ncode.\nThe AutoBoot feature allows the host memory controller to take boot code from an S25FL512S device immediately after the end of\nreset, without having to send a read command. This saves 32 or more cycles and simplifies the logic needed to initiate the rea ding\nof boot code.\n■As part of the power up reset, ha rdware reset, or command reset  process the AutoBoot feature aut omatically starts a read acces s\nfrom a pre-specified address. At the time the reset process is completed, the device is ready to deliver code from the startin g address.\nThe host memory controller only needs to drive CS# signal from high to low and begin toggling the SCK signal. The S25FL512S\ndevice will delay code output for a pre-specified number of clo ck cycles before co de streams out.\n❐The Auto Boo t Start Delay (ABSD) field of the AutoB oot register  specifies the initial delay if any is needed by the host.\n❐The host cannot send commands during this time.\n❐If ABSD = 0, the maximum SCK frequency is 50 MHz.\n❐If ABSD > 0, the maximum SCK fr equency is 133 MHz if the QUAD b it CR1[1] is 0 or 104 MHz i f the QUAD bit is set to 1.\n■The starting address of the boot c ode is selected by the value programmed into the AutoBoot Sta rt Address (ABSA) field of the\nAutoBoot Register which specifi es a 512 byte boundary aligned l ocation; the default address is 00000000h.\n❐Data will continuously shift  out until CS# returns high.\n■At any point after the first dat a byte is transferred, when CS#  returns high, the SPI device will reset to standard SPI mode; able to\naccept normal command operations.\n❐A minimum of one byte must be transferred.\n❐AutoBoot mode will not initiate again until another power cycle  or a reset occurs.\n■An AutoBoot Enable bit  (ABE) is set to enabl e the AutoBoot feat ure.\nThe AutoBoot register bits are nonvolatile and provide:\n■The starting address (512-byte boundary), set by the AutoBoot S tart Address (ABSA). The size of the ABSA field is 23 bits for\ndevices up to 32-Gbit.\n■The number of in itial delay cycles, set by  the AutoBoot Start D elay (ABSD) 8-bit count value.\n■The AutoBoot Enable.\nIf the configuration register QUA D bit CR1[1] is set to 1, the boot code will be provided 4 bits per cycle in the same manner as a Read\nQuad Out command. If the QUAD bit  is 0 the code is delivered se rially in the same manner as a Read command.1321 0 987654 03 9 383736\nInstructio n32-Bit\nAddress\n31 2930 1 32 0\n1 32 0 765 44443424140 47 4645\n1 32 0 765 4Dummy Byt e5251504948 55 5453\nDATA OUT 1 DATA OUT 2SCK\nSI\nSO\nMSBHigh Impedance7\nMSBCS#\n1 32 0 765 4\nDocument Number: 001-98284 Rev. *R Page 76 of 136S25FL512S\nFigure 63.  AutoBoot Sequence (CR1[1]=0)\nFigure 64.  AutoBoot Sequence (CR1[1]=1)\n9.3.13 AutoBoot Regis ter Read (ABRD 14h)\nThe AutoBoot Register Read command is shifted into SI. Then the  32-bit AutoBoot Register is shif ted out on SO, LSB first, most\nsignificant bit of each byte first. It is possible to read the AutoBoot Register continuously by providing multiples of 32 clo ck cycles. If\nthe QUAD bit CR1[1] is cleared to 0, the maximum operating cloc k frequency for ABRD command is 133 MHz. If the QUAD bit CR1[1]\nis set to 1, the maximum operat ing clock frequency for ABRD com mand is 104 MHz.\nFigure 65.  AutoBoot Register Read (ABRD 14h) Command\n9.3.14 AutoBoot Regis ter Write (ABWR 15h)\nBefore the ABWR command can be accepted, a Write Enable (WREN) command must be issued and decoded by the device, which\nsets the Write Enable Latch (WEL)  in the Status Register to ena ble any write operations.\nThe ABWR command is entered by shifting the instruction and the  data bytes on SI, LSB first, most significant bit of each byte  first.\nThe ABWR data is 32 bits in length. \nThe ABWR command has status reported in Status Register-1 as bo th an erase and a programming operation. An E_ERR or a P_ERR\nmay be set depending on whether th e erase or programming phase of updating the register fails.\nCS# must be driven to the logic high state after the 32nd bit o f data has been latched. If not, the ABWR command is not execut ed.\nAs soon as CS# is driven to the logic high state, the self-time d ABWR operation is initiated. While the ABWR operation is in p rogress,\nStatus Register-1 may be read to check the value of the Write-I n Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 du ring the\nself-timed ABWR operation, and is a 0. when it is completed. Wh en the ABWR cycle is completed, the Write Enable Latch (WEL) is\nset to a 0. The maximu m clock frequency for the ABWR command is  133 MHz.CS#\nSCK\nSI\nSO\nPhase7654321076543210\nWait States (ABSD) Data 1 Data N\nCS#\nSCK\nIO0\nIO1IO2IO3\nPhase \n                                               \n40404040404\n51515151515\n62626262626\n73737373737\nWait States (ABSD) Data 1 Data 2 Data 3 Data 4 Data 5 ...\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nDocument Number: 001-98284 Rev. *R Page 77 of 136S25FL512S\nFigure 66.  AutoBoot Register Write (ABWR) Command\n9.3.15 Program NVDLR (PNVDLR 43h)\nBefore the Program NVDLR (PNVDLR) command can be accepted by th e device, a Write Enable (WREN) command must be issued\nand decoded by the device. After the Write Enable (WREN) comman d has been decoded successfully, the device will set the Write\nEnable Latch (WEL) to ena ble the PNVDLR operation.\nThe PNVDLR command is entered by  shifting the instruction and t he data byte on SI. \nCS# must be driven to the logic high state after the eighth (8t h) bit of data has been latched. I f not, the PNVDLR command is not\nexecuted. As soon as CS# is driv en to the logic high state, the  self-timed PNVDLR operation is initiated. While the PNVDLR ope ration\nis in progress, the Status Register may be read to check the va lue of the Write-In Progress (WIP ) bit. The Write-In Progress ( WIP) bit\nis a 1 during the self-timed PNVDLR cycle, and is a 0. when it is completed. The PNVDLR operation can report a program error i n the\nP_ERR bit of the status register. When the PNVDLR operation is completed, the Write Enable Latch (WEL) is set to a 0 The maxim um\nclock frequency for the PN VDLR command is 133 MHz.\nFigure 67.  Program NVDLR (PNVDLR 43h) Command Sequence\n9.3.16 Write VDLR (WVDLR 4Ah)\nBefore the Write VDLR (WVDLR) command can be accepted by the de vice, a Write Enable (WREN) command must be issued and\ndecoded by the device. After the Write Enable (WREN) command ha s been decoded successfully, the device will set the Write Enab le\nLatch (WEL) to enable WVDLR operation.\nThe WVDLR command is entered by shifting the instruction and th e data byte on SI.\nCS# must be driven to the logic high state after the eighth (8t h) bit of data has been latched. If not, the WVDLR command is n ot\nexecuted. As soon as CS# is driven to the logic high state, the  WVDLR operation is initiated with no delays. The maximum clock\nfrequency for the PNVDLR command is 133 MHz.\nFigure 68.  Write VDLR (WVDLR 4Ah) Command SequenceCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7\nInstruction Input Data 1\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Input Data\nCS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Data\nDocument Number: 001-98284 Rev. *R Page 78 of 136S25FL512S\n9.3.17 Data Learning Patt ern Read (DLPRD 41h)\nThe instruction is shifted on SI, then the 8-bit DLP is shifted  out on SO. It is possible to re ad the DLP continuously by prov iding multiples\nof eight clock cycles. The maxi mum operating cl ock frequency fo r the DLPRD command is 133 MHz.\nFigure 69.  DLP Read (DLPRD 41h) Command Sequence\n9.4 Read Memory Array Commands\nRead commands for the main flash array prov ide many options for  prior generation SPI  compatibility or enha nced performance SPI :\n■Some commands transfer address or data on each rising edge of S CK. These are called Single Data Rate commands (SDR).\n■Some SDR commands transfer address one bit per rising edge of S CK and return data 1, 2, or 4 b its of data per rising edge of S CK.\nThese are called Read or Fast Rea d for 1-bit data ; Dual Output Read for 2-bit data, and Q uad Output for 4-bit data.\n■Some SDR commands transfer both address and data 2 or 4 bits pe r rising edge of SCK. These are called Dual I/O for 2 bit and\nQuad I/O for 4 bit.\n■Some commands transfer address and data on both the rising edge  and falling edge of SCK. These are called Double Data Rate\n(DDR) commands.\n■There are DDR commands for 1, 2, or 4 bits of address or data p er SCK edge. These are called Fa st DDR for 1-bit, Dual I/O DDR\nfor 2-bit, and Quad  I/O DDR for 4-bit per edge transfer.\nAll of these commands begin with an instruction code that is tr ansferred one bit per SCK rising edge. The instruction is follo wed by\neither a 3- or 4-byte address transferred at SDR or DDR. Comman ds transferring address or data 2 or 4 bits per clock edge are called\nMultiple I/O (MIO) commands . For FL-S devices at \n256 Mb or higher density, the traditional SPI 3-byte addresses are unable to directly address all locations in the memory arra y. These\ndevice have a bank address register that is used with 3-byte ad dress commands to supply the high order address bits beyond the\naddress from the host system. The default bank address is zero.  Commands are provided to load and read the bank address regist er.\nThese devices may also be configured to take a 4-byte address f rom the host system with the tr aditional 3-byte address command s.\nThe 4-byte address mode for traditional commands is activated b y setting the External Address (EXTADD) bit in the bank address\nregister to 1.\nThe Quad I/O commands provide a performance improvement option controlled by mode bits that are sent following the address bit s.\nThe mode bits indicate whether the command following the end of  the current read will be another  read of the same type, withou t an\ninstruction at the beginning of the read. These mode bits give the option to eliminate the instru ction cycles when doing a ser ies of\nQuad I/O read accesses.\nA device ordering option provides an enhanced high performance option by adding a similar mode bit scheme to the DDR Fast Read ,\nDual I/O, and Dual I/O DDR comma nds, in addition to the Quad I/ O command.\nSome commands require delay cycl es following the address or mod e bits to allow time to access the memory array. The delay cycl es\nare traditionally called dummy c ycles. The dummy cycles are ign ored by the memory thus any data provided by the host during th ese\ncycles is “don’t care” and the host may also leave the SI signa l at high impedance during the dummy cycles. When MIO commands\nare used the host must stop dri ving the I/O signals (outputs ar e high impedance) before the end of last dummy cycle. When DDR\ncommands are used the host must not drive the I/O signals durin g any dummy cycle. The number of  dummy cycles varies with the\nSCK frequency or performance opt ion selected via the Configurat ion Register 1 (CR1) Latency Code (LC). Dummy cycles are\nmeasured from SCK falling edge to next SCK falling edge. SPI ou tputs are traditionally driven to a new value on the falling ed ge of\neach SCK. Zero dummy cycles means the returning data is driven by the memory on the same falling edge of SCK that the host sto ps\ndriving address or mode bits.\nThe DDR commands may optionally have an 8-edge Data Learning Pa ttern (DLP) driven by the memo ry, on all data outputs, in the\ndummy cycles immediately before t he start of data. The DLP can help the host memory controller de termine the phase shift from SCK\nto data edges so that t he memory controller can capture data at  the center of the data eye.\nWhen using SDR I/O commands at higher SCK frequencies (>50 MHz) , an LC that provides 1 or more dummy cycles should be\nselected to allow additional time for the host to stop driving before the memory starts driving data, to minimize I/O driver c onflict. When\nusing DDR I/O commands with the DLP enabled, an LC that provide s 5 or more dummy cycles should be selected to allow 1 cycle of\nadditional time for the host to stop driving befor e the memory starts driving t he 4 cycle DLP.CS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\n7 6 5 43 2 1 0 7 6 5 4 3 2 1 0\nInstruction Data 1 Data N\nDocument Number: 001-98284 Rev. *R Page 79 of 136S25FL512S\nEach read command ends when CS# is returned High at any point d uring data return. CS# must not be returned High during the mod e\nor dummy cycles before data returns as this may cause mode bits  to be captured incorrectly; making it indeterminate as to whet her\nthe device remains in enhanc ed high performance read mode.\n9.4.1 Read (Read 03h or 4READ 13h)\nThe instruction \n■03h (ExtAdd=0) is followed by a  3-byte address (A23-A0) or\n■03h (ExtAdd=1) is followed by a  4-byte address (A31-A0) or\n■13h is followed by a 4-b yte address (A31-A0)\nThen the memory contents, at th e address given, are shifted out  on SO. The maximum operating clock frequency for the READ\ncommand is 50 MHz.\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nFigure 70.  Read Command S equence (READ 03h or 13h)\n9.4.2 Fast Read (FAST_RE AD 0Bh or 4FAST_READ 0Ch)\nThe instruction\n■0Bh (ExtAdd=0) is followed by  a 3-byte address (A23-A0) or\n■0Bh (ExtAdd=1) is followed by  a 4-byte address (A31-A0) or\n■0Ch is followed by a 4 -byte address (A31-A0)\nThe address is followed by zero or eight dummy cycles depending  on the latency code set in the Configuration Register. The dum my\ncycles allow the device internal c ircuits additional time for a ccessing the initial address location. During the dummy cycles the data\nvalue on SO is “don’t care” and may be high impedance. Then the  memory contents, at the addre ss given, are shifted out on SO.\nThe maximum operating clock fre quency for FAST READ command is 133 MHz.\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nFigure 71.  Fast Read (FAST_READ 0Bh or 0Ch) Command Sequence w ith Read Latency\nFigure 72.  Fast Read Command (FAST_READ 0Bh or 0Ch) Sequence w ithout Read LatencyCS#\nSCK\nSI\nSO\nPhase \n                                                \n76543210A 10  \n7654321076543210  \nInstruction Address Data 1 Data N\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n76543210A 10  \n76543210  \nInstruction Address     Dummy Cycles Data 1\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n76543210A 10  \n7654321076543210  \nInstruction Address Data 1 Data N\nDocument Number: 001-98284 Rev. *R Page 80 of 136S25FL512S\n9.4.3 Dual Output Read (DOR 3Bh or 4DOR 3Ch)\nThe instruction \n■3Bh (ExtAdd=0) is followed by  a 3-byte address (A23-A0) or\n■3Bh (ExtAdd=1) is followed by  a 4-byte address (A31-A0) or\n■3Ch is followed by a 4 -byte address (A31-A0)\nThen the memory contents, at the address given, is shifted out two bits at a time through I/O0 (SI) and I/O1 (SO). Two bits ar e shifted\nout at the SCK frequency by the f alling edge of the SCK signal.\nThe maximum operating clock frequency for the Dual Output Read command is 104 MHz. For Dual Output Read commands, there\nare zero or eight dummy cycles r equired after the last address bit is shifted into SI before data begins shifting out of I/O0 and I/O1.\nThis latency period (i.e., dummy  cycles) allows t he device’s in ternal circuitry enough time to r ead from the initial address. During the\ndummy cycles, the data value on SI is a “don’t care” and may be  high impedance. The num ber of dummy cycles is determined by th e\nfrequency of SCK (refer to Table 22 on page 50 ).\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nFigure 73.   Dual Output Read Command Sequence (3-Byte Address,  3Bh [ExtAdd=0], LC=10b)\nFigure 74.  Dual Output Read Com mand Sequence (4-Byte Address, 3Ch or 3Bh [ExtAdd=1, LC=10b])\nFigure 75.  Dual Output Read Com mand Sequence (4-Byte Address, 3Ch or 3Bh [ExtAdd=1, LC=11b])CS#\nSCK\nIO0\nIO1\nPhase765432102322210 64206420\n75317531\nInstruction 8 Dummy Cycles Data 1 Data 2 Address\nCS#\nSCK\nIO0\nIO1\nPhase765432103130290 64206420\n75317531\nInstruction 8 Dummy Cycles Data 1 Data 2 Address\nCS#\nSCK\nIO0\nIO1\nPhase76543210313029064206420\n75317531\nInstruction Data 1 Data 2 Address\nDocument Number: 001-98284 Rev. *R Page 81 of 136S25FL512S\n9.4.4 Quad Output Read ( QOR 6Bh or 4QOR 6Ch)\nThe instruction \n■6Bh (ExtAdd=0) is followed by  a 3-byte address (A23-A0) or\n■6Bh (ExtAdd=1) is followed by  a 4-byte address (A31-A0) or\n■6Ch is followed by a 4 -byte address (A31-A0)\nThen the memory contents, at the address given, is shifted out four bits at a time through I/O0-I/O3. Each nibble (4 bits) is shifted out\nat the SCK frequency by the f alling edge of the SCK signal.\nThe maximum operating clock frequ ency for Quad Output Read comm and is 104 MHz. For Quad Output Read Mode, there may be\ndummy cycles required after the last address bit is shifted int o SI before data begins shifting out of I/O0-I/O3. This latency  period (i.e.,\ndummy cycles) allows the device’s  internal circuitry enough tim e to set up for the initial addr ess. During the dummy cycles, t he data\nvalue on I/O0-I/O3 is a “don’t care” and may be high impedance.  The number of dummy cycles is det ermined by the frequency of S CK\n(refer to Table 22 on page 50 ).\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nThe QUAD bit of Configuration Re gister must be set (CR Bit1=1) to enable the Quad mode capability.\nFigure 76.  Quad Output Read (QOR 6Bh or 4QOR 6Ch) Command Sequ ence with Read Latency\nFigure 77.  Quad Output Read (QOR 6Bh or 4QOR 6Ch) Command Sequ ence without Read LatencyCS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                                              \n76543210A 10 40404040404\n51515151515\n62626262626\n73737373737\nInstruction Address Dummy D1D2D3D4D5\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                               \n7 6 5 4 3 2 1 0 A  1 0 4 0 4 0 4 0 4 0 4 0 4\n5 1 5 1 5 1 5 1 5 1 5\n6 2 6 2 6 2 6 2 6 2 6\n7 3 7 3 7 3 7 3 7 3 7\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nDocument Number: 001-98284 Rev. *R Page 82 of 136S25FL512S\n9.4.5 Dual I/O Read (DI OR BBh or 4DIOR BCh)\nThe instruction \n■BBh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n■BBh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n■BCh is followed by a 4 -byte address (A31-A0)\nThe Dual I/O Read commands improve throughput with two I/O sign als — I/O0 (SI) and I/O1 (SO). It is similar to the Dual Output\nRead command but takes input of the address two bits per SCK ri sing edge. In some applications, the reduced address input time\nmight allow for code execution in  place (XIP) i.e. directly fro m the memory device.\nThe maximum operating clock fre quency for Dual I/O Read is 104 MHz.\nFor the Dual I/O Read command, there is a latency required afte r the last address bits are shift ed into SI and SO before data begins\nshifting out of I/O0 and I/O1. There are different ordering par t numbers that select the latency code table used for this comm and, either\nthe High Performance LC (HPLC) table or the Enhanced High Perfo rmance LC (EHPLC) table. The HPLC table does not provide\ncycles for mode bits so each Dual I/O Read command starts with the 8 bit instruction, followed by address, followed by a laten cy period.\nThis latency period (dummy cycles ) allows the device internal c ircuitry enough time to access data at the initial address. Dur ing the\ndummy cycles, the data value on SI  and SO are “don’t care” and may be high impedance. The num ber of dummy cycles is determined\nby the frequency of SCK ( Table 22 on page 50 ). The number of dummy cycles is set by the LC bits in the Conf iguration Register (CR1).\nThe EHPLC table does provide cycles for mode bits so a series o f Dual I/O Read commands may eliminate the 8-bit instruction af ter\nthe first Dual I/O Read command s ends a mode bit pattern of Axh  that indicates the following command will also be a Dual I/O R ead\ncommand. The first Dual I/O Read command in a series starts wit h the 8-bit instruction, followe d by address, followed by four cycles\nof mode bits, followed by a latency period. If the mode bit pat tern is Axh the next command is assumed to be an additional Dua l I/O\nRead command that does not provide instruction bits. That comma nd starts with address, followed by mode bits, followed by late ncy.\nThe Enhanced High Performance feature removes the need for the instruction sequence and greatly improves code execution (XIP).\nThe upper nibble (bits 7-4) of t he Mode bits control the length  of the next Dual I/O Read command through the inclusion or exc lusion\nof the first byte inst ruction code. The low er nibble (bits 3-0)  of the Mode bits are “don’t care ” (“x”) and may be high impeda nce. If the\nMode bits equal Axh, then the device remains in Dual I/O Enhanc ed High Performance Read Mode and the next address can be\nentered (after CS# is raised high and then asserted low) withou t the BBh or BCh instruction, as shown in Figure 81 ; thus, eliminating\neight cycles for the command sequence. The following sequences will release the device from Dual  I/O Enhanced High Performance\nRead mode; after which,  the device can acce pt standard SPI comm ands:\n1. During the Dual I/O Enhanced H igh Performance Command Sequenc e, if the Mode bits a re any value other than Axh, then the \nnext time CS# is raised high th e device will be released from D ual I/O Read Enhanced High Performance Read mode.\nDuring any operation, if CS# toggles high to low to high for ei ght cycles (or less) and data input (I/O0 and I/O1) are not set  for a valid\ninstruction sequence, then the device will be released from Dua l I/O Enhanced High Performance Read mode. Note that the four\nmode bit cycles are part of the device’s internal circuitry lat ency time to access the initial address after the last address cycle that is\nclocked into I/O0 (SI) and I/O1 (SO).\nIt is important that the I/O signals be set to high-impedance a t or before the falling edge of  the first data out clock. At hi gher clock\nspeeds the time available to turn off the host outputs before t he memory device begins to drive (bus turn around) is diminishe d. It is\nallowed and may be helpful in preventing I/O signal contention,  for the host system to turn off the I/O signal outputs (make t hem high\nimpedance) during the last two “don’t care” mode cycles or duri ng any dummy cycles.\nFollowing the latency period the memory content, at the address  given, is shifted out two bits at a time through I/O0 (SI) and  I/O1\n(SO). Two bits are shifted out  at the SCK frequency at the fall ing edge of SCK signal.\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nCS# should not be driven high dur ing mode or dummy  bits as this  may make the mode  bits indeterminate.\nDocument Number: 001-98284 Rev. *R Page 83 of 136S25FL512S\nFigure 78.  Dual I/O Read Comm and Sequence (3-Byte Address, BBh  [ExtAdd=0], HPLC=00b)\nFigure 79.  Dual I/O Read Comm and Sequence (4-Byte Address, BBh  [ExtAdd=1], HPLC=10b)\nFigure 80.  Dual I/O Read Command Sequence (4-Byte Address, BCh  or BBh [ExtAdd=1], EHPLC=10b)\nFigure 81.  Continuous Dual I/O Read Command Sequence (4-Byte A ddress, BCh or BBh [ExtAdd=1], EHPLC=10b)CS#\nSCK\nIO0\nIO1\nPhase765432102220180 64206420\n2321191 75317531\nInstruction Address 4 Dummy Data 1 Data 2\nCS#\nSCK\nIO0\nIO1\nPhase765432103028260 64206420\n3129271 75317531\nInstruction 6 Dummy Data 1 Data 2 Address\nCS#\nSCK\nIO0\nIO1\nPhase \n                                                      \n7654321030  206420 64206420 \n31  317531 75317531 \nInstruction Address Mode Dum Data 1 Data 2\nCS#\nSCK\nIO0\nIO1\nPhase  \n                                                 \n6420 30  206420 64206420 \n7531 31  317531 75317531 \nData N Address Mode Dum Data 1 Data 2\nDocument Number: 001-98284 Rev. *R Page 84 of 136S25FL512S\n9.4.6 Quad I/O Read (QIOR EBh or 4QIOR ECh)\nThe instruction\n■EBh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n■EBh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n■ECh is followed by a 4 -byte address (A31-A0)\nThe Quad I/O Read command improves throughput with four I/O sig nals — I/O0-I/O3. It is similar to the Quad Output Read command\nbut allows input of the address bits four bits per serial SCK c lock. In some applications, the reduced instruction overhead mi ght allow\nfor code execution (XIP) directly from the S25FL512S device. Th e QUAD bit of the Configuration Register must be set (CR Bit1=1 )\nto enable the Quad capabili ty of the S25FL512S device.\nThe maximum operating clock fre quency for Quad I/O Read is 104 MHz.\nFor the Quad I/O Read command, there is a latency required afte r the mode bits (described bel ow) before data begins shifting o ut of\nI/O0-I/O3. This latency period (i.e., dummy cycles) allows the device’s internal circuitry enough time to access data at the i nitial\naddress. During latency cycles, the data value on I/O0-I/O3 are  “don’t care” and may be high impedance. The number of dummy\ncycles is determined by the frequ ency of SCK and the latency co de table (refer to Table 22 on page 50 ). There are different ordering\npart numbers that select the latency code table used for this c ommand, either the High Performance LC (HPLC) table or the Enha nced\nHigh Performance LC (EHPLC) table. The number of dummy cycles i s set by the LC bits in the Conf iguration Register (CR1). Howev er,\nboth latency code tabl es use the same latency values for the Qu ad I/O Read command.\nFollowing the latency period, t he memory contents at the addres s given, is shifted out four bits at a time through I/O0-I/O3. Each nibble\n(4 bits) is shifted out at the SCK frequency by the falling edg e of the SCK signal.\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nAddress jumps can be done without the need for additional Quad I/O Read instructions. This is controlled through the setting o f the\nMode bits (after the address sequence, as shown in Figure 82 on page 85  or Figure 84 on page 85 ). This added feature removes the\nneed for the instruction sequence and greatly improves code exe cution (XIP). The upper nibble (bits 7-4) of the Mode bits cont rol the\nlength of the next Quad  I/O instruction through the inclusion o r exclusion of the first byte instruction code. The lower nibbl e (bits 3-0)\nof the Mode bits are “don’t care” (“x”). If the Mode bits equal  Axh, then the device remains in Quad I/O High Performance Read  Mode\nand the next address can be entered (after CS# is raised high a nd then asserted low) without requiring the EBh or ECh instruct ion,\nas shown in Figure 83 on page 85  or Figure 85 on page 85 ; thus, eliminating eight cycles  for the command sequence. The following\nsequences will release the device from Quad I/O High Performanc e Read mode; after which, the device can accept standard SPI\ncommands:\n1. During the Quad I/O Read Comman d Sequence, if  the Mode bits a re any value other than Axh, then  the next time CS# is raised \nhigh the device will be released f rom Quad I/O High Performance  Read mode.\nDuring any operation, if CS# toggles high to low to high for ei ght cycles (or less) and data inp ut (I/O0-I/O3) are not set for  a valid\ninstruction sequence, then the device will be released from Qua d I/O High Performance Read mode. Note that the two mode bit cl ock\ncycles and additional wait states  (i.e., dummy cycles) allow th e device’s internal circuitry latency time to access the initia l address\nafter the last address cycle t hat is clocked into I/O0-I/O3.\nIt is important that the I/O0-I/O3 signals be set to high-imped ance at or before the falling edge of the first data out clock.  At higher\nclock speeds the time available to turn off the host outputs be fore the memory device begins to drive (bus turn around) is dim inished.\nIt is allowed and may be helpful i n preventing I/O0-I/O3 signal  contention, for the h ost system to tu rn off the I/O0-I/O3 sign al outputs\n(make them high impedance) during the last “don’t care” mode cy cle or during an y dummy cycles.\nCS# should not be driven high dur ing mode or dummy  bits as this  may make the mode  bits indeterminate.\nDocument Number: 001-98284 Rev. *R Page 85 of 136S25FL512S\nFigure 82.  Quad I/O Read Command  Sequence (3-Byte Address, EBh  [ExtAdd=0], LC=00b)\nFigure 83.  Continuous Quad I/O Read Command Sequence (3-Byte A ddress), LC=00b\nFigure 84.  Quad I/O Read Command  Sequence(4-Byte Address, ECh or EBh [ExtAdd=1], LC=00b)\nFigure 85.  Continuous Quad I/O Read Command Sequence (4-Byte A ddress), LC=00bCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                     \n7654321020  4040 40404040  \n21  5151 51515151  \n22  6262 62626262  \n23  7373 73737373  \nInstruction Address Mode Dummy D1 D2 D3 D4\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase  \n                                                  \n40 4 0 20  4 0 4 0 4 0 4 06 4 2 0  \n51 5 1 21  5 1 5 1 5 1 5 17 5 3 1 \n6 2 6 2 22  6 2 6 2 6 26 1 7 5 3 1 \n7 3 7 3 23  7 3 7 3 7 37 1 7 5 3 1 \nDN-1 D N Address Mode Dummy D1 D  2 D 3 D 4\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                     \n7654321028  4040 40404040  \n29  5151 51515151  \n30  6262 62626262  \n31  7373 73737373  \nInstruction Address Mode Dummy D 1 D 2 D 3 D 4\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase  \n                                                  \n40 4 0 28  4 0 4 0 4 0 4 06 4 2 0  \n51 5 1 29  5 1 5 1 5 1 5 17 5 3 1 \n6 2 6 2 30  6 2 6 2 6 26 1 7 5 3 1 \n7 3 7 3 31  7 3 7 3 7 37 1 7 5 3 1 \nDN-1 D N Address Mode Dummy D 1 D 2 D 3 D 4\nDocument Number: 001-98284 Rev. *R Page 86 of 136S25FL512S\n9.4.7 DDR Fast Read (D DRFR 0Dh, 4DDRFR 0Eh)\nThe instruction \n■0Dh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n■0Dh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n■0Eh is followed by a 4 -byte address (A31-A0)\nThe DDR Fast Read command improves throughput by transferring a ddress and data on both the falling and rising edge of SCK. It\nis similar to the Fast Read com mand but allows transfer of addr ess and data on every edge of the clock.\nThe maximum operating clock fr equency for DDR Fast Read command  is 80 MHz.\nFor the DDR Fast Read command, t here is a latency required afte r the last address bits are shifted into SI before data begins shifting\nout of SO. There are different ordering part numbers that selec t the latency code table used for this command, either the High\nPerformance LC (HPLC) table or the Enhanced High Performance LC  (EHPLC) table. The HPLC table does not provide cycles for\nmode bits so each DDR Fast Read c ommand starts with the 8-bit i nstruction, followed by address, followed by a latency period.\nThis latency period (dummy cycles ) allows the device internal c ircuitry enough time to access data at the initial address. Dur ing the\ndummy cycles, the data value on SI is “don’t care” and may be h igh impedance. The number of dummy cycles is determined by the\nfrequency of SCK (see Table 22 on page 50 ). The number of dummy cycles is set by the LC bits in the Conf iguration Register (CR1).\nThen the memory contents, at the address given, is shifted out,  in DDR fashion, one bit at a time on each clock edge through S O.\nEach bit is shifted out at the SCK frequency by the rising and falling edge of t he SCK signal.\nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nThe EHPLC table does provide cycl es for mode bits so a series o f DDR Fast Read commands may eliminate the 8-bit instruction af ter\nthe first DDR Fast Read command sends a mode bit pattern of com plementary first and second Nibbl es, e.g. A5h, 5Ah, 0Fh, etc., that\nindicates the following command will also be a DDR Fast Read co mmand. The first DDR Fast Read co mmand in a series starts with\nthe 8-bit instruction, followed by address, followed by four cy cles of mode bits, followed by a latency period. If the mode bi t pattern is\ncomplementary the next command is assumed to be an additional D DR Fast Read command that does not provide instruction bits.\nThat command starts with addre ss, followed by mode bits, follow ed by latency.\nWhen the EHPLC table is used, address jumps can be done without  the need for additional DDR Fast Read instructions. This is\ncontrolled through the setting of the Mode bits (after the addr ess sequence, as shown in Figure 86 on page 87  and Figure 88\non page 87 . This added feature removes th e need for the ei ght bit SDR ins truction sequence to reduce in itial access time (improves\nXIP performance). The Mode bits control the length of the next DDR Fast Read operation through the inclusion or exclusion of t he\nfirst byte instruction code. If the upper nibble (I/O[7:4]) and  lower nibble (I/O[3:0]) of the Mode bits are complementary (i. e. 5h and Ah)\nthen the next address can be enter ed (after CS# is raised high and then asserted low) without requiring the 0Dh or 0Eh instruc tion,\nas shown in Figure 87  and Figure 89 , thus, eliminating eight cycles from the command sequence. The  following sequences will release\nthe device from this continuous  DDR Fast Read mode; after which , the device can accept  standard SPI commands:\n1. During the DDR Fast Read Command  Sequence, if the Mode bits a re not complementary the next t ime CS# is raised high the \ndevice will be released from t he continuous DDR Fast Read mode.\n2. During any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (SI) are not set for a va lid instruction \nsequence, then the device will b e released from DDR Fast Read m ode. \nCS# should not be driven high dur ing mode or dummy  bits as this  may make the mode  bits indeterminate.\nThe HOLD function is not valid  during any part of a Fast DDR Co mmand. \nAlthough the data learning pattern (DLP) is programmable, the f ollowing example shows example of the DLP of 34h. The DLP 34h\n(or 00110100) will be driven on each of the active outputs (i.e . all four I/Os on a x4 device, both I/Os on a x2 device and th e single\nSO output on a x1 device). This pattern was chosen to cover bot h DC and AC data transition scenarios. The two DC transition\nscenarios include data low for a long period of time (two half clocks) followed by a high going transition (001) and the compl ementary\nlow going transition (110). The tw o AC transition scenarios inc lude data low for a short period of time (one half clock) follo wed by a\nhigh going transition (101) and the complementary low going tra nsition (010). The DC transitions will typically occur with a s tarting\npoint closer to the supply rail than the AC transitions that ma y not have fully settled to their steady state (DC) levels. In many cases\nthe DC transitions will bound the beginning of the data valid p eriod and the AC transitions will bound the ending of the data valid\nperiod. These transitions will allow the host controller to ide ntify the beginning and ending of  the valid data eye. Once the data eye\nhas been characterized the opti mal data capture point can be ch osen. See Section 7.6.12 SPI DDR Data Learning Registers\non page 55  for more details. \nDocument Number: 001-98284 Rev. *R Page 87 of 136S25FL512S\nFigure 86.  DDR Fast R ead Initial Ac cess (3-Byte Address, 0Dh [ ExtAdd=0, EHPLC=11b])\nFigure 87.  Continuo us DDR Fast Read Subse quent Access (3-Byte Address [ExtAdd=0, EHPLC=11b])\nFigure 88.  DDR Fast R ead Initial Access (4-B yte Address, 0Eh o r 0Dh [ExtAdd=1], EHPLC=01b)[47]\nFigure 89.  Continuous DDR Fast  Read Subsequent Access (4-Byte Address [ExtAdd=1], EHPLC=01b)[47]\nFigure 90.  DDR Fast R ead Subsequent Access (4-Byte Address, HP LC=01b)CS#\nSCK\nSI\nSO\nPhase \n                                               \n7 6 5 4 3 2 1 02322 076543210  \n7654321076543210\nInstruction Address Mode Dummy Data 1 Data 2\nCS#\nSCK\nIO0\nIO1\nPhase \n                          \n23 1076543210  \n7654321076\nAddress Mode Dum Data 1 D2\nCS#\nSCK\nSI\nSO\nPhase \n                                               \n7 6 5 4 3 2 1 0 31 1076543210  \n7 6 5 4 321 0 7654321076\nInstruction Address Mode DLP Data 1 D2\nCS#\nSCK\nSI\nSO\nPhase \n                                \n31 1076543210  \n7   6 5   4 321   0 7654321076\nAddress Mode DLP Data 1 D2\nNote\n47. Example DLP of 34h (or 00110100).CS#\nSCK\nSI\nSO\nPhase \n                                            \n7 6 5 4 3 2 1 0 3.10  \n7654321076\nInstruction Address Dummy Data 1 D2\nDocument Number: 001-98284 Rev. *R Page 88 of 136S25FL512S\n9.4.8 DDR Dual I/O Read (BDh, BEh)\nThe instruction \n■BDh (ExtAdd=0) is followed b y a 3-byte address (A23-A0) or\n■BDh (ExtAdd=1) is followed b y a 4-byte address (A31-A0) or\n■BEh is followed by a 4-byte address (A31-A0)\nThen the memory contents, at th e address given, is shifted out,  in a DDR fashion, two bits at a time on each clock edge throug h I/O0\n(SI) and I/O1 (SO). Two bits are shifted out at the SCK frequen cy by the rising and falling edge of the SCK signal.\nThe DDR Dual I/O Read command improves throughput with two I/O signals — I/O0 (SI) and I/O1 (SO). It is similar to the Dual I/ O\nRead command but transfers two a ddress, mode, or data bits on e very edge of the clock. In some applications, the reduced instr uction\noverhead might allow for code exec ution (XIP) directly from the  S25FL512S device.\nThe maximum operating clock frequency for DDR Dual I/O Read com mand is 80 MHz.\nFor DDR Dual I/O Read commands, t here is a laten cy required aft er the last address bits are s hifted into I/O0 and I/O1, before  data\nbegins shifting out of I/O0 and I/O1. There are different order ing part numbers that select th e latency code table used for th is command,\neither the High Performance LC (HPLC) table or the Enhanced Hig h Performance LC (EHPLC) table. The number of latency (dummy)\nclocks is determined by the frequency of SCK (refer to Table 21 on page 50  or Table 23 on page 51 ). The number of dummy cycles\nis set by the LC bits in the Configuration Register (CR1).\nThe HPLC table does not provide cycles for mode bits so each Du al I/O command starts with the 8 bit instruction, followed by a ddress,\nfollowed by a latency period. This latency period allows the de vice’s internal circuitry enough time to access the initial add ress. During\nthese latency cycles, the data v alue on SI (I/O0) and SO (I/O1)  are “don’t care” and may be high impedance. When the Data Lear ning\nPattern (DLP) is enabled the host system must not drive the I/O  signals during the dummy cycles. The I/O signals must be left high\nimpedance by the host so that the  memory device can drive the D LP during the dummy cycles.\nThe EHPLC table does provide cycles  for mode bits so a series o f Dual I/O DDR commands may elimi nate the 8 bit i nstruction aft er\nthe first command sends a complementary mode bit pattern, as sh own in Figure 91  and Figure 93 on page 89 . This added feature\nremoves the need for the eight bit SDR instruction sequence and  dramatically reduces initial a ccess times (improves XIP perfor -\nmance). The Mode bits control the length of the next DDR Dual I /O Read operation through the inclusion or exclusion of the fir st byte\ninstruction code. If the upper nibble (I/O[7:4]) and lower nibb le (I/O[3:0]) of the Mode bits are complementary (i.e. 5h and A h) the\ndevice transitions to Continuous DDR Dual I/O Read Mode and the  next address can be entered (af ter CS# is raised high and then\nasserted low) without requiring the BDh or BEh instruction, as shown in Figure 92 on page 89 , and thus, eliminating eight cycles from\nthe command sequence. The followin g sequences will release the device from Continuous DDR Dual I/O Read mode; after which,\nthe device can accept standard SPI commands:\n1. During the DDR Dual I/O Read Command Sequence, if the Mode bi ts are not complementary the next time CS# is raised high and \nthen asserted low the device will be released from DDR Dual I/O  Read mode.\n2. During any operation, if CS# t oggles high to low to high for eight cycles (or less)  and data in put (I/O0 and I/ O1) are not s et for a \nvalid instruction sequence, t hen the device will be released fr om DDR Dual I/O Read mode. \nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nCS# should not be driven high dur ing mode or dummy bits as this  may make the mode bits indeterminate. The HOLD function is not\nvalid during Dual I/O DDR commands.\nNote that the memory devices may drive the I/Os with a preamble  prior to the first data value. The preamble is a data learning  pattern\n(DLP) that is used by the host c ontroller to optimize data capt ure at higher frequencies. The pr eamble DLP drives the I/O bus for the\nfour clock cycles immediately bef ore data is out put. The host m ust be sure to stop driving the I/O bus prior to the time that the memory\nstarts outputting the preamble.\nThe preamble is intended to give the host controller an indicat ion about the round trip time from when the host drives a clock  edge to\nwhen the corresponding data value returns from the memory devic e. The host controller will skew the data capture point during the\npreamble period to optimize timing margins and then use the sam e skew time to capture the data during the rest of the read ope ration.\nThe optimized capture point will be determined during the pream ble period of every read operatio n. This optimization strategy is\nintended to compensate for both  the PVT (process, voltage, temp erature) of both the memory device and the host controller as w ell\nas any system level delays ca used by flight ti me on the PCB.\nDocument Number: 001-98284 Rev. *R Page 89 of 136S25FL512S\nAlthough the data learning pattern (DLP) is programmable, the f ollowing example shows example of the DLP of 34h. The DLP 34h\n(or 00110100) will be driven on each of the active outputs (i.e . all four SIOs on a x4  device, both SIOs on a x2 device and th e single\nSO output on a x1 device). This pattern was chosen to cover bot h DC and AC data transition scenarios. The two DC transition\nscenarios include data low for a long period of time (two half clocks) followed by a high going transition (001) and the compl ementary\nlow going transition (110). The tw o AC transition scenarios inc lude data low for a short period of time (one half clock) follo wed by a\nhigh going transition (101) and the complementary low going tra nsition (010). The DC transitions will typically occur with a s tarting\npoint closer to the supply rail than the AC transitions that ma y not have fully settled to their steady state (DC) levels. In many cases\nthe DC transitions will bound the beginning of the data valid p eriod and the AC transitions will bound the ending of the data valid\nperiod. These transitions will allow the host controller to ide ntify the beginning and ending of  the valid data eye. Once the data eye\nhas been characterized the opti mal data capture point can be ch osen. See Section 7.6.12 SPI DDR Data Learning Registers\non page 55  for more details.\nFigure 91.  DDR Dual I/O Read Initial Access (4-Byte Address, B Eh or BDh [ExtAdd=1], EHPLC= 01b)\nFigure 92.  Continuous  DDR Dual I/O Read Su bsequent Access (4-B yte Address, EHPLC= 01b)\nFigure 93.  DDR Dual I/O Read (4- Byte Address, BEh or BDh [ExtA dd=1], HPLC=00b)CS#\nSCK\nIO0\nIO1\nPhase \n                                        \n7 6 5 4 3 2 1 0 3028 06420 7  6 5  4 321  0 64206 \n3129 17531 7  6 5  4 321  0 75317 \nInstruction Address Mode Dum DLP Data 1\nCS#\nSCK\nIO0\nIO1\nPhase \n                        \n30 2 0 64 2 0 7     6 4     5 3 21     0 6 42 0 6  \n31 3 1 75 3 1 7     6 4     5 3 21     0 7 53 1 7  \nAddress Mode Dummy DLP Data 1 D2\nCS#\nSCK\nIO0\nIO1\nPhase \n                                      \n7 6 5 4 3 2 1 0 30 20 64206 \n31 31 75317\nInstruction Address Dummy Data 1 D2\nDocument Number: 001-98284 Rev. *R Page 90 of 136S25FL512S\n9.4.9 DDR Quad I/O Read (EDh, EEh)\nThe Read DDR Quad I/O command improves throughput with four I/O  signals - I/O0-I/O3. It is similar to the Quad I/O Read comman d\nbut allows input of the address four bits on every edge of the clock. In some applications, the reduced instruction overhead m ight allow\nfor code execution (XIP) directly from the S25FL512S device. Th e QUAD bit of the Configuration Register must be set (CR Bit1=1 )\nto enable the Quad capability.\nThe instruction \n■EDh (ExtAdd=0) is followed b y a 3-byte address (A23-A0) or\n■EDh (ExtAdd=1) is followed b y a 4-byte address (A31-A0) or\n■EEh is followed by a 4-byte address (A31-A0)\nThe address is followed by mode bits. Then the memory contents,  at the address given, is shifted out, in a DDR fashion, with f our bits\nat a time on each clock edge through I/O0-I/O3.\nThe maximum operating clock fre quency for Read DDR Quad I/O com mand is 80 MHz.\nFor Read DDR Quad I/O, there is a latency required after the la st address and mode bits are shifted into the I/O0-I/O3 signals  before\ndata begins shifting out of I/O 0-I/O3. This latency period (dum my cycles) allows the device’s internal circuitry enough time t o access\nthe initial address. During thes e latency cycles, the data valu e on I/O0-I/O3 are “don’t care” and may be high impedance. When  the\nData Learning Pattern (DLP) is enabled the host system must not  drive the I/O signals during the dummy cycles. The I/O signals  must\nbe left high impedance by the host so that the memory device ca n drive the DLP duri ng the dummy cycles.\nThere are different ordering par t numbers that s elect the laten cy code table used for this command, either the High Performanc e LC\n(HPLC) table or the Enhanced High Performance LC (EHPLC) table.  The number of dummy cycles is determined by the frequency\nof SCK (refer to Table 21 on page 50 ). The number of dummy cycles is set by the LC bits in the Conf iguration Register (CR1).\nBoth latency tables provide cycles for mode bits so a series of  Quad I/O DDR commands may eliminate the 8 bit instruction afte r the\nfirst command sends a complementary mode bit pattern, as shown in Figure 94  and Figure 96 . This feature removes the need for the\neight bit SDR instruction sequence and dramatically reduces ini tial access times (improves XIP pe rformance). The Mode bits con trol\nthe length of the  next Read DDR Quad I/O operation through the inclusion or exclusion of the fi rst byte instruction code. If t he upper\nnibble (I/O[7:4]) and lower nibbl e (I/O[3:0]) of the Mode bits are complementary (i.e. 5h and A h) the device transitions to Co ntinuous\nRead DDR Quad I/O Mode and the next address can be entered (aft er CS# is raised high and then asserted low) without requiring\nthe EDh or EEh instruction, as shown in Figure 95 on page 91  and Figure 97 on page 91  thus, eliminating ei ght cycles from the\ncommand sequence. The following sequences will release the devi ce from Continuous Read DDR Quad I/O mode; after which, the\ndevice can accept standard SPI commands:\n1. During the Read DDR Quad I/O Co mmand Sequence, if the Mode bi ts are not complementary the  next time CS# is raised high \nand then asserted low the device  will be released from Read DDR  Quad I/O mode.\n2. During any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (I/O0, I/O1, I/O2, and I/ O3) are not \nset for a valid instruction seq uence, then the device will be r eleased from Read DDR Quad I/O mode. \nThe address can start at any byte location of the memory array.  The address is automatically incremented to the next higher ad dress\nin sequential order after each byte of data is shifted out. The  entire memory can therefore be read out with one single read i nstruction\nand address 000000h provided. When the highest address is reach ed, the address counter will wrap around and roll back to 00000 0h,\nallowing the read sequence t o be continued indefinitely.\nCS# should not be driven high dur ing mode or dummy bits as this  may make the mode bits indeterminate. The HOLD function is not\nvalid during Quad I/O DDR commands.\nNote that the memory devices drive the I/Os with a preamble pri or to the first data value. The preamble is a pattern that is u sed by\nthe host controller to optimize data capture at higher frequenc ies. The preamble drives the I/O bus for the four clock cycles immediately\nbefore data is output. The host must be sure to stop driving th e I/O bus prior to the time that the memory starts outputting t he preamble.\nThe preamble is intended to give the host controller an indicat ion about the round trip time from when the host drives a clock  edge to\nwhen the corresponding data value returns from the memory devic e. The host controller will skew the data capture point during the\npreamble period to optimize timing margins and then use the sam e skew time to capture the data during the rest of the read ope ration.\nThe optimized capture point will be determined during the pream ble period of every read operatio n. This optimization strategy is\nintended to compensate for both  the PVT (process, voltage, temp erature) of both the memory device and the host controller as w ell\nas any system level delays ca used by flight ti me on the PCB.\nDocument Number: 001-98284 Rev. *R Page 91 of 136S25FL512S\nAlthough the data learning pattern (DLP) is programmable, the f ollowing example shows example of the DLP of 34h. The DLP 34h\n(or 00110100) will be driven on each of the active outputs (i.e . all four SIOs on a x4  device, both SIOs on a x2 device and th e single\nSO output on a x1 device). This pattern was chosen to cover bot h DC and AC data transition scenarios. The two DC transition\nscenarios include data low for a long period of time (two half clocks) followed by a high going transition (001) and the compl ementary\nlow going transition (110). The tw o AC transition scenarios inc lude data low for a short period of time (one half clock) follo wed by a\nhigh going transition (101) and the complementary low going tra nsition (010). The DC transitions will typically occur with a s tarting\npoint closer to the supply rail than the AC transitions that ma y not have fully settled to their steady state (DC) levels. In many cases\nthe DC transitions will bound the beginning of the data valid p eriod and the AC transitions will bound the ending of the data valid\nperiod. These transitions will allow the host controller to ide ntify the beginning and ending of  the valid data eye. Once the data eye\nhas been characterized the optimal data capture point can be ch osen. See SPI DDR Data Learning Registers on page 55  for more\ndetails.\nFigure 94.  DDR Quad I/O Read Init ial Access (3-Byte Address, E Dh [ExtAdd=0 ], HPLC=11b)\nFigure 95.  Continuous DDR Quad I/O Read Subsequent Access (3-B yte Address,HPLC=11b)\nFigure 96.  DDR Quad I/O Read Init ial Access (4-Byte Address, E Eh or EDh [ExtAdd=1], EHPLC=01b)[48]\nFigure 97.  Continuo us DDR Quad I/O Read Subsequent Access (4-B yte Address, EHPLC=01b)[48]CS#\nSCK\nIO0\nIO1IO2IO3\nPhase \n                                           \n7 6 5 4 3 2 1 0 201612 84040 765432104040\n211713 95151 765432105151\n22181410 6262 765432106262\n23191511 7373 765432107373\nInstruction Address Mode Dummy DLP D1 D2\nCS#\nSCK\nIO0\nIO1\nIO2\nIO3\nPhase \n                         \n201612 84040 4040404040\n211713 95151 5151515151\n22181410 6262 6262626262\n23191511 7373 7373737373\nAddress Mode Dummy D1 D2 D3 D4 D5\nCS#\nSCK\nIO0\nIO1\nIO2\nIO3\nPhase \n                                            \n7 6 5 4 3 2 1 0 2.2.2.1.1.84040 7  6 5  4 321  0 4040\n2.2.2.1.1.95151 7  6 5  4 321  0 5151\n3.2.2.1.1.1.6262 7  6 5  4 321  0 6262\n3.2.2.1.1.1.7373 7  6 5  4 321  0 7373\nInstruction Address Mod. Dummy DLP D1 D2\nNote\n48. Example DLP of 34h (or 00110100).CS#\nSCK\nIO0\nIO1\nIO2\nIO3\nPhase \n                             \n2824201612 84040 7   6 5   4 321   0 40404\n2925211713 95151 7   6 5   4 321   0 51515\n302622181410 6262 7   6 5   4 321   0 62626\n312723191511 7373 7   6 5   4 321   0 73737\nAddress Mode Dummy DLP D1 D2\nDocument Number: 001-98284 Rev. *R Page 92 of 136S25FL512S\n9.5 Program Flash Array Commands\n9.5.1 Program Granularity\n9.5.1.1 Automatic ECC\nEach 16 byte aligned and 16 byte length Programming Block has a n automatic Error Correction Code (ECC) value. The data block\nplus ECC form an ECC unit. In co mbination with Error Detection and Correction (EDC) logic the ECC is used to detect and correc t\nany single bit error found during a read access. When data is f irst programmed within an ECC unit the ECC value is set for the  entire\nECC unit. If the same ECC unit is programmed more than once the  ECC value is changed to disable the EDC function. A sector era se\nis needed to again enable Automatic ECC on that Programming Blo ck. The 16 byte Program Block is the smallest program granulari ty\non which Automatic ECC is enabled.\nThese are automatic operations transparent to the user. The tra nsparency of the Automatic ECC feature enhances data accuracy f or\ntypical programming operations which write data once to each EC C unit but, facilitates software compatibility to previous gene rations\nof FL family of products by allowing for single byte programmin g and bit walking in which the same ECC unit is programmed more\nthan once. When an ECC unit has Automatic ECC disabled, EDC is not done on data read from the ECC unit location.\nAn ECC status register is provided for determining if ECC is en abled on an ECC unit and whether any errors have been detected and\ncorrected in the ECC unit data or the ECC (See ECC Status Register (ECCSR) on page 53 .) The ECC Status Register Read (ECCRD)\ncommand is used to read the ECC status on any ECC unit.\nError Detection and Correction (EDC) is applied to all parts of  the Flash address spaces other  than registers. An Error Correc tion\nCode (ECC) is calculated for each group of bytes protected and the ECC is stored in a hidden area related to the group of byte s. The\ngroup of protected bytes and the related ECC are together calle d an ECC unit.\nECC is calculated for each 16 byte aligned and length ECC unit.\n■Single Bit EDC is suppo rted with 8 ECC bits per ECC unit, plus 1 bit for an ECC disable Flag.\n■Sector erase resets al l ECC bits and ECC disable flags in a sec tor to the defaul t state (enabled).\n■ECC is programmed as part of t he standard Program commands oper ation.\n■ECC is disabled automat ically if multiple p rogramming operation s are done on the same ECC unit.\n■Single byte programming or bit wa lking is allowed but disables ECC on the second program to t he same 16-byte ECC unit.\n■The ECC disable flag is programmed when ECC is disabled.\n■To re-enable ECC for an ECC unit that has been disabled, the Se ctor that includes the E CC unit must be erased.\n■To ensure the best data integrity provided by EDC, each ECC uni t should be programmed only once  so that ECC is stored for that\nunit and not disabled.\n■The calculation, programming, and disabling of ECC is done auto matically as part of a program ming operation. T he detection and\ncorrection, if needed, is done aut omatically as part of read op erations. The host system sees only corrected data from a read\noperation.\n■ECC protects the OTP region - howe ver a second program operatio n on the same ECC unit will di sable ECC permanently on that\nECC unit (OTP is one time programmable, hence an erase operatio n to re-enable the ECC enable/indicator bit is prohibited).\n9.5.1.2 Page Programming\nPage Programming is done by loading a Page Buffer with data to be programmed and issuing a programming command to move data\nfrom the buffer to the memory array. This sets an upper limit o n the amount of data that can be programmed with a single progr amming\ncommand. Page Programming allows up to a page size (512 bytes) to be programmed in one operatio n. The page is aligned on the\npage size address boundary. It is possible to program from one bit up to a page size in each Page programming operation. It is\nrecommended that a multiple of 16 byte length and aligned Progr am Blocks be written. For the very best performance, programmin g\nshould be done in full pages o f 512 bytes aligned on 512-byte b oundaries with each Page bei ng programmed only once.\n9.5.1.3 Single Byte Programming\nSingle Byte Programming allows full backward compatibility to t he standard SPI Page Programming (PP) command by allowing a\nsingle byte to be programmed anywhere in the memory array. Whil e single byte programming is supported, this will disable Autom atic\nECC on the 16 byte ECC unit where the byte is located.\nDocument Number: 001-98284 Rev. *R Page 93 of 136S25FL512S\n9.5.2 Page Program ( PP 02h or 4PP 12h)\nThe Page Program (PP) commands allows bytes to be programmed in  the memory (changing bits from 1 to 0). Before the Page\nProgram (PP) commands can be accepted by the device, a Write En able (WREN) command must be issued and decoded by the\ndevice. After the Write Enable (WREN) command has been decoded successfully, the device sets t he Write Enable Latch (WEL) in\nthe Status Register  to enable any write operations.\nThe instruction \n■02h (ExtAdd=0) is followed by a  3-byte address (A23-A0) or\n■02h (ExtAdd=1) is followed by a  4-byte address (A31-A0) or\n■12h is followed by a 4-b yte address (A31-A0)\nand at least one data byte on S I. Up to a page can be provided on SI after the 3-byte address with instruction 02h or 4-byte a ddress\nwith instruction 12h has been provided. If the 9 least signific ant address bits (A8-A0) are not all zero, all transmitted data  that goes\nbeyond the end of the current page are programmed from the star t address of the same page (from the address whose 9 least\nsignificant bits (A8-A0) are all zero) i.e. the address wraps w ithin the page aligned address boundaries. This is a result of only requiring\nthe user to enter one  single page address to cover the entire p age boundary.\nIf less than a page of data is sent to the device, these data b ytes will be programmed in sequence, starting at the provided a ddress\nwithin the page, without having any affect on the other bytes o f the same page.\nFor optimized timings, using th e Page Program (PP) command to l oad the entire page size program buffer within the page boundar y\nwill save overall programming tim e versus loading  less than a p age size into the program buffer.\nThe programming process is managed by the flash memory device i nternal control logic. After a  programming command is issued,\nthe programming operat ion status can be checked using the Read Status Register-1 command. The WIP bit (SR1[0]) will indicate\nwhen the programming operation is completed. The P_ERR bit (SR1 [6]) will indicate if an error occurs in the programming operat ion\nthat prevents successful com pletion of programming.\nFigure 98.  Page Program (PP 02h or 4PP 12h) Command Sequence\n9.5.3 Quad Page Program (QP P 32h or 38h, or 4QPP 34h)\nThe Quad-input Page Program (QPP) command allows bytes to be pr ogrammed in the memory (changing bits from 1 to 0). The\nQuad-input Page Program (QPP) command allows up to a page size (512 bytes) of data to be loaded into the Page Buffer using fou r\nsignals: I/O0-I/O3. QPP can improve performance for PROM Progra mmer and applications that have slower clock speeds (< 12 MHz)\nby loading 4 bits of data per clock cycle. Systems with faster clock speeds do not realize as m uch benefit for the QPP command  since\nthe inherent page program time bec omes greater than the time it  takes to clock-in the data. The maximum frequency for the QPP\ncommand is 80 MHz.\nTo use Quad Page Program the Quad Enable Bit in the Configurati on Register must be set (QUAD=1). A Write Enable command\nmust be executed befor e the device will a ccept the QPP command (Status Register-1, WEL=1). \nThe instruction \n■32h (ExtAdd=0) is followed by a  3-byte address (A23-A0) or\n■32h (ExtAdd=1) is followed by a  4-byte address (A31-A0) or\n■38h (ExtAdd=0) is followed by a  3-byte address (A23-A0) or\n■38h (ExtAdd=1) is followed by a  4-byte address (A31-A0) or\n■34h is followed by a 4-b yte address (A31-A0)\nand at least one data byte, into  the I/O signals. Data must be programmed at the previously e rased (FFh) memory locations. \nRecommend the programming page is aligned on the page size addr ess boundary. It is possible to program from one bit up to a pa ge\nsize in each Page programming operation. It is recommended that  a multiple of 16 byte length and aligned Program Blocks be wri tten.\nThis insures that Automatic ECC is not disabled”.CS#\nSCK\nSI\nSO\nPhase76543210A 5432107654321076543210\nInstruction Address Input Data 1 Input Data 2\nDocument Number: 001-98284 Rev. *R Page 94 of 136S25FL512S\nAll other functions of QPP are i dentical to Page Program. The Q PP command sequence is show n in the figure below.\nFigure 99.  Quad 512-byte Page Program Command Sequence\n9.5.4 Program Suspend (PGSP 85h) and Resume (PGRS 8Ah)\nThe Program Suspend command allows the system to interrupt a pr ogramming operation and then read from any other\nnon-erase-suspended sector or non-program-suspended-page. Progr am Suspend is valid only duri ng a programming operation. \nCommands allowed after the Program Suspend command is issued:\n■Read Status Register 1 (RDSR1 05h)\n■Read Status Register 2 (RDSR2 07h)\nThe Write in Progress (WIP) bit in Status Register 1 (SR1[0]) m ust be checked to know when the programming operation has stopp ed.\nThe Program Suspend Status bit in the Status Register-2 (SR2[0] ) can be used to determine if a programming operation has been\nsuspended or was completed at the time WIP changes to 0. The ti me required for the suspend operation to complete is tPSL, see\nTable 45 on page 104 .\nSee Table 43 on page 97  for the commands allowed wh ile programming is suspend.\nThe Program Resume command 8Ah mu st be written to resume the pr ogramming operation after a Program Suspend. If the\nprogramming operation was completed during the suspend operatio n, a resume command is not needed and has no effect if issued.\nProgram Resume commands will be ignored unless a Program operat ion is suspended.\nAfter a Program Resume command is issued, the WIP bit in the St atus Register-1 will be set to a 1 and the programming operatio n\nwill resume. Program operations may be interrupted as often as necessary e.g. a program suspend command could immediately\nfollow a program resume command but, in order for a program ope ration to progress to completion there must be some periods of\ntime between resume and the nex t suspend command greater than o r equal to tPRS. See Table 45 on page 104 .\nFigure 100.  Program Suspend (PGSP 85h) Command Sequence\nFigure 101.  10.55 Program Resu me (PGRS 8Ah) Co mmand SequenceCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                               \n7 6 5 4 3 2 1 0 A  1 0 4 0 4 0 4 0 4 0 4 0 4\n5 1 5 1 5 1 5 1 5 1 5\n6 2 6 2 6 2 6 2 6 2 6\n7 3 7 3 7 3 7 3 7 3 7\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nCS#\nSCK\nSI\nSO\nPhasePhase     \n                                                                         \n76543210 76543210 76543210\n76543210\nSuspend Instruction Read Status Instruction Status Instr. During Suspend\nRepeat Status Read Until SuspendedtPSL\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\nInstruction\nDocument Number: 001-98284 Rev. *R Page 95 of 136S25FL512S\n9.6 Erase Flash Array Commands\n9.6.1 Sector Erase ( SE D8h or 4SE DCh)\nThe Sector Erase (SE) command set s all bits in the addressed se ctor to 1 (all bytes are FFh). Before the Sector Erase (SE) com mand\ncan be accepted by th e device, a Write Enable (WREN) command mu st be issued and decoded by the device, which sets the Write\nEnable Latch (WEL) in the Stat us Register to enable any write o perations.\nThe instruction \n■D8h [ExtAdd=0] is followed by a 3-byte address (A23-A0), or\n■D8h [ExtAdd=1] is followed by a 4-byte address (A31-A0), or\n■DCh is followed by a 4-byte address (A31-A0)\nCS# must be driven into the logic high state after the twenty-f ourth or thirty-second bit of address has been latched in on SI . This will\ninitiate the erase cycle, which i nvolves the pre-programming an d erase of the chosen sector. If CS# is not driven high after t he last bit\nof address, the sector erase operation will not  be executed. \nAs soon as CS# is driven into the logic high state, the interna l erase cycle will be in itiated. With the in ternal erase cycle in progress,\nthe user can read the value of the Write-In Progress (WIP) bit to check if the operation has b een completed. The WIP bit will indicate\na 1 when the erase cycl e is in progress and a0 when the erase c ycle has been completed.\nA Sector Erase (SE) command applied to a sector that has been W rite Protected through the Block Protection bits or ASP, will n ot be\nexecuted and will set the E_ERR status.\nASP has a PPB and a DYB prot ection bit for each sector.\nFigure 102.  Sector Erase (SE D8h or 4SE DCh) Command Sequence\n9.6.2 Bulk Erase (BE 60h or C7h)\nThe Bulk Erase (BE) command sets all bits to 1 (all bytes are F Fh) inside the entire flash memory array. Before the BE command  can\nbe accepted by the device, a Write Enable (WREN) command must b e issued and decoded by the device, which sets the Write Enable\nLatch (WEL) in the Status Regist er to enable any write operatio ns.\nCS# must be driven into the logi c high state after the eighth b it of the instruction byte has been latched in on SI. This will  initiate the\nerase cycle, which inv olves the pre-programming and erase of th e entire flash memory array. If CS# is not driven high after th e last\nbit of instruction, the BE ope ration will not b e executed.\nAs soon as CS# is driven into the logic high state, the erase c ycle will be initiated. With the erase cycle in progress, the u ser can read\nthe value of the Write-In Progress (WIP) bit to determine when the operation has been completed. The WIP bit will indicate a 1  when\nthe erase cycle is in progress and a 0 when the erase cycle has  been completed.\nA BE command can be executed only when the Block Protection (BP 2, BP1, BP0) bits are set to 0’s.  If the BP bits are not zero, the\nBE command is not executed and E_ERR is not set. The BE command  will skip any sectors protec ted by the DYB or PPB and the\nE_ERR status will not be set.\nFigure 103.  Bulk Er ase Command SequenceCS#\nSCK\nSI\nSO\nPhase \n                        \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDocument Number: 001-98284 Rev. *R Page 96 of 136S25FL512S\n9.6.3 Erase Suspend and Resume Commands (ERSP 75h or ERRS 7Ah)\nThe Erase Suspend command, allow s the system to interrupt a sec tor erase operation and then read from or program data to, any\nother sector. Erase Suspend is valid only during a sector erase  operation. The Erase Suspend co mmand is ignored if written dur ing\nthe Bulk Erase operation.\nWhen the Erase Suspend command is written during the sector era se operation, the device requires a maximum of tESL (erase\nsuspend latency) to suspend the erase operation and update the status bits. See Table 46 on page 104 .\nCommands allowed after the Erase Suspend command is issued:\n■Read Status Register 1 (RDSR1 05h)\n■Read Status Register 2 (RDSR2 07h)\nThe Write in Progress (WIP) bit in Status Register 1 (SR1[0]) m ust be checked to know when the erase operation has stopped. Th e\nErase Suspend bit in Status Regis ter-2 (SR2[1]) can be used to determine if an erase operation has been suspended or was compl eted\nat the time WIP changes to 0.\nIf the erase operation was completed during the suspend operati on, a resume command is not needed and has no effect if issued.\nErase Resume commands will be i gnored unless an Erase operation  is suspended.\nSee Table 43 on page 97  for the commands allowed while erase is suspend.\nAfter the erase operation has been suspended, the sector enters  the erase-suspend mode. The syst em can read data from or progr am\ndata to the device. Reading at an y address within an erase-susp ended sector produces  undetermined data. \nA WREN command is required bef ore any command  that will change nonvolatile data, even during erase suspend.\nThe WRR and PPB Erase commands ar e not allowed dur ing Erase Sus pend, it is therefore not possibl e to alter the Block Protectio n\nor PPB bits during Erase Susp end. If there are sectors that may  need programming during Erase suspend, these sectors should be\nprotected only by DYB bits that can be turned off during Erase Suspend. However, WRR is allowed immediately following the BRAC\ncommand; in this special case the WRR is interpreted as a write  to the Bank Address Register, not a write to SR1 or CR1.\nIf a program command is sent for a location within an erase sus pended sector the program operation will fail with the P_ERR bi t set.\nAfter an erase-suspended program operation is complete, the dev ice returns to the erase-suspen d mode. The system can determine\nthe status of t he program operation by r eading the WIP bit in t he Status Register, ju st as in the standard program operation.\nThe Erase Resume command 7Ah must  be written to resume the eras e operation if an Erase is s uspend. Erase Resume commands\nwill be ignored unless an Erase is Suspend.\nAfter an Erase Resume command is sent, the WIP bit in the statu s register will be set to a 1 and the erase operation will cont inue.\nFurther Resume commands are ignored. \nErase operations may be interrup ted as often as necessary e.g. an erase suspend command could immediately follow an erase\nresume command but, in order for  an erase operation to progress  to completion there must be some periods of time between resum e\nand the next suspend command g reater than or equal to tERS. See Table 46 on page 104 .\nFigure 104.  Erase Suspend (ERSP 75h) Command Sequence\nFigure 105.  Erase Resume (ERRS 7Ah) Command SequenceCS#\nSCK\nSI\nSO\nPhasePhase     \n                                                                         \n76543210 76543210 76543210\n76543210\nSuspend Instruction Read Status Instruction Status Instr. During Suspend\nRepeat Status Read Until SuspendedtESL\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDocument Number: 001-98284 Rev. *R Page 97 of 136S25FL512S\nTable 43.  Commands Allowed Du ring Program or Erase Suspend\nInstruction \nNameInstruction \nCode \n(Hex)Allowed \nDuring \nErase \nSuspendAllowed \nDuring \nProgram \nSuspendComment\nBRAC B9 X XBank address register may need to be changed during a suspend t o reach \na sector for read or program.\nBRRD 16 X XBank address register may need to be changed during a suspend t o reach \na sector for read or program.\nBRWR 17 X XBank address register may need to be changed during a suspend t o reach \na sector for read or program.\nCLSR 30 X – Clear status may be used  if a program operation fails during er ase \nsuspend. \nDYBRD E0 X – It may be necessary to remove and restore dynamic protection du ring \nerase suspend to allow progr amming during erase suspend. \nDYBWR E1 X – It may be necessary to remove and restore dynamic protection du ring \nerase suspend to allow progr amming during erase suspend. \nERRS 7A X – Required to resume from erase suspend.\nDDRFR 0D X X All array reads allowed in suspend.\n4DDRFR 0E X X All array reads allowed in suspend.\nFAST_READ 0B X X All array reads allowed in suspend.\n4FAST_READ 0C X X All array reads allowed in suspend.\nMBR FF X X May need to reset a read operation during suspend.\nPGRS 8A X XNeeded to resume a program operat ion. A program resume may also  be \nused during nested pr ogram suspend within an erase suspend.\nPGSP 85 X – Program suspend a llowed during erase suspend.\nPP 02 X – Required for array program during erase suspend.\n4PP 12 X – Required for array program during erase suspend.\nPPBRD E2 X – Allowed for checking persistent p rotection before attempting a program \ncommand during er ase suspend. \nQPP 32, 38 X – Required for array program during erase suspend.\n4QPP 34 X – Required for array pr ogram during erase suspend.\n4READ 13 X X All array reads allowed in suspend.\nRDCR 35 X X –\nDIOR BB X X All array reads allowed in suspend.\n4DIOR BC X X All array reads allowed in suspend.\nDOR 3B X X All array reads allowed in suspend.\n4DOR 3C X X All array reads allowed in suspend.\nDDRDIOR BD X X All array reads allowed in suspend.\n4DDRDIOR BE X X All array reads allowed in suspend.\nDDRQIOR ED X X All array reads allowed in suspend.\nDDRQIOR4 EE X X All array reads allowed in suspend.\nQIOR EB X X All array reads allowed in suspend.\n4QIOR EC X X All array reads allowed in suspend.\nQOR 6B X X All array reads allowed in suspend.\nDocument Number: 001-98284 Rev. *R Page 98 of 136S25FL512S\n9.7 One Time Program Array Commands\n9.7.1 OTP Program (OTPP 42h)\nThe OTP Program command programs data in the One Time Program r egion, which is in a different address space from the main\narray data. The OTP region is 1024 bytes so, the address bits f rom A23 to A10 must be zero f or this command. Refer to Section 7.5\nOTP Address Space on page 45  for details on the OTP region. The protocol of the OTP Program  command is the same as the Page\nProgram command. Before the OT P Program command can be accepted  by the device, a Write Enable (WREN) command must be\nissued and decoded by t he device, which set s the Write Enable L atch (WEL) in the Status Registe r to enable any write operation s.\nTo program the OTP array in bit granularity, the rest of the bi ts within a data byte can be set to 1.\nEach region in the OTP memory sp ace can be programmed one or mo re times, provided that the regi on is not locked. Attempting to\nprogram zeros in a region that is locked will fail with the P_E RR bit in SR1 set to 1 Programming ones, even in a protected ar ea does\nnot cause an error and does not  set P_ERR. Subsequent OTP progr amming can be performed only on the un-programmed bits (that\nis, 1 data). \nFigure 106.  Page Program (OTPP 42h) Command Sequence\n9.7.2 OTP Read (OTPR 4Bh)\nThe OTP Read command reads data from the OTP region. The OTP re gion is 1024 bytes so, the address bits from A23 to A10 must\nbe zero for this command. Refer to Section 7.5 OTP Address Space on page 45  for details on the OTP region. The protocol of the\nOTP Read command is similar to the Fast Read command except tha t it will not wrap to the starting address after the OTP addres s\nis at its maximum; instead, the data beyond the maximum OTP add ress will be undefined. Also, the OTP Read command is not\naffected by the latency code. The OTP read command always has o ne dummy byte of latency as shown below.\nFigure 107.  Read OTP (OTPR 4Bh) Command Sequence4QOR 6C X X All array reads allowed in suspend.\nRDSR1 05 X X Needed to read WIP to d etermine end of suspend process .\nRDSR2 07 X XNeeded to read suspen d status to determine whether the operatio n is \nsuspended or complete.\nREAD 03 X X All array reads allowed in suspend.\nRESET F0 X X Reset allowed anytime.\nWREN 06 X – Required for program command within erase suspend.\nWRR 01 X XBank register may need to be changed during a suspend to reach a sector \nneeded for read or program. WRR is allowed when following BRAC.Table 43.  Commands Allowed Duri ng Program or Erase Suspend (Co ntinued)\nInstruction \nNameInstruction \nCode (Hex)Allowed \nDuring \nErase \nSuspendAllowed \nDuring \nProgram \nSuspendComment\nCS#\nSCK\nSI\nSO\nPhase7654321023 5432107654321076543210\nInstruction Address Input Data 1 Input Data 2\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321023  10  \n76543210  \nInstruction Address Dummy Cycles Data 1\nDocument Number: 001-98284 Rev. *R Page 99 of 136S25FL512S\n9.8 Advanced Sector Protection Commands\n9.8.1 ASP Read (ASPRD 2Bh)\nThe ASP Read instruction 2Bh is shifted into SI by the rising e dge of the SCK signal. Then the 16-bit ASP register contents is  shifted\nout on the serial output SO, LSB first. Each bit is shifted out  at the SCK frequency by the falling edge of the SCK signal. It  is possible\nto read the ASP register continuously by providing multiples of  16 clock cycles. The maximum o perating clock frequency for the  ASP\nRead (ASPRD) command is 133 MHz.\nFigure 108.  ASPRD Command\n9.8.2 ASP Program (ASPP 2Fh)\nBefore the ASP Program (ASPP) comm and can be accepted by the de vice, a Write Enable (WREN) command must be issued. After\nthe Write Enable (WREN) command has been decoded, the device wi ll set the Write Enable Latch (WEL) in the Status Register to\nenable any write operations.\nThe ASPP command is entered by d riving CS# to the logic low sta te, followed by the instruction and two data bytes on SI, LSB f irst.\nThe ASP Register is two data bytes in length. \nThe ASPP command affects the P_ER R and WIP bits of the Status a nd Configuration Registers in the same manner as any other\nprogramming operation.\nCS# input must be driven to the logic high state after the sixt eenth bit of data has been latched in. If no t, the ASPP command  is not\nexecuted. As soon as CS# is driv en to the logic high state, the  self-timed ASPP operat ion is initi ated. While the ASPP operati on is in\nprogress, the Status Register may be read to check the value of  the Write-In Progress (WIP) bit.  The Write-In Progress (WIP) b it is a\n1 during the self-timed ASPP oper ation, and is a 0 when it is c ompleted. When the ASPP operation is completed, the Write Enabl e\nLatch (WEL) is set to a 0.\nFigure 109.  A SPP (2Fh) Command\n9.8.3 DYB Read (DYBRD E0h)\nThe instruction E0h is latched into SI by the rising edge of th e SCK signal. Followed by the 32-bit address selecting location  zero\nwithin the desired sector (note, the high order address bits no t used by a particular density device must be zero). Then the 8 -bit DYB\naccess register contents are shifted out on the serial output S O. Each bit is shifted out at the SCK frequency by the falling edge of the\nSCK signal. It is possible to read the same DYB access register  continuously by providing multip les of eight clock cycles. The  address\nof the DYB register does not increment so this is not a means t o read the entire DYB array. Each location must be read with a separate\nDYB Read command. The maximum o perating clock frequency for REA D command is 133 MHz.\nFigure 110.  DYBRD Command SequenceCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nCS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input ASPR Low Byte Input ASPR High Byte\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n7654321076543210  \nInstruction Address Register Repeat Register\nDocument Number: 001-98284 Rev. *R Page 100 of 136S25FL512S\n9.8.4 DYB Write (DYBWR E1h)\nBefore the DYB Write (DYBWR) com mand can be accepted by the dev ice, a Write Enable (WREN) co mmand must be issued. After\nthe Write Enable (WREN) command has been decoded, the device wi ll set the Write Enable Latch (WEL) in the Status Register to\nenable any write operations.\nThe DYBWR command is entered by driving CS# to the logic low st ate, followed by the instruction,  the 32-bit address selecting location\nzero within the desired sector (note, the high order address bi ts not used by a particular dens ity device must b e zero), then the data\nbyte on SI. The DYB Access Regis ter is one data byte in length.\nThe DYBWR command affects the P_ ERR and WIP bits of the Status and Configuration Registers in the same manner as any other\nprogramming operation. CS# must be driven to the logic high sta te after the eighth bit of data has been latched in. If not, th e DYBWR\ncommand is not executed. As soon a s CS# is driven to the logic high state, the self-timed DYBWR operation is initiated. While the\nDYBWR operation is in progress, the Status Register may be read  to check the value of the Write-In Progress (WIP) bit. The Wri te-In\nProgress (WIP) bit is a 1 during the self-timed DYBWR operation , and is a 0 when it is completed. When the DYBWR operation is\ncompleted, the Write Enable Latch (WEL) is set to a 0. \nFigure 111.  DYBWR (E1h) Command Sequence\n9.8.5 PPB Read (PPBRD E2h)\nThe instruction E2h is shifted into SI by the rising edges of t he SCK signal, followed by the 32-bit address selecting locatio n zero within\nthe desired sector (note, the h igh order address bits not used by a particular density device must be zero) Then the 8-bit PPB  access\nregister contents are shifted out on SO. \nIt is possible to read the same PPB access register continuousl y by providing multiples of eight clock cycles. The address of the PPB\nregister does not increment so this is not a means to read the entire PPB array. Each location m ust be read with a separate PP B Read\ncommand. The maximum operating cl ock frequency for the PPB Read  command is 133 MHz.\nFigure 112.  PPBRD (E2h) Command SequenceCS#\nSCK\nSI\nSO\nPhase76543210 3 1 54321076543210\nInstruction Address Input Data\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n7654321076543210  \nInstruction Address Register Repeat Register\nDocument Number: 001-98284 Rev. *R Page 101 of 136S25FL512S\n9.8.6 PPB Program (PPBP E3h)\nBefore the PPB Program (PPBP) command can be accepted by the de vice, a Write Enable (WREN) command must be issued. After\nthe Write Enable (WREN) command has been decoded, the device wi ll set the Write Enable Latch (WEL) in the Status Register to\nenable any write operations.\nThe PPBP command is entered by driving CS# to the logic low sta te, followed by the instruction, followed by the 32-bit address\nselecting location zero within t he desired sector (note, the hi gh order address bits not used by  a particular density device m ust be zero).\nThe PPBP command affects the P_E RR and WIP bits o f the Status a nd Configuration Registers in  the same manner as any other\nprogramming operation.\nCS# must be driven to the logic high state after the last bit o f address has been latched in. If not, the PPBP command is not executed.\nAs soon as CS# is driven to the l ogic high state, the self-time d PPBP operation is initiated. Wh ile the PPBP operation is in p rogress,\nthe Status Register may be read to check the value of the Write -In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during\nthe self-timed PPBP operation, and is a 0 when it is completed.  When the PPBP operation is completed, the Write Enable Latch ( WEL)\nis set to a 0.\nFigure 113.  PPBP (E3h) Command Sequence\n9.8.7 PPB Erase (PPBE E4h)\nThe PPB Erase (PPBE) command sets all PPB bits to 1. Before the  PPB Erase command can be accepted by the device, a Write\nEnable (WREN) command must be issued and decoded by the device,  which sets the Write Enable Lat ch (WEL) in the Status Register\nto enable any write operations.\nThe instruction E4h is shifted into SI by the rising edges of t he SCK signal.\nCS# must be driven into the logi c high state after the eighth b it of the instruction byte has been latched in on SI. This will  initiate the\nbeginning of internal erase cycle,  which involves the pre-progr amming and erase of the entire PPB memory array. Without CS# be ing\ndriven to the logic high state a fter the eighth bit of the inst ruction, the PPB erase opera tion will not be executed.\nWith the internal erase cycle i n progress, the user can read th e value of the Write-In Progre ss (WIP) bit to check if the oper ation has\nbeen completed. The WIP bit will indicate a 1 when the erase cy cle is in progress and a 0 when the erase cycle has been comple ted.\nErase suspend is not allowed during PPB Erase.\nFigure 114.  PPB Erase (PPB E E4h) Command Sequence\n9.8.8 PPB Lock Bit Read (PLBRD A7h)\nThe PPB Lock Bit Read (PLBRD) c ommand allows the PPB Lock Regis ter contents to be read out of SO. It is possible to read the\nPPB lock register contin uously by providing multiples of eight clock cycles. The PPB Lock Register content s may only be read w hen\nthe device is in standb y state with no othe r operation in progr ess. It is recommended to check th e Write-In Progress (WIP) bit  of the\nStatus Register before issuing a new command to the device.\nFigure 115.  PPB Lock Register Read Command SequenceCS#\nSCK\nSI\nSO\nPhase \n                         \n7 6 5 4 3 2 1 0 31  1 0\nInstruction     Address\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nDocument Number: 001-98284 Rev. *R Page 102 of 136S25FL512S\n9.8.9 PPB Lock Bit Write (PLBWR A6h)\nThe PPB Lock Bit Write (PLBWR) c ommand clears the PPB Lock Regi ster to zero. Before the PLBWR command can be accepted\nby the device, a Write Enable (WREN) command must be issued and  decoded by the device, which sets the Write Enable Latch (WEL)\nin the Status Register to enable any write operations.\nThe PLBWR command is entered by d riving CS# to the logic low st ate, followed by the instruction.\nCS# must be driven to the logic high state after the eighth bit  of instruction has been latched in. If not, the PLBWR command is not\nexecuted. As soon as CS# is driv en to the logic high state, the  self-timed PLBWR operation is i nitiated. While the PLBWR opera tion\nis in progress, the Status Register may still be read to check the value of the Write-In Progress (WIP) bit. The Write-In Prog ress (WIP)\nbit is a 1 during the self-timed PLBWR operation, and is a 0 wh en it is completed. When the PLBWR operation is completed, the Write\nEnable Latch (WEL) is set to a 0. The maximum clock frequency f or the PLBWR command is 133 MHz.\nFigure 116.  PPB Lock Bit Write (PLBWR A6h) Command Sequence\n9.8.10 Password R ead (PASSRD E7h)\nThe correct password value may be read only after it is program med and before the Password Mode has been selected by\nprogramming the Password Protection Mode bit to 0 in the ASP Re gister (ASP[2]). After the Passwor d Protection Mode is selected\nthe PASSRD command is ignored.\nThe PASSRD command is shifted int o SI. Then the 64-bit Password  is shifted out on the serial output SO, LSB first, most signif icant\nbit of each byte first. Each bit is shifted out at the SCK freq uency by the falling edge of the SCK signal. It is possible to read the\nPassword continuously by provid ing multiples of 64 clock cycles . The maximum operating clock frequency for the PASSRD command\nis 133 MHz.\nFigure 117.  Password Read (PASSRD E7h) Command Sequence\n9.8.11 Password Program (PASSP E8h)\nBefore the Password Program (PASSP) command can be accepted by the device, a Write Enable (WREN) command must be issued\nand decoded by the device. After the Write Enable (WREN) comman d has been decoded, the device sets the Write Enable Latch\n(WEL) to enable t he PASSP operation.\nThe password can only be programmed before the Password Mode is  selected by programming the Password Protection Mode bit\nto 0 in the ASP Register (ASP[2]).  After the Password Protectio n Mode is selected the  PASSP command is ignored.\nThe PASSP command is entered by driving CS# to the logic low st ate, followed by the instructio n and the password data bytes on  SI,\nLSB first, most significant bit  of each byte first. The passwor d is sixty-four (6 4) bits in length. \nCS# must be driven to the logic h igh state after the sixty-four th (64th) bit of data has been latched. If not, the PASSP command is no t\nexecuted. As soon as CS# is driven to the logic high state, the  self-timed PASSP operation is initiated. While the PASSP opera tion is\nin progress, the Statu s Register may be read  to check the value  of the Write-In Progress (WIP) bit. The Write-In Progress (WIP ) bit\nis a 1 during the self-timed PASSP cycle, and is a 0 when it is  completed. The PASSP command can report a program error in the\nP_ERR bit of the status register. When the PASSP operation is c ompleted, the Write Enable Latch (WEL) is set to a 0. The maxim um\nclock frequency for the P ASSP command is 133 MHz.\nFigure 118.  Password Program (PASSP E8h) Command SequenceCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nCS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input Password Low Byte     Input Password High Byte\nDocument Number: 001-98284 Rev. *R Page 103 of 136S25FL512S\n9.8.12 Password Unlock (PASSU E9h)\nThe PASSU command is entered by  driving CS# to the logic low st ate, followed by the instruction and the password data bytes on  SI,\nLSB first, most significant bit  of each byte first. The passwor d is sixty-four (6 4) bits in length. \nCS# must be driven to the logic high state after the sixty-four th (64th) bit of data has been latched. If not, the PASSU command is no t\nexecuted. As soon as CS# is driv en to the logic high state, the  self-timed PASSU operation is in itiated. While the PASSU opera tion\nis in progress, the Status Register may be read to check the va lue of the Write-In Progress (WIP ) bit. The Write-In Progress ( WIP) bit\nis a 1 during the se lf-timed PASSU cycle, a nd is a 0 when it is  completed. \nIf the PASSU command supplied password does not match the hidde n password in the Password Register, an error is reported by\nsetting the P_ERR bit to 1. The WIP bit of the status register also remains set to 1. It is necessary to use the CLSR command to clear\nthe status register, the RESET c ommand to software reset the de vice, or drive the RESET# input l ow to initiate a hardware rese t, in\norder to return the P_ERR and WIP bits to 0. This returns the d evice to standby state, ready for new commands such as a retry of the\nPASSU command.\nIf the password does match, the PPB Lock bit is set to 1. The m aximum clock frequency for t he PASSU command is 133 MHz.\nFigure 119.  Password Unlock (PASSU E9h) Command Sequence\n9.9 Reset Commands\n9.9.1 Software Reset Command (RESET F0h)\nThe Software Reset command (RESET) restores the device to its i nitial power up state, except for the volatile FREEZE bit in th e\nConfiguration regist er CR1[1] and the vol atile PPB Lock bit in the PPB Lock Register. The Freeze bit and the PPB Lock bit will  remain\nset at their last value prior to the software reset. To clear t he FREEZE bit and set the PPB Lock bit to its protection mode s elected\npower on state, a full power-on-reset sequence or hardware rese t must be done. Note that the nonvolatile bits in the configura tion\nregister, TBPROT, TBPARM, and BPNV, retain their previous state  after a Software Reset. The Block Protection bits BP2, BP1, an d\nBP0, in the status register wil l only be reset if they are conf igured as volatile via the BPNV bi t in the Configuration Regist er (CR1[3])\nand FREEZE is cleared to zero . The software reset cannot be us ed to circumvent the FREEZE or PPB Lock bit protection mechanis ms\nfor the other security configurat ion bits. The reset command is  executed when CS# is brought to high state and requires tRPH time to\nexecute.\nFigure 120.  Softw are Reset (RESET F0h ) Command Sequence\n9.9.2 Mode Bit Reset (MBR FFh)\nThe Mode Bit Reset (MBR) command can be used to return the devi ce from continuous high performance read mode back to normal\nstandby awaiting any new command . Because some device packages lack a hardware RESET# input  and a device that is in a\ncontinuous high performance read mode may not recognize any nor mal SPI command, a system hardware reset or software reset\ncommand may not be recognized by the device. It is recommended to use the MBR command after a system reset when the RESET#\nsignal is not available or, before sending a software reset, to  ensure the device is released from continuous high performance  read\nmode.\nThe MBR command sends  Ones on SI or I/O0 for 8 SCK cycles. I/O1  to I/O3 are “don’t care” during these cycles.\nFigure 121.  Mode Bit (MBR FFh) Reset Command SequenceCS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input Password Low Byte     Input Password High Byte\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDocument Number: 001-98284 Rev. *R Page 104 of 136S25FL512S\n9.10 Embedded Algorithm Performance Tables\nTable 44.  Program and Erase Performance\nSymbol Parameter Min Typ[49]Max[50]Unit\ntW WRR Write Time  – 560 2000 ms \ntPP Page Programming (512  bytes) – 340 750/1300[51]µs\ntSESector Erase Time \n(256-kB logical sectors = 4 x 64 kB physical sectors) – 520 2600 ms\ntBE Bulk Erase Time (S25FL512S) – 103 460 sec\nNotes\n49. Typical program and erase times assume the following conditi ons: 25°C, VCC = 3.0V; 10,000 cycles; checkerboard data pattern.\n50. Under worst case conditions o f 90°C; 100,000 cycles max.\n51. Industrial temperature range / Industrial Plus temperature r ange.\nTable 45.  Program Suspend AC Parameters\nParameter Min Typical Max Unit Comments \nProgram Suspend Latency (tPSL) –  40 µs The time from Program Suspend command \nuntil the WIP bit is 0\nProgram Resume to next Program \nSuspend (tPRS) 0.06 100  – µsMinimum is the time needed to issue the next \nProgram Suspend command but ≥ typical \nperiods are needed for Program to progress to \ncompletion\nTable 46.  Erase Suspend AC Parameters\nParameter Min Typical Max Unit Comments \nErase Suspend Latency (tESL) –  – 45 µs The time from Erase Suspend command until \nthe WIP bit is 0\nErase Resume to next Erase Suspend \n(tERS) 0.06 100 – µsMinimum is the time needed to issue the next Erase Suspend comm and but ≥ typical \nperiods are needed for the Erase to progress \nto completion\nDocument Number: 001-98284 Rev. *R Page 105 of 136S25FL512S\n10. Data Integrity\n10.1 Erase Endurance\n10.2 Data Retention\nContact Cypress Sales and FAE for further i nformation on the da ta integrity. An applicat ion note is available at:\nwww.cypress.com/appnotes .Table 47.  Erase Endurance\nParameter Minimum Unit \nProgram/Erase cycles per main Flash array sectors 100K PE cycleProgram/Erase cycles per PPB arra y or nonvolatile  register arra y\n[52]100K PE cycle\nNote\n52. Each write command to a nonvolatile register causes a PE cyc le on the entire nonvolatile register array. OTP bits and regis ters internally reside in a separate array \nthat is not PE cycled.\nTable 48.  Data Retention\nParameter Test Conditions Minimum \nTime Unit \nData Retention Time 1K Program/Erase Cycles 20 Years\n10K Program/Erase Cycles 20 Years100K Program/Erase Cycles 2 Years\nDocument Number: 001-98284 Rev. *R Page 106 of 136S25FL512S\n11. Software Interface Reference\n11.1 Command Summary\nTable 49.  S25FL512S Instruction Set (sorted by instruction)\nInstruction (Hex) Command Name Command Description Maximum Frequency (MHz)\n01 WRR Write Register \n(Status-1, Configuration-1) 133\n02 PP Page Program (3- or 4-byte \naddress) 133\n03 READ Read (3- or 4-byte address) 50\n04 WRDI Write Disable 13305 RDSR1 Read Status Register-1 133\n06 WREN Write Enable 133\n07 RDSR2 Read Status Register-2 133\n0B FAST_READ Fast Read (3- or 4-byte address) 133\n0C 4FAST_READ Fast Read (4-byte address) 133\n0D DDRFR DDR Fast Read (3- or 4-byte \naddress)80\n0E 4DDRFR DDR Fast Read (4-byte address) 80\n12 4PP Page Program (4-byte address) 133\n13 4READ Read (4-byte address) 50\n14 ABRD AutoBoot Register Read 13315 ABWR AutoBoot Register Write 133\n16 BRRD Bank Register Read 133\n17 BRWR Bank Register Write 13318 ECCRD ECC Read 133\n2B ASPRD ASP Read 133\n2F ASPP ASP Program 133\n30 CLSR Clear Status Register - \nErase/Program Fail Reset 133\n32 QPP Quad Page Program (3- or 4-byte \naddress)80\n34 4QPPQuad Page Program (4-byte \naddress) 80\n35 RDCR Read Configuration Register-1 13338 QPP Quad Page Program (3- or 4-byte \naddress)80\n3B DOR Read Dual Out (3- or 4-byte \naddress)104\n3C 4DOR Read Dual Out (4-byte address) 104\n41 DLPRD Data Learning Pattern Read 133\n42 OTPP OTP Program 133\n43 PNVDLR Program NV Data Learning Register 133\n4A WVDLR Write Volatile Data Learning \nRegister 133\n4B OTPR OTP Read 1335A RSFDPRead Serial Flash Discoverable \nParameters133\n60 BE Bulk Erase 133\nDocument Number: 001-98284 Rev. *R Page 107 of 136S25FL512S\n6B QOR Read Quad Out (3- or 4-byte \naddress)104\n6C 4QOR Read Quad Out (4-byte address) 104\n75 ERSP Erase Suspend 133\n7A ERRS Erase Resume 133\n85 PGSP Program Suspend 133\n8A PGRS Program Resume 133\n90 READ_ID (REMS) Read Electronic Manufacturer \nSignature 133\n9F RDID Read ID (JEDEC Manufacturer ID \nand JEDEC CFI)133\nA3 MPM Reserved for Multi-I/O-High Perf \nMode (MPM) 133\nA6 PLBWR PPB Lock Bit Write 133\nA7 PLBRD PPB Lock Bit Read 133\nAB RES Read Electronic Signature 50\nB9 BRACBank Register Access\n(Legacy Command formerly used \nfor Deep Power Down)133\nBB DIOR Dual I/O Read (3- or 4-byte address) 104\nBC 4DIOR Dual I/O Read (4-byte address) 104\nBD DDRDIOR DDR Dual I/O Read (3- or 4-byte \naddress)80\nBE 4DDRDIOR DDR Dual I/O Read (4-byte \naddress) 80\nC7 BE Bulk Erase (alternate command) 133\nD8 SE Erase 256 kB (3- or 4-byte address) 133\nDC 4SE Erase 256 kB (4-byte address) 133\nE0 DYBRD DYB Read 133E1 DYBWR DYB Write 133\nE2 PPBRD PPB Read 133\nE3 PPBP PPB Program 133E4 PPBE PPB Erase 133\nE5 Reserved-E5 Reserved –\nE6 Reserved-E6 Reserved –E7 PASSRD Password Read 133\nE8 PASSP Password Program 133\nE9 PASSU Password Unlock 133\nEB QIOR Quad I/O Read (3- or 4-byte \naddress)104\nEC 4QIOR Quad I/O Read (4-byte address) 104ED DDRQIORDDR Quad I/O Read (3- or 4-byte \naddress)80\nEE 4DDRQIOR DDR Quad I/O Read (4-byte \naddress) 80\nF0 RESET Software Reset 133\nFF MBR Mode Bit Reset 133Table 49.  S25FL512S Instruction Set (sorted by instruction) (C ontinued)\nInstruction (Hex) Command Name Command Description Maximum Frequency (MHz)\nDocument Number: 001-98284 Rev. *R Page 108 of 136S25FL512S\n11.2 Serial Flash Discoverable Parameters (SFDP) Address Map\nThe SFDP address space has a header starting at address zero th at identifies the SFDP data structure and provides a pointer to  each\nparameter. One Basic Flash parameter is mandated by the JEDEC J ESD216B standard. Two optional parameter tables for Sector\nMap and 4 Byte Address Instructions follow the Basic Flash tabl e. Cypress provides an additional parameter by pointing to the ID-CFI\naddress space i.e. the ID-CFI address space is a sub-set of the  SFDP address space. The paramet er tables portion of the SFDP d ata\nstructure are located within the ID-CFI address space and is th us both a CFI parameter and an SFDP parameter. In this way both\nSFDP and ID-CFI information can be accessed by either the RSFDP  or RDID commands.\nTable 50.  SFDP Overview Map\nByte Address Description\n0000h Location zero within JEDEC JESD216B S FDP space – start of  SFDP header \n,,, Remainder of SFDP header f ollowed by undefined space \n1000h Location zero within ID-CF I space – start of ID-CFI param eter tables \n... ID-CFI parameters \n1120h Start of SFDP parameter whi ch is also one of the CFI para meter tables \n... Remainder of SFDP parameter  tables followed by either more CFI parameters or undefined space \nDocument Number: 001-98284 Rev. *R Page 109 of 136S25FL512S\n11.2.1 Field Definitions\nTable 51.  SFDP Header\nRelative Byte \nAddressSFDP Dword \nAddressData Description \n00h \nSFDP Header \n1st DWORD 53h This is the entry point for Read SFDP (5Ah) command i.e. locati on zero within SFDP space \nASCII “S” \n01h 46h ASCII “F” \n02h 44h ASCII “D” 03h 50h ASCII “P” \n04h \nSFDP Header \n2nd DWORD 06h SFDP Minor Revision (06h = JED EC JESD216 Revision B) This revis ion is backward \ncompatible with all prior minor revisions. Minor r evisions are changes that define previously \nreserved fields, add fields to t he end, or that clarify definit ions of existing fields. Increments \nof the minor revision value indi cate that previously reserved p arameter fields may have been \nassigned a new definition or entire Dwords may have been added to the parameter table. \nHowever, the definition of previ ously existing fields is unchan ged and therefore remain \nbackward compatible with earlier SFDP parameter table revisions . Software can safely \nignore increments of the minor r evision number, as long as only  those parameters the \nsoftware was designed to support are  used i.e. previously reser ved fields and additional \nDwords must be masked or ignored . Do not do a simple compare o n the minor revision \nnumber, looking only for a match with the revision number that the software is designed to \nhandle. There is no problem with using a higher number minor re vision.\n05h 01h SFDP Major Revision This is the original major revision. This m ajor revision is compatible \nwith all SFDP reading and parsing software. \n06h 05h Number of Parameter Headers (zero based, 05h = 6 parame ters) \n07h FFh Unused 08h \nParameter \nHeader 0 1st \nDWORD 00h Parameter ID LSb (00h = JEDEC SFDP Basic SPI Flash Paramete r) \n09h 00h Parameter Minor Revision (00h =  JESD216) - This older revision parameter header is \nprovided for any legacy SFDP reading and parsing software that requires seeing a minor \nrevision 0 parameter header. SF DP software designed to handle l ater minor revisions should \ncontinue reading parameter headers looking for a higher numbere d minor revision that \ncontains additional parameters for that software revision. \n0Ah 01h Parameter Major Revision (01h = T he original major revision - a ll SFDP software is \ncompatible with this major revision. \n0Bh 09h Parameter Table Length (in double words = Dwords = 4 by te units) 09h = 9 Dwords \n0Ch \nParameter \nHeader 0 2nd \nDWORD 20h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC B asic SPI Flash parameter \nbyte offset = 1120h \n0Dh 11h Parameter Table Pointer Byte 1 \n0Eh 00h Parameter Table Pointer Byte 2 \n0Fh FFh Parameter ID MSb (FFh = JEDEC defined legacy Parameter ID) \n10h \nParameter \nHeader 1 1st \nDWORD 00h Parameter ID LSb (00h = JEDEC SFDP Basic SPI Flash Paramete r) \n11h 05h Parameter Minor Revision (05h =  JESD216 Revision A) - This olde r revision parameter \nheader is provided for any legacy SFDP reading and parsing soft ware that requires seeing a \nminor revision 5 parameter header. SFDP software designed to ha ndle later minor revisions \nshould continue reading parameter headers looking for a later m inor revision that contains \nadditional parameters. \n12h 01h Parameter Major Revision (01h = T he original major revision - a ll SFDP software is \ncompatible with this major revision. \n13h 10h Parameter Table Length (in double words = Dwords = 4 by te units) 10h = 16 Dwords \n14h \nParameter \nHeader 1 2nd \nDWORD 20h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC B asic SPI Flash parameter \nbyte offset = 1120h address \n15h 11h Parameter Table Pointer Byte 1 \n16h 00h Parameter Table Pointer Byte 2 17h FFh Parameter ID MSb (FFh = JEDEC defined Parameter) \nDocument Number: 001-98284 Rev. *R Page 110 of 136S25FL512S\n18h \nParameter \nHeader 2 1st \nDWORD 00h Parameter ID LSb (00h = JEDEC SFDP Basic SPI Flash Paramete r) \n19h 06h Parameter Minor Revision (06h = JESD216 Revision B) \n1Ah 01h Parameter Major Revision (01h = T he original major revision - a ll SFDP software is \ncompatible with this major revision. \n1Bh 10h Parameter Table Length (in double words = Dwords = 4 by te units) 10h = 16 Dwords \n1Ch \nParameter \nHeader 2 2nd \nDWORD 20h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC B asic SPI Flash parameter \nbyte offset = 1120h address \n1Dh 11h Parameter Table Pointer Byte 1 \n1Eh 00h Parameter Table Pointer Byte 2 \n1Fh FFh Parameter ID MSb (FFh = JEDEC defined Parameter) \n20h \nParameter \nHeader 3 1st \nDWORD 81h Parameter ID LSb (81h = SFDP Sector Map Parameter) \n21h 00h Parameter Minor Revision ( 00h = Initial version as defi ned in JESD216 Revision B) \n22h 01h Parameter Major Revision (01h = T he original major revision - a ll SFDP software that \nrecognizes this parameter’s ID is compatible with this major re vision. \n23h 02h Parameter Table Length (in double words = Dwords = 4 by te units) 02h = 2 Dwords \n24h \nParameter \nHeader 3 2nd \nDWORD 60h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC p arameter byte offset = \n1160h \n25h 11h Parameter Table Pointer Byte 1 \n26h 00h Parameter Table Pointer Byte 2 27h FFh Parameter ID MSb (FFh = JEDEC defined Parameter) \n28h \nParameter \nHeader 4 1st \nDWORD 84h Parameter ID LSb (00h = SFDP 4 Byte Address Instructions Pa rameter) \n29h 00h Parameter Minor Revision ( 00h = Initial version as defi ned in JESD216 Revision B) \n2Ah 01h Parameter Major Revision (01h = T he original major revision - a ll SFDP software that \nrecognizes this parameter’s ID is compatible with this major re vision. \n2Bh 02h Parameter Table Length (in double words = Dwords = 4 by te units) (2h = 2 Dwords) \n2Ch \nParameter \nHeader 4 2nd \nDWORD 68h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC p arameter byte offset = \n1168h \n2Dh 11h Parameter Table Pointer Byte 1 \n2Eh 00h Parameter Table Pointer Byte 2 \n2Fh FFh Parameter ID MSb (FFh = JEDEC defined Parameter) \n30h \nParameter \nHeader 5 1st \nDWORD \n 01h Parameter ID LSb (Spansion Vendor Specific ID-CFI parameter) Le gacy Manufacturer ID \n01h = AMD / Spansion \n31h 01h Parameter Minor Revision (01h = ID-CFI updated with SFD P Rev B table) \n32h 01h Parameter Major Revision (01h = T he original major revision - a ll SFDP software that \nrecognizes this parameter’s ID is compatible with this major re vision. \n33h 5ChParameter Table Length (in double words = Dwords = 4 byte units\n) CFI starts at 1000h, the \nfinal SFDP parameter (CFI ID = A5)  starts at 111Eh (SFDP starti ng point of 1120h -2hB of \nCFI parameter header), for a length of 11EhB excluding the CFI A5 parameter. The final CFI \nA5 parameter adds an additional 52hB for a total of 11Eh + 82h = 170hB. 170hB/4 = 5Ch \nDwords.\n34h \nParameter \nHeader 5 2nd \nDWORD 00h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) Entry p oint for ID-CFI parameter is \nbyte offset = 1000h relative to SFDP location zero. \n35h 10h Parameter Table Pointer Byte 1 36h 00h Parameter Table Pointer Byte 2 \n37h 01h Parameter ID MSb (01h = JEDEC JEP106 Bank Number 1) Table 51.  SFDP Header (Continued)\nRelative Byte \nAddressSFDP Dword \nAddressData Description \nDocument Number: 001-98284 Rev. *R Page 111 of 136S25FL512S\n11.3 Device ID and Common Flash  Interface (ID-CFI) Address Map\n11.3.1 Field Definitions\nTable 52.  Manufacturer and Device ID\nByte Address Data Description \n00h 01h Manufacturer ID for Spansion01h 02h (512 Mb) Device ID MSB - Memory Interface Type02h 20h (512 Mb) Device ID LSB - Density\n03h xxhID-CFI Length - number bytes fo llowing. Adding this value to th e \ncurrent location of 03h gives t he address of the last valid loc ation \nin the ID-CFI address map. A value of 00h indicates the entire \n512-byte ID-CFI space must be read because the actual length of  \nthe ID-CFI information is longer t han can be indicated by this \nlegacy single byte field. The value is OPN dependent.\n04h 00h (Uniform 256-kB sect ors) Sector Architecture\n05h 80h (FL-S Family) Family ID06h xxh ASCII characters for Model\nRefer to Section 12 Ordering Information on page 131  for the \nmodel number definitions. 07h xxh\n08h xxh Reserved\n09h xxh Reserved\n0Ah xxh Reserved0Bh xxh Reserved\n0Ch xxh Reserved0Dh xxh Reserved\n0Eh xxh Reserved\n0Fh xxh Reserved\nTable 53.  CFI Query Identification String \nByte Address Data Description \n10h\n11h\n12h 51h\n52h59h Query Unique ASCII string “QRY” \n13h\n14h 02h\n00h Primary OEM Command Set\nFL-P backward compatible command set ID\n15h\n16h 40h\n00h Address for Primary Extended Table \n17h\n18h 53h\n46h Alternate OEM Command Set \nASCII characters “FS” for SPI (F) interface, S Technology\n19h\n1Ah 51h\n00h Address for Alternate OEM Extended Table \nDocument Number: 001-98284 Rev. *R Page 112 of 136S25FL512S\nTable 54.  CFI System Interface String\nByte Address Data Description \n1Bh 27h VCC Min. (erase/progr am): 100 millivolts\n1Ch 36h VCC Max. (erase/program): 100 millivolts\n1Dh 00h VPP Min. voltage (00h = no VPP present) \n1Eh 00h VPP Max. voltage (00h = no VPP present) \n1Fh 06h Typical timeout per single byte program 2N µs\n20h 09h (512B page) Typical timeout for Min. size Page program 2N µs \n(00h = not supported) \n21h 09h (256 kB) Typical timeout  per individual sector erase 2N ms \n22h 11h (512 Mb) Typical timeout for full chip erase 2N ms (00h = not supported) \n23h 02h Max. timeout for byte program 2N times typical \n24h 02h Max. timeout for page program 2N times typical \n25h 03h Max. timeout per individual sector erase 2N times typical\n26h 03h Max. timeout for f ull chip erase 2N times typical \n(00h = not supported) \nTable 55.  Device Geometry De finition for 512-Mb Device\nByte Address Data Description \n27h 1Ah (512 Mb) Device Size = 2N bytes;\n28h 02h Flash Device Interface Description; \n0000h = x8 only \n0001h = x16 only \n0002h = x8/x16 capable 0003h = x32 only \n0004h = Single I/O SPI, 3-byte address \n0005h = Multi I/O SPI , 3-byte address \n0102h = Multi I/O SPI, 3- or 4-byte address 29h 01h \n2Ah 09h Max. number of bytes  in multi-byte write = 2N\n(0000 = not supported\n0009h = 512B page) 2Bh 00h \n2Ch 01h Number of Erase Block R egions within device \n1 = Uniform Device, 2 = Boot Device \n2Dh FFh \nErase Block Region 1 Informa tion (refer to JEDEC JEP137)\n32 sectors = 32 -1 = 001Fh \n4-kB sectors = 256 bytes x 0010h 2Eh 00h \n2Fh 00h \n30h 04h \n31h thru 3Fh FFh RFU \nDocument Number: 001-98284 Rev. *R Page 113 of 136S25FL512S\nTable 56.  CFI Primary Vendo r-Specific Extended Query  \nByte Address Data Description \n40h 50h \nQuery-unique ASCII string “PRI” 41h 52h \n42h 49h 43h 31h Major version number = 1, ASCII 44h 33h Minor version number = 3, ASCII \n45h 21h Address Sensitive Unlock (Bits 1-0) \n00b = Required\n01b = Not Required \nProcess Technology (Bits 5-2)\n0000b = 0.23 µm Floating Gate \n0001b = 0.17 µm Floating Gate 0010b = 0.23 µm MirrorBit\n0011b = 0.11 µm Floating Gate \n0100b = 0.11 µm MirrorBit\n0101b = 0.09 µm MirrorBit1000b = 0.065 µm MirrorBit\n46h 02h Erase Suspend \n0 = Not Supported\n1 = Read Only2 = Read and Program\n47h 01h Sector Protect \n00 = Not Supported\nX = Number of sectors in group \n48h 00h Temporary Sector Unprotect \n00 = Not Supported\n01 = Supported \n49h 08h Sector Protect/Unprotect Scheme \n04 = High Volt age Method \n05 = Software Command  Locking Method \n08 = Advanced Sector Protection Method \n09 = Secure\n4Ah 00h Simultaneous Operation \n00 = Not Supported\nX = Number of Sectors \n4Bh 01h Burst Mode (Synchronous  sequential read) support\n00 = Not Supported\n01 = Supported \n4Ch xxhPage Mode Type, model dependent\n00 = Not Supported\n01 = 4 Word Read Page02 = 8 Read Word Page03 = 256-Byte Program Page04 = 512-Byte Program Page \n4Dh 00h ACC (Acceleration) Supply Minimum \n00 = Not Suppor ted, 100 mV \n4Eh 00h ACC (Acceleration) Supply Maximum \n00 = Not Suppor ted, 100 mV \nDocument Number: 001-98284 Rev. *R Page 114 of 136S25FL512S\nThe Alternate Vendor-Specific Extended Query provides informati on related to the expanded command set provided by the FL-S\nfamily. The alternate query parameters use a format in which ea ch parameter begins with an ident ifier byte and a parameter len gth\nbyte. Driver software can check each parameter ID and can use t he length value to skip to the next parameter if the parameter is not\nneeded or not recogni zed by the software.4Fh 07h WP# Protection \n01 = Whole Chip \n04 = Uniform Device wit h Bottom WP Protect \n05 = Uniform Device w ith Top WP Protect \n07 = Uniform Device wit h Top or Bottom Write Protect (user sele ct)\n50h 01h Program Suspend \n00 = Not Supported\n01 = Supported \nTable 57.  CFI Alternate Vendor- Specific Extended Query Header\nByte Address Data Description \n51h 41h \nQuery-unique ASCII string “ALT” 52h 4Ch \n53h 54h 54h 32h Major version number = 2, ASCII 55h 30h Minor version number = 0, ASCII \nTable 58.  CFI Alternate Vendor- Specific Extended Query Paramet er 0\nParameter Relative \nByte Address \nOffsetData Description \n00h 00h Parameter ID ( Ordering Part Number)\n01h 10hParameter Length (The number of  following bytes in this paramet er. Adding this value \nto the current location value +1  = the first byte of the next p arameter)\n02h 53h ASCII “S” for manufacturer (Spansion)03h 32h\nASCII “25” for Product Cha racters (Single Die SPI)\n04h 35h\n05h 46h\nASCII “FL” for Interface Characters (SPI 3 Volt)\n06h 4Ch\n07h 35h (512 Mb)\nASCII characters for density 08h 31h (512 Mb)\n09h 32h (512 Mb)\n0Ah 53h ASCII “S” for Technology (65nm MirrorBit)0Bh xxh\nReserved for Future Use (RFU)0Ch xxh\n0Dh xxh\n0Eh xxh\n0Fh xxh\n10h xxh\n11h xxhTable 56.  CFI Primary Vendo r-Specific Extended Query   (Continued)\nByte Address Data Description \nDocument Number: 001-98284 Rev. *R Page 115 of 136S25FL512S\nTable 59.  CFI Alternate Vendor- Specific Extended Query Paramet er 80h Address Options\nParameter Relative \nByte Address \nOffsetData Description \n00h 80h Parameter ID ( Ordering Part Number)\n01h 01hParameter Length (The number of  following bytes in this paramet er. Adding this value \nto the current location value +1  = the first byte of the next p arameter)\n02h F0hBits 7:4 - Reserved = 1111b\nBit 3 - AutoBoot support - Ye s= 0b, No = 1bBit 2 - 4-byte address instructions support ed - Yes = 0b, No = 1b\nBit 1 - Bank address + 3-byte a ddress instructions supported - Yes = 0b, No = 1b\nBit 0 - 3-byte address instructions support ed - Yes = 0b, No = 1b\nTable 60.  CFI Alternate Vendor- Specific Extended Query Paramet er 84h Suspend Commands\nParameter Relative \nByte Address \nOffsetData Description \n00h 84h Parameter ID (Suspend Commands\n01h 08hParameter Length (The number of  following bytes in this paramet er. Adding this value \nto the current location value +1  = the first byte of the next p arameter)\n02h 85h Program suspen d instruction code\n03h 28h Program suspend latency maximum (µs)04h 8Ah Program resume instruction code05h 64h Program resume to next suspend typical (µs)06h 75h Erase suspen d instruction code\n07h 28h Erase suspend latency maximum (µs)08h 7Ah Erase resume instruction code09h 64h Erase resume to ne xt suspend typical (µs)\nTable 61.  CFI Alternate Vendor- Specific Extended Query Paramet er 88h Data Protection\nParameter Relative \nByte Address \nOffsetData Description \n00h 88h Parameter ID  (Data Protection)\n01h 04hParameter Length (The number of  following bytes in this paramet er. Adding this value \nto the current location value +1  = the first byte of the next p arameter)\n02h 0Ah OTP size 2N bytes, FFh = not supported\n03h 01h OTP address map format, 01h  = FL-S format, FFh = not supp orted\n04h xxhBlock Protect Type, model dependent\n00h = FL-P, FL-S, FFh = not supported\n05h xxhAdvanced Sector Protection type, model dependent\n01h = FL-S ASP\nDocument Number: 001-98284 Rev. *R Page 116 of 136S25FL512S\nTable 62.  CFI Alternate Vendor- Specific Extended Query Paramet er 8Ch Reset Timing\nParameter Relative \nByte Address \nOffsetData Description \n00h 8Ch Parameter ID (Reset Timing)\n01h 06hParameter Length (The number of  following bytes in this paramet er. Adding this value \nto the current location value +1  = the first byte of the next p arameter)\n02h 96h POR maximum value03h 01h POR maximum exponent 2\nN µs\n04h 23h Hardware Reset maximum  value, FFh = not supported\n05h 00h Hardware Reset maximum exponent 2N µs\n06h 23h Software Reset maximum  value, FFh = not supported\n07h 00h Software Reset maximum exponent 2N µs\nTable 63.  CFI Alternate Vendor- Specific Extended Query Paramet er 90h - HPLC(SDR)\nParameter Relative \nByte Address OffsetData Description \n00h 90h Parameter ID (Latency Code Table)01h 56hParameter Length (The number of following bytes in this paramet er. Adding this value to the \ncurrent location value +1 = the first byte of the next paramete r)\n02h 06h Number of rows03h 0Eh Row length in bytes\n04h 46h Start of header (row 1), ASCII “F” for frequency column h eader\n05h 43h ASCII “C” for Code column header06h 03h Read 3-byte address instruction\n07h 13h Read 4-byte address instruction\n08h 0Bh Read Fast 3-byte address instruction09h 0Ch Read Fast 4-byte address instruction\n0Ah 3Bh Read Dual Out 3-byte address instruction\n0Bh 3Ch Read Dual Out 4-byte address instruction\n0Ch 6Bh Read Quad Out 3-byte address instruction\n0Dh 6Ch Read Quad Out 4-byte address instruction\n0Eh BBh Dual I/O Read 3-byte address instruction\n0Fh BCh Dual I/O Read 4-byte address instruction\n10h EBh Quad I/O Read 3-byte address instruction\n11h ECh Quad I/O Read 4-byte address instruction\n12h 32h Start of row 2, SCK frequency limit for this row (50 MHz)\n13h 03h Latency Code for this row (11b)\n14h 00h Read mode cycles15h 00h Read latency cycles\n16h 00h Read Fast mode cycles\n17h 00h Read Fast latency cycles18h 00h Read Dual Out mode cycles\n19h 00h Read Dual Out latency cycles\nDocument Number: 001-98284 Rev. *R Page 117 of 136S25FL512S\n1Ah 00h Read Quad Out mode cycles\n1Bh 00h Read Quad Out latency cycles\n1Ch 00h Dual I/O Read mode cycles\n1Dh 04h Dual I/O Read latency cycles\n1Eh 02h Quad I/O Read mode cycles\n1Fh 01h Quad I/O Read latency cycles\n20h 50h Start of row 3, SCK frequency limit for this row (80 MHz)\n21h 00h Latency Code for this row (00b)22h FFh Read mode cycles (FFh = command not supported at this fre quency)\n23h FFh Read latency cycles\n24h 00h Read Fast mode cycles25h 08h Read Fast latency cycles\n26h 00h Read Dual Out mode cycles\n27h 08h Read Dual Out latency cycles\n28h 00h Read Quad Out mode cycles\n29h 08h Read Quad Out latency cycles\n2Ah 00h Dual I/O Read mode cycles\n2Bh 04h Dual I/O Read latency cycles\n2Ch 02h Quad I/O Read mode cycles2Dh 04h Quad I/O Read latency cycles\n2Eh 5Ah Start of row 4, SCK frequency limit for this row (90 MHz)\n2Fh 01h Latency Code for this row (01b)\n30h FFh Read mode cycles (FFh = command not supported at this fre quency)\n31h FFh Read latency cycles\n32h 00h Read Fast mode cycles33h 08h Read Fast latency cycles\n34h 00h Read Dual Out mode cycles\n35h 08h Read Dual Out latency cycles36h 00h Read Quad Out mode cycles\n37h 08h Read Quad Out latency cycles\n38h 00h Dual I/O Read mode cycles39h 05h Dual I/O Read latency cycles\n3Ah 02h Quad I/O Read mode cycles\n3Bh 04h Quad I/O Read latency cycles\n3Ch 68h Start of row 5, SCK frequency limit for this row (104 MHz )\n3Dh 02h Latency Code for this row (10b)\n3Eh FFh Read mode cycles (FFh = command not supported at this fre quency)\n3Fh FFh Read latency cycles\n40h 00h Read Fast mode cycles\n41h 08h Read Fast latency cycles42h 00h Read Dual Out mode cycles\n43h 08h Read Dual Out latency cyclesTable 63.  CFI Alternate Vendor- Specific Extended Query Paramet er 90h - HPLC(SDR) (Continued)\nParameter Relative \nByte Address OffsetData Description \nDocument Number: 001-98284 Rev. *R Page 118 of 136S25FL512S\n44h 00h Read Quad Out mode cycles\n45h 08h Read Quad Out latency cycles46h 00h Dual I/O Read mode cycles\n47h 06h Dual I/O Read latency cycles\n48h 02h Quad I/O Read mode cycles49h 05h Quad I/O Read latency cycles\n4Ah 85h Start of row 6, SCK frequency limit for this row (133 MHz )\n4Bh 02h Latency Code for this row (10b)\n4Ch FFh Read mode cycles (FFh = command not supported at this fre quency)\n4Dh FFh Read latency cycles\n4Eh 00h Read Fast mode cycles\n4Fh 08h Read Fast latency cycles\n50h FFh Read Dual Out mode cycles\n51h FFh Read Dual Out latency cycles\n52h FFh Read Quad Out mode cycles\n53h FFh Read Quad Out latency cycles54h FFh Dual I/O Read mode cycles\n55h FFh Dual I/O Read latency cycles\n56h FFh Quad I/O Read mode cycles57h FFh Quad I/O Read latency cycles\nTable 64.  CFI Alternate Vendor- Specific Extended Query Paramet er 9Ah - HPLC DDR \nParameter Relative \nByte Address OffsetData Description \n00h 9Ah Parameter ID (Latency Code Table)01h 2AhParameter Length (The number of following bytes in this paramet er. Adding this value to the \ncurrent location value +1 = the first byte of the next paramete r)\n02h 05h Number of rows\n03h 08h Row length in bytes\n04h 46h Start of header (row 1), ASCII “F” for frequency column h eader\n05h 43h ASCII “C” for Code column header\n06h 0Dh Read Fast DDR 3-byte address instruction\n07h 0Eh Read Fast DDR 4-byte address instruction08h BDh DDR Dual I/O Read 3-by te address instruction\n09h BEh DDR Dual I/O Read 4-by te address instruction\n0Ah EDh Read DDR Quad I/O 3-byte address instruction0Bh EEh Read DDR Quad I/O 4-byte address instruction\n0Ch 32h Start of row 2, SCK frequency limit for this row (50 MHz)\n0Dh 03h Latency Code for this row (11b)\n0Eh 00h Read Fast DDR mode cycles\n0Fh 04h Read Fast DDR latency cycles\n10h 00h DDR Dual I/O Read mode cycles\n11h 04h DDR Dual I/O Read latency cyclesTable 63.  CFI Alternate Vendor- Specific Extended Query Paramet er 90h - HPLC(SDR) (Continued)\nParameter Relative \nByte Address OffsetData Description \nDocument Number: 001-98284 Rev. *R Page 119 of 136S25FL512S\n12h 01h Read DDR Quad I/O mode cycles\n13h 03h Read DDR Quad I/O latency cycles14h 42h Start of row 3, SCK frequency limit for this row (66 MHz)\n15h 00h Latency Code for this row (00b)\n16h 00h Read Fast DDR mode cycles17h 05h Read Fast DDR latency cycles\n18h 00h DDR Dual I/O Read mode cycles\n19h 06h DDR Dual I/O Read latency cycles\n1Ah 01h Read DDR Quad I/O mode cycles\n1Bh 06h Read DDR Quad I/O latency cycles\n1Ch 42h Start of row 4, SCK frequency limit for this row (66 MHz)1Dh 01h Latency Code for this row (01b)\n1Eh 00h Read Fast DDR mode cycles\n1Fh 06h Read Fast DDR latency cycles\n20h 00h DDR Dual I/O Read mode cycles\n21h 07h DDR Dual I/O Read latency cycles22h 01h Read DDR Quad I/O mode cycles\n23h 07h Read DDR Quad I/O latency cycles\n24h 42h Start of row 5, SCK frequency limit for this row (66 MHz)25h 02h Latency Code for this row (10b)\n26h 00h Read Fast DDR mode cycles\n27h 07h Read Fast DDR latency cycles28h 00h DDR Dual I/O Read mode cycles\n29h 08h DDR Dual I/O Read latency cycles\n2Ah 01h Read DDR Quad I/O mode cycles2Bh 08h Read DDR Quad I/O latency cyclesTable 64.  CFI Alternate Vendor- Specific Extended Query Paramet er 9Ah - HPLC DDR  (Continued)\nParameter Relative \nByte Address OffsetData Description \nDocument Number: 001-98284 Rev. *R Page 120 of 136S25FL512S\nTable 65.  CFI Alternate Vendor- Specific Extended Query Paramet er 90h - EHPLC (SDR)\nParameter Relative \nByte Address OffsetData Description \n00h 90h Parameter ID (Latency Code Table)01h 56hParameter Length (The number of following bytes in this paramet er. Adding this value to the \ncurrent location value +1 = the first byte of the next paramete r)\n02h 06h Number of rows03h 0Eh Row length in bytes\n04h 46h Start of header (row 1), ASCII “F” for frequency column h eader\n05h 43h ASCII “C” for Code column header06h 03h Read 3-byte address instruction\n07h 13h Read 4-byte address instruction\n08h 0Bh Read Fast 3-byte address instruction09h 0Ch Read Fast 4-byte address instruction\n0Ah 3Bh Read Dual Out 3-byte address instruction\n0Bh 3Ch Read Dual Out 4-byte address instruction\n0Ch 6Bh Read Quad Out 3-byte address instruction\n0Dh 6Ch Read Quad Out 4-byte address instruction\n0Eh BBh Dual I/O Read 3-byte address instruction\n0Fh BCh Dual I/O Read 4-byte address instruction\n10h EBh Quad I/O Read 3-byte address instruction\n11h ECh Quad I/O Read 4-byte address instruction\n12h 32h Start of row 2, SCK frequency limit for this row (50 MHz)\n13h 03h Latency Code for this row (11b)14h 00h Read mode cycles\n15h 00h Read latency cycles\n16h 00h Read Fast mode cycles17h 00h Read Fast latency cycles\n18h 00h Read Dual Out mode cycles\n19h 00h Read Dual Out latency cycles\n1Ah 00h Read Quad Out mode cycles\n1Bh 00h Read Quad Out latency cycles\n1Ch 04h Dual I/O Read mode cycles1Dh 00h Dual I/O Read latency cycles\n1Eh 02h Quad I/O Read mode cycles\n1Fh 01h Quad I/O Read latency cycles\n20h 50h Start of row 3, SCK frequency limit for this row (80 MHz)\n21h 00h Latency Code for this row (00b)\n22h FFh Read mode cycles (FFh = command not supported at this fre quency)\n23h FFh Read latency cycles\n24h 00h Read Fast mode cycles\n25h 08h Read Fast latency cycles26h 00h Read Dual Out mode cycles\n27h 08h Read Dual Out latency cycles\n28h 00h Read Quad Out mode cycles\nDocument Number: 001-98284 Rev. *R Page 121 of 136S25FL512S\n29h 08h Read Quad Out latency cycles\n2Ah 04h Dual I/O Read mode cycles2Bh 00h Dual I/O Read latency cycles\n2Ch 02h Quad I/O Read mode cycles\n2Dh 04h Quad I/O Read latency cycles\n2Eh 5Ah Start of row 4, SCK frequency limit for this row (90 MHz)\n2Fh 01h Latency Code for this row (01b)\n30h FFh Read mode cycles (FFh = command not supported at this fre quency)\n31h FFh Read latency cycles\n32h 00h Read Fast mode cycles\n33h 08h Read Fast latency cycles34h 00h Read Dual Out mode cycles\n35h 08h Read Dual Out latency cycles\n36h 00h Read Quad Out mode cycles\n37h 08h Read Quad Out latency cycles\n38h 04h Dual I/O Read mode cycles39h 01h Dual I/O Read latency cycles\n3Ah 02h Quad I/O Read mode cycles\n3Bh 04h Quad I/O Read latency cycles\n3Ch 68h Start of row 5, SCK frequency limit for this row (104 MHz )\n3Dh 02h Latency Code for this row (10b)\n3Eh FFh Read mode cycles (FFh = command not supported at this fre quency)\n3Fh FFh Read latency cycles\n40h 00h Read Fast mode cycles\n41h 08h Read Fast latency cycles42h 00h Read Dual Out mode cycles\n43h 08h Read Dual Out latency cycles\n44h 00h Read Quad Out mode cycles45h 08h Read Quad Out latency cycles\n46h 04h Dual I/O Read mode cycles\n47h 02h Dual I/O Read latency cycles48h 02h Quad I/O Read mode cycles\n49h 05h Quad I/O Read latency cycles\n4Ah 85h Start of row 6, SCK frequency limit for this row (133 MHz )\n4Bh 02h Latency Code for this row (10b)\n4Ch FFh Read mode cycles (FFh = command not supported at this fre quency)\n4Dh FFh Read latency cycles\n4Eh 00h Read Fast mode cycles\n4Fh 08h Read Fast latency cycles\n50h FFh Read Dual Out mode cycles51h FFh Read Dual Out latency cycles\n52h FFh Read Quad Out mode cyclesTable 65.  CFI Alternate Vendor- Specific Extended Query Paramet er 90h - EHPLC (SDR) (Continued)\nParameter Relative \nByte Address OffsetData Description \nDocument Number: 001-98284 Rev. *R Page 122 of 136S25FL512S\n53h FFh Read Quad Out latency cycles\n54h FFh Dual I/O Read mode cycles55h FFh Dual I/O Read latency cycles\n56h FFh Quad I/O Read mode cycles\n57h FFh Quad I/O Read latency cycles\nTable 66.  CFI Alternate Vendor- Specific Extended Query Paramet er 9Ah - EHPLC DDR \nParameter Relative \nByte Address OffsetData Description \n00h 9Ah Parameter ID (Latency Code Table)01h 2AhParameter Length (The number of following bytes in this paramet er. Adding this value to the \ncurrent location value +1 = the first byte of the next paramete r)\n02h 05h Number of rows03h 08h Row length in bytes\n04h 46h Start of header (row 1), ASCII “F” for frequency column h eader\n05h 43h ASCII “C” for Code column header\n06h 0Dh Read Fast DDR 3-byte address instruction\n07h 0Eh Read Fast DDR 4-byte address instruction08h BDh DDR Dual I/O Read 3-by te address instruction\n09h BEh DDR Dual I/O Read 4-by te address instruction\n0Ah EDh Read DDR Quad I/O 3-byte address instruction0Bh EEh Read DDR Quad I/O 4-byte address instruction\n0Ch 32h Start of row 2, SCK frequency limit for this row (50 MHz)\n0Dh 03h Latency Code for this row (11b)\n0Eh 04h Read Fast DDR mode cycles\n0Fh 01h Read Fast DDR latency cycles\n10h 02h DDR Dual I/O Read mode cycles\n11h 02h DDR Dual I/O Read latency cycles\n12h 01h Read DDR Quad I/O mode cycles\n13h 03h Read DDR Quad I/O latency cycles14h 42h Start of row 3, SCK frequency limit for this row (66 MHz)\n15h 00h Latency Code for this row (00b)\n16h 04h Read Fast DDR mode cycles17h 02h Read Fast DDR latency cycles\n18h 02h DDR Dual I/O Read mode cycles\n19h 04h DDR Dual I/O Read latency cycles\n1Ah 01h Read DDR Quad I/O mode cycles\n1Bh 06h Read DDR Quad I/O latency cycles\n1Ch 42h Start of row 4, SCK frequency limit for this row (66 MHz)1Dh 01h Latency Code for this row (01b)\n1Eh 04h Read Fast DDR mode cycles\n1Fh 04h Read Fast DDR latency cycles\n20h 02h DDR Dual I/O Read mode cyclesTable 65.  CFI Alternate Vendor- Specific Extended Query Paramet er 90h - EHPLC (SDR) (Continued)\nParameter Relative \nByte Address OffsetData Description \nDocument Number: 001-98284 Rev. *R Page 123 of 136S25FL512S\n21h 05h DDR Dual I/O Read latency cycles\n22h 01h Read DDR Quad I/O mode cycles23h 07h Read DDR Quad I/O latency cycles\n24h 42h Start of row 5, SCK frequency limit for this row (66 MHz)\n25h 02h Latency Code for this row (10b)26h 04h Read Fast DDR mode cycles\n27h 05h Read Fast DDR latency cycles\n28h 02h DDR Dual I/O Read mode cycles29h 06h DDR Dual I/O Read latency cycles\n2Ah 01h Read DDR Quad I/O mode cycles\n2Bh 08h Read DDR Quad I/O latency cycles\nTable 67.  CFI Alternate Vendor- Specific Extended Query Paramet er F0h RFU\nParameter Relative \nByte Address \nOffsetData Description \n00h F0h Parameter ID (RFU)\n01h 0FhParameter Length (The number of  following bytes in this paramet er. Adding this value \nto the current location value +1  = the first byte of the next p arameter)\n02h FFh RFU\n... FFh RFU\n10h FFh RFU\nTable 68.  CFI Alternate Vendor- Specific Extended Query Paramet er A5h, JEDEC SFDP Rev B\nCFI Parameter \nRelative Byte \nAddress Offset SFDP \nParameter \nRelative Byte \nAddress Offset SFDP Dword \nName Data  Description \n00h — N/A A5h CFI Parameter ID (JEDEC SFDP) \n01h — N/A 50h CFI Parameter Length (The number of following bytes in this par ameter. Adding this value \nto the current location value +1 = the first byte of the next p arameter) \n02h 00h \nJEDEC Basic Flash \nParameter Dword-1 E7h Start of SFDP JEDEC parameter, located at 1120h in the overall SFDP address space. Bits \n7:5 = unused = 111b Bit 4:3 = 06h is status register write inst ruction & status register is \ndefault nonvolatile= 00b Bit 2 = Program Buffer > 64Bytes = 1 B its 1:0 = Uniform 4KB erase \nunavailable = 11b \n03h 01h FFh Bits 15:8 = Uniform 4KB erase opcode = not supporte d = FFh \n04h 02h F3h (FLxxxSAG) \nF7h (FLxxxSDP) Bit 23 = Unused = 1b Bit 22 = Supports Quad Out Read = Yes = 1b  Bit 21 = Supports Quad \nI/O Read = Yes =1b Bit 20 = Supports Dual I/O Read = Yes = 1b B it19 = Supports DDR 0= \nNo, 1 = Yes Bit 18:17 = Number of Address Bytes, 3 or 4 = 01b B it 16 = Supports Dual Out \nRead = Yes = 1b \n05h 03h FFh Bits 31:24 = Unused = FFh 06h 04h \nJEDEC Basic Flash \nParameter Dword-2 FFh \nDensity in bits, zero based, 512Mb = 1FFFFFFFh 07h 05h FFh \n08h 06h FFh 09h 07h 1Fh Table 66.  CFI Alternate Vendor- Specific Extended Query Paramet er 9Ah - EHPLC DDR  (Continued)\nParameter Relative \nByte Address OffsetData Description \nDocument Number: 001-98284 Rev. *R Page 124 of 136S25FL512S\n0Ah 08h \nJEDEC Basic Flash \nParameter Dword-3 44h Bits 7:5 = number of Quad I/O Mo de cycles = 010b Bits 4:0 = num ber of Quad I/O Dummy \ncycles = 00100b for def ault latency code 00b \n0Bh 09h EBh Quad I/O instruction code \n0Ch 0Ah 08h Bits 23:21 = number of Quad Out Mode cycles = 000b Bits 20:16 =  number of Quad Out \nDummy cycles = 01000b \n0Dh 0Bh 6Bh Quad Out instruction code \n0Eh 0Ch \nJEDEC Basic Flash \nParameter Dword-4 08h Bits 7:5 = number of Dual Out Mode cycles = 000b Bits 4:0 = num ber of Dual Out Dummy \ncycles = 01000b for def ault latency code \n0Fh 0Dh 3Bh Dual Out instruction code \n10h 0Eh 04h (HPLC) 80h \n(EHPLC)Bits 23:21 = number of Dual I/O M ode cycles = 100 b for EHPLC or  000b for HPLC Bits \n20:16 = number of Dual I/O Dummy cycles = 00000b for EHPLC or 0 0100b for HPLC \nDefault Latency code = 00b \n11h 0Fh BBh Dual I/O instruction code \n12h 10h \nJEDEC Basic Flash \nParameter Dword-5 EEh Bits 7:5 RFU = 111b Bit 4 = Quad All supported = No = 0b Bits 3 :1 RFU = 111b Bit 0 = Dual \nAll not supported = 0b \n13h 11h FFh Bits 15:8 = RFU = FFh \n14h 12h FFh Bits 23:16 = RFU = FFh \n15h 13h FFh Bits 31:24 = RFU = FFh 16h 14h \nJEDEC Basic Flash \nParameter Dword-6 FFh Bits 7:0 = RFU = FFh \n17h 15h FFh Bits 15:8 = RFU = FFh \n18h 16h FFh Bits 23:21 = number of Dual All Mode cycles = 111b Bits 20:16 =  number of Dual All Dummy \ncycles = 11111b \n19h 17h FFh Dual All instruction code \n1Ah 18h \nJEDEC Basic Flash \nParameter Dword-7 FFh Bits 7:0 = RFU = FFh \n1Bh 19h FFh  \n1Ch 1Ah FFh Bits 15:8 = RFU = FFh \n1Dh 1Bh EBh Bits 23:21 = number of Quad All Mode cycles = 111b Bits 20:16 =  number of Quad All \nDummy cycles = 11111b \n1Eh 1Ch \nJEDEC Basic Flash \nParameter Dword-8 00h Quad All mode Quad I/O (4-4-4) instruction code \n1Fh 1Dh FFh Erase type 1 instruction = not supported = FFh \n20h 1Eh 00h Erase type 2 size 2\nN Bytes = not supported = 00h \n21h 1Fh FFh Erase type 2 instruction = not supported = FFh 22h 20h \nJEDEC Basic Flash \nParameter Dword-9 12h Erase type 3 size 2\nN Bytes = 256KB = 12h \n23h 21h D8h Erase type 3 instruction \n24h 22h 00h Erase type 4 size 2N Bytes = not supported = 00h \n25h 23h FFh Erase type 4 instruction = not supported = FFh \n26h 24h \nJEDEC Basic Flash \nParameter \nDword-10 F2h Bits 31:30 = Erase type 4 Era se, Typical time units (00b: 1  ms, 01b: 16 ms, 10b: 128 ms, \n11b: 1 s) = RFU = 11b Bits 29:25 = Erase type 4 Erase, Typical time count = RFU = 11111b \n( typ erase time = count +1 * units = RFU ) Bits 24:23 = Erase type 3 Erase, Typical time \nunits (00b: 1 ms, 01b: 16 ms, 10b: 128 ms, 11b: 1 s) = 128mS = 10b Bits 22:18 = Erase type \n3 Erase, Typical time count = 00011b ( typ erase time = count + 1 * units = 4*128mS = \n512mS) Bits 17:16 = Erase type 2 Erase, Typical time units (00b : 1 ms, 01b: 16 ms, 10b: \n128 ms, 11b: 1 s) = RFU = 11b Bits 15:11 = Erase type 2 Erase, Typical time count = RFU = \n11111b ( typ erase time = count +1 * units = RFU ) Bits 10:9 = Erase type 1 Erase, Typical \ntime units (00b: 1 ms, 01b: 16 ms, 10b: 128 ms, 11b: 1 s) = RFU  = 11b Bits 8:4 = Erase type \n1 Erase, Typical time count = RFU = 11111b ( typ erase time = c ount +1 * units = RFU ) Bits \n3:0 = Multiplier from typical erase time to maximum erase time = 2*(N+1), N=2h = 6x \nmultiplier Binary Fields: 11-11111-10-00011-11-11111-11-11111-0 010 Nibble Format: \n1111_1111_0000_1111_1111_1111_1111_0010 Hex Format: FF_0F_FF_F2  27h 25h FFh \n28h 26h 0Fh \n29h 27h FFhTable 68.  CFI Alternate Vendor- Specific Extended Query Paramet er A5h, JEDEC SFDP  Rev B (Continued)\nCFI Parameter \nRelative Byte \nAddress Offset SFDP \nParameter \nRelative Byte \nAddress Offset SFDP Dword \nName Data  Description \nDocument Number: 001-98284 Rev. *R Page 125 of 136S25FL512S\n2Ah 28h \nJEDEC Basic Flash \nParameter \nDword-11 91h Bit 31 Reserved = 1b Bits 30:29 = Chip Erase, Typical time units (00b: 16 ms, 01b: 256 ms, \n10b: 4 s, 11b: 64 s) = 4s = 10b Bits 28:24 = Chip Erase, Typica l time count, (count+1)*units, \ncount = 11001b, ( typ Program time = count +1 * units = 26*.4uS  = 104S Bits 23 = Byte \nProgram Typical time, additional byte units (0b:1uS, 1b:8uS) = 1uS = 0b Bits 22:19 = Byte \nProgram Typical time, additional byte count, (count+1)*units, c ount = 0000b, ( typ Program \ntime = count +1 * units = 1*1uS = 1uS Bits 18 = Byte Program Ty pical time, first byte units \n(0b:1uS, 1b:8uS) = 8uS = 1b Bits 17:14 = Byte Program Typical t ime, first byte count, \n(count+1)*units, count = 1100b, ( typ Program time = count +1 *  units = 13*8uS = 104uS \nBits 13 = Page Program Typical time units (0b:8uS, 1b:64uS) = 6 4uS = 1b Bits 12:8 = Page \nProgram Typical time count, (co unt+1)*units, count = 00101b, ( typ Program time = count \n+1 * units =6*64uS = 384uS) Bits 7:4 = Page size 2N, N=9h, = 512B page Bits 3:0 = \nMultiplier from typical time to m aximum for Page or Byte progra m = 2*(N+1), N=1h = 4x \nmultiplier Binary Fields: 1-10-11001-0-0000-1-1100-1-00101-1001 -0001 Nibble Format: \n1101_1001_0000_0111_0010_0101_1001_0001 Hex Format: D9_07_25_91  2Bh 29h 25h \n2Ch 2Ah 07h \n2Dh 2Bh D9h \n2Eh 2Ch \nJEDEC Basic Flash \nParameter \nDword-12 ECh Bit 31 = Suspend and Resume supported = 0b Bits 30:29 = Sus pend in-progress erase max \nlatency units (00b: 128ns, 01b: 1us, 10b: 8us, 11b: 64us) = 8us = 10b Bits 28:24 = Suspend \nin-progress erase max latency count = 00101b, max erase suspend  latency = count +1 * \nunits = 6*8uS = 48uS Bits 23:20 = Erase resume to suspend inter val count = 0001b, interval \n= count +1 * 64us = 2 * 64us = 12 8us Bits 19:18 = Suspend in-pr ogress program max \nlatency units (00b: 128ns, 01b: 1us, 10b: 8us, 11b: 64us) = 8us = 10b Bits 17:13 = Suspend \nin-progress program max latency count = 00100b, max erase suspe nd latency = count +1 * \nunits = 5*8uS = 40uS Bits 12:9 = Program resume to suspend inte rval count = 0001b, \ninterval = count +1 * 64us = 2 * 64us = 128us Bit 8 = RFU = 1b Bits 7:4 = Prohibited \noperations during erase suspend = xxx0b: May not initiate a new  erase anywhere (erase \nnesting not permitted) + xx1xb: May not initiate a page program  in the erase suspended \nsector size + x1xxb: May not initiate a read in the erase suspe nded sector size + 1xxxb: The \nerase and program restrictions in bits 5:4 are sufficient = 111 0b Bits 3:0 = Prohibited \nOperations During Program Suspend = xxx0b: May not initiate a n ew erase anywhere \n(erase nesting not permitted) + xx0xb: May not initiate a new p age program anywhere \n(program nesting not permitted) + x1xxb: May not initiate a rea d in the program suspended \npage size + 1xxxb: The erase and program restrictions in bits 1 :0 are sufficient = 1100b \nBinary Fields: 0-10-00101-0001-10-00100-0001-1-1110-1100 Nibble  Format: \n0100_0101_0001_1000_1000_0011_1110_1100 Hex Format: 45_18_83_EC  2Fh 2Dh 83h \n30h 2Eh 18h \n31h 2Fh 45h \n32h 30h \nJEDEC Basic Flash \nParameter \nDword-13 8Ah \nBits 31:24 = Erase Suspend Instruction = 75h Bits 23:16 = Erase  Resume Instruction = 7Ah \nBits 15:8 = Program Suspend Instr uction = 85h Bits 7:0 = Progra m Resume Instruction = \n8Ah 33h 31h 85h \n34h 32h 7Ah \n35h 33h 75h \n36h 34h \nJEDEC Basic Flash \nParameter \nDword-14 \n F7h Bit 31 = Deep Power Down Supported = not supported = 1 Bits  30:23 = Enter Deep Power \nDown Instruction = not supported = FFh Bits 22:15 = Exit Deep P ower Down Instruction = \nnot supported = FFh Bits 14:13 = Exit Deep Power Down to next o peration delay units = \n(00b: 128ns, 01b: 1us, 10b: 8us, 11b: 64us) = 64us = 11b Bits 1 2:8 = Exit Deep Power \nDown to next operation delay count = 11111b, Exit Deep Power Do wn to next operation \ndelay = (count+1)*units = not supported Bits 7:4 = RFU = Fh Bit  3:2 = Status Register \nPolling Device Busy = 01b: Lega cy status polling supported = Us e legacy polling by reading \nthe Status Register with 05h instruction and checking WIP bit[0 ] (0=ready; 1=busy). Bits 1:0 \n= RFU = 11b Binary Fields: 1-11111111-11111111-11-11111-1111-01 -11 Nibble Format: \n1111_1111_1111_1111_1111_1111_1111_0111 Hex Format: FF_FF_FF_F7  37h 35h FFh \n38h 36h FFh \n39h 37h  FFh\n3Ah 38h \nJEDEC Basic Flash \nParameter \nDword-15 00h Bits 31:24 = RFU = FFh Bit 23 = Hold and WP Disable = not s upported = 0b Bits 22:20 = \nQuad Enable Requirements = 101b: QE is bit 1 of the status regi ster 2. Status register 1 is \nread using Read Status instruction 05h. Status register 2 is re ad using instruction 35h. QE \nis set via Write Status instruction 01h with two data bytes whe re bit 1 of the second byte is \none. It is cleared via Write Status with two data bytes where b it 1 of the second byte is zero. \nBits 19:16 0-4-4 Mode Entry Met hod = xxx1b: Mode Bits[7:0] = A5 h Note QE must be set \nprior to using this mode + x1xxb: Mode Bits[7:0] = Axh + 1xxxb:  RFU = 1101b Bits 15:10 \n0-4-4 Mode Exit Met hod = xx_xxx1b: M ode Bits[7:0] = 00h will te rminate this mode at the \nend of the current read operation + xx_1xxxb: Input Fh (mode bi t reset) on DQ0-DQ3 for 8 \nclocks. This will terminate the mo de prior to the next read ope ration. + x1_xxxxb: Mode \nBit[7:0] != Axh + 1x_x1xx: RFU 3Bh 39h F6h \n3Ch 3Ah 5Dh \n3Dh 3Bh FFh Table 68.  CFI Alternate Vendor- Specific Extended Query Paramet er A5h, JEDEC SFDP  Rev B (Continued)\nCFI Parameter \nRelative Byte \nAddress Offset SFDP \nParameter \nRelative Byte \nAddress Offset SFDP Dword \nName Data  Description \nDocument Number: 001-98284 Rev. *R Page 126 of 136S25FL512S\nThis parameter type (P arameter ID F0h) may  appear multiple time s and have a different length eac h time. The para meter is used to\nreserve space in the ID-CFI ma p or to force space (pad) to alig n a following parameter to a required boundary.3Eh 3Ch \nJEDEC Basic Flash \nParameter \nDword-16 F0h Bits 31:24 = Enter 4-Byte Addressing = xxxx_1xxxb: 8-bit vo latile bank register used to \ndefine A[30:A24] bits. MSb (bit[7]) is used to enable/disable 4 -byte address mode. When \nMSb is set to ‘1’, 4-byte address mode is active and A[30:24] b its are don’t care. Read with \ninstruction 16h. Write instruction is 17h with 1 byte of data. When MSb is cleared to ‘0’, \nselect the active 128 Mb segment by setting the appropriate A[3 0:24] bits and use 3-Byte \naddressing. + xx1x_xxxxb: Supports dedicated 4-Byte address ins truction set. Consult \nvendor data sheet for the instruction set definition or look fo r 4 Byte Address Parameter \nTable. + 1xxx_xxxxb: Reserved = 10101000b Bits 23:14 = Exit 4-B yte Addressing = \nxx_xxxx_1xxxb: 8-bit volatile bank register used to define A[30 :A24] bits. MSb (bit[7]) is \nused to enable/disable 4-byte address mode. When MSb is cleared  to ‘0’, 3-byte address \nmode is active and A30:A24 are used to select the active 128 Mb  memory segment. Read \nwith instruction 16h. Write instruction is 17h, data length is 1 byte. + xx_xx1x_xxxxb: \nHardware reset + xx_x1 xx_xxxxb: Software reset (see bits 13:8 i n this DWORD) + \nxx_1xxx_xxxxb: Power cycle + x1 _xxxx_xxxxb: Reserved + 1x_xxxx_ xxxxb: Reserved = \n1111101000b Bits 13:8 = Soft Reset and Rescue Sequence Support = x0 _1xxxb: issue \ninstruction F0h + 1x_xxxxb: exit 0-4-4 mode is required prior t o other reset sequences \nabove if the device may be operating in this mode. = 101000b Bi t 7 = RFU = 1 Bits 6:0 = \nVolatile or Nonvolatile Register and Write Enable Instruction f or Status Register 1 = \nxx1_xxxxb: Status Register 1 cont ains a mix of volatile and non volatile bits. The 06h \ninstruction is used to enable wr iting of the register. + x1x_xx xxb: Reserved + 1xx_xxxxb: \nReserved = 1110000b Binary Fields: 10101000- 11111 01000-101000-1-1110000 Nibble \nFormat: 1010_1000_ 1111_1010_0010_1000_1111_0000 Hex Format: A8_FA_28_F0 3Fh 3Dh 28h \n40h 3Eh FAh \n41h 3Fh A8h \n42h 40h \nJEDEC Sector Map \nParameter Dword-1 \nConfig-0 Header FFh \nBits 31:24 = RFU = FFh Bits 23:16 = Region count (Dwords -1) = 00h: One region Bits 15:8 \n= Configuration ID = 00h: Uniform 256KB sectors Bits 7:2 = RFU = 111111b Bit 1 = Map \nDescriptor = 1 Bit 0 = The end descriptor = 1 43h 41h 00h \n44h 42h 00h \n45h 43h FFh \n46h 44h \nJEDEC Sector Map \nParameter Dword-2 \nConfig-0 Region-0 F4h Bits 31:8 = Region size = 00FFFFh: Region size as count-1 o f 256 Byte units = 64MB/256 = \n256K Count = 262144, value = count -1 = 262144 -1 = 262143 = 3F FFFh \nBits 4:7 = RFU = Fh Erase Type not supported = 0/ supported = 1  \nBits 3 = Erase Type 4 support = 0b ---Erase Type 4 is not defin ed \nBits 2 = Erase Type 3 support = 1b ---Erase Type 3 is 256KB era se and is supported in the \n256KB sector region \nBits 1 = Erase Type 2 support = 0b ---Erase Type 2 is 64KB eras e and is not supported in \nthe 256KB sector region \nBits 0 = Erase Type 1 support = 0b --- Erase Type 1 is 4KB eras e and is not supported in \nthe 256KB sector region Format: 0000_0011_1111_1111_1111_1111_1111_0100 Hex Format: 03_ FF_FF_F4 47h 45h FFh \n48h 46h FFh \n49h 47h 03h \n4Ah 48h \nJEDEC 4 Byte \nAddress \nInstructions \nParameter Dword-1 FFh Supported = 1, Not Supported = 0 Bits 31:20 = RFU = FFFh Bi t 19 = Support for nonvolatile \nindividual sector lock write comma nd, Instruction=E3h = 1 Bit 1 8 = Support for nonvolatile \nindividual sector lock read command, Instruction=E2h = 1 Bit 17  = Support for volatile \nindividual sector lock Write command, Instruction=E1h = 1 Bit 1 6 = Support for volatile \nindividual sector lock Read command, Instruction=E0h = 1 Bit 15  = Support for (1-4-4) \nDTR_Read Command, Instruction=EEh = 1 Bit 14 = Support for (1-2 -2) DTR_Read \nCommand, Instruction=BEh = 1 Bit 13 = Support for (1-1-1) DTR_R ead Command, \nInstruction=0Eh = 1 Bit 12 = Support for Erase Command – Type 4  = 0 Bit 11 = Support for \nErase Command – Type 3 = 1 Bit 10 = Support for Erase Command –  Type 2 = 0 Bit 9 = \nSupport for Erase Command – Type 1 = 0 Bit 8 = Support for (1-4 -4) Page Program \nCommand, Instruction=3Eh =0 Bit 7 = Support for (1-1-4) Page Pr ogram Command, \nInstruction=34h = 1 Bit 6 = Support for (1-1-1) Page Program Co mmand, Instruction=12h = \n1 Bit 5 = Support for (1-4-4) FAST_READ Command, Instruction=EC h = 1 Bit 4 = Support \nfor (1-1-4) FAST_READ Command, Instruction=6Ch = 1 Bit 3 = Supp ort for (1-2-2) \nFAST_READ Command, Instruction=BCh = 1 Bit 2 = Support for (1-1 -2) FAST_READ \nCommand, Instruction=3Ch = 1 Bit 1 = Support for (1-1-1) FAST_R EAD Command, \nInstruction=0Ch = 1 Bit 0 = Support for (1-1-1) READ Command, I nstruction=13h = 1 4Bh 49h E8h \n4Ch 4Ah FFh \n4Dh 4Bh  FFh\n4Eh 4Ch \nJEDEC 4 Byte \nAddress \nInstructions \nParameter Dword-2 FFh \nBits 31:24 = FFh = Instruction for Erase Type 4: RFU Bits 23:16  = DCh = Instruction for \nErase Type 3 Bits 15:8 = FFh = Instruction for Erase Type 2: RF U Bits 7:0 = FFh = \nInstruction for Erase Type 1: RFU 4Fh 4Dh FFh \n50h 4Eh DCh 51h 4Fh FFh Table 68.  CFI Alternate Vendor- Specific Extended Query Paramet er A5h, JEDEC SFDP  Rev B (Continued)\nCFI Parameter \nRelative Byte \nAddress Offset SFDP \nParameter \nRelative Byte \nAddress Offset SFDP Dword \nName Data  Description \nDocument Number: 001-98284 Rev. *R Page 127 of 136S25FL512S\n11.4Device ID and Common Flash I nterface (ID-CFI) ASO Map — Aut omotive Only\nThe CFI Primary Vendor-Specifi c Extended Query is extended to i nclude Electronic Marking info rmation for device traceability.\nFab Lot # + Wafer # + Die X Coor dinate + Die Y C oordinate gives  a unique ID for each device.\n11.5 Registers\nThe register maps are copied in this section as a quick referen ce. See S e c t i o n7 . 6  R e g i s t e r s  o np a g e4 7  for the full description of the\nregister contents.Address Data Field # of \nbytes Data \nFormat Example of \nActual Data Hex Read Out of Example Data \n(SA) + 0180h Size of Electro nic Marking 1 Hex 20 14h \n(SA) + 0181h Revision of Electronic Marking 1 Hex 1 01h (SA) + 0182h Fab Lot # 8 ASCII LD87270 4Ch, 44h, 38h, 37h, 32h,  37h, 30h, FFh \n(SA) + 018Ah Wafer # 1 Hex 23 17h (SA) + 018Bh Die X Coordinate 1 Hex 10 0Ah \n(SA) + 018Ch Die Y Coordinate 1 Hex 15 0Fh (SA) + 018Dh Class Lot # 7 ASCII BR33150 42h, 52h, 33h, 33h, 31 h, 35h, 30h \n(SA) + 0194h Reserved for Future 12 N/A N/A FFh, FFh, FFh, FFh, FFh, FFh, FFh, FFh,\nFFh, FFh, FFh, FFh \nTable 69.  Status Register-1 (SR1)\nBits Field \nName Function Type Default State Description \n7 SRWD Status Register \nWrite Disable Nonvolatile 0 1 = Locks state of SRWD , BP, and configuration \nregister bits when WP# is low by ignoring WRR \ncommand\n0 = No protection, e ven when WP# is low \n6 P_ERR Programming \nError Occurred Volatile, Read only 0 1 = Error occurred \n0 = No Error \n5 E_ERR Erase Error \nOccurred Volatile, Read only 0 1= Error occurred \n0 = No Error \n4 BP2 \nBlock \nProtection Volatile if CR1[3]=1, \nNonvolatile if \nCR1[3]=0 1 if CR1[3]=1, \n0 when \nshipped from \nCypress Protects selected range of sectors (Block) from \nProgram or Erase 3 BP1 \n2 BP0 \n1 WEL Write Enable \nLatch Volatile 0 1 = Device a ccepts Write Regist ers (WRR), program \nor erase commands \n0 = Device ignores Write R egisters (WRR), program \nor erase commands \nThis bit is not affected by WRR, only WREN and \nWRDI commands affect this bit. \n0 WIP Write in \nProgress Volatile, Read only 0 1= Device Busy, a Write Registers (WRR), program, \nerase or other operat ion is in progress \n0 = Ready Device is in stand by mode and can accept \ncommands \nDocument Number: 001-98284 Rev. *R Page 128 of 136S25FL512S\nTable 70.  Configuration Register (CR1)\nBits Field Name Function Type Default \nState Description \n7 LC1 \nLatency Code Nonvolatile 0 Selects number of init ial read latency cycles\nSee Latency Code Tables 6 LC0 0 \n5 TBPROT Configures Start of \nBlock Protection OTP 0 1 = BP starts at bottom (Low address)\n0 = BP starts at top (High address) \n4 RFU RFU  RFU 0 Reserved for Future Use \n3 BPNV Configures BP2-0 in \nStatus Register OTP 0 1 = Volatile \n0 = Nonvolatile \n2 RFU RFU RFU 0 Reserved for Future Use \n1 QUAD Puts the device into \nQuad I/O operation Nonvolatile 0 1 = Quad \n0 = Dual or Serial \n0 FREEZE Lock current state of \nBP2-0 bits in Status \nRegister, TBPROT \nin Configuration \nRegister, and OTP \nregions Volatile 0 1 = Block Protection and OTP locked\n0 = Block Protection and OTP un-locked \nTable 71.  Status Register-2 (SR2)\nBits Field Name Function Type Default State Description \n7 RFU Reserved – 0 Res erved for Future Use \n6 RFU Reserved – 0 Res erved for Future Use \n5 RFU Reserved – 0 Res erved for Future Use \n4 RFU Reserved – 0 Res erved for Future Use \n3 RFU Reserved – 0 Res erved for Future Use \n2 RFU Reserved – 0 Res erved for Future Use \n1 ES Erase Suspend Volatile, Read only 0 1 = In erase suspend mode. \n0 = Not in erase suspend mode. \n0 PS Program \nSuspend Volatile, Read only 0 1 = In program suspend mode. \n0 = Not in program suspend mode.\nTable 72.  Bank Address Register (BAR)\nBits Field Name Function Type Default State Description \n7 EXTADD Extended Address \nEnable Volatile 0b 1 = 4-byte (32-bits) addre ssing required from command.\n0 = 3-byte (24-bits) addre ssing from command + Bank \nAddress \n6 to 2 RFU Reserved Volatile 00000b Reserved for Future Use \n1 BA25 Bank Address Volatile 0 A25 for 512 Mb device0 RFU Bank Address Volatile 0 R FU for lower density device \nDocument Number: 001-98284 Rev. *R Page 129 of 136S25FL512S\nTable 73.  ASP Register (ASPR)\nBits Field Name Function Type Default \nState Description \n15 to 9 RFU Reserved OTP 1 Reserved for Future Use \n8 RFU Reserved OTP \nNote [53] Reserved for Future Use \n7 RFU Reserved OTP Reserved for Future Use 6 RFU Reserved OTP 1 Reserved for Future Use 5 RFU Reserved OTP \nNote [53]Reserved for Future Use \n4 RFU Reserved OTP Reserved for Future Use 3 RFU Reserved OTP Reserved for Future Use \n2 PWDMLB Password \nProtection Mode \nLock Bit OTP 1 0 = Password Protection Mode permanently enabled. \n1 = Password Protection M ode not permanently enabled.\n1 PSTMLB Persistent \nProtection Mode \nLock Bit OTP 1 0 = Persistent Protection Mode permanently enabled. \n1 = Persistent Protection Mode not permanently enabled.\n0 RFU Reserved OTP 1 Reserved for Future Use \nNote\n53. Default value depends on ordering part number, see Initial Delivery State on page 130 .\nTable 74.  Password Register (PASS)\nBits Field \nName Function Type Default State Description \n63 to 0 PWD Hidden \nPassword OTP FFFFFFFF-FFFFFF\nFFh Nonvolatile OTP storage of 64-bit password. The password \nis no longer readable after the password protection mode is selected by programming ASP register bit 2 to zero. \nTable 75.  PPB Lock Register (PPBL)\nBits Field Name Function Type Default State Description \n7 to 1 RFU Reserved Volatile 00h Reserved for Future Use \n0 PPBLOCK Protect PPB Array Volatile Persistent Protection Mode = 1 \nPassword Protection Mode = 0 0 = PPB array protecte d until next power \ncycle or hardware reset 1 = PPB array may be  programmed or \nerased\nTable 76.  PPB Access Register (PPBAR)\nBits Field Name Function Type Default \nState Description \n7 to 0 PPB Read or Program \nper sector PPB Nonvolatile FFh 00h = PPB for the sector addressed by the PPBRD or \nPPBP command is programmed to ‘0’, protecting that \nsector from program or erase operations. \nFFh = PPB for the sector addressed by the PPBRD or \nPPBP command is erased to ‘ 1’, not protecting that \nsector from program or erase operations. \nDocument Number: 001-98284 Rev. *R Page 130 of 136S25FL512S\n11.6 Initial Delivery State\nThe device is shipped from Cyp ress with nonvolatile bits set as  follows:\n■The entire memory array is erase d: i.e. all bits are set to 1 ( each byte contains FFh).\n■The OTP address space has the fi rst 16 bytes programmed to a ra ndom number. All other bytes are erased to FFh.\n■The SFDP address space contains  the values as defined in the de scription of the SFDP address space.\n■The ID-CFI address space contai ns the values as defined in the description of the ID-CFI address space.\n■The Status Register 1 contains 0 0h (all SR1 bits are cleared to  0’s).\n■The Configuration Register 1 contains 00h.\n■The Autoboot register contains 00h.\n■The Password Register contains FFFFFFFF-FFFFFFFFh\n■All PPB bits are 1.\n■The ASP Register contents depend  on the ordering options select ed:Table 77.  DYB Access Register (DYBAR)\nBits Field Name Function Type Default State Description \n7 to 0 DYB Read or Write \nper sector DYB Volatile FFh 00h = DYB for the sector add ressed by the DYBRD or DYBP \ncommand is cleared to ‘0’, protecting that sector from program or \nerase operations. \nFFh = DYB for the sector addressed by the DYBRD or DYBP \ncommand is set to ‘1’, not protect ing that sector from program or \nerase operations. \nTable 78.  Nonvolatile Data Learning Register (NVDLR)\nBits Field Name Function Type Default State Description \n7 to 0 NVDLP Nonvolatile \nData Learning \nPatternOTP 00h OTP value that may be transfer red to the host during DDR read \ncommand latency (dummy) cycles to provide a training pattern to  \nhelp the host more accurately cen ter the data capture point in \nthe received data bits.\nTable 79.  Volatile Data L earning Register (NVDLR)\nBits Field Name Function Type Default State Description \n7 to 0 VDLP Volatile Data \nLearning \nPattern Volatile Takes the \nvalue of \nNVDLR \nduring POR \nor ResetVolatile copy of the NVDLP used  to enable and deliver the Data \nLearning Pattern (DLP) to t he outputs. The VDLP may be \nchanged by the host dur ing system operation.\nTable 80.  ASP Register Content\nOrdering Part Number Model ASPR Default Value\n01, 21, 31, R1, A1, B1, C1, D1,91, Q1, 71, 61, 81 FE7Fh\nK1, L1. S1, T1, Y1, Z1, M1 , N1, U1, V1, W1, X1 FE4Fh\nDocument Number: 001-98284 Rev. *R Page 131 of 136S25FL512S\n12 Ordering Information\nThe ordering part number is form ed by a valid combination of th e following:\nS25FL 512 S AG M F I 0 1 1\nPacking Type\n0 = Tray \n1 = Tube\n3 = 13” Tape and Reel\nModel Number (Sector Type)\n1 = Uniform 256-kB sectors[54]\nModel Number (Latency Type, Package Details, RESET# and VIO Support)\n0 = EHPLC, SO footprint\n2 = EHPLC, 5 x 5 ball BGA footprint3 = EHPLC, 4 x 6 ball BGA footprint\nG = EHPLC, SO footprint with RESET#\nR = EHPLC, SO footpr int with RESET# and V\nIOA = EHPLC, 5 x 5 ball BGA footprint with RESET# and VIOB = EHPLC, 4 x 6 ball BGA footprint with RESET# and VIOC = EHPLC, 5 x 5 ball BG A footprint with RESET#\nD = EHPLC, 4 x 6 ball BG A footprint with RESET#\n9 = HPLC, SO footprint\n4 = HPLC, 5 x 5 ball BGA footprint8 = HPLC, 4 x 6 ball BGA footprint\nH = HPLC, SO foot print with RESET#\nQ = HPLC, SO footprint with RESET# and V\nIO7 = HPLC, 5 x 5 ball BGA footprint with RESET# and VIO6 = HPLC, 4 x 6 ball BGA footprint with RESET# and VIOE = HPLC, 5 x 5 ball BG A footprint with RESET#\nF = HPLC, 4 x 6 ball BGA footprint with RESET#\nTemperature Range \nI = Industrial (–40°C to + 85°C)\nV = Industrial Plus (–40°C to + 105°C)A = Automotive, AEC-Q100 Grade 3 (–40°C to + 85°C)\nB = Automotive, AEC-Q100 Grade 2 (–40°C to + 105°C)\nM = Automotive, AEC-Q100 Grade 1 (–40°C to + 125°C)\nPackage Materials[57]\nF = Halogen-free, Lead (Pb)-free \nH = Halogen free, Lead (Pb)-free\nPackage Type\nM = 16-pin SO package\nB = 24-ball BGA 6 x 8 mm package, 1.00 mm pitch\nSpeed\nAG = 133 MHz\nDP = 66 MHz DDR\nDS = 80 MHz DDR\nDevice Technology\nS = 65 nm MirrorBit Process Technology\nDensity512 = 512 Mb\nDevice FamilyS25FLCypress Memory 3.0 V-Only, Serial Peripheral Interface (SPI) Fl ash Memory\nNotes\n54. Uniform 256-kB sectors = All sectors are uniform 256-kB with  a 512B programming buffer.\n55. EHPLC = Enhanced High Performance Latency Code table.56. HPLC = High Performance Latency Code table.\n57. Halogen free definition is in accordance with IE 61249-2-21 specification.\nDocument Number: 001-98284 Rev. *R Page 132 of 136S25FL512S\n12.1 Valid Combinations — Standard\nValid Combinations list configurations planned to be supported in volume for this device. Consul t your local sales office to c onfirm\navailability of specific valid c ombinations and to check on new ly released combinations.\n12.2 Valid Combinations — A utomotive Grade / AEC-Q100\nThe table below lists configurations that are Automotive Grade / AEC-Q100 qualified and are planned to be available in volume.  The\ntable will be updated as new combinations are released. Consult  your local sales representative to confirm availability of spe cific\ncombinations and to check on newly released combinations.\nProduction Part Approval Process (PPAP) support is only provide d for AEC-Q100 grade products.\nProducts to be used in end-use applications that require ISO/TS -16949 compliance must be AEC-Q100 grade products in\ncombination with PPAP. Non–AEC-Q 100 grade products are not manu factured or documented i n full compliance with \nISO/TS-16949 requirements.\nAEC-Q100 grade products are also offered without PPAP support f or end-use applications that do not require ISO/TS-16949\ncompliance.Valid Combinations — Standard\nBase Ordering \nPart NumberSpeed \nOptionPackage and \nTemperatureModel Number Packing Type Package Marking[58]\nS25FL512SAGMFI, MFV 01, G1, R1 0, 1, 3 FL512S +  A + (Temp) + F + (Model Numbe r)\nBHI, BHV 21, 31, A1, B1, C1, D1 0, 3 FL512S + A + (Temp) + H + (Mo del Number)\nDPMFI, MFV 01, G1 0, 1, 3 FL512S + D + (Temp) + F + (Model Number)\nBHI, BHV 21, 31, C1, D1 0, 3 FL512S + D + (Temp) + H + (Model Numb er)\nDSMFI, MFV 01, G1, R1 0, 1, 3 FL512S +  S + (Temp) + F + (Model Numbe r)\nBHI, BHV 21, 31, A1, B1, C1, D1 0, 3 FL512S + S + (Temp) + H + (Mo del Number)\nNote\n58. Example, S25FL512SAGMFI000 package marking would be FL512SAI F00.\nValid Combinations — Automotive Grade / AEC-Q100\nBase Ordering \nPart NumberSpeed \nOptionPackage and \nTemperatureModel Number Packing Type Package Marking \nS25FL512SAGMFA, MFB, \nMFM01, G1, R1 0, 1, 3 FL512S + A +  (Temp) + F + (Model Number)\nBHA, BHB, \nBHM21, 31, A1, B1, C1, D1 0, 3 FL512S +  A + (Temp) + H + (Model Numb er)\nDP BHB 21, C1 0, 3 FL512S + D + (Temp) + H + (Model Number)\nDSMFA, MFB, \nMFM01, G1, R1 0, 1, 3 FL512S + S +  (Temp) + F + (Model Number)\nBHA, BHB, \nBHM21, 31, A1, B1, C1, D1 0, 3 FL512S + S + (Temp) + H + (Model Numb er)\nDocument Number: 001-98284 Rev. *R Page 133 of 136S25FL512S\n13. Revision History\nDocument History Page\nDocument Title: S25FL512S, 512 M b (64 MB), 3.0 V SPI Flash Memo ry\nDocument Number: 001-98284\nRev. ECN No.Orig. of \nChangeSubmission \nDateDescription of Change\n** – BWHA 12/20/2011 Initial release\n*A – BWHA 03/02/2012General: Changed data sheet designat ion from Advance Informatio n to Preliminary\nPerformance Summary: Current Consumption table: corrected Seria l Read 50 MHz and\nSerial Read 133 MHz valuesDC Characteristics: DC Characteri stics table: corrected ICC1 va lues\nSDR AC Characteristics: AC Char acteristics (Single Die Package,  VIO = VCC 2.7V to\n3.6V) table: corrected TCSH and TSU Max valuesAC Characteristics (Single Die Package, VIO 1.65V to 2.7V, VCC 2.7V to 3.6V) table:\ncorrected TCSH and TSU Max values\nEmbedded Algorithm Performance Tables: Program and Erase Perfor mance table: cor-\nrected TW Typ and Max values\nDevice ID and Common Flash Interface (ID-CFI) Address Map: Upda ted table: CFI Al-\nternate Vendor-Specific Extended Query Parameter 0\n*B – BWHA 05/02/2012Global: Added 105°C updates\nOrdering Information: Updated Valid Combinations table\nEmbedded Algorithm Performance Tables: Updated table: Program a nd Erase Perfor-\nmance\n*C – BWHA 06/13/2012 SDR AC Characteristics: Updated tHO value from  0 Min to 2 ns Min\n*D – BWHA 04/12/2013 Global: Data Sheet designation updated from Pr eliminary to Full Production\n*E – BWHA 12/20//2013Global 80 MHz DDR Read operation added\nPerformance Summary:\nUpdated Maximum Read Rates DDR (VIO = VCC = 3V to 3.6V) table\nCurrent Consumption table: added Quad DDR Read 80 MHzMigration Notes FL Generations Comparison table: updated DDR va lues for FL-S\nSDR AC Characteristics:Up dated Clock Timing figure\nDDR AC Characteristics: Updated AC Characteristics — DDR Operat ion table\nDDR Output Timing: Updated SPI DDR Data Valid Window figure and  Notes\nOrdering Information:\nAdded 80 MHz to Speed optionValid Combinations table: added DS to Speed Option\n*F – BWHA 01/08/2014 DDR AC Characteristics: Removed AC Characteris tics 80 MHz Operation table.\n*G – BWHA 12/18/2014SDR AC Characteristics: AC Char acteristics (Single Die Package,  V\nIO = VCC 2.7V to \n3.6V) table: removed tV (Min) value.\nAC Characteristics (Single Die Package, VIO 1.65V to 2.7V, VCC 2.7V to 3.6V) table: \nremoved tV (Min) value.\nBank Address Register: Bank Addre ss Register (BAR) table: corre cted Bit 0.\nSerial Flash Discoverable Parameters (SFDP) Address Map: \nUpdated section SFDP Overview Map table: updated\nField Definitions: updated SFDP Header table.Device ID and Common Flash Interface (ID-CFI) Address Map: Fiel d Definitions: added \nCFI Alternate Vendor-Specific Extended Query Parameter A5h, JED EC SFDP Rev B \ntable.\n*H – BWHA 01/21/2015Capacitance Characteristics: Capacitance table: added T\nA = 25°C under Test \nConditions.\nSDR AC Characteristics: AC Char acteristics (Single Die Package,  VIO = VCC 2.7V to \n3.6V) table: changed tSU (Min).\nConfiguration Register 1 (CR1 ): Latency Codes for DDR Enhanced High Performance \ntable: added 80 MHz\nCommand Set Summary: S25FL512S Command Set (sorted by function)  table: \nupdated Maximum Frequency (MHz) o f DDR Command Descriptions to 80 MHz.\nRead Memory Array Commands: Changed 66 MHz to 80 MHz throughout  section.\nSoftware Interface Reference: S25FL512S Instruction Set (sorted  by instruction) table: \nupdated Maximum Frequency (MHz) o f DDR Command Descriptions to 80 MHz.\nDocument Number: 001-98284 Rev. *R Page 134 of 136S25FL512S\n*I 4871631 BWHA 08/24/2015Replaced “Automotive Temperature Range” with “Industrial Plus T emperature Range” in\nall instances across the document.\nUpdated Section 2. Signal Descriptions on page 8 :\nUpdated Section 2.11 Versatile I/O Power Supply (VIO) on page 11 :\nUpdated description.\nUpdated to Cypress template.\n*J 5347120 TOCU 09/20/2016Added ECC related information in  all instances across the docum ent.\nAdded “Extended”, “Automotive, AEC-Q100 Grade 3”, “Automotive, AECQ100 Grade 2”,\n“Automotive, AEC-Q100 Grade 1” temperature range related inform ation in all instances\nacross the document.\nAdded Logic Block Diagram .\nUpdated Section 4. Electrical Specifications on page 24 :\nAdded Section 4.2 Thermal Resistance on page 24 .\nUpdated Section 4.4 Power-Up and Power-Down on page 25 :\nUpdated Table 6 : \nChanged minimum value of VCC (low) parameter from 1.0 V to 1.6 V.\nChanged minimum value of tPD parameter from 1.0 µs to 10.0 µs.\nUpdated Section 5. Timing Specifications on page 28 :\nUpdated Section 5.4 SDR AC Characteristics on page 32 :\nUpdated Table 11 :\nUpdated Table 12 :\nRUpdated Section 5.5 DDR AC Characteristics on page 36 : \nUpdated Table 13 :\nChanged minimum value of tHO parameter corresponding to 66 MHz from 0 ns to 1.5 ns.\nRemoved minimum value of tV parameter.\nUpdated Section 7. Address Space Maps on page 44 :\nUpdated Section 7.6 Registers on page 47 :\nAdded Section 7.6.6 ECC Status Register (ECCSR) on page 53 .\nAdded Table 17 .\nUpdated Section 9. Commands on page 62 :\nUpdated Section 9.1 Command Set Summary on page 63 :\nUpdated Section 9.1.1 Extended Addressing on page 63 :\nUpdated Table 39 :\nUpdated Section 9.3 Register Access Commands on page 70 :\nUpdated Section 9.3.7 Write Registers (WRR 01h) on page 72 :\nUpdated description.\nAdded Section 9.3.11 ECC Status Register Read (ECCRD 18h) on page 75 .\nUpdated Section 9.5 Program Flash Array Commands on page 92 :\nUpdated Section 9.5.1 Program Granularity on page 92 :\nAdded Section 9.5.1.1 Automatic ECC on page 92 .\nAdded Section 10. Data Integrity on page 105 .\nUpdated Section 12 Ordering Information on page 131 :\nNo change in part numbers.Added Section 12.2 Valid Combinations — Automotive Grade / AEC-Q100 on page 132 .\nUpdated to new template.\n*K 5613561 ECAO 03/17/2017Updated t\nSU in Table 11, AC Characteristics (Single Die Package, VIO = VCC 2.7V to\n3.6V) on page 32 .\nUpdated Cypress logo and Sales page.Document History Page (Continued)\nDocument Title: S25FL512S, 512 M b (64 MB), 3.0 V SPI Flash Memo ry\nDocument Number: 001-98284\nRev. ECN No.Orig. of \nChangeSubmission \nDateDescription of Change\nDocument Number: 001-98284 Rev. *R Page 135 of 136S25FL512S\n*L 5700261 BWHA 05/22/2017Remove Extended Temperature Range MPN option Section 12 Ordering Information\non page 131 .\nUpdated Package Drawings Section 6.1 SOIC 16-Lead Package on page 38 ,\nSection 6.2 FAB024 24-Ball BGA Package on page 40 , Section 6.3 FAC024 24-Ball BGA\nPackage on page 42 .\nUpdated Section 9.5.3 Quad Page Program (QPP 32h or 38h, or 4QPP 34h) on page 93 .\nAdded “DP” speed option in Section  Valid Combinations — Automotive Grade / AEC-\nQ100 on page 132 .\n*M 5959962 BWHA 11/10/2017Updated Table 5 on page 24 .\nCorrected JEDEC Sector Map Parameter Dword-2 in Table 68 on page 123 .\nUpdated Section 12 Ordering Information on page 131  definition of letters in OPN \nindicating package material.\nUpdated Section 5.5.3 DDR Data Valid Timing Using DLP on page 37 , Example.\nUpdated Package Drawings on Section 6. Physical Interface on page 38 .\nChange the description of CR1[4] from “RFU” to “DNU” in Table 19 on page 49 .\n*N 5969843 BWHA 12/15/2017Added Model C1 to DP speed option of Valid Combination in Section 12.2 Valid Combi-\nnations — Automotive Grade / AEC-Q100 on page 132 .\nUpdated Sales page.\n*O 6099450 BWHA 03/21/2018Table 12  and Table 13 : Removed the Max value of tCSH and updated the Max value of \ntSU as “3000”.\n*P 6215133 BWHA 06/22/2018Updated Section 5.5.3 DDR Data Valid Timing Using DLP on page 37 .\nUpdated Package Materials in Section 12 Ordering Information on page 131 .\n*Q 6457023 BWHA 01/23/2019Updated FL-S device density in Section 1.2.2.5 Deep Power-Down on page 5 .\nUpdated Section 5 Thermal Resistance on page 24 .\n*R 6554934 BWHA 04/30/2019Added Section 11.4 Device ID and Common Flash Interface (ID-CFI) ASO M ap — \nAutomotive Only on page 127 .\nUpdated Section 1.3 Glossary on page 6 .Document History Page (Continued)\nDocument Title: S25FL512S, 512 M b (64 MB), 3.0 V SPI Flash Memo ry\nDocument Number: 001-98284\nRev. ECN No.Orig. of \nChangeSubmission \nDateDescription of Change\n© Cypress Semiconductor Corporation, 2011-2019. This document i s the property of Cypress Semiconductor Corporation and its sub sidiaries (“Cypress”).  This document, including any software o r\nfirmware included or referenced in this document (“Software”), is owned by Cypress under the intellectual property laws and tr eaties of the United States and other countries worldwide.  Cyp ress\nreserves all rights under such laws and treaties and does not, except as specifically stated in  this paragraph, grant any lice nse under its patents, copyrights, trademarks, or other intelle ctual property\nrights.  If the Software is not accompanied by a license agreem ent and you do not otherwise have a written agreement with Cypr ess governing the use of the Software, then Cypress hereby gran ts\nyou a personal, non-exclusive, nontransferable license (without  the right to sublicense) (1) under its copyright rights in the  Software (a) for Software provided in source code form, to mod ify and reproduce\nthe Software solely for use with Cypress hardware products, onl y internally within your organization, and (b) to distribute th e Software in binary code form externally to end users (either directly or\nindirectly through resellers and distributors), solely for use on Cypress hardware product units, and (2) under those claims o f Cypress\'s patents that are infringed by the Software (as prov ided by\nCypress, unmodified) to make, use, distribute, and import the S oftware solely for use with Cypress hardware products.  Any oth er use, reproduction, modification, translation, or compilation  of the\nSoftware is prohibited.\nTO THE EXTENT PERMITTED BY APPLICABLE LAW, CYPRESS MAKES NO WAR RANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS DOCU MENT OR ANY SOFTWARE\nOR ACCOMPANYING HARDWARE, INCLUDING, BUT NOT LIMITED TO, THE IM PLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULA R PURPOSE.  No computing\ndevice can be absolutely secure.  Therefore, despite security m easures implemented in Cypress hardware or software products, C ypress shall have no liability arising out of any security brea ch, such\nas unauthorized access to or use of a Cypress product.  CYPRESS  DOES NOT REPRESENT, WARRANT, OR GUARANTEE THAT CYPRESS PRODUCT S, OR SYSTEMS CREATED USING\nCYPRESS PRODUCTS, WILL BE FREE FROM CORRUPTION, ATTACK, VIRUSES , INTERFERENCE, HACKING, DATA LOSS OR THEFT, OR OTHER SECURITY INTRUSION (collectively, "Security\nBreach").  Cypress disclaims any liability relating to any Secu rity Breach, and you shall and hereby do release Cypress from a ny claim, damage, or other liability arising from any Security Breach.  In\naddition, the products described in these materials may contain  design defects or errors known as errata which may cause the p roduct to deviate from published specifications.  To the extent  permitted\nby applicable law, Cypress reserves the right to make changes t o this document without further notice. Cypress does not assume  any liability arising out of the application or use of any pro duct or\ncircuit described in this document.  Any information provided i n this document, including any sample design information or pro gramming code, is provided only for reference purposes.  It is the\nresponsibility of the user of th is document to properly design,  program, and test the functionality and safety of any applicat ion made of this information and any resulting product.  "High- Risk Device"\nmeans any device or system whose failure could cause personal i njury, death, or property damage.  Examples of High-Risk Device s are weapons, nuclear installat ions, surgical implants, and ot her\nmedical devices. “Critical Component” means any component of a High-Risk Device whose failure to perform can be reasonably exp ected to cause, directly or indirectly, the failure of the High -Risk\nDevice, or to affect its safety or effectiveness.  Cypress is n ot liable, in whole or in part, and you shall and hereby do rel ease Cypress from any claim, damage, or other liability arising  from any use of\na Cypress product as a Critical Component in a High-Risk Device .  You shall indemnify and hold Cypress, its directors, officer s, employees, agents, affiliates, distributors, and assigns har mless from\nand against all claims, costs, damages, and expenses, arising o ut of any claim, including claims for product liability, person al injury or death, or property damage arising from any use of a Cypress\nproduct as a Critical Component in a High-Risk Device.  Cypress  products are not intended or authorized for use as a Critical Component in any High-Risk Device except to the limited extent that (i)\nCypress\'s published data sheet for the product explicitly state s Cypress has qualified the product for use in a specific High- Risk Device, or (ii) Cypress has given you advance written auth orization to\nuse the product as a Critical Component in the specific High-Ri sk Device and you have signed a separate indemnification agreem ent.\nCypress, the Cypress logo, Spansion, the Spansion logo, and com binations thereof, WICED, PSoC, CapSense, EZ-USB, F-RAM, and Tr aveo are trademarks or registered trademarks of Cypress in\nthe United States and other countries.  For a more complete lis t of Cypress trademarks, visit cypress.com.  Other names and br ands may be claimed as property of their respective owners.S25FL512S\nDocument Number: 001-98284 Rev.  *R Revised  April 30, 2019 Page 136 of 136Sales, Solutions, an d Legal Information\nWorldwide Sales and Design Support\nCypress maintains a worldwide network of offices, solution cent ers, manufacturer’s representativ es, and distributors. To find the office \nclosest to you, visit us at Cypress Locations .\nProducts\nArm® Cortex® Microcontrollers cypress.com/arm\nAutomotive cypress.com/automotive\nClocks & Buffers cypress.com/clocks\nInterface cypress.com/interface\nInternet of Things cypress.com/iot\nMemory cypress.com/memory\nMicrocontrollers cypress.com/mcu\nPSoC cypress.com/psoc\nPower Management ICs cypress.com/pmic\nTouch Sensing cypress.com/touch\nUSB Controllers cypress.com/usb\nWireless Connectivity cypress.com/wirelessPSoC® Solutions\nPSoC 1 | PSoC 3 | PSoC 4  | PSoC 5LP | PSoC 6 MCU\nCypress Developer Community\nCommunity | Projects  | Video  | Blogs  | Training  | Components\nTechnical Support\ncypress.com/support\n'}]
!==============================================================================!
### Component Summary: S25FL512SAGMFI010

**Key Characteristics and Specifications:**

- **Voltage Ratings:**
  - Core Supply Voltage (VCC): 2.7 V to 3.6 V
  - I/O Supply Voltage (VIO): 1.65 V to 3.6 V

- **Current Ratings:**
  - Maximum Read Current: 33 mA (at 133 MHz)
  - Maximum Program Current: 100 mA
  - Maximum Erase Current: 100 mA
  - Standby Current: 0.07 mA (typical)

- **Power Consumption:**
  - Active Power Consumption during Read: Up to 61 mA (Quad Read at 104 MHz)
  - Standby Power Consumption: 0.07 mA (typical)

- **Operating Temperature Range:**
  - Industrial: -40 °C to +85 °C
  - Industrial Plus: -40 °C to +105 °C
  - Automotive AEC-Q100 Grade 1: -40 °C to +125 °C

- **Package Type:**
  - Available in 16-pin SOIC and 24-ball BGA packages.

- **Special Features:**
  - Supports SPI with Multi-I/O (Single, Dual, Quad).
  - Automatic ECC (Error Correction Code) for data integrity.
  - Advanced Sector Protection (ASP) and Block Protection features.
  - AutoBoot feature for executing code directly from flash memory.
  - 100,000 Program-Erase Cycles minimum endurance.
  - 20-Year Data Retention minimum.

- **Moisture Sensitive Level (MSL):**
  - MSL Level 3 per JEDEC J-STD-020E.

**Description:**
The S25FL512S is a 512 Mb (64 MB) SPI Flash memory device developed by Cypress Semiconductor, now part of Infineon Technologies. It utilizes advanced 65 nm MirrorBit® technology and Eclipse™ architecture, which enhances programming and erasing performance. The device is designed for high-density applications requiring non-volatile memory storage, offering a flexible interface with support for various read modes (Normal, Fast, Dual, Quad, and DDR).

**Typical Applications:**
The S25FL512S is commonly used in embedded systems for:
- Code shadowing and Execute-In-Place (XIP) applications.
- Firmware storage in consumer electronics, automotive, and industrial applications.
- Data storage for IoT devices and smart appliances.
- Boot code storage for microcontrollers and processors.

This device is ideal for applications that require fast access times, high reliability, and robust data protection features.