[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of PS09FN production of SCIOSENSE from the text: \n  \n \n \n \n \n \n   \n \n \nacam -messelectronic  gmbH  \n \nis now  \n  \nMember of the \nams G roup  \nThe technical content of th is acam -messelectronic  document  is still valid.  \n \n \n \n \n \n \n \nContact  information:  \n \nHeadquarters:  \nams AG  \nTobelbaderstrasse 30  \n8141 Unterpremstaetten, Austria  \nTel: +43 (0) 3136 500 0 \ne-Mail:  ams_sales @ams.com  \n \n \nPlease visit our website at www.ams.com  \n   \n  \n \n \n\uf031®\uf020\n5th November  2014  \nDocument -No: DB_ PSØ9_Vol2_ en V1.0 \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n© acam-messelectronic gmbh 2014 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n“Preliminary ” product information describes a product which is not in full production so \nthat full information about the product is not available yet. Therefore, acam-messelectronic \ngmbh (“acam” ) reserves the right to modify this product without notice. The information \nprovided by this data sheet is believed to be accurate and reliable. However, no \nresponsibility is assumed by acam for its use, nor for any infringements of patents or \nother rights of third parties that may result from its use. The information is subject to \nchange without notice and is provided “as is” without warranty of any kind (expressed or \nimplied). Picocap is a registered trademark of acam. All other brand and product names in \nthis document are trademarks or service marks of their respective owners.  \n \n \nFor a complete listing of Direct Sales, Distributor and Sales Representative contacts, visit \nthe acam web site at: \n \nhttp://www.acam.de/sales/distributors/  \n \nFor technical support you can contact the acam support team in the headquarters in \nGermany or the Distributor in your country. The contact details of acam in Germany are: \n \nsupport@acam.de  or by phone  +49-7244-74190. \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  1-1 \n \n1 Overview .................................................................................................. 1-3  \n1.1 General ..............................................................................................  1-3  \n1.2 Functional Block Diagram .......................................................................  1-3  \n2 CPU & Memory .........................................................................................  2-4  \n2.1 Block Diagram .....................................................................................  2-4  \n2.2 Memory Organization ............................................................................  2-5  \n2.3 Arithmetic Logic Unit (ALU) ..................................................................  2-14 \n2.4 Status and Result Registers ................................................................ . 2-15 \n3 General Funtions ......................................................................................  3-19 \n3.1 System Reset, Sleep Mode and Auto-configuration ....................................  3-19 \n3.2 CPU Clock Generation .........................................................................  3-20 \n3.3 Watchdog Counter and Single Conversion Counter ...................................  3-21 \n3.4 Timer ...............................................................................................  3-21 \n4 Instruction Set .........................................................................................  4-22 \n4.1 Branch instructions ............................................................................  4-22 \n4.2 Arithmetic operations .........................................................................  4-22 \n5 Assembly Programs .................................................................................  5-46 \n5.1 Directives .........................................................................................  5-47 \n5.2 Sample Code .....................................................................................  5-48 \n6 Miscellaneous ...........................................................................................  6-1  \n6.1 Bug Report .........................................................................................  6-1  \n6.2 Document History ................................................................................  6-1  \n \n  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n1-2 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de    \n \n  \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  1-3 \n \n \nThe PSØ 9 is a system- on-chip for ultra low-power and high resolution applications. It was \ndesigned especially for weight scales but fits also to any kind of force or torque \nmeasurements based on metal strain gages. It takes full advantage of the digital \nmeasuring principle of PICOSTRAIN. Thus, it combines the performance of a 28-Bit signal \nconverter with a 24-Bit microprocessor. This volume 2 datasheet describes the PS Ø9 CPU \nand the instruction set for programming the CPU. In stand-alone operation it is mandatory \nto have a program running in the CPU, but also in front-end mode, when operated as pure \nresistance- to-digital converter, the CPU might be used to implement additional data post-\nprocessing on chip. \n \nCeramic\noscilaltor\nExternal LCD Driver10 kHz\nCLK\nSPI / IIC -InterfaceTemperature \nMeasuremen\ntStrain \nGage \nControl\nTDC-UnitCPU\n24 Bit\nEEPROM\n128 x 8 \nBit\nUARTMeasurement \nUnitWatchdog Timer4 Mhz\nRef OscReset\nROM\n3K x 8 \nBitConfigRAM\n160 x 24 \nBitLoad cell\nLoad cell\nLoad cell\nLoad cell8K x 8 \nBit OTPIO \nPinsup to 4 Capacitive Keys\nup to 24 Resistive Keys8 Digital GPIOs\nUART GPIOs\nSPI / IIC\n \nFigure 1-1: PSØ 9 block diagram  \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-4 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nacam designed its own proprietary 24-bit central processing unit. It combines calculation \npower with ultro-low power operation. Only this special design made it possible to build a \nsystem that runs with a few µ A current only, but offers complex post-processing of the \nhigh-resolution measurement data. \nThe program itself is stored in an 8k OTP. During development it can be stored \nalternat ively in an external EEPROM.  \nFor effective programming, acam implemented already some special functions like the \n48-bit ultiplication and division in ROM code. \n \nFigure 2-1: Block Diagram \n8-bit7-bit address16-bit \naddress16-bit address\n8-bit \naddress24-bit\n8-bitROM\nSPI / IIC Serial Interface\nControl UnitRAMFlags\nALU\nConfig\n.\nRAM Address\nPointerOTP / \nexternal \nEEPROM\nProgram\nCounter\nStack\n8 Level User\n EEPROM\n \n \n  \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-5 \n \nFigure 2-2 : PSØ 9 Memory Organization \nFFFF h  \n..........  \nF000 h  65535  \n..........  \n61440   \nROM Program memory   \n4k \nEFFF h  \n \n \n \n \n.......... \n \n \n \n \n2000 h  61439  \n \n \n \n \n..........  \n \n \n \n \n8192   \n \n \n \n \nReserved   \n \n \n \n \n \n1FFF h  \n \n..........  \n \n2F h \n..........  \n0000 h  8191  \n \n..........  \n \n47 \n..........  \n0  \n \nUser program Memory  \n8192 bytes of OTP / External EEPROM  \n \nConfiguration , optional  (mirrored to RAM)  \n  \n \n \n8k \n \n \nThe user program memory in PSØ 9 available for user programming is 8 kbyte in size. This \n8 kB user program memory is implemented by an on-chip one time programmable ROM, \nthe OTP. As the name suggests, this memory is writable only once. Hence for development \nof the user program, the PSØ 9 supports an erasable and re-programmable external \nEEPROM, maximum 8 kB in size. Once the application program development is complete \nwith the external EEPROM, then the same program can be downloaded into the OTP and it \nwill function in the same manner with the OTP. \n(Except prolonged code execution time as described further in 2.2.3 ). \nThe first 48 bytes of the OTP from location 0 – 47 are reserved for the configuration data. \nIn order to enable programming of the OTP, an external programming voltage of 6.5 V \nmust be available on pin VPP_OTP of the PSØ 9. \nThe following flow diagram shows how the OTP is generally handled, details follow in \nsubsequent sections. \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-6 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Figure 2-3: Using the OTP \n \n \n \nThe OTP needs an external voltage of 6.5 V on the VPP_OTP pin of the PSØ 9 in order to \nenable programming. In addition to enabling the OTP, there are op codes to enable and \ndisable the PROG (Enable Programming) signal of the OTP. \nThe following is a flowchart that shows the SPI command sequence to write a byte to the \nOTP. \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-7 Figure 2-4: Writing to the OTP \n \nFor a list of all op codes pertaining to accessing the OTP through the SPI / IIC interface, \nrefer to Vol.1, Chapter 4, section 4.5.3.3 OTP Access. \n \nOn power on reset, the OTP is by default read protected. An un-programmed OTP content \nis all 0s. To enable the OTP, the Address 8143, called the Fuse Address must be read \nfirst. When the content of the Fuse address is all 0s indicating an un-programmed OTP , \nthen the OTP is enabled for reading, i.e. the OTP is unprotected. \nHence this de-protection is the first step in working with the OTP. \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-8 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   The following is a flowchart that shows the general sequence of sending SPI commands to \nread a byte from the OTP. This is the sequence to be used when controlling the PSØ 9 by \nan external microcontroller, through the SPI / IIC interface.  \nFigure 2-5: Reading the OTP \n \nFor a list of values of all op codes for accessing the OTP through the SPI / IIC interface, \nrefer to Vol.1, Chapter 4, section 4.5.3.3 OTP Access. \n \nOnce the OTP has been programmed with the user program and when the code \ndevelopment is complete, the code c an be read protected with the Fuse address. For read \nprotecting the OTP, the fuse address 8143 must be written with a non-zero value. The \nread protection process is completed by reading the address 8143 after writing it with \nthe non-zero value. \n \nAn external EEPROM of up to 8 kB size is supported as user program memory by the \nPSØ 9 with the sole purpose of supporting user program development. The final program \nwill be written to the on-chip OTP. It is to be noted that the program will be executed in \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-9 exactly the same manner, irrespective of whether the user program memory is the OTP or \nthe external EEPROM. \nThe programming sequence to write a byte into the external EEPROM and to read a byte \nfrom the external EEPROM through the SPI / IIC interface can be found under Vol.1, \nChapter 4, section 4.5.3.4 External EEPROM Access. \n \nThis section describes how the program can be developed by the user using the external \nEEPROM as the program memory. \nAs already stated, basically a user program is executed in the same manner, irrespective \nof whether the user program memory used is the OTP or the external EEPROM. However \nthe PSØ 9 has to know, which of the two has to be used as the user program memory. For \nthis purpose, as a standard operation on power-up, the PSØ 9 checks for the presence of \nan external EEPROM by reading address 0 of the external EEPROM. When 00 or FF is \nread back from address 0 of the EEPROM, then the PSØ 9 takes the internal OTP as the \nuser program memory and executes the code from the OTP. When a value other than 00 \nand FF is read from the Address 0 of the external EEPROM, then the EEPROM is \nconsidered to be the user program memory by the chip and user code in the external \nEEPROM is executed. \nThe content of address 00 corresponds to value of the bits 23:16 of Configuration \nregister 0 (tdc_conv_cnt). \nFigure 2-6: Program Memory on POR \n \nOnce the user program development is completed using the external EEPROM then, the \nfinal program is ready to be written to the OTP. Then the external EEPROM is either \nremoved physically or it is made inactive to the PSØ 9 by writing the address 00 of the \nexternal EEPROM with 00 or FF. The following flowchart gives an overview of how the user \nprogram is developed using the EEPROM and transferred to the OTP finally. \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-10 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Figure 2-7: User Programm Development \n \nThe PSØ 9 Assembler Software which is used for user program development supports \ndownloading the developed program to the external EEPROM or to the on chip OTP. The \ntarget for downloading the program can be selected from a drop down list on the \nDownload page of the assembler. \nThe lower 48 bytes in the user program memory are reserved for an automatic \nconfiguration of the PSØ 9 during a power- on reset. 3 successive bytes are added to a 24 \nbit word. So there are 16 words of 24 bit each that are used for configuration register 0 \nto 15. During a power- on reset they are copied into RAM address es 48 to 63. \nGenerally the code execution from the external EEPROM takes longer than from the \ninternal OTP. This fact needs to be considered when delay routines are realized using \nincr/decr opcodes in loops as the delay will be longer when executed from the EEPROM in \ncomparison with the OTP. The code execution from the external EEPROM is approx. 10 to \n15 times slower than from the internal OTP. \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-11 \n \nIn PSØ 9, 4 kbytes is reserved for the ROM starting at address F000 h. All computation \nroutines needed for the PICOSTRAIN measuring method reside here. The program can \njump back from the ROM to the OTP/external EEPROM. \n \n \nThe user EEPROM in PSØ 9 is 128 bytes of 8 bits each. This user EEPROM can be used to \nstore calibration data that can be accessed from the user program. The processor can \nwrite to and read from th is EEPROM, byte-wise using the putepr and getepr op-codes. This \nEEPROM hangs on the same address bus as the RAM. Hence the RAM address pointer is \nused to address both the user EEPROM and the RAM. See section 2.2.7  to get more \ndetails with code snippets on how the RAM address pointer is used to address both the \nuser EEPROM and the RAM. \n  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-12 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nTable 2-1: RAM address organization \n255 … 240 Status and Result registers in stand -alone mode (same content as 31 – 16) \n(e.g. using the DSP Instruction Set)  \n239 ... 208  System RAM  \n207 \n... \n96 User RAM 207  \n... \nUser RAM 96  \n95 ... 92  Reserved  \n91 ... 86  UART Config  / status reg  \n85 ... 8 1 Internal registers  \n80 UART Config  / status reg  \n79... 64  Reserved for internal use  \n63 \n.... \n48 Config reg 15  \n...... \nConfig reg 0  \n47 \n..... \n32 User RAM 47  \n..... \nUser RAM 32  \n31 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 Modrspan result  \nTimer  \nI/O status – falling, rising and pressed status of the 8 GPIO s  \nStatus of the 24 Multi Input keys, Pressed or Released  \nStatus : rising edge on the 24 Multi Input keys  \nStatus : falling edge on the 24 Multi Input keys  \nUBATT  \nCAL  \nHB1+  \nStatus flags  \nTMP  \nHB0 = 1/4 * (HB1+HB2+HB3+HB4)   \nHB4 = (G -H) / (G+H) * \nHB3 = (E -F) / (E+F) * \nHB2 = (C -D) / (C+D) * \nHB1 = (A -B) / (A+B)  * User RAM   \n31 ... 16  \n \nStatus and  \nResult \nregisters  in \nfront end  \nmode;  \n(e.g. using \nexternal µ C)  \n15 \n..... \n0 User RAM 15  \n..... \nUser RAM 0  \n* Parameters A..H represent the discharging times at the different ports, see section 2.4.1  Result Registers  for more details \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-13 \n \nThe RAM has its own address bus with 256 addresses. The width of 24 bit corresponds \nto the register width of the ALU. By means of the RAM address pointer a single RAM \naddress is mapped into the ALU. It then acts as a fourth accumulator register. Changing \nthe RAM address pointer does not affect the content of the addressed RAM. The RAM \naddress pointer itself is modified by separate opcodes (ramadr, incramadr, ...). As \nexplained in the previous section, the RAM address bus is additionally used to address \n128 bytes of user EEPROM with particular op codes. \nFigure 2-8: RAM Address Pointer \n \nWhen the RAM address pointer is set to a value and op codes putepr and getepr are \nused, the RAM address pointer points to the respective byte in the user EEPROM. Hence \noperations are carried out with the respective user EEPROM byte. All other op codes like \nmove r, x set the RAM address pointer to point to the RAM, hence the operation is \nperformed in the RAM. \nThe following sample code illustrates how the RAM address pointer is used to access the \nuser EEPROM and the RAM, based on the op code used. \n \n \nSample code : \nRamadr  3 // Sets the RAM address pointer to address 3  \nMove  r, x // Moves the content of the X accumulator to the RAM address 3 \n   // RAM Address Pointer is pointing to the RAM  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-14 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Ramadr  4 // Sets the RAM address pointer to address 4  \nGetepr  x // Gets the content of the user EEPROM address 4 into the X  \n    // accumulator  \n   // RAM Address Pointer is pointing to the user EEP ROM \nRamadr  3 // Sets the RAM address pointer to address 3  \nPutepr  x // Moves the content of the X  accumulator to the user EEPROM \n    // address  3 \n   // RAM Address Pointer is pointing to the user EEPROM  \nClear  r // Clears the content of RAM address 3  \n   // RAM Address Pointer is pointing to the RAM  \n \n \nFigure 2-9 : ALU block diagram \nAdd\nSub\nShift\nRAM-\nAddressControl\n+ ROMFlags\nCEOS\nY\nZ\nRAMX\n \n \n  \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-15 \n \nThe ALU has three 24-Bit accumulators, X, Y and Z. The RAM is addressed by the RAM \naddress pointer and the addressed RAM cell is used as forth accumulator. A single RAM \naddress is mapped into the ALU by the ram address pointer. So in total there are 4 \naccumulators. All transfer operations (move, swap) and arithmetic –operations (shift, add, \nmult24 , …) can be applied to all accumulators.  \n \nThe processor controls 4 flags with each operation. Not-Equal and Sign flags are set with \neach write access to one of the accumulators (incl. RAM). Additionally, the Carry and \nOverflow flags are set in case of a calculation (Add / Sub / shiftR). It is possible to query \neach flag in a jump instruction. \n \nShows the carry over in an addition or subtraction. With shift operations (shiftL, rotR, \netc.) it shows the bit that has been shifted out. \n \nThis flag is set to zero in case a new result not equal to zero is written into an \naccumulator (add, sub, move ,swap, etc.). \n \nThe sign is set when a new result is written into an accumulator (add, sub, move, swap, \netc.) and the highest bit (MSB) is 1. \n \nIndicates an overflow during an addition or subtraction of two numbers in two‘s \ncomplement representation. \n \n \nContent of the RAM result registers at the end of a measurement: \nram = 16 : HB1 = (A-B) / (A+B) HB1 un-compensated \nram = 17 : HB2 = (C-D) / (C+D) HB2 un-compensated \nram = 18 : HB3 = (E-F) / (E+F) HB3 un-compensated \nram = 19 : HB4 = (G-H) / (G+H) HB4 un-compensated \nram = 20 : HB0 = 1/4 * (HB1+HB2+HB3+HB4) \n  HB0 compensated sum \nram = 21 : TMP = RTemp / Rsg Temperature measurement value, \n  see Vol.1, Chapter 3, Section 3.5.10  \n  Internal Temp. Measurement \nram = 22 : Status flags See section 2.4.2  Status Register  \nram = 23 : HB1+ Time measurement TDC at SG_A1, Pin11 \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-16 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   ram = 24 : CAL Resolution TDC \nram = 25 : UBATT Measured supply voltage \nram = 26 : Status_Multi_F Indicates falling edge occurrence on 24 possible \n  Multi Input keys \nram = 27 : Status_Multi_R Indicates rising edge occurrence on 24 possible \n  Multi Input keys \nram = 28 : Status_Multi_P Status of the 24 Multi Input keys, Pressed or Released \nram = 29 : Status_IO Falling, Rising and Current Status of 8 GPIO pins \nram = 30 : Timer Status of the timer on measurement completion \nram = 31 : Modrspan Rspan value on measurement completion. \n  For load cells with Rspan, the ratio Rspan/Rsg when bit \n  mod_rspan = 1 in Config_reg1. \n \n A :  Discharge time measurement at SG_A1 \n B :  Discharge time measurement at SG_A2 \n C :  Discharge time measurement at SG_B1 \n D :  Discharge time measurement at SG_B2 \n E :  Discharge time measurement at SG_C1 \n F :  Discharge time measurement at SG_C2 \n G :  Discharge time measurement at SG_D1 \n H :  Discharge time measurement at SG_D2 \n RTemp : Discharge time measurement through the combination of Integrated Rspan \n   and strain gage resistor at SG_D1 and SG_C2 \n Rsg :  Discharge time measurement at SG_D1 || SG_C2 \n HB1 :  Result in 1100⁄  𝑝𝑝𝑚 \n HB2 :  Result in 1100⁄  𝑝𝑝𝑚 \n HB3 :  Result in 1100⁄  𝑝𝑝𝑚 \n HB4 :  Result in 1100⁄  𝑝𝑝𝑚 \n HB0 :  Result in 1100⁄  𝑝𝑝𝑚 \n TMP :  current ratio CR by 1 +𝑇𝑀𝑃\n220⁄   \n Status : See above \n HB1+ :  Result in 250 ∗𝑆𝐺𝐴1\n214⁄  𝑛𝑠   @ 4 MHz clock \n CAL :  Calculation of Resolution by 250,000\n𝐶𝐴𝐿⁄  𝑝𝑠 @ 4 MHz clock \n UBATT : Calculation of Supply Voltage by 2.0 + 1.6 ∗𝑈𝐵𝐴𝑇𝑇64⁄  𝑉 \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  2-17 HB1, HB2, HB3, HB4, HB0 and TMP are given as two’s complement. MSB = 1 indicates a \nnegative value. To get the positive value calculate 224 – X. \n \nBased on a standard extension of a load cell (2 mV/V) the resistance variation is 0.2 %, \ne.g. 2 Ω at a 1000 Ω load cell. The change of 0.2 % corresponds to 2000 ppm. For \nreasons of internal calculations and accuracy, the result is given in x100 of 2000 ppm (= \n200,000 ppm). Please note that the value in this register depends not only on the load \ncell’s sensitivity but also on the Mult_HBx setting in PSØ 9 . This explanation is based on \nMult_HBx = 1. \n1.5 mV/V load cell, PICOSTRAIN wiring, Mult_HBx = 1: \n1.5 mV/V = 1500 ppm \uf0e0 result in PSØ 9  at maximum strain: 150,000 (0x0249F0)  \n2 mV/V load cell, Wheatstone wiring, Mult_HBx = 1: \n2 mV/V means 1.333 mV/V in Wheatstone = 1333 ppm (due to a reduction in strain) \uf0e0 \n    result in PSØ 9  at maximum strain: 133,333 (0x0208D5)  \n1 mV/V load cell, PICOSTRAIN wiring, Mult_HBx = 4: \n1 mV/V = 1000 ppm \uf0e0 result in PSØ 9  at max imum  strain: 400,000 (0x061A80)  \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n2-18 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nTable 2-2: Status Register (RAM Address 246) \nStatus[23] = flg_status_cport4  Status flag of capacitive port 4  \nStatus[22] = flg_status_cport3  Status flag of capacitive port 3  \nStatus[21] = flg_status_cport2  Status flag of capacitive port 2  \nStatus[20] = flg_status_cport1  Status flag of capacitive port 1  \nStatus[19] = flg_rstpwr  1 = Power -on reset caused jump into OTP / ext. EEPROM  \nStatus[18] = flg_rstssn  1 = Pushed button caused jump into OTP / ext. EEPROM  \nStatus[17] = flg_wdtalt  1 = Watchdog interrupt caused jump into OTP / ext. EEPROM  \nStatus[16] = flg_endavg  1 = End of m easurement caused jump into OTP / ext. EEPROM  \nStatus[15] = flg_intav0  1 = Jump into OTP / ext. EEPROM in sleep mode  \nStatus[14] = flg_ub_low  1 = Low voltage  \nStatus[13] = flg_errtdc  1 = TDC error  \nStatus[12] = reserved  1 = reserved  \nStatus[11] = flg_err_cport  1 = Error at capacitive ports  \nStatus[10] = flg_errprt  1 = Error at strain gauge ports  \nStatus[09] = flg_timout  1 = Timeout TDC  \nStatus[08] = flg_ext_interrupt  1 = DSP start by external interrupt  \nStatus[07] = flg_cport4_r  1 = Rising edg e at capacitive port 4, 0 = no edge  \nStatus[06] = flg_cport3_r  1 = Rising edge at capacitive port 3, 0 = no edge  \nStatus[05] = flg_cport2_r  1 = Rising edge at capacitive port 2, 0 = no edge  \nStatus[04] = flg_cport1_r  1 = Rising edge at capacitive port 1,  0 = no edge  \nStatus[03] = flg_cport4_f  1 = Falling edge at capacitive port 4, 0 = no edge  \nStatus[02] = flg_cport3_f  1 = Falling edge at capacitive port 3, 0 = no edge  \nStatus[01] = flg_cport2_f  1 = Falling edge at capacitive port 2, 0 = no edge  \nStatus[00] = flg_cport1_f  1 = Falling edge at capacitive port 1, 0 = no edge  \n \nThe status of the inputs can be queried from the status registers at RAM address 250 to \n252. Please see Vol.1, Chapter 4, Section 4.3.3 Multi-input keys for more details. \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  3-19 \n \n \nALU activity is requested by a reset (power-on, watchdog), the end of measurement or in \nsleep mode the end of the conversion counter. A reset has priority over the other two \nitems. First the ALU jumps into the ROM code starting with address F000 h. There a first \ncheck is done whether the ALU was activated after a reset or not. \nIn case of a reset, the flag otp_pwr_cfg is checked to decide whether the auto-\nconfiguration data from the OTP/external EEPROM have to be copied into the RAM or not.  \nSubsequently, the flag otp_pwr_prg is checked to decide whether OTP/ external EEPROM \nuser code (starting at address 48) ought to be executed. In stand-alone operation this is \nreasonable and otp_pwr_cfg bit should be 1. In front end operation this is unlikely and with \notp_pwr_cfg = 0 the µ P is stopped. \nIn case the ALU is started not by a reset the TDC unit starts a measurement or, in sleep \nmode, the conversion counter is started without a measurement. Afterwards the flag \notp_usr_prg is checked to decide whether a jump into the user code in OTP/external \nEEPROM (address 48) must be performed or not. Again, in stand-alone operation \notp_usr_prg =1 is reasonable, in front-end operation otp_usr_prg = 0 will be more likely. \nIn the user code in the OTP / external EEPROM first the flag flg_rstpwr should be checked \nto see whether the reason for the jump was a reset. If yes, a detailed check is \nrecommended to see whether the reset comes from a power-on reset, a pushed button, \nthe watchdog interrupt. \nOtherwise a check of flag flg_intav0 will indicate if the chip is still in sleep mode or if an \nactive strain measurement is running. \nAt the end the ALU is stopped. This implements a complete reset of the ALU including the \nstart flags. Also the program stack is reset. Only the RAM data remain unchanged. \n \nWhen applying the supply voltage to the chip a power-on reset is generated. The whole \nchip is reset, only the RAM remains unchanged.  \nIn case otp_pwr_prg = 1 the user code at EEPROM address 48 is started. \n \nA power-on reset can also be triggered by the watchdog timer. This happens in case the \nmicroprocessor is started four times without being reset by the opcode “clrwdt”. Status bit \nflg_wdtalt in register 224+22; bit 17 indicates a timeout of the watchdog timer. \nIn case otp_pwr_prg = 1 the user code at EEPROM address 48 is started. \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n3-20 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nIn stand-alone mode (if Mode pin is unconnected) it is possible to apply an external power-\non at pin 6 (SPI_CSN_RST). This can be used as a reset button. The status of the button \ncan be requested from status bit flg_rstssn in register 224+22, bit 18. \nIn case otp_pwr_prg = 1 the user code at EEPROM address 48 is started. \n \nIn sleep mode only the 10 kHz oscillator is running. At regular intervals the \nmicroprocessor is waked up but without doing a measurement. In this phase it can check \nthe I/Os. A start-up of the microprocessor from sleep mode is indicated by status bit \nflg_intav0 in register 224+22, bit 22. \nConfiguration:  tdc_sleepmode  Register 1, Bit 17 \n    tdc_conv_cnt [7:0]  Register 0, Bits 23 to 16 \nNote : The sleep mode works only in combination with Single_conversion = 1 in \nConfigreg_02 \nSleep mode is activated by setting tdc_sleepmode = 1. This is equivalent to set avrate = 0. \nIn sleep mode the conversion counter tdc_cnv_cnt is running to the end and then \nimmediately starting the user program beginning at address 48 in the EEPROM.  \nAfter running in sleep mode the TDC has to be reinitialized for measurements. \n \nThe basic clock for the system is the internal, low-current 10 kHz oscillator. It is used to \ntrigger measurements in single conversion mode for the TDC unit in measurement range 2 \nas pre-counter as basis for the cycle time in stretched modes. \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  3-21 Figure 3-1: Clock Generation \n \n \nThe TDC conversion counter starts a measurement in single conversion mode. It is \nrunning continuously. The single conversion rate is given by 10 kHz / 64 / tdc_conv_cnt. \nWith the beginning of a measurement the watchdog counter is increased. The watchdog \ncounts the conversions. At the end of a measurement the microprocessor starts to ru n \nthe user code. In normal operation the watchdog has to be reset by CLRWDT before the \nuser code ends. The watchdog causes a power- on reset in case the TDC doesn’t finish its \nmeasurement because of an error or the user code does not run to end. \nIt is possible to switch off the watchdog when controlling the PSØ 9 by the SPI interface \n(Mode pin is connected to 0) sending SPI opcode watch_dog_off. Further the watchdog is \nreset by each signal edge at the SPI_CSN_RST pin. \n \nPSØ9 has a real time counter that counts automatically after a power-on reset in periods \nof 12.8 ms. The value of this timer can be read out at address 254, it is updated at the \nend of each measurement. The counter rolls over at 224 bit, which corresponds to a \nperiod of 46 hours \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-22 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nThe complete instruction set of the PSØ 9 consists of 69 core instructions that have \nunique op-codes decoded by the CPU.  \n \nThere are 3 principles of jumping within the code: \nJump. Absolute addressing within the whole address space of 8 kB. \nBranch. Relative to the actual address, jump within the address range of –128 to +127. \nSkip. Jump ahead up to 3 op-codes (3 to 15 bytes). \nThe assembler puts together jump and branch into goto-instructions. \nIt is possible to jump into subroutines only by means of absolute jumps and without any \ncondition. \n \nThe RAM is organized in 24 Bit words. All instructions are based on two’s complement \noperations. An arithmetic command combines two accumulators and writes back the \nresult into the first mentioned accumulator. The RAM address pointer points to the RAM \naddress that is handled in the same way as an accumulator. Each operation on the \naccumulator affects the four flags. The status of the flags refers to the last operation. \nTable 4-1 : Instruction set \nabs  div24  clrC clear \nadd  divmod  rotl decramadr  \ncompare   mult24  rotR incramadr  \ncompl   mult48  setC move \ndecr  shiftL ramadr  \ngetflag   shiftR  swap \nincr    \nsign    \nsub    \n \n \n \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-23 \nand bitclr equal \neor bitinv getepr  \nnor bitset  putepr  \ninvert   addepr  \nnand   \nnor   \nor   \n \nskip    \ngoto  clk10kHz  \ngotoBitC  skipBitC  clrwdt  \ngotoBitS  skipBitS  nop \ngotoCarC  skipCarC  stop \ngotoCarS  skipCarS  initTDC  \ngotoEQ  skipEQ  newcyc  \ngotoNE  skipNE   \ngotoNeg  skipNeg   \ngotoOvrC  skipOvrC   \ngotoOvrS  skipOvrS   \ngotoPos  skipPos   \njsub   \njsubret    \n \nSyntax:  abs p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = | p1 | \nFlags affected:  C O S Z  \nBytes:  2 \nCycles:  2 \nDescription:  Absolute value of register  \nCategory:  Simple arithmetic  \n \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-24 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \nSyntax:  add p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 + p2  \nFlags affected:  C O S Z  \nBytes:  1 (p2 = ACCU)  \n4 (p2 = number)  \nCycles:  1 (p2 = ACCU)  \n4 (p2 = number)  \nDescription:  Addition of two registers or addition of a constant to a register  \nCategory:  Simple arithmetic  \n \nSyntax:  addepr x  \nParameters:  ACCU[x]  \nCalculus:  x = x+Value (EEprom(rampointer))  \nFlags:  Z S C O  \nBytes:  2 \nCycles:  100..200  \nDescription:  Adds the value from the content of the EEPROM register, currently addressed \nby the ram address pointer, to the X -Accumulator.  \nCategory:  EEPROM access  \n \nSyntax:  and p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 AND p2  \nFlags affected:  S Z \nBytes:  2 (p2 = ACCU)  \n5 (p2 = \nnumber)   \nCycles:  3 (p2 = ACCU)  \n6 (p2 = \nnumber)   \nDescription:  Logic AND of 2 registers or Logic AND of register and constant  \nCategory:  Logic \n \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-25 \nSyntax:  bitclr p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = number 0 to 23  \nCalculus:  p1 = p1 and not (1<<p2)  \nFlags affected:  S Z \nBytes:  2 \nCycles:  2 \nDescription:  Clear a single bit in the destination register  \nCategory:  Bitwise  \n \nSyntax:  bitinv p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = number 0 to 23  \nCalculus:  p1 = p1 eor (1<<p2)  \nFlags affected:  S Z \nBytes:  2 \nCycles:  2 \nDescription:  Invert a single bit in the destination register  \nCategory:  Bitwise  \n \nSyntax:  bitset p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = number 0 to 23  \nCalculus:  p1 = p1 or (1<<p2)  \nFlags affected:  S Z \nBytes:  2 \nCycles:  2 \nDescription:  Set a single bit in the destination register  \nCategory:  Bitwise  \n \nSyntax:  clear p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = 0 \nFlags affected:  S Z \nBytes:  1 \nCycles:  1 \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-26 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Description:  Clear addressed register to 0  \nCategory:  RAM access  \n \nSyntax:  clk10khz p1  \nParameters:  p1 = number 0 or 1  \nCalculus:  - \nFlags affected:  - \nBytes:  2 \nCycles:  3 \nDescription:  Change clock source of processor to 10 kHz. The clock of the processor is \nswitched to the slower 10 kHz clock instead of the 40 MHz. The 10 kHz clock \nis still stable to variations in temperature and supply voltage. If p1 is set to 1 \nthe 10 kHz clock is on, if p 1 == 0 the 10 kHz clock is off.  With the 10  kHz \nclock beeper application at the IO -Port may programmed with the \nmicrocontroller. Do not switch directly between CLK4MHz and CLK10k Hz. \nCategory:  Miscellaneous  \n \nSyntax:  clrC \nParameters:  - \nCalculus:  - \nFlags affected:  C O \nBytes:  1 \nCycles:  1 \nDescription:  Clear Carry and Overflow flags  \nCategory:  Shift and Rotate  \n \nSyntax:  clrwdt  \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  2 \nCycles:   \nDescription:  Clear watchdog. This opcode is used to clear the watchdog at the end of a \nprogram run. Apply this opcode right before ‚stop‘.  \nCategory:  Miscellaneous  \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-27 Syntax:  compare p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  --- = p2 - p1 only the flags are changed but not the registers  \nFlags affected:  C O S Z  \nBytes:  1 (p1 = ACCU , p2 = ACCU ) \n4 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = ACCU ) \n4 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Comparison of 2 registers by subtraction. Comparison of a constant with a \nregister by subtraction The flags are changed according to the subtraction \nresult, but not the re gisters contents themselves  \nCategory:  Simple arithmetic  \n \nSyntax:  compl p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = - p1 = not p1 + 1  \nFlags affected:  S Z \nBytes:  2 \nCycles:  2 \nDescription:  two‘s complement of register  \nCategory:  Simple arithmetic  \n \nSyntax:  decr p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = p1 – 1 \nFlags affected:  C O S Z  \nBytes:  1 \nCycles:  1 \nDescription:  Decrement register  \nCategory:  Simple arithmetic  \n \nSyntax:  decramadr  \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  1 \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-28 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Cycles:  1 \nDescription:  Decrement RAM address pointer by one  \nCategory:  Ram Access  \n \nSyntax:  div24 p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  \nCalculus:  p1 = ( p1 << 24 ) / p2 (if |p1| <  |p2/2| )  \nFlags affected:  S & Z of p1  \nBytes:  2 \nCycles:  20 \nDescription:  Signed division of 2 registers, 24 bits of the division of 2 registers, result is \nassigned to p1  \nCategory:  Complex arithmetic  \n \nSyntax:  divmod p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  \nCalculus:  p1 = p1 / p2 and p2 = p1 % p2  \nFlags affected:  S Z \nBytes:  2 \nCycles:   \nDescription:  Signed modulo division of 2 registers, 24 higher bits of the division of 2 \nregisters, result is assigned to p1, the rest is placed to p2  \nCategory:  Complex arithmetic  \n \nSyntax:  eor p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 xor p2, bit combination 0 / 0 and 1 / 1 returns 0, bit combination 0 \n/ 1and 1 / 0 returns 1  \nFlags affected:  S Z \nBytes:  2 (p1 = ACCU , p2 = ACCU ) \n5 (p1 = ACCU , p2 = NUMBER ) \nCycles:  3 (p1 = ACCU , p2 = ACCU ) \n6 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Logic XOR (exclusive OR, antivalence) of the 2 given registers  \nLogic XOR (exclusive OR, antivalence) of register with constant  \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-29 Category:  Logic \n \nSyntax:  eorn p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 xnor p2, bit combination 0 / 0 and 1 / 1 return 1, bit combination 0 \n/ 1 and 1 / 0 return 0  \nFlags affected:  S Z \nBytes:  2 (p1 = ACCU , p2 = ACCU ) \n5 (p1 = ACCU , p2 = NUMBER ) \nCycles:  3 (p1 = ACCU , p2 = ACCU ) \n6 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Logic XNOR (exclusive NOR, equivalence) of the 2 given registers  \nLogic XNOR (exclusive NOR, equivalence) of register with constant  \nCategory:  Logic \n \nSyntax:  equal p1  \nParameters:  p1 = 24 -Bit number  \nCalculus:  - \nFlags affected:  - \nBytes:  3 \nCycles:   \nDescription:  Write 3 bytes (p1) to configuration register of OTP/external EEPROM. The \nequal opcode is used to write 3 bytes of configuration data directly to a \nregister. Therefore the opcode is simply used 16 times in the beginning of the \nassembler listing, fed with the configuration data given through p1. The \nconfiguration of the OTP/ external EEPROM is done in the lower area from \nbyte 0..47, combi ned in 16x 24bit registers. From byte 48 upwards, the user \ncode is written. Use this opcode to provide your own configuration instead of \nthe standard configuration.  \nCategory:  OTP/ External EEPROM access  \n \nSyntax:  getepr p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = EEPROM register content (addressed by RAM address pointer)  \nFlags affected:  S Z \nBytes:  1 \nCycles:  6 \nDescription:  Get EEPROM into register. The addressed register p1 gets the EEPROM \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-30 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   register content which  is addressed by the RAM address pointer. This opcode \nneeds temporarily a place in the program counter stack (explanation see \nbelow).  \nCategory:  EEPROM Access  \n \nSyntax:  getflag p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  signum = set if p1 < 0  \nnotequalzero = set if p1 <> 0  \nFlags affected:  S Z \nBytes:  1 \nCycles:  1 \nDescription:  Set the signum and notequalzero flag according to the addressed register, \ncontent of the register is not affected  \nCategory:  Simple arithmetic  \n \nSyntax:  goto p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute \njump)   \nCycles:  3 (relative jump)  \n4 (absolute jump)  \nDescription:  Jump without condition. Program counter is set to target address. The target \naddress is given by u sing a jump label. Jump range: 0< address < 8  kB \nSee examples section for how to introduce a jump label.  \nCategory:  Unconditional jump  \n \nSyntax:  gotoBitC p1, p2, p3  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = NUMBER [0...23]  \np3 = JUMPLABEL  \nCalculus:  if (bit p2 of register p1 == 0) PC = p3 \nFlags affected:  - \nBytes:  3 \nCycles:  4 \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-31 Description:  Jump on bit clear. Program counter will be set to target address if selected bit  \nin register p1 is clear. The target address is given by using a jump label. See \nexamples section for how to introduce a jump label.  \nCategory:  Bitwise  \n \nSyntax:  gotoBitS p1, p2, p3  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = NUMBER [0..23]  \np3 = JUMPLABEL  \nCalculus:  if (bit p2 of register p1 == 1)  \nPC = p3 \nFlags affected:  - \nBytes:  3 \nCycles:  4 \nDescription:  Jump on bit set. Program counter will be set to target address if selected bit \nin register p1 is set. The target address is given by using a jump label. See \nexamples section for how to introduce a jump label.  \nCategory:  Bitwise  \n \nSyntax:  gotoCarC p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (carry == 0) PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \n4 (absolute jump)  \nDescription:  Jump on carry clear. Program counter will be set to target address if carry is \nclear. The target address is given by using a jump label. See examples section \nfor how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoCarS p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (carry == 1) PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-32 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   4 (absolute jump)  \nDescription:  Jump on carry set. Program counter will be set to target address if carry is \nset. The target address is given by using a jump label. See examples section \nfor how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoEQ p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (Z == 0) PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \n4 (absolute jump)  \nDescription:  Jump on equal zero. Program counter will be set to target address if the \nforegoing result is equal to zero. The target address is given by using a jump \nlabel. See examples section for how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoNE p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (Z == 1)  PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \n4 (absolute jump)  \nDescription:  Jump on not equal zero. Program counter will be set to target address if the  \nforegoing result is not equal to zero. The target address is given by using a \njump label. See examples section for how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoNeg p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (S == 1) PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-33 4 (absolute jump)  \nDescription:  Jump on negative. Program counter will be set to target address if the \nforegoing result is negative. The target a ddress is given by using a jump label. \nSee examples section for how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoOvrC p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (O == 0) PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \n4 (absolute jump)  \nDescription:  Jump on overflow clear. Program counter will be set to target address if the \noverflow flag of the foregoing operation is clear. The target address is give n by \nusing a jump label. See examples section for how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoOvrS p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (O == 1)  PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \n4 (absolute jump)  \nDescription:  Jump on overflow set. Program counter will be set to target address if the \noverflow flag of the foregoing operation is set. The target address is given by \nusing a jump label. See examples section for how to introduce a jump label.  \nCategory:  Goto on flag  \n \nSyntax:  gotoPos p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  if (S == 0) PC = p1 \nFlags affected:  - \nBytes:  2 (relative jump)  \n3 (absolute jump)  \nCycles:  3 (relative jump)  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-34 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   4 (absolute jump)  \nDescription:  Jump on positive. Program counter will be set to target address if the \nforegoing result is positive. The target address is given by using a jump label. \nSee examples section for how to introduce a j ump label.  \nCategory:  Goto on flag  \n \nSyntax:  incr p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = p1 + 1  \nFlags affected:  C O S Z  \nBytes:  1 \nCycles:  1 \nDescription:  Increment register  \nCategory:  Simple arithmetic  \n \nSyntax:  incramadr  \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  1 \nCycles:  1 \nDescription:  Increment RAM address pointer by 1  \nCategory:  RAM access  \n \nSyntax:  initTDC  \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  2 \nCycles:  3 \nDescription:  Initialization reset of the TDC (time -to-digital converter). Should be sent after \nconfiguration of registers. The initTDC preserves all configurations.  \nCategory:  Miscellaneous  \n \n \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-35 \nSyntax:  invert p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = not p1  \nFlags affected:  S Z \nBytes:  2 \nCycles:  2 \nDescription:  Bitwise inversion of register  \nCategory:  Logic \n \nSyntax:  jsub p1  \nParameters:  p1 = JUMPLABEL  \nCalculus:  PC = p1 \nFlags affected:  C O S Z  \nBytes:  3 \nCycles:  4 \nDescription:  Jump to subroutine without condition. The program counter is loaded by the \naddress given through the jump label. The subroutine is processed until the \nkeyword ‚jsubret‘ occurs. T hen a jump back is performed and the next \ncommand after the jsub -call is executed. This opcode needs temporarily a \nplace in the program counter stack (explanation see below). Jump range: 0< \naddress < 8  kB \nCategory:  Unconditional Jump  \n \nSyntax:  jsubret  \nParameters:  - \nCalculus:  PC = PC from jsub -call \nFlags affected:  - \nBytes:  1 \nCycles:  3 \nDescription:  Return from subroutine. A subroutine can be called via ‚jsub‘ and  exited by \nusing jsubret. The program is continued at the next command following the \njsub-call. You have to close a subroutine with jsubret - otherwise there will be \nno jump back.  \nCategory:  Unconditional Jump  \n \n \n \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-36 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \nSyntax:  move p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -bit number  \nCalculus:  p1 = p2 \nFlags affected:  S Z \nBytes:  1 (p1 = ACCU , p2 = ACCU ) \n4 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = ACCU ) \n4 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Move content of p2 to p1  (p1 = ACCU , p2 = ACCU ) \nMove constant to p1  (p1 = ACCU , p2 = NUMBER ) \nCategory:  RAM access  \n \n \nSyntax:  mult24 p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  \nCalculus:  p1 = (p1 * p2) >> 24  \nFlags affected:  S & Z of p1  \nBytes:  2 \nCycles:  30 \nDescription:  Signed multiplication of 2 registers like mult48, but only the 24 higher bits of \nthe multiplication of 2 registers, result is stored in p1  \nCategory:  Complex arithmetic  \n \nSyntax:  mult48 p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  \nCalculus:  p1, p2 = p1 * p2  \nFlags affected:  S & Z of p1  \nBytes:  2 \nCycles:  30 \nDescription:  Signed multiplication of 2 registers.  \nHigher 24 bits of the multiplication is placed to p1  \nLower 24 bits of the multiplication is placed to p2  \nCategory:  Complex arithmetic  \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-37 \nSyntax:  nand p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np1 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 nand p2  \nreturns only 0 in case of bit combination 1 / 1  \nFlags affected:  S Z \nBytes:  2 (p1 = ACCU , p2 = ACCU ) \n5 (p1 = ACCU , p2 = NUMBER ) \nCycles:  3 (p1 = ACCU , p2 = ACCU ) \n6 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Logic NAND (negated AND) of the 2 given registers  \nLogic NAND (negated AND) of register with constant  \nCategory:  Logic \n \nSyntax:  newcyc  \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  2 \nCycles:  3 \nDescription:  Start of TDC. This opcode can be used after configuration and initialization of \nthe PSØ 9 to start a new measurement cycle. Normally this is done by the \nPSØ 81 ROM routines itself, but in case of custom -designed reset procedures \nthis opcode can play a role.  \nCategory:  Miscellaneous  \n \nSyntax:  - \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  1 \nCycles:  1 \nDescription:  Placeholder code or timing adjust (no function)  \nCategory:  Miscellaneous  \n \n \n \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-38 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \nSyntax:  nor p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 nor p2  \nreturns only 1 in case of bit combination 0 / 0  \nFlags affected:  S Z \nBytes:  2 (p1 = ACCU , p2 = ACCU ) \n5 (p1 = ACCU , p2 = NUMBER ) \nCycles:  3 (p1 = ACCU , p2 = ACCU ) \n6 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Logic NOR (negated OR) of the 2 given registers  \nLogic NOR (negated OR) of register with constant  \nCategory:  Logic \n \nSyntax:  or p1, p2  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = ACCU [x, y, z, r]  or 24 -Bit number  \nCalculus:  p1 = p1 or p2  \nreturns only 0 in case of bit combination 0 / 0  \nFlags affected:  S Z \nBytes:  2 (p1 = ACCU , p2 = ACCU ) \n5 (p1 = ACCU , p2 = NUMBER ) \nCycles:  3 (p1 = ACCU , p2 = ACCU ) \n6 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Logic OR of the 2 given registers  \nLogic OR of register with constant  \nCategory:  Logic \n \nSyntax:  putepr p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  EEPROM register (ad dressed by RAM address pointer)  = p1 [7:0]  \nFlags affected:  - \nBytes:  4 \nCycles:   ~12.5 ms  \nDescription:  Put register into EEPROM. The lower 8 bits of the addressed register p1 is \nmoved to the EEPROM (the EEPROM register address is set by the RAM \naddress pointer). EEPROM bytes 0 to 127 are accessible via ‚putepr‘, bysetting \nthe RAM add ress pointer to addresses 0 to 127 respectively. This opcode \nneeds temporarily a place in the program counter stack (explanation see \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-39 below). It is recommended not to use putepr in combination with the skip \nopcodes due to relatively longer execution times ( ~30ms).  \nCategory:  EEPROM access  \n \nSyntax:  ramadr p1  \nParameters:  p1 = 8 -Bit number  \nCalculus:  - \nFlags affected:  - \nBytes:  2 \nCycles:  2 \nDescription:  Set pointer to RAM address (range: 0...255)  \nCategory:  RAM access  \n \nSyntax:  rotL p1(, p2)  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = 4 -Bit number or none  \nCalculus:  p1 = p1<< 1+ carry; carry  = MSB(x) (in case rotL p1, without p2)  \np1 = repeat (p2) rotL p1(in case rotL p1, p2 ) \nFlags affected:  C O S Z (of the last  step) \nBytes:  1 (p1 = ACCU , p2 = none ) \n2 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = none ) \n1+p2 ( p1 = ACCU , p2 = NUMBER ) \nDescription:  Rotate p1 left \uf0e0 shift p1 register to the left, fill LSB with carry, MSB is placed \nin carry register  \nRotate p1 left p2 times with carry \uf0e0 shift p1 register p2 times to the left, in \neach step fill LSB with the carry and place the MSB in the carry  \nCategory:  Shift and rotate  \n \nSyntax:  rotR p1(, p2)  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = 4-Bit number or none  \nCalculus:  p1 = p1>> 1+ carry;  \ncarry: =MSB(x) (in case rotR p1, without p2)  \np1 = repeat (p2) rotR p1 (in case rotR p1, p2 ) \nFlags affected:  C O S Z (of the last step)  \nBytes:  1 (p1 = ACCU , p2 = none ) \n2 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = none ) \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-40 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   1 + p2 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Rotate p1 right \uf0e0 shift p1 register to the right, fill MSB with carry, LSB is \nplaced in carry register  \nRotate p1 right p2 times with carry \uf0e0 shift p1 register p2 times to the right, \nin each step fill MSB with the carry and place the LSB in the carry  \nCategory:  Shift and rotate  \n \nSyntax:  round p1, p2  \nParameters:  p1 = ACCU [x]  \np2 = NUMBER [half scale division]  \nCalculus:  p1 = round (p1, p2)  \nFlags affected:   \nBytes:  7 \nCycles:  subroutine call  \nDescription:  Rounds the number in x. Depending on the configured ‚half scale division‘ the \nnumber stored in x will be rounded down or up (down <  5, up >= 5).  \nCategory:  Miscellaneous  \n \nSyntax:  setC \nParameters:  - \nCalculus:  - \nFlags affected:  C O \nBytes:  1 \nCycles:  1 \nDescription:  Set carry flag and clear overflow flag  \nCategory:  Shift and Rotate  \n \nSyntax:  shiftL p1(, p2)  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = 4 -Bit number or none  \nCalculus:  p1 = p1<< 1; carry = MSB(x) (in case rotL p1, without p2)  \np1 = repeat (p2) shiftL p1(in case rotL p1, p2 ) \nFlags affected:  C O S Z  \nBytes:  1 (p1 = ACCU , p2 = none ) \n2 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = none ) \n1 + p2 ( p1 = ACCU , p2 = NUMBER ) \nDescription:  Shift p1 left \uf0e0 shift p1 register to the left, fill LSB with 0, MSB is placed in \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-41 carry register  \nShift p1 left p2 times \uf0e0 shift p1 register p2 times to the left, in each step fill \nLSB with the 0  and place the MSB in the carry  \nCategory:  Shift and rotate  \n \nSyntax:  shiftR p1(, p2)  \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = 4 -Bit number or none  \nCalculus:  p1 = p1>> 1; carry  = MSB(x) (in case rotL p1, without p2)  \np1 = repeat (p2) shiftL p1 (in case rotL p1, p2 ) \nFlags affected:  C O S Z  \nBytes:  1 (p1 = ACCU , p2 = none ) \n2 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = none ) \n1 + p2 ( p1 = ACCU , p2 = NUMBER ) \nDescription:  Signed shift right of p1 \uf0e0 shift p1 right, MSB is duplicated according to \nwhether the number is positive or negative  \nSigned shift p1 right p2 times \uf0e0 shift p1 register p2 times to the right, MSB \nis duplicated according to whether the number is positive or negative  \nCategory:  Shift and rotate  \n \nSyntax:  sign p1  \nParameters:  p1 = ACCU [x, y, z, r]  \nCalculus:  p1 = p1 / | p1 | \np1 =  1 = 0x000001     if p1 >= 0  \np1 = -1 = 0xFFFFFF   if p1 < 0  \nFlags affected:  S Z \nBytes:  2 \nCycles:  2 \nDescription:  Sign of addressed register in complement of two notations .  \nA positive value returns 1, a negative value returns -1 \nZero is assumed to be positive  \nCategory:  Simple arithmetic  \n \nSyntax:  skip p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  PC = PC + bytes of next p1 lines  \nFlags affected:   \nBytes:  1 \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-42 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Cycles:  1 + skipped commands  \nDescription:  Skip p1 without conditions  \nCategory:  Unconditional jump  \n \nSyntax:  skipBitC p1, p2 ,p3 \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = NUMBER[0..23]  \np2 = NUMBER [1, 2, 3]  \nCalculus:  if (bit p2 of register p1 == 0)  \n PC = PC + bytes of next p3 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p3 commands if bit p2 of register p1 is clear  \nCategory:  Bitwise  \n \nSyntax:  skipBitS p1, p2 ,p3 \nParameters:  p1 = ACCU [x, y, z, r]  \np2 = NUMBER[0..23]  \np3 = NUMBER [1, 2, 3]  \nCalculus:  if (bit p2 of register p1 == 1)  \nPC = PC + bytes of next p3 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p3 commands if bit p2 of register p1 is set  \nCategory:  Bitwise  \n \nSyntax:  skipCarC p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (carry == 0)  \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if carry clear  \nCategory:  Skip on flag  \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-43 Syntax:  skipCarS p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (carry == 1)  \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if carry set  \nCategory:  Skip on flag  \n \nSyntax:  skipEQ p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (notequalzero ==  0) \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if result of previous operation is equal to zero  \nCategory:  Skip on flag  \n \nSyntax:  skipNE p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (notequalzero == 1)  \n PC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if result of previous operation is not equal to zero  \nCategory:  Skip on flag  \n \nSyntax:  skipNeg p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (signum == 1)  \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n4-44 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   Description:  Skip p1 commands if result of previous operation was smaller than 0  \nCategory:  Skip on flag  \n \nSyntax:  skipOvrC p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (overflow == 0)  \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if overflow is clear  \nCategory:  Skip on flag  \n \nSyntax:  skipOvrS p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (overflow == 1)  \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if overflow is set  \nCategory:  Skip on flag  \n \nSyntax:  skipPos p1  \nParameters:  p1 = NUMBER [1, 2, 3]  \nCalculus:  if (signum == 0)  \nPC = PC + bytes of next p1 lines  \nFlags affected:  - \nBytes:  1 \nCycles:  1 + skipped commands  \nDescription:  Skip p1 commands if result of previous operation was greater or equal to 0  \nCategory:  Skip on flag  \n \n \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  4-45 Syntax:  stop \nParameters:  - \nCalculus:  - \nFlags affected:  - \nBytes:  1 \nCycles:  1 \nDescription:  The DSP and clock generator are stopped, the converter and the EEPROM go \nto standby. A restart of the converter can be achieved by an external event like \n‚watchdog timer‘, ‚external switch‘ or  ‚new strain measurement results‘. \nUsually this opcode is the last command in the assembler listing.  \nCategory:  Miscellaneous  \n \nSyntax:  sub p1, p2  \nParameters:  p1 = NUMBER [1, 2, 3]  \np2 = NUMBER [1, 2, 3]  or 24 -Bit number  \nCalculus:  p1 = p2 – p1 \nFlags affected:  C O S Z  \nBytes:  1 (p1 = ACCU , p2 = ACCU ) \n4 (p1 = ACCU , p2 = NUMBER ) \nCycles:  1 (p1 = ACCU , p2 = ACCU ) \n4 (p1 = ACCU , p2 = NUMBER ) \nDescription:  Subtraction of 2 registers  \nSubtraction of register from constant  \nCategory:  Simple arithmetic  \n \nSyntax:  swap p1, p2  \nParameters:  p1 = ACCU [x, y, r]  \np2 = ACCU [x, y, r]  \nCalculus:  p1 = p2 and p2 = p1 \nFlags affected:  - \nBytes:  1 \nCycles:  3 \nDescription:  Swap of 2 registers  \nThe value of two registers is exchanged between each other.  \nNot possible with ACCU[z]  \nCategory:  RAM Access  \n \n \n  \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n5-46 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nThe PSØ 9 assembler is a multi-pass assembler that translates assembly language files into HEX \nfiles as they will be downloaded into the device. For convenience, the assembler can include \nheader files to be then downloaded. The user can write his own header files but also integrate the \nlibrary header files as they are provided by acam. The assembly program is made of many \nstatements which contain instructions and directives. The instructions have been explained in the \nformer section 4 of this datasheet. In the following we describe the directives and some sample \ncode. \nEach line of the assembly program can contain only one directive or instruction statement. \nStatements must be contained in exactly one line. \nA symbol is a name that represents a value. Symbols are composed of up to 31 characters from \nthe following list: \nA - Z, a - z, 0 - 9, _ \nSymbols are not allowed to start with numbers. The assembler is case sensitive, so care has to \nbe taken for this. \nNumbers can be specified in hexadecimal or decimal. Decimal have no additional specifier. \nHexadecimals are specified by leading “0x”.  \nAn expression is a combination of symbols, numbers and operators. Expressions are evaluated at \nassembly time and can be used to calculate values that otherwise would be difficult to be \ndetermined. \nThe following operators are available with the given precedence: \nLevel Operator  Description  \n1 () Brackets, specify order of execution  \n2 * /  Multiplication, Division  \n3 + —  Addition, Subtraction  \n \n \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  5-47 \n \nThe assembler directives define the way the assembly language instructions are processed. They \nalso provide the possibility to define constants, to reserve memory space and to control the \nplacement of the code. Directives do not produce executable code. \nThe following table provides an overview of the assembler directives. \nCONST Constant definition, CONST [name] [value]  \nvalue might be a number, a constant, a \nsum of both  CONST Slope 42 \nCONST Slope constant +  1 \nLABEL: Label for target address of jump \ninstructions. Labels end with a colon. All \nrules that apply to symbol names also \napply to labels.  jsub LABEL1  \nLABEL1:  \n... \njsubret  \n; Comment, lines of text that might be \nimplemented to explain the code. It begins \nwith a s emicolon character. The \nsemicolon and all subsequent characters \nin this line will be ignored by the \nassembler. A comment can appear on a \nline itself or follow an instruction.  ; this is a comment  \n<comment>  \n<endcomment>  Comment, lines of text that might be \nimplemented to explain the code. It begins \nwith <comment> directive and ends with \n<endcomment> directive. All subsequent \ncharacters between these directives will \nbe ignored by the assembler.  <comment>  \nthis is ...  \na very long ...  \ncomment  \n<endcomment>  \n#include Include the header or library file named in \nthe quotation marks "". The code will be \nadded at the line of the include command.  \nIn the quotation marks the re might be just \nthe file name in case it is in the same \nfolder as the program, but also the \ncomplete path.  #include "rdc.h"  \n \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n5-48 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de   \n \nThe following code shows the basic structure of any PSØ 9 program: \n;-------------------------------------------------------- \n; File:program_template.asm \n; This is a template for a standard user program that shows the various possible flags \nthat can be \n; read to find out what caused the DSP to jump into the user code. Some part of user code \nneeds \n;  to be executed on POR, some on External interrupt etc. Those jumps that are relevant to \nthe user \n;  can be retained, the rest can be commented. \n; Author: VK \n;-------------------------------------------------------- \n \n#include "config.h" \n#include "PS09_RAM_constants.h" \n \nramadr  224+22 \nskipBitC  r, 19, 1 ; Checking for power on reset flag, Bit 19 - in Status register  \njsub  Routine_POR \ngoto  end \n    \nramadr  224+22 \nskipBitC  r, 18, 1  ; Checking for SSN_RST (S6) Button Pressed : Bit 18 - in Status \nregister  \njsub  Routine_Button_Press \ngoto  end \n \nramadr  224+22 \nskipBitC  r, 17, 1 ; Checking for Watchdog reset : Bit 17 - in Status register  \njsub  Routine_watchdog \ngoto  end \n \nramadr  224+22 \nskipBitC  r, 16, 1 ; Checking for End of measurement : Bit 16 - in Status register  \njsub  Routine_measurement_end \ngoto  end \n \nramadr  224+22 \nskipBitC  r, 15, 1 ; Checking for wakeup in Sleep mode : Bit 15 - in Status register  \njsub  Routine_sleep_mode \ngoto  end \n \nramadr  224+22 \nskipBitC  r, 08, 1 ; Checking for DSP start due to External Pin Interrupt : Bit 08 –  \nin Status register  \njsub  Routine_ext_interrupt \ngoto  end \n \nramadr  80 \nskipBitC  r, 08, 1 ; Check for jump into user code because of Receive Int from UART: \n Bit 08 - Reg.80  \njsub  Routine_uart_rec_int \ngoto  end \n    \nRoutine_POR:   \n;----------------------Insert Power on reset routine h ere---------------------------  \nnop \njsubret \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  5-49 ;------------------------------------------------------- \n \nRoutine_Button_Press: \n;----------- Insert routine to be executed on Pushed button here------------    \nnop \njsubret \n;------------------------------------------------------- \n \nRoutine_watchdog: \n;----------------------Insert reset routine for watchdog reset here--------------- -- \nnop \njsubret \n;------------------------------------------------------- \n \nRoutine_measurement_end: \n;------Insert routine to be executed on measurement end here --------------    \nnop \njsubret \n;------------------------------------------------------- \n \nRoutine_sleep_mode: \n;----------------------Insert routine for wakeup in Sleep mode here--------------   \nnop \njsubret \n;------------------------------------------------------- \n \nRoutine_ext_interrupt: \n;------Insert Interrupt service routine for External Interrupt from Pin here---   \nnop \njsubret \n;------------------------------------------------------- \n \nRoutine_uart_rec_int: \n;-------------Insert interrupt routine for UART receive Interrupt here-----------   \nnop \njsubret \n;------------------------------------------------------- \nend:  \nclrwdt \nstop \n;-----end of program------------------------------ \n \n \nThe following example from the Assembler program shows a simple program to display \nresults on an LCD: \n;-------------------------------------------------------- \n; File: simple_meas_with_LCD.asm \n; \n; Author: VK / UTG \n;-------------------------------------------------------- \n \n;-------------------------------------------------------- \n;  Simple program to demonstrate calculation of Initial Offset after POR and after the Initial \nOffset is taken, it goes to measure mode. \n; State 1: Take init offset value (ignore first 4 measurements) Then average over next 5. \n; State 2: Take measurement value and substract init offset value, then scale to display \ncorrect weight. \n; \n \nMember of the ams Group\n\uf031®\uf020 PSØ9 DSP  \n5-50 acam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de    \n#include "config.h" \n; The other include files are included at the end of the program \n \n \n;-------------   Constants for measurement program --------------------------------- \nCONST  init_offset_for_measurement   121 \nCONST  count_measurements     122 \nCONST  temp_count      123 \nCONST  init_offset_status     124    \n; To store the status of init_offset, 0 - if offset calculation is not yet complete \n; 1 - if offset calculation is complete  \n;---------------------------------------------------------------------------------- \nstart: \n; On POR configure the PS09 to act as SPI master to communicate with the Holtek driver  \nramadr  224+22 \nskipBitC  r, 19, 3 ; Checking for power on reset : flg_rstpwr bit \njsub  cfg_spi_master ; Configures the SPI master lines on GPIO0, GPIO1 and GPIO2 \n; To use other pins for the SPI master, change in this include file accordingly   \njsub  cfg_ht_driver ; Configure the HT1621 driver for display \njsub  init_values     \n \nramadr  init_offset_status   ; Check status of init offset \nskipBitS  r, 0, 2       \njsub  get_init_offset \ngoto  end \n;Refresh the displayed value on measurement completion    \nramadr  22+224   \nskipBitS  r, 16, 1 ; Check for end of measurement - Bit 16 \ngoto  end   \n;----------- -------------- To display measurement values on LCD--------------------  \n; Reading measurement value HB0 into x Akku \nramadr  224+20        \nmove  x, r \nramadr   init_offset_for_measurement \nmove  y, r \nsub  x, y \nabs  x \n;-------------------------- Mutiplication factor -----------------------------------  \nshiftL  x, 4  ; HB0 * 2^4 \nmove  z, 0x8D5E5  ; With 2000 g load and no multiplication factor (& with division \nby 10 seen below): Meas.value = 3629  \n    ; (2000 / 3629) * 2^20 = 0x8D15F \n    ; This factor is further corrected with again 500 g load  \n(500/499) * 0x8D15F = 0x8D5E5 \n    ; The above 2^4 and 2^20 factors are multiplied to adjust for the \nfollowing mult24 opcode \nmult24  x, z  ; Implicit to opcode , result is / 2^24 \nmove  z, 10  ; division by 10 to omit the LSB, only 4 digits needed \ndivmod  x, z        \nmove  y, 0  ; Number of digits after the decimal point \njsub  notolcd  ; Routine to convert the display value to LCD format \nmove  z, 0x10  ; 0x10 - Code to display units as gm,Codes for other units are  \npresent in notolcd.h \njsub   display_value_on_Holtek ; Displaying the data with the Holtek driver \nend:   \nclrwdt \nstop \n;-----end of main program------------------------------ \n \n;------------------------- -Subroutines--------------------------- \ninit_values: \nramadr  count_measurements \nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  5-51 clear  r \n \nramadr  init_offset_status \nclear  r \nramadr  temp_count    ; Use a temporary counter  \nclear  r \njsubret \n;================================================================================== \nget_init_offset: \nmove  x, 0xFFFF00     ; setting all the segments \nmove  y, 0xFFFFFF \nmove  z, 0 \njsub  display_text_on_Holtek \n;--------- Get current measurement value and save it to x for further processing  ------- \nramadr  224+20  ;HB0 value \nmove  x, r \n;--------- Count Loops and dismiss first 4 measurements --------------- \nramadr  temp_count ; Use a temporary counter  \nincr  r \ncompare  r,4  ; Is it higher than 4? -> Ignore first 4 measurements \ngotoNeg  apply_roll_avg ; From the 5th measurement, perform a rolling average \njsub  roll_avg_init5 ; Initalize rolling average filter with measurement value in X \ngoto  end_init_offset \n;==================================================================================  \napply_roll_avg: \n;--------- Use rolling average filter for init offset value  --------------- \njsub  rolling_avg_5 ; 5 times rolling average  \n;------------- Count Loops for Initial Offset ---------------------------------- \nramadr  count_measurements \nincr  r \ncompare  r,5  ; Take 5 measurements \ngotoPos  end_init_offset ; Is it lesser than 5? , then take more measurements else store  \nthe offset \n;---- After 5 valid measurements save filtered value to RAM as initial offset for measurement- \nramadr  init_offset_for_measurement ; Init offset value for measurement mode \nmove  r, x \nramadr  init_offset_status \nincr  r  ;  Set status of init_offset_status to 1 (init offset taken) \nend_init_offset: \njsubret \n;================================================================================== \n#include "rollavg.h"  ; This file is used to calculate the rolling average of the measurement \n#include "cfg_spi_master.h" ; These include files are used ONLY for using the Holtek LCD driver \n#include "cfg_ht_driver.h" \n#include "notolcd.h" \n#include "display_value_on_Holtek.h" \n#include "display_text_on_Holtek.h" \n \nFor details on programming with the assembler tool please refer to the PS09-EVA-KIT \ndatasheet, which includes a description of the assembler software. \n \n  \nMember of the ams Group\nMember of the ams Group\nPSØ9 DSP  \nacam messelectronic gmbh - Friedrich-List-Str.4 - 76297 Stutensee - Germany - www.acam.de  6-1 \n \n \n(See Data Sheet, Volume 1 “ General Data and Front-end Description ”) \n \n \n05.11.2014 First release of Volume 2, Version 1.0 \n \n \n \n \n \nMember of the ams Group\n \n \n \nacam -messelectronic gmbh  \nFriedrich -List-Straß e 4  \n76297 Stutensee -Blankenloch  \nGermany  \nPhone  +49 7244 7419 – 0 \nFax +49 7244 7419 – 29 \nE-Mail support@acam.de  \nwww.acam.de   \nMember of the ams Group\nMouser Electronics\n  \nAuthorized Distributor\n \n  \nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\n \n \n \n ScioSense:   \n\xa0 PS09FN\xa0 PS09 DICE\xa0 PS09-EVA-LC MODULE\xa0 PS09-EVA-HR MODULE\xa0 PS09-DLC MODULE\n'}]
!==============================================================================!
### Component Summary: PS09FN from ScioSense

#### Key Specifications:
- **Voltage Ratings**: Not explicitly stated in the provided text.
- **Current Ratings**: Not explicitly stated in the provided text.
- **Power Consumption**: Ultra-low power operation, typically in the microamp range.
- **Operating Temperature Range**: Not explicitly stated in the provided text.
- **Package Type**: Not explicitly stated in the provided text.
- **Special Features**: 
  - System-on-chip design for ultra-low power and high-resolution applications.
  - Integrated 28-bit signal converter and 24-bit microprocessor.
  - Supports various interfaces including SPI and IIC.
  - On-chip EEPROM for user program storage.
  - Watchdog timer and sleep mode functionality.
- **Moisture Sensitive Level (MSL)**: Not explicitly stated in the provided text.

#### Description:
The **PS09FN** is a system-on-chip (SoC) designed primarily for ultra-low-power and high-resolution applications, particularly in weight scales and force or torque measurements utilizing metal strain gauges. It integrates a 28-bit signal converter with a 24-bit microprocessor, allowing for complex data processing while maintaining low power consumption. The device is capable of operating in stand-alone mode or as a resistance-to-digital converter, with the option to implement additional data post-processing on-chip.

#### Typical Applications:
The PS09FN is typically used in:
- **Weight Scales**: For precise weight measurement and data processing.
- **Force and Torque Measurement**: Suitable for applications requiring accurate force or torque readings based on strain gauge technology.
- **Industrial Automation**: Can be integrated into systems requiring precise measurement and control.
- **Consumer Electronics**: Potential use in devices that require weight or force sensing capabilities.

This component is particularly advantageous in applications where power efficiency is critical, and high-resolution measurements are necessary.