[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of S25FL064LABNFV040 production of INFINEON TECHNOLOGIES from the text:Datasheet Please read the Important Notice and Warnings at the end of this document 002-12878 Rev. *G\nwww.infineon.com page 1  2022-07-21S25FL064L  \n64 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nGeneral description\nThe FL-L family devices are flash non-volatile memory products using: \n• Floating gate technology\n• 65-nm process lithography\nThe FL-L family connects to a host system via a serial peri pheral interface (SPI). Tradit ional SPI single bit serial \ninput and output (single I/O or SIO) is  supported as well as optional two bit (Dual I/O or DIO) and four bit wide \nQuad I/O (QIO), and Quad Peripheral Interface (QPI) commands. In addition, there are Double Data Rate (DDR) \nRead commands for QIO and QPI that transfer address and read data on both edges of the clock.\nThe architecture features a page programming buffer th at allows up to 256 bytes to be programmed in one \noperation and provides individual 4 KB sector, 32 KB half  block sector, 64 KB block sector, or entire chip erase.\nBy using FL-L family devices at the higher clock rate s supported, with Quad comma nds, the instruction read \ntransfer rate can match or exceed traditional parall el interface, asynchronous , NOR Flash memories, while \nreducing signal count dramatically.\nThe FL-L family products offer high densities coupled wi th the flexibility and fast performance required by a \nvariety of mobile or embedded applications. Provides an  ideal storage solution for systems with limited space, \nsignal connections, and power. These memories offer flexibility and perfor mance well beyond ordinary serial \nflash devices. They are ideal for code shadowing to RAM,  executing code directly (XIP), and storing re-program-\nmable data.\nFeatures\n• Serial peripheral interfac e (SPI) with multi-I/O\n- Clock polarity and phase modes 0 and 3\n- Double data rate (DDR) option\n- Quad peripheral interface (QPI) option\n- Extended addressing: 24- or 32- bit address options\n- Serial command subset and footprint compatible with S25FL-A, S25FL1-K, S25FL-P , S25FL-S, and S25FS-S SPI \nfamilies\n- Multi I/O command subset and footprint compatible with S25FL-P , S25FL-S and S25FS-S SPI families\n•R e a d\n- Commands: Normal, Fast, Dual I/O, Quad I/O, DualO, QuadO, DDR Quad I/O\n- Modes: Burst wrap, Continuous (XIP), QPI\n- Serial flash discoverable parameters (SFDP) for configuration information\n• Program architecture\n- 256-bytes page programming buffer\n- Program suspend and resume\n•E r a s e  a r c h i t e c t u r e\n- Uniform 4 KB sector erase\n- Uniform 32 KB half block erase\n- Uniform 64 KB block erase \n- Chip erase\n- Erase suspend and resume\n• 100,000 program-erase cycles, minimum\n• 20 year data retention, minimum\nDatasheet 2 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nFeatures\n• Security features\n- Status and Configuration Register protection- Four Security Regions of 256-bytes each outside the main flash array\n- Legacy block protection: Block range\n- Individual and region protection \n• Individual block lock: Volatile individual sector/block \n• Pointer region: Non-volatile sector/block range\n• Power supply lock-down, password, or permanent protection of Security Regions 2 and 3 and pointer region\n• Technology\n- 65-nm floating gate technology\n• Single supply voltage with CMOS I/O\n- 2.7 V to 3.6 V\n• Temperature range / grade\n- Industrial (–40°C to +85°C)\n- Industrial Plus (–40°C to +105°C)\n- Automotive, AEC-Q100 grade 3 (–40°C to +85°C)- Automotive, AEC-Q100 grade 2 (–40°C to +105°C)\n- Automotive, AEC-Q100 grade 1 (–40°C to +125°C)\n• Packages (all Pb-free)\n- 8-lead SOIC 208 mil (SOC008)\n- 16-lead SOIC 300 mil (SO3016)-U S O N  4  \uf0b4 4 mm (UNF008)\n- WSON 5 x 6 mm (WND008)\n- BGA-24 6 \uf0b4 8 mm \n•5  \uf0b4 5 ball (FAB024) footprint\n•4  \uf0b4 6 ball (FAC024) footprint\n- Known good die (KGD) and known tested die\nDatasheet 3 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPerformance summary\nPerformance summary\nTable 1 Maximum read rates SDR\nCommand Clock rate (MHz) MBps\nRead 50 6.25Fast Read 108 13.5Dual Read 108 27Quad Read 108 54\nTable 2 Maximum read rates DDR\nCommand Clock rate (MHz) MBps\n DDR Quad Read 54 54\nTable 3 Typical program and erase rates\nOperation KBps\nPage programming 5694 KB sector erase 6132 KB half block erase 10664 KB block erase 142\nTypical current consumption\nOperation Typical current Unit\nRead 50 MHz 10 mAFast read 5MHz 10 mA\nFast read 10 MHz 10 mA\nFast read 20 MHz 10 mA\nFast read 50 MHz 15 mA\nFast read 108 MHz 20 mA\nQuad I/O / QPI read 108 MHz 20 mA\nQuad I/O / QPI DDR read 33 MHz 15 mA\nQuad I/O / QPI DDR read 54 MHz 17 mA\nProgram 17 mA\nErase 17 mA\nStandby SPI 20 µA\nStandby QPI 35 µA\nDeep power down 2 µA\nDatasheet 4 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTable of contents\nTable of contents\nGeneral description ............................................................................................................ ...............1\nFeatures ....................................................................................................................... ....................1\nPerformance summary ............................................................................................................ ..........3\nTable of contents .............................................................................................................. .................4\n1 Product overview ............................................................................................................. ..............6\n1.1 Migration notes ............................................................................................................ ...........................................6\n2 Connection diagrams .......................................................................................................... ............8\n2.1 SOIC 16-lead............................................................................................................... .............................................8\n2.2 8- Connector packages ...................................................................................................... .....................................8\n2.3 BGA ball footprint ........................................................................................................ ...........................................9\n3 Signal descriptions .......................................................................................................... .............10\n3.1 Serial peripheral interface with multiple input / output  (SPI-MIO) ........................................................ ...........10\n3.2 Input/output summary....................................................................................................... ..................................10\n3.3 Multiple input / output (MIO) .............................................................................................. .................................11\n3.4 Serial Clock (SCK)......................................................................................................... .........................................11\n3.5 Chip Select (CS#).......................................................................................................... .........................................11\n3.6 Serial Input (SI) / IO0.................................................................................................... .........................................11\n3.7 Serial Output (SO) / IO1 ................................................................................................... .....................................12\n3.8 Write Protect (WP#) / IO2.................................................................................................. ....................................12\n3.9 IO3 / RESET#............................................................................................................... ...........................................12\n3.10 RESET#.................................................................................................................... .............................................13\n3.11 Voltage Supply (VCC) ...................................................................................................... ....................................13\n3.12 Supply and Signal Ground (VSS) .........................................................................................................................13\n3.13 Not Connected (NC) ........................................................................................................ ....................................13\n3.14 Reserved for Future Use (RFU) ............................................................................................. ..............................13\n3.15 Do Not Use (DNU).......................................................................................................... ......................................13\n4 Block diagram ................................................................................................................ ..............14\n4.1 System block diagrams ...................................................................................................... ..................................14\n5 Signal protocols............................................................................................................. ...............16\n5.1 SPI clock modes ............................................................................................................ ........................................16\n5.2 Command protocol........................................................................................................... ....................................17\n5.3 Interface states ........................................................................................................... ..........................................22\n5.4 Data protection ............................................................................................................ .........................................26\n6 Address space maps ........................................................................................................... ...........27\n6.1 Overview................................................................................................................... .............................................27\n6.2 Flash memory array ......................................................................................................... .....................................27\n6.3 ID address space ........................................................................................................... ........................................28\n6.4 JEDEC JESD216 serial flash discoverable parameters (SFDP) space ...... ............... ............... ............ ............ .....28\n6.5 Security Regions address space............................................................................................. ..............................28\n6.6 Registers .................................................................................................................. ..............................................29\n7 Data protection .............................................................................................................. ..............46\n7.1 Security Regions ........................................................................................................... ........................................46\n7.2 Deep Power Down............................................................................................................ .....................................46\n7.3 Write Enable commands ...................................................................................................... ................................47\n7.4 Write Protect signal....................................................................................................... ........................................47\n7.5 Status Register Protect (SRP1, SRP0) ....................................................................................... ...........................48\n7.6 Array protection ........................................................................................................... .........................................49\n7.7 Individual and region protection ........................................................................................... ..............................54\n8 Commands ..................................................................................................................... ..............59\n8.1 Command set summary ........................................................................................................ ...............................59\n8.2 Identification commands .................................................................................................... .................................66\nDatasheet 5 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTable of contents\n8.3 Register Access commands ................................................................................................... ...............................69\n8.4 Read Memory Array commands ................................................................................................. ..........................86\n8.5 Program Flash Array commands............................................................................................... ...........................95\n8.6 Erase Flash Array commands............................................................................................................................... ................................. 97\n8.7 Security Regions Array commands ............................................................................................ ........................105\n8.8 Individual Block Lock commands............................................................................................................................... ...................... 107\n8.9 Pointer Region command............................................................................................................................... ..................................... 112\n8.10 Individual and Region Protection (IRP) commands.... ....................................................................... .............113\n8.11 Reset commands ............................................................................................................ ..................................120\n9 Data integrity ............................................................................................................... .............. 124\n9.1 Erase endurance ............................................................................................................ .....................................124\n9.2 Data retention ............................................................................................................. ........................................124\n10 Software interface reference ................................................................................................ ..... 125\n10.1 JEDEC JESD216B serial flas h discoverable parameters .. ............... ............... ............... ............ ............ ..........125\n10.2 Device ID address map ..................................................................................................... ................................133\n10.3 Initial delivery state .................................................................................................... ......................................133\n11 Electrical specifications............................................................................................................................... ....................................... 134\n11.1 Absolute maximum ratings[61]........................................................................................................................... .............................. 134\n11.2 Latchup characteristics ................................................................................................... .................................134\n11.3 Thermal resistance ........................................................................................................ ...................................134\n11.4 Operating ranges .......................................................................................................... ....................................135\n11.5 Power-up and power-down................................................................................................... ...........................136\n11.6 DC characteristics ........................................................................................................ .....................................138\n12 Timing specifications ....................................................................................................... ......... 141\n12.1 Key to switching waveforms................................................................................................ .............................141\n12.2 AC test conditions ........................................................................................................ .....................................141\n12.3 Reset ..................................................................................................................... .............................................142\n12.4 SDR AC characteristics.................................................................................................... ..................................145\n12.5 DDR AC characteristics .................................................................................................... .................................148\n12.6 Embedded algorithm performance tables ..................................................................................... .................150\n13 Ordering information ........................................................................................................ ........ 151\n13.1 Valid combinations — Standard............................................................................................. ..........................152\n13.2 Valid combinations — Automotive grade / AEC-Q100.......................................................................... ...........152\n14 Physical diagrams ........................................................................................................... .......... 153\nRevision history ............................................................................................................... ............. 159\nDatasheet 6 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nProduct overview\n1P r o d u c t  o v e r v i e w\n1.1 Migration notes\n1.1.1 Features comparison\nThe FL064L family is command subset and footprint comp atible with prior generation FL-S, FL1-K and FL-P \nfamilies.\nTable 1 SPI families comparison\nParameter FL-L FL-L FL-S FL1-K FL-P\nTechnology node 65-nm 65-nm 65-nm 90-nm 90-nm \nArchitecture Floating gate Floating gate MIRRORBIT™ Eclipse Floating gate MIRRORBIT™\nRelease date  In production In production In production In production In production Density 64 Mb 256 Mb 128 Mb - 1 Gb 16 Mb - 64 Mb 32 Mb - 256 Mb \nBus width x1, x2, x4 x1, x2, x4 x1, x2, x4 x1, x2, x4 x1, x2, x4 \nSupply voltage 2.7 V - 3.6 V 2.7 V - 3.6 V2.7 V - 3.6 V / 1.65 V - \n3.6 V V\nIO 2.7 V - 3.6 V 2.7 V - 3.6 V \nNormal Read Speed 6 MBps (50 MHz) 6 MBps (50 MHz)  6 MBps (50 MHz) 6 MBps (50 MHz) 5 MBps (40 MHz) \nFast Read Speed 13 MBps \n(108 MHz)16.5 MBps \n(133 MHz) 17 MBps (133 MHz) 13 MBps \n(108 MHz)13 MBps \n(104 MHz) \nDual Read Speed 26 MBps \n(108 MHz)33 MBps\n(133 MHz) 26 MBps (104 MHz) 26 MBps\n(108 MHz)20 MBps \n(80 MHz) \nQuad Read Speed 52 MBps\n(108 MHz)66 MBps\n(133 MHz) 52 MBps (104 MHz) 52 MBps \n(108 MHz)40 MBps \n(80 MHz) \nQuad Read Speed \n(DDR)54 MBps \n(54 MHz) 66 MBps\n(66 MHz) 80 MBps (80 MHz) – –\nProgram buffer size 256 B 256B 256 B / 512 B 256 B 256 B \nErase sector/block size 4 KB / 32 KB / \n64 KB4 KB / 32 KB / \n64 KB64 KB / 256 KB 4 KB / 64 KB 64 KB / 256 KB\nParameter sector size – – 4 KB (option) – 4 KB Sector / block erase \nrate (typ.)61 KB/s (4 KB)\n106 KB/s (32 KB)142 KB/s (64 KB)80 KB/s (4 KB)\n168 KB/s (32 KB)237 KB/s (64 KB)500 KB/s80 KB/s (4 KB)\n128 KB/s (64 KB)130 KB/s\nPage programming \nrate (typ.)569 KB/s (256 B) 854 KB/s (256 B)1.2 MBps (256 B)\n1.5 MBps (512 B) 365 KB/s 170 KB/s\nSecurity Region / OTP 1024 B 1024 B 1024 B 768 B (3 \uf0b4 256 B) 506 B \nIndividual and region \nprotection or advanced sector protection Yes Yes Yes Yes No \nErase suspend/resume Yes Yes Yes Yes No\nProgram \nsuspend/resumeYes Yes Yes Yes No \nOperating temperature–40°C to +85°C \n–40°C to +105°C –40°C to +125°C–40°C to +85°C \n–40°C to +105°C –40°C to +125°C–40°C to +85°C \n–40°C to +105°C–40°C to +85°C \n–40°C to +105°C –40°C to +125°C–40°C to +85°C\n–40°C to +105°C\nNote\n1. Refer to individual datasheets for further details.\nDatasheet 7 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nProduct overview\n1.1.2 Known differences from prior generations\n1.1.2.1 Error reporting\nFL-K, FL1-K and FL-P memories either do not have error st atus bits or do not set them if program or erase is \nattempted on a protected sector. This product family does have error reporting status bits for program and erase operations. These can be set when there is an internal fa ilure to program or erase, or  when there is an attempt \nto program or erase a protected sector. In these cases the program or erase operation did not complete as requested by the command. The P_ERR or E_ERR bits and the WIP bit will be set to and remain 1 in SR1V. The \nClear Status Register command must be sent to clear the errors and return the device to STANDBY state.\n1.1.2.2 Status Register Protect 1 bit\nThe Configuration Register 1 SRP1 bit CR1V[0], locks the state of the Legacy Block Protection bits (SR1NV[5:2] & \nSR1V[5:2]), CMP_NV (CR1NV[6]) and TBPROT_NV bit (SR1NV[6]), as freeze did in prior generations. In the FS-S and FL-S families the Freeze bit also lock s the state of the Configuration Regist er 1 BPNV_O bit (CR1NV[3]), and the \nsecure silicon region (OTP) area. \n1.1.2.3 WRR Single Register Write\nIn some legacy SPI devices, a Write Registers (WRR) co mmand with only one data byte would update Status \nRegister 1 and clear some bits in Configuration Register 1,  including the Quad mode bit. This could result in \nunintended exit from Quad mode. This product family only  updates Status Register 1 when a single data byte is \nprovided. The Configuration Register 1 is not modified in this case.\n1.1.2.4 Other legacy commands not supported\n• Autoboot related commands\n• Bank Address related commands\n• Hold# replaced by the Reset#\n1.1.2.5 New features\nThis product family introduces new features to Infineon SPI category memories:\n• Security Regions password protection\n• IRP individual region protection\nDatasheet 8 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nConnection diagrams\n2 Connection diagrams\n2.1 SOIC 16-lead\nFigure 1 16-lead SOIC package (SO3016), top view\n2.2 8- Connector packages\nFigure 2 8-pin plastic small outline package (SOIC8)\nFigure 3 8-connector package (USON 4 x 4), top SOIC 16NCIO3 / RESET# SCK\nSI / IO01\n2\n31\n41 3141516\nCS#\nSO / IO1 WP# / IO2VSS5\n6\n7\n8VCC\nRESET#\n9101112 NC\nRF\nUDNURF\nU\nDNU\nSOIC 8CS#\nSO / IO1\nWP# /  I O2\nVSSVCC\nIO 3 / RESET#\nSCK\nSI / IO01\n2\n31\n45678\nUSONCS#\nSO / IO1\nWP#  /  I O2\nVSSVCC\nIO 3 / R ESET #\nSCK\nSI / IO02\n31\n4 5678\nDatasheet 9 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nConnection diagrams\nView\nFigure 4 8-connector package (WSON 5 x 6), top view[3]\n2.3 BGA ball footprint \nFigure 5 24-ball BGA, 5 x 5 ball footprint (FAB024), top view[4, 5]\nFigure 6 24-ball BGA, 4 x 6 ball footprint (FAC024), top view[5]WS ONCS#\nSO / IO1\nWP#  /  I O2\nVSSVCC\nIO 3 / R E S E T #\nSCK\nSI / IO02\n31\n4 5678\nNotes\n2. Signal connections are in the same relative positions as  FAC024 BGA, allowing a single PCB footprint to use either\npackage.\n3. The RESET# input has an internal pull-u p and may be left unconnected in the system if Quad mode and hardware reset \nare not in use.\n4. Signal connections are in the same relative positions as  FAC024 BGA, allowing a single PCB footprint to use either \npackage.\n5. The RESET# input has an internal pull-u p and may be left unconnected in the system if Quad mode and hardware reset \nare not in use.12 345\nAA\nB\nC\nDC\nENC NC NC\nNC\nNC\nNC\nNC NC NC NCRESET#\nRFUDNU\nDNU\nDNUSCK VSS VCC\nCS# RFU WP#/IO2\nSO/IO1 SI/IO0\n12 34\nAA\nB\nC\nDC\nENC NC\nNC NC NCRESET#\nRF\nUDNU\nDNU\nDNUSCK VSS VCC\nCS# RFU WP#/I O2\nSO/IO1 SI/IO0IO3/\nRESET#\nF\nNC NC NC NCNC\nDatasheet 10 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal descriptions\n3 Signal descriptions\n3.1 Serial peripheral interface with multiple input / output (SPI-MIO) \nMany memory devices connect to their host system with se parate parallel control, address, and data signals that \nrequire a large number of signal connections and larger package size. The large number of connections increase \npower consumption due to so many signals swit ching and the larger package increases cost.\nThe S25FL-L family reduces the number of signals for connec tion to the host system by serially transferring all \ncontrol, address, and data information over six signals.  This reduces the cost of the memory package, reduces \nsignal switching power, and either reduces the host connection count or frees host connectors for use in \nproviding other features.\nThe S25FL-L family uses the industry standard single bi t SPI and also supports optional extension commands for \ntwo bit (Dual) and four bit (Quad) wide  serial transfers. This multiple width interface is called SPI multi-I/O or \nSPI-MIO.\n3.2 Input/output summary\nTable 2 Signal list \nSignal name Type Description\nRESET# Input Hardware Reset . Low = Device resets and returns to STANDBY state, ready to receive a \ncommand. The signal has an internal pull-up resistor and may be left unconnected in the \nhost system if not used.\nSCK Input Serial Clock\nCS# Input Chip Select\nSI / IO0 I/O Serial Input  for Single Bit Data commands or IO0 for Dual or Quad commands.\nSO / IO1 I/O Serial Output  for Single Bit Data commands. IO1 for Dual or Quad commands.\nWP# / IO2 I/O Write Protect  when not in Quad mode (CR1 V[1] = 0 and SR1NV[7] = 1). \nIO2  when in Quad mode (CR1V[1] = 1). \nThe signal has an internal pull-up resistor an d may be left unconnected in the host system \nif not used for Quad commands or write protection. If write protection is enabled by \nSR1NV[7] = 1 and CR1V[1] = 0, the host system is required to drive WP# HIGH or LOW during a WRR or WRAR command.\nIO3 / RESET# I/O IO3  in Quad I/O mode, when Configuration Register  1 QUAD bit, CR1V[1] = 1, or in QPI mode, \nwhen Configuration Register 2 QPI bit, CR2V[3] = 1 and CS# is LOW. \nRESET#  when enabled by CR2V[7] = 1 and not in Quad I/O mode, CR1V[1] = 0, or when \nenabled in Quad mode, CR1V[1] = 1 and CS# is HIGH. The signal has an internal pull-up resistor an d may be left unconnected in the host system \nif not used for Quad commands or RESET#.\nV\nCC Supply Power Supply\nVSS Supply Ground\nNC Unused Not Connected.  No device internal signal is connected to the package connector nor is there \nany future plan to use the connector for a signal. The connection may safely be used for routing space for a signal on a printed circuit board (PCB). However, any signal connected \nto an NC must not have voltage levels higher than V\nCC. \nNote\n6. Inputs with internal pull-ups or pull-downs drive less than 2 \uf06dA. Only during power-up is the current larger at 150 \uf06dA for \n4 \uf06ds. Resistance of pull-ups or pull-down resistors with  the typical process at Vcc = 3.3 V at –40°C is ~4.5 M \uf057 and at 90°C \nis ~6.6 M\uf057.\nDatasheet 11 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal descriptions\n3.3 Multiple input / output (MIO) \nTraditional SPI single bit wide commands (single or SIO) send information from the host to the memory only on \nthe serial input (SI) signal. Data may be sent back to  the host serially on the serial output (SO) signal.\nDual or Quad Input / Output (I/O) commands send instructions to the memory only on the SI/IO0 signal. Address \nor data is sent from the host to the memory as bit pairs on IO0 and IO1 or four bit (nibble) groups on IO0, IO1, IO2, and IO3. Data is returned to the host similarly as bit pair s on IO0 and IO1 or four bit (nibble) groups on IO0, IO1, \nIO2, and IO3.\nQPI mode transfers all instructions, addresses, and data fr om the host to the memory as  four bit (nibble) groups \non IO0, IO1, IO2, and IO3. Data is returned to the host simi larly as four bit (nibble) grou ps on IO0, IO1, IO2, and IO3.\n3.4 Serial Clock (SCK)\nThis input signal provides the synchr onization reference for the SPI interfac e. Instructions, addresses, or data \ninput are latched on the rising edge of the SCK signal. Da ta output changes after the falling edge of SCK, in SDR \ncommands.\n3.5 Chip Select (CS#)\nThe Chip Select signal indicates when a command is transf erring information to or from the device and the other \nsignals are relevant for the memory device. \nWhen the CS# signal is at the logic HIGH state, the device  is not selected and all input signals are ignored and all \noutput signals are high impedance. The device will be in the Standby Power mode, unless an internal embedded \noperation is in progress. An embedded operation is in dicated by the Status Register 1 Write-In-Progress bit \n(SR1V[0]) set to 1, until the operation is completed. Some  example embedded operations are: program, erase, or \nWrite Registers (WRR) operations. \nDriving the CS# input to the logic LOW state enables th e device, placing it in the Active Power mode. After \npower-up, a falling edge on CS# is required prior to the start of any command.\n3.6 Serial Input (SI) / IO0\nThis input signals used to transfer data serially into the device. It receives instructions, addresses, and data to be programmed. Values are latched on the rising edge of serial SCK clock signal. SI becomes IO0 - an input and \noutput during dual and quad commands for receiving instructions, addresses, and data to be programmed \n(values latched on rising edge of serial SCK clock signal) as well as shifting out data (on the falling edge of SCK, \nin SDR commands, and on every ed ge of SCK, in DDR commands).RFU Reserved Reserved for Future Use.  No device internal signal is currently connected to the package \nconnector but there is potential future use of the connector for a signal. It is recommended \nto not use RFU connectors for PCB routing channe ls so that the PCB may take advantage of \nfuture enhanced features in compatible footprint devices.\nDNU Reserved Do Not Use.  A device internal signal may be connected to the package connector. The \nconnection may be used by Infineon for test  or other purposes and is not intended for \nconnection to any host system signal. Any DNU signal related function will be inactive when \nthe signal is at VIL. The signal has an internal pull-down resistor and may be left unconnected \nin the host system or may be tied to VSS. Do not use these connections for PCB signal routing \nchannels. Do not connect any host system signal to this connection. Table 2 Signal list  (continued)\nSignal name Type Description\nNote\n6. Inputs with internal pull-ups or pull-downs drive less than 2 \uf06dA. Only during power-up is the current larger at 150 \uf06dA for \n4 \uf06ds. Resistance of pull-ups or pull-down resistors with  the typical process at Vcc = 3.3 V at –40°C is ~4.5 M \uf057 and at 90°C \nis ~6.6 M\uf057.\nDatasheet 12 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal descriptions\n3.7 Serial Output (SO) / IO1\nThis output signals used to transfer da ta serially out of the device. Data is shifted out on the falling edge of the \nserial SCK clock signal. SO becomes IO1 - an input and output during Dual and Quad commands for receiving \naddresses, and data to be programmed (values latched on risi ng edge of serial SCK clock signal) as well as shifting \nout data (on the falling edge of SCK in SDR command s, and on every edge of SCK, in DDR commands).\n3.8 Write Protect (WP#) / IO2\nWhen WP# is driven Low (VIL), when the Status Register Protect 0 (SRP 0_NV) or (SRP0) bit of Status Register 1 \n(SR1NV[7]) or (SR1V[7]) is set to a 1, it is not possible to  write to Status Registers, Configuration Registers or DLR \nregisters. In this situation, the command selecting SR 1NV, SR1V, CR1NV,CR1V, CR2NV, CR2V, CR3NV, DLRNV and \nDLRV is ignored, and no error is set.\nThis prevents any alteration of the legacy block protecti on settings. As a consequence, all the data bytes in the \nmemory area that are protected by the legacy block protection feature are also hardware protected against data modification if WP# is Low during commands changing Stat us Registers, Configuration Registers or DLR registers, \nwith SRP0_NV set to 1. Similarly, the Security Region lock bits (LB3-LB0) are protected against programming.\nThe WP# function is not available when the Quad mode  is enabled (CR1V[1] = 1)  or QPI mode is enabled \n(CR2V[3] = 1). The WP# function is replaced by IO2 for input and output during Quad mode or QPI mode is enabled (CR2V[3] = 1) for receiving addresses, and data to be programmed (values are latched on rising edge of the SCK \nsignal) as well as shifting out data on the falling edge of SCK, in SDR commands, and on every edge of SCK, in DDR commands).\nWP# has an internal pull-up resistance; when unconnected, WP# is at V\nIH and may be left unconnected in the host \nsystem if not used for Quad mode or QPI mode or protection.\n3.9 IO3 / RESET#\nIO3 is used for input and output during Quad mode (CR1V[1]  = 1) or QPI mode is enable d (CR2V[3] = 1) for receiving \naddresses, and data to be programmed (values are latched on rising edge of the SCK signal) as well as shifting \nout data (on the falling edge of SCK, in SDR comm ands, and on every edge of SCK, in DDR commands).\nThe IO3 / RESET# input may also be us ed to initiate the hardware reset function when the IO3 / RESET# feature \nis enabled by writing Configuration Register 2 volatile or  non-volatile bit 7 (CR2V[7] = 1)or (CR2NV[7] = 1). The \ninput is only treated as RESET# when the device is no t in Quad modes (114,144,444), CR 1V[1] = 0, or when CS# is \nHIGH. When Quad modes are in use, CR1V[1] = 1or QPI mode  is enabled (CR2V[3] = 1), and the device is selected \nwith CS# LOW, the IO3 / RESET# is used only as IO3 for information transfer. When CS # is HIGH, the IO3 / RESET# \nis not in use for information transfer and is used as th e reset input. By conditioning the reset operation on CS# \nHIGH during Quad modes (114,144,444), the reset functi on remains available duri ng Quad modes (114,144,444). \nWhen the system enters a reset condition, the CS# signal must be driven HIGH as part of the reset process and \nthe IO3 / RESET# signal is driven LOW. When CS# goes HI GH, the IO3 / RESET# input transitions from being IO3 to \nbeing the reset input. The reset condition is then detect ed when CS# remains HIGH and the IO3 / RESET# signal \nremains LOW for tRP. If a reset is not intended, the system is requir ed to actively drive IO3 / RESET# to HIGH along \nwith CS# being driven HIGH at the end of a transfer of da ta to the memory. Following transfers of data to the host \nsystem, the memory will drive IO3 HIGH during tCS. This will ensure that IO3 / RESET# is not left floating or being \npulled slowly to high by the internal or an external passi ve pull-up. Thus, an unintended reset is not triggered by \nthe IO3 / RESET# not being recognized as high before the end of tRP. \nThe IO3 / RESET# input reset feature is disabled when (CR2V[7] = 0).\nThe IO3 / RESET# input has an internal pull-up resistor and may be left unconnected in the host system if not used \nfor Quad mode or the reset function. The internal pull-up will hold IO3 / RESET# HIGH after the host system has \nactively driven the signal high and then stops driving the signal. \nNote that IO3 / RESET# input cannot be shared by more than one SPI-MIO memory if any of them are operating \nin Quad I/O mode as IO3 being driven to or from one selected memory may look like a reset signal to a second non-selected memory sharing th e same IO3 / RESET# signal.\nDatasheet 13 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal descriptions\n3.10 RESET#\nThe RESET# input provides a hardware method of resett ing the device to STANDBY state, ready for receiving a \ncommand. When RESET# is driven to logic LOW (VIL) for at least a period of tRP, the device starts the hardware \nreset process.\nRESET# causes the same initialization process as is performed when power comes up and requires tPU time.\nRESET# may be asserted LOW at any time. To ensure da ta integrity any operation that was interrupted by a \nhardware reset should be reinitiated once the device is ready to accept a command sequence.\nRESET# has an internal pull-up resistor and may be left unconnected in the host system if not used. The internal \npull-up will hold Reset HIGH after the host system has ac tively driven the signal HIGH and then stops driving the \nsignal. \nThe RESET# input is not available on all packages options.  When not available the RESET# input of the device is \ntied to the inactive state.\n3.11 Voltage Supply (VCC)\nVCC is the voltage source for all device internal logic. It is  the single voltage used for all device internal functions \nincluding read, program, and erase.\n3.12 Supply and Signal Ground (VSS)\nVSS is the common voltage drain and ground reference for the device core, input signal receivers, and output \ndrivers.\n3.13 Not Connected (NC)\nNo device internal signal is connected to the package co nnector nor is there any future plan to use the connector \nfor a signal. The connection may safely be used for routing space for a signal on a printed circuit board (PCB).\n3.14 Reserved for Future Use (RFU)\nNo device internal signal is currently connected to the package connector but there is potential future use of the \nconnector. It is recommended to not use RFU connector s for PCB routing channels so that the PCB may take \nadvantage of future enhanced features in compatible footprint devices.\n3.15 Do Not Use (DNU)\nA device internal signal may be connected to the pack age connector. The connection may be used by Infineon \nfor test or other purposes and is not intended for connection to any host system signal. Any DNU signal related function will be inactive when the signal is at V\nIL. The signal has an internal pull- down resistor and may be left \nunconnected in the host system or may be tied to VSS. Do not use these connections for PCB signal routing \nchannels. Do not connect any host system signal to these connections. \nDatasheet 14 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nBlock diagram\n4B l o c k  d i a g r a m\n4.1 System block diagrams\nFigure 7 Bus master and memory devices on the SPI bus - Single bit data path\nFigure 8 Bus master and memory device s on the SPI bus - Dual bit data pathMemory array\nControl \nlogic\nData pathX decodersCS#\nSCK\nSI/IO0\nSO/IO1\nRESET#/IO3WP#/IO2\nRESET#I/OY decoders\nData latch\nRESET#\nWP#\nSI\nSCK\nCS#\nCS#WP#\nSI\nSCK\nCS2#\nCS1#\nSPI\nbus masterSO\nSPI flash SPI flashRESET#\nSO\nRESET#\nWP#\nIO1\nSCK\nCS#\nCS#WP#\nIO1\nSCK\nCS2#\nCS1#\nSPI\nbus masterIO0\nSPI flash SPI flashRESET#\nIO0\nDatasheet 15 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nBlock diagram\nFigure 9 Bus master and memory devices on the SPI bus - Quad bit data path - separate RESET#\nFigure 10 Bus master and memory devices on the SPI bus - Quad bit data path - I/O3 / RESET#RESET#\nIO3\nIO2\nIO1\nSCK\nCS#\nCS#IO3\nIO2\nIO1\nSCK\nCS2#\nCS1#\nSPI\nbus masterIO0\nSPI flash SPI flashRESET#\nIO0\nIO3 / RESET#\nIO2\nIO1\nSCK\nCS#IO3 / RESET#\nIO2IO1\nSCK\nCS#\nSPI\nbus masterIO0\nSPI flashIO0\nDatasheet 16 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5 Signal protocols\n5.1 SPI clock modes\n5.1.1 Single data rate (SDR)\nThe FL-L family can be driven by an embedded micro- controller (bus master) in either of the two following \nclocking modes.\n•Mode 0  with clock polarity (CPOL) = 0 and, clock phase (CPHA) = 0\n•Mode 3  with CPOL = 1 and, CPHA = 1\nFor these two modes, input data into the device is always latched in on the rising edge of the SCK signal and the \noutput data is always available from the falling edge of the SCK clock signal.\nThe difference between the two modes is the clock polari ty when the bus master is in Standby mode and not \ntransferring any data.\n• SCK will stay at logic LOW state with CPOL = 0, CPHA = 0\n• SCK will stay at logic HIGH state with CPOL = 1, CPHA = 1\nFigure 11 SPI SDR modes supported\nTiming diagrams throughout the remainder of the document are generally shown as both Mode 0 and 3 by \nshowing SCK as both HIGH and LOW at the fall of CS#. In some cases, a timing di agram may show only Mode 0 \nwith SCK LOW at the fall of CS#. In such a case, Mode 3 timing simply means clock is HIGH at the fall of CS# so no SCK rising edge set up or hold time to the falling edge of CS# is needed for Mode 3.\nSCK cycles are measured (counted) from one falling edge of  SCK to the next falling edge of SCK. In Mode 0 the \nbeginning of the first SCK cycle in a command is measured fr om the falling edge of CS# to the first falling edge of \nSCK because SCK is already LOW at the beginning of a command.CPOL=0_CPHA=0_SCLK\nCPOL=1_CPHA=1_SCLK\nCS#\nSI_IO0\nSO_IO1MSb\nMSb\nDatasheet 17 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.1.2 Double data rate (DDR)\nMode 0 and Mode 3 are also supported for DDR commands.  In DDR commands, the instruction bits are always \nlatched on the rising edge of clock, the same as in SDR commands. However, the address and input data that \nfollow the instruction are latched on both the rising and fa lling edges of SCK. The first address bit is latched on \nthe first rising edge of SCK following the falling edge at th e end of the last instruction bit. The first bit of output \ndata is driven on the falling edge at the end of the last access latency (dummy) cycle.\nSCK cycles are measured (counted) in the same way as in SDR commands, from one falling edge of SCK to the \nnext falling edge of SCK. In Mode 0 the beginning of the first SCK cycle in a command is measured from the falling \nedge of CS# to the first falling edge of SCK becaus e SCK is already low at the beginning of a command.\nFigure 12 SPI DDR modes supported\n5.2 Command protocol\nAll communication between the host system and FL-L fami ly memory devices is in the form of units called \ncommands. See "Commands" on page 59 for definition and details for all commands. \nAll commands begin with an 8-bit instruction that selects th e type of information transfer or device operation to \nbe performed. Commands may also have an address, inst ruction modifier, latency period, data transfer to the \nmemory, or data transfer from the memory. All instruction, address, and data information is transferred sequen-tially between the host system and memory device. \nCommand protocols are also classified by a numerica l nomenclature using three numbers to reference the \ntransfer width of three command phases: \n• instruction; • address and instruction modifier (Continuous Read mode bits); \n•d a t a .  \nSingle bit wide commands start with an  instruction and may provide an addres s or data, all sent only on the SI \nsignal. Data may be sent back to the host serially on the SO signal. This is referenced as a 1-1-1 command protocol \nfor single bit width instruction, single bit width address and modifier, single bit data.\nDual-output or quad-output commands provide an address sent from the host as serial on SI (IO0) then followed \nby dummy cycles. Data is returned to the host as bit pairs on IO0 and IO1 or, four bit (nibble) groups on IO0, IO1, IO2, and IO3. This is referenced as 1-1-2 fo r Dual-O and 1-1-4 for Quad-O command protocols.\nDual or quad input / output (I/O) commands provide an address sent from the host as bit pairs on IO0 and IO1 or, \nfour bit (nibble) groups on IO0, IO1,  IO2, and IO3 then followed by dummy cy cles. Data is returned to the host \nsimilarly as bit pairs on IO0 and IO1 or, four bit (nibble) gro ups on IO0, IO1, IO2, and IO3.  This is referenced as 1-2-2 \nfor dual I/O and 1-4-4 for quad I/O command protocols.\nThe FL-L family also supports a QPI mode in which all in formation is transferred in 4 bit width, including the \ninstruction, address, modifier, and data. This is referenced as a 4-4-4 command protocol.CPOL=0_CPHA=0_SCLK\nCPOL=1_CPHA=1_SCLK\nCS#\nTransfer_Phase\nIO0\nIO1IO2IO3Inst. 7 Inst. 0 A28 A24 A0M4M0 DLP. DLP.D0D1\nA29 A25 A1M5M1 DLP. DLP.D0D1\nA30 A26 A2M6M2 DLP. DLP.D0D1\nA31 A27 A3M7M3 DLP. DLP.D0D1          Dummy / DLP Address Mode Instruction\nDatasheet 18 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\nCommands are structured as follows:\n• Each command begins with CS# going LOW and ends with  CS# returning HIGH. The memory device is selected \nby the host driving the Chip Select (CS#) signal LOW throughout a command. \n• The serial clock (SCK) marks the transfer of each bit or group of bits between the host and memory.\n• Each command begins with an eight bit (byte) instruct ion. The instruction selects the type of information \ntransfer or device operation to be performed. The inst ruction transfers occur on SC K rising edges. However, \nsome Read commands are modified by a prior Read comma nd, such that the instruct ion is implied from the \nearlier command. This is called Co ntinuous Read mode. When the device is in Continuous Read mode, the \ninstruction bits are not transmitted at the beginning of  the command because the instruction is the same as \nthe Read command that initiated the Continuous Read  mode. In Continuous Read mode the command will \nbegin with the read address. Thus, Continuous Read mode removes eight instruction bits from each Read \ncommand in a series of same type Read commands.\n• The instruction may be stand alone or may be followed by address bits to select a location within one of several \naddress spaces in the device. The instruction determines  the address space used. Th e address may be either a \n24-bit or a 32-bit, byte boundary, ad dress. The address transfers occur on  SCK rising edge, in SDR commands, \nor on every SCK edge, in DDR commands.\n• In legacy SPI mode, the width of all transfers following the instruction are determined by the instruction sent. \nFollowing transfers may continue to be single bit serial on only the SI or Serial Output (SO) signals, they may be \ndone in two bit groups per (dual) transfer on the IO0 an d IO1 signals, or they may be done in 4 bit groups per \n(quad) transfer on the IO0-IO3 signals.  Within the dual or quad groups the least significant bit is on IO0. More \nsignificant bits are placed in significance order on each  higher numbered IO signal. Single bits or parallel bit \ngroups are transferred in most to least significant bit order.\n• In QPI mode, the width of all transfers is a 4 bi t wide (Quad) transfer on the IO0-IO3 signals.\n• Dual and quad I/O read instructions se nd an instruction modifier called Continuous Read mode bits, following \nthe address, to indicate whether the next command will be of the same type with an implied, rather than an explicit, instruction. These mode bits initiate or end the Continuous Read mode. In Continuous Read mode, the \nnext command thus does not provide an instruction byte, only a new address and mode bits. This reduces the \ntime needed to send each command when the same co mmand type is repeated in a sequence of commands. \nThe mode bit transfers occur on SCK rising edge, in SDR commands, or on every SCK edge, in DDR commands.\n• The address or mode bits may be followed by write data to be stored in the memory device or by a read latency \nperiod before read data is returned to the host. \n• Write data bit transfers occur on SCK rising edge, in  SDR commands, or on every SCK edge, in DDR commands.\n• SCK continues to toggle during any read access latency period. The latency may be zero to several SCK cycles \n(also referred to as dummy cycles). At the end of the read latency cycles, the first read data bits are driven from the outputs on SCK falling edge at the end of the last read  latency cycle. The first read data bits are considered \ntransferred to the host on the following SCK rising edge. Each following transfer occurs on the next SCK rising \nedge, in SDR commands, or on every SCK edge, in DDR commands.\n• If the command returns read data to the host, the device  continues sending data transfers until the host takes \nthe CS# signal HIGH. The CS# signal can be driven HIGH af ter any transfer in the read  data sequence. This will \nterminate the command.\n• At the end of a command that does not return data, the host drives the CS# input HI GH. The CS# signal must go \nHIGH after the eighth bit, of a stand alone instruction or, of  the last write data byte that is transferred. That is, \nthe CS# signal must be driven HIGH when the number of bits after the CS # signal was driven LOW is an exact \nmultiple of eight bits. If the CS# sign al does not go HIGH exactly at the ei ght bit boundary of the instruction or \nwrite data, the command is rejected and not executed. \n• All instruction, address, and mode bits are shifted into th e device with the most significant bits (MSb) first. The \ndata bits are shifted in and out of the device MSb first. All data is transferred in byte units with the lowest address \nbyte sent first. Following bytes of data are sent in lo west to highest byte address order i.e. the byte address \nincrements.\n• All attempts to read the flash memory array during a pr ogram, erase, or a write cycle (embedded operations) \nare ignored. The embedded operation will continue to execute without any affect. A very limited set of \ncommands are accepted during an embedded operatio n. These are discussed in the individual command \ndescriptions.\n• Depending on the command, the time for execution vari es. A command to read status information from an \nexecuting command is available to determine when the command completes execution and whether the \ncommand was successful.\nDatasheet 19 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.2.1 Command sequence examples\nFigure 13 Standalone Instruction command\nFigure 14 Single Bit Wide Input command\nFigure 15 Single Bit Wide Ou tput command without latency\nFigure 16 Single Bit Wide I/O command with latency\nFigure 17 Dual Output Read commandCS#\nSCK\nSI_IO0\nSO_IO1-IO3\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nSO_IO1-IO3\nSO\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Input Data\nCS#\nSCLK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\n7 6 5 43 2 1 0 7 6 5 4 3 2 1 0\nInstruction Data 1 Data 2\nCS#\nSCLK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n76543210 \nInstruction          Address Dummy Cycles Data 1\nCS#\nSCK\nIO0\nIO1\nPhase7654321031 10 64206420\n75317531\nInstruction Address Dummy Cycles Data 1 Data 2\nDatasheet 20 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\nFigure 18 Quad Output Read command\nFigure 19 Dual I/O command\nFigure 20 Quad I/O command[7]\nFigure 21 Quad I/O Read command in QPI mode[7] CS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                                              \n7654321031 10 40404040404\n51515151515\n62626262626\n73737373737\nInstruction Address Dummy D1 D2 D3 D4 D5\nCS#\nSCK\nIO0IO1\nPhase \n                                                      \n7654321030  206420 64206420 \n31  317531 75317531 \nInstruction Address Mode Dum Data 1 Data 2\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                                     \n7654321028  4040 40404040 \n29  5151 51515151 \n30  6262 62626262 \n31  7373 73737373 \nInstruction            Address Mode      Dummy D1 D2 D3 D4\nNote\n7. The gray bits are optional, the host does not have to drive bits during that cycle.CS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                         \n4 028  4 0 4 0 4 0 4 0 4 0 4 0  \n5 129  5 1 5 1 5 1 5 1 5 1 5 1  \n6 230  6 2 6 2 6 2 6 2 6 2 6 2  \n7 331  7 3 7 3 7 3 7 3 7 3 7 3  \nInstruct.                Address Mode Dummy D1 D2 D3 D4\nDatasheet 21 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n1.\nFigure 22 DDR Quad I/O Read command\nFigure 23 DDR Quad I/O Read command QPI mode\nAdditional sequence diagrams, specific  to each command, are provided in "Commands" on page 59.CS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                          \n7 6 5 4 3 2 1 0A-3 84040 765432104040\nA-2 95151 765432105151\nA-1 26262 765432106262\nA 37373 765432107373\nInstruction       Address Mode Dummy DLP D1 D2\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                             \n4 0 A-3 84040 765432104040\n5 1 A-2 95151 765432105151\n6 2 A-1 26262 765432106262\n7 3 A 37373 765432107373\nInstruct.   Address Mode Dummy DLP D1 D2\nDatasheet 22 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.3 Interface states\nThis section describes the input and output signal levels as related to the SPI interface behavior.\nLegend\nZ = No driver - floating signal\nHL = Host driving VIL\nHH = Host driving VIH\nHV = Either HL or HHX = HL or HH or ZHT = Toggling between HL and HH\nML = Memory driving V\nIL\nMH = Memory driving VIH\nMV = Either ML or MHTable 3 Interface states summary  \nInterface state VCC SCK CS# RESET#IO3 / RE-\nSET#WP# / \nIO2SO / IO1 SI / IO0\nPower-Off <VCC (low) X X X X X Z X\nLow Power \nHardware Data Protection<VCC (cut-off) X X X X X Z X\nPower-On (cold) Reset ≥VCC (min) X HH X X X Z X\nHardware (warm) Reset Non-Quad \nmode≥VCC (min) X X HL HL X Z X\nHardware (warm) Reset Quad mode ≥VCC (min) X HH HL HL X Z X\nInterface Standby ≥VCC (min) X HH HH HH X Z X\nInstruction Cycle (Legacy SPI) ≥VCC (min) HT HL HH HH HV Z HV\nSingle Input Cycle\nHost to Memory Transfer≥VCC (min) HT HL HH HH X Z HV\nSingle Latency (dummy) cycle ≥VCC (min) HT HL HH HH X Z X\nSingle Output Cycle\nMemory to Host Transfer≥VCC (min) HT HL HH HH X MV X\nDual Input Cycle\nHost to Memory Transfer≥VCC (min) HT HL HH HH X HV HV\nDual Latency (dummy) Cycle ≥VCC (min) HT HL HH HH X X X\nDual Output Cycle\nMemory to Host Transfer≥VCC (min) HT HL HH HH X MV MV\nQuad Input Cycle\nHost to Memory Transfer≥VCC (min) HT HL HH HV HV HV HV\nQuad Latency (dummy) cycle ≥VCC (min) HT HL HH X X X X\nQuad Output Cycle\nMemory to Host Transfer≥VCC (min) HT HL HH MV MV MV MV\nDDR Quad Input Cycle\nHost to Memory Transfer≥VCC (min) HT HL HH HV HV HV HV\nDDR Latency (dummy) cycle ≥VCC (min) HT HL HH X X X X\nDDR Quad Output Cycle\nMemory to Host Transfer≥VCC (min) HT HL HH MV MV MV MV\nDatasheet 23 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.3.1 Power-off\nWhen the core supply voltage is at or below the VCC (Low)  voltage, the device is considered to be powered off. The \ndevice does not react to external signals, and is prev ented from performing any program or erase operation. \n5.3.2 Low power hardware data protection\nWhen VCC is less than VCC (ut-off),  the memory device will ignore comma nds to ensure that program and erase \noperations can not start when the core supply voltage is out of the operating range. When the core voltage supply \nremains at or below the VCC (Low)  voltage for ≥ tPD time, then rises to ≥ VCC (Minimum)  the device will begin its Power \nOn Reset (POR) process. POR continues until the end of tPU. During tPU the device does not react to external input \nsignals nor drive any outputs. Following the end of tPU the device transitions to the Interface Standby state and \ncan accept commands. For additional information on POR see "Power-on (cold) reset" on page 142 .\n5.3.3 Hardware (warm) reset\nA configuration option is provided to allow IO3 / RESET# to be used as a hardware reset input when the device is \nnot in any quad or QPI mode or when it is in any quad mode or QPI mode and CS# is HIGH. In quad or QPI mode \non some packages a separate reset input is provided (RES ET #). When IO3 / RESET# or RESET# is driven LOW for \ntRP time the device starts the hardware reset process. The process continues for tRPH time. Following the end of \nboth tRPH and the reset hold time following the rise of RESET# (tRH) the device transitions to the Interface \nSTANDBY state and can accept commands. For additional information on hardware reset see "Reset" on page \n142.\n5.3.4 Interface standby\nWhen CS# is HIGH, the SPI interface is in STANDBY stat e. Inputs other than RESET# are ignored. The interface \nwaits for the beginning of a new command. The next inte rface state is Instruction Cycle when CS# goes LOW to \nbegin a new command. \nWhile in interface STANDBY state the me mory device draws standby current (ISB) if no embedded algorithm is in \nprogress. If an embedded algorithm is in progress, the related current is drawn until the end of the algorithm \nwhen the entire device retu rns to standby current draw.\n5.3.5 Instruction cycle (Legacy SPI mode)\nWhen the host drives the MSb of an instruction and CS# goes LOW, on the next rising edge of SCK the device \ncaptures the MSb of the instruction that begins the ne w command. On each following rising edge of SCK the \ndevice captures the next lower significance bit of the 8 bit instruction. The host keeps CS# LOW, and drives the \nWrite Protect (WP#) and IO3 / RESET# signals as needed fo r the instruction. However, WP# is only relevant during \ninstruction cycles of a WRR or WRAR command or any other commands which affect Status registers, \nConfiguration Registers and DLR Registers, and is other wise  ignored. IO3 / RESET# is driven HIGH when the device \nis not in Quad mode (CR1V[1] = 0) or QPI mode (CR2V[3] = 0) and hardware reset is not required.\nEach instruction selects the address space that is operat ed on and the transfer form at used during the remainder \nof the command. The transfer format may be Single, Dual O, Quad O, Dual I/O, or Quad I/O, or DDR Quad I/O. The expected next interface state depends on the instruction received.\nSome commands are stand alone, needing no address or da ta transfer to or from the memory. The host returns \nCS# HIGH after the rising edge of SCK for the eighth bit of the instruction in such commands. The next interface \nstate in this case is Interface Standby.\nDatasheet 24 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.3.6 Instruction cycle (QPI mode)\nIn QPI mode, when CR2V[3] = 1, instructions are transferre d 4 bits per cycle. In this mode, instruction cycles are \nthe same as a quad input cycle. See "QPP or QOR address input cycle" on page 25.\n5.3.7 Single input cycle - Host to Memory transfer\nSeveral commands transfer information af ter the instruction on the single serial input (SI) signal from host to the \nmemory device. The host keeps RESET# HIGH, CS# LOW, and drives SI as needed for the command. The memory \ndoes not drive the serial output (SO) signal.\nThe expected next interface state depends on the instru ction. Some instructions continue sending address or \ndata to the memory using additional single input cycles. Ot hers may transition to single latency, or directly to \nsingle, dual, or quad output cycle states.\n5.3.8 Single latency (dummy) cycle\nRead commands may have zero to several latency cycles during which read data is read from the main Flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the Latency Code in \nthe Configuration Register (CR3V[3:0]).  During the latency cycles, the host keeps RESET# and IO3 / RESET# HIGH, \nCS# LOW and SCK toggles. The write protect (WP#) signal is ignored. The host may drive the SI signal during these \ncycles or the host may leave SI floating. The memory do es not use any data driven on SO or other I/O signals \nduring the latency cycles. The memory do es not drive the serial output (SO)  or I/O signals during the latency \ncycles.\nThe next interface state depends on the command structur e i.e. the number of latency cycles, and whether the \nread is single, dual, or quad width.\n5.3.9 Single output cycle - Memory to Host transfer\nSeveral commands transfer information back to the host on  the single serial output (SO) signal. The host keeps \nRESET# and IO3 / RESET# HIGH, CS# LOW. The write protect (WP#) signal is ignored. The memory ignores the serial input (SI) signal. The memory drives SO with data.\nThe next interface state continues to be Single output  Cycle until the host returns CS# to HIGH ending the \ncommand.\n5.3.10 Dual input cycle - Host to Memory transfer\nThe read dual I/O command transfers two address or mode  bits to the memory in each cycle. The host keeps \nRESET# and IO3 / RESET# HIGH, CS# LOW. The write protec t (WP#) signal is ignored. The host drives address on \nS I/I O 0  a n d  S O/I O 1 .  \nThe next interface state following the delivery of address an d mode bits is a dual latency cycle if there are latency \ncycles needed or dual output cy cle if no latency is required.\n5.3.11 Dual latency (dummy) cycle\nRead commands may have zero to several latency cycles during which read data is read from the main Flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the latency code in \nthe Configuration Register (CR3V[3:0]).  During the latency cycles, the host keeps RESET# and IO3 / RESET# HIGH, \nCS# LOW, and SCK continues to toggle. The write protect (WP#) signal is ignored. The host may drive the SI / IO0 and SO / IO1 signals during these cycles or the host may leave SI / IO0 and SO / IO1 floating. The memory does not use any data driven on SI / IO0 and SO / IO1 during th e latency cycles. The host must stop driving SI / IO0 and \nSO / IO1 on the falling edge of SCK at th e end of the last latency cycle. It is recommended that the host stop driving \nthem during all latency cycles so that there is sufficient time for the host drivers to turn off before the memory \nbegins to drive at the end of the latency cycles. This pr events driver conflict between host and memory when the \nsignal direction changes. The memory does not drive th e SI / IO0 and SO / IO1 signals during the latency cycles.\nThe next interface state following the last latency cycle is a dual output cycle.\nDatasheet 25 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.3.12 Dual output cycle - Memory to Host transfer\nThe read dual output and read dual I/O return data to the host two bits in each cycle. The host keeps RESET# and \nIO3 / RESET# HIGH, CS# LOW. The write protect (WP#) signal  is ignored. The memory drives data on the SI / IO0 \nand SO / IO1 signals during the dual output  cycles on the falling edge of SCK.\nThe next interface state continues to be dual output cycle until the host return s CS# to HIGH ending the \ncommand.\n5.3.13 QPP or QOR address input cycle\nThe Quad Page Program and Quad Output Read commands send address to the memory only on IO0. The other \nIO signals are ignored. The host keeps RESET# and IO3 / RESET# HIGH, CS# LOW, and drives IO0.\nFor QPP the next interface state following the delivery of address is the quad input cycle. For QOR the next \ninterface state following address is a quad latency cycle if there are latency cycles needed or quad output cycle \nif no latency is required.\n5.3.14 Quad input cycle - Host to Memory transfer\nThe Quad I/O Read command transfers four address or mode bits to the memory in each cycle. In QPI mode, the Quad I/O Read and Page Program commands transfer four da ta bits to the memory in each cycle, including the \ninstruction cycles. The host keeps CS # LOW, and drives the IO signals.\nFor Quad I/O Read, the next interface state following the de livery of address and mode bits is a quad latency cycle \nif there are latency cycles needed or quad output cycle if no latency is required. For QPI mode page program, the \nhost returns CS# HIGH following the delivery of data to be programmed and the interface returns to STANDBY \nstate.\n5.3.15 Quad latency (dummy) cycle\nRead commands may have zero to several latency cycles during which read data is read from the main flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the latency code in \nthe Configuration Register (CR3V[3:0]). During the latenc y cycles, the host keeps CS# LOW and continues to toggle \nSCK. The host may drive the IO signals during these cycles or the host may le ave the IO floating. The memory does \nnot use any data driven on IO during the latency cycles. The host must stop driving the IO signals on the falling \nedge at the end of the last latency cycle. It is recomm ended that the host stop driv ing them during all latency \ncycles so that there is sufficient time  for the host drivers to turn off before the memory begins to drive at the end \nof the latency cycles. This prevents dr iver conflict between host and memory  when the signal direction changes. \nThe memory does not drive the IO signals during the latency cycles.\nThe next interface state following the last latency cycle is a quad output cycle.\n5.3.16 Quad output cycle - Memory to Host transfer\nThe Quad-O and Quad I/O Read returns data to the host four bits in each cycle. The host keeps CS# LOW. The \nmemory drives data on IO0-IO3 signals during the quad output cycles.\nThe next interface state continues to be quad output cycle until the host returns CS# to HIGH ending the \ncommand.\n5.3.17 DDR quad input cycle - Host to Memory transfer\nThe DDR Quad I/O Read command sends ad dress, and mode bits to the memory on all the IO signals. Four bits \nare transferred on the rising edge of SCK and four bits on  the falling edge in each cy cle. The host keeps CS# LOW.\nThe next interface state following the delivery of address and mode bits is a DDR latency cycle.\nDatasheet 26 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSignal protocols\n5.3.18 DDR latency cycle\nDDR Read commands may have one to several latency cycles during which read data is read from the main flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the latency code in \nthe Configuration Register (CR3V[3:0]). During the latenc y cycles, the host keeps CS# LOW. The host may not drive \nthe IO signals during these cycles. So that there is sufficie nt time for the host drivers to turn off before the memory \nbegins to drive. This prevents driver conflict between host and memory when the signal direction changes. The \nmemory has an option to drive all the IO signals with a Data Learning Pattern (DLP) during the last 4 latency \ncycles. The DLP option should not be enabled when there ar e fewer than five latency cycles so that there is at \nleast one cycle of high impedance for turn around of the IO signals before  the memory begins driving the DLP . \nWhen there are more than 4 cycles of latency the memory does not drive the IO signals until the last four cycles \nof latency.\nThe next interface state following the last latency cycle is  a DDR quad output cycle, depending on the instruction.\n5.3.19 DDR quad output cycle - Memory to Host transfer\nThe DDR quad I/O read command returns bits to the host on  all the IO signals. Four bits are transferred on the \nrising edge of SCK and four bits on the fallin g edge in each cycle. The host keeps CS# LOW.\nThe next interface state continues to be DDR quad output  cycle until the host return s CS# to HIGH ending the \ncommand.\n5.4 Data protection\nSome basic protection against unintended changes to st ored data are provided and controlled purely by the \nhardware design. These are described below. Other software managed protection methods are discussed in the software section of this document.\n5.4.1 Power-up\nWhen the core supply voltage is at or below the VCC (Low)  voltage, the device is considered to be powered off. The \ndevice does not react to external signals, and is prevented from performing any program or erase operation. User is not allowed to enter any valid command during tPU.\n5.4.2 Low power\nWhen VCC is less than VCC (Cut-off)  the memory device will ignore commands to ensure that program and erase \noperations can not start when the core supp ly voltage is out of the operating range.\n5.4.3 Clock pulse count\nThe device verifies that all data modifying commands consis t of a clock pulse count that is a multiple of eight bit \ntransfers (byte boundary) before executing them. A command  not ending on an 8 bit (byte) boundary is ignored \nand no error status is set for the command. \n5.4.4 Deep power down (DPD)\nIn DPD mode the device responds only to the Resume from DPD command (RES ABh). All other commands are ignored during DPD mode, thereby protecting the memo ry from program and erase operations. If the IO3 / \nRESET# function has been enabled (CR2 V[7] = 1) or if RESET# is active, IO3 / RESET# or RESET# going LOW will \nstart a hardware reset and release the device from DPD mode. \nDatasheet 27 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6 Address space maps\n6.1 Overview\n6.1.1 Extended address\nThe FL-L family supports 32-bit (4-byte) addresses to en able higher density devices than allowed by previous \ngeneration (legacy) SPI devices that supported only 24-bi t (3-byte) addresses. A 24-bit, byte resolution, address \ncan access only 16 MB (128 Mb) maximum density. A 32-bit, byte resolution, address allows direct addressing of \nup to a 4 GB (32 Gb) address space.\nLegacy commands continue to support 24-bit addresses fo r backward software compatibility. Extended 32-bit \naddresses are enabled in two ways:\n• Extended address mode — a volatile Configuration Regi ster bit that changes all legacy commands to expect \n32-bits of address supplied from the host system.\n• 4-byte address commands — that perform both legacy and new functions, which always expect 32-bit address.\nThe default condition for extended addr ess mode, after power-up or reset, is controlled by a non-volatile config-\nuration bit. The default extended address mode may be set for 24- or 32-bit addresses. This enables legacy \nsoftware compatible access to the first 128 Mb of a device or  for the device to start directly in 32-bit address mode. \n6.1.2 Multiple address spaces\nMany commands operate on the ma in Flash memory array. Some commands operate on address spaces \nseparate from the main Flash array. Each separate addr ess space uses the full 24- or  32-bit address but may only \ndefine a small portion of the available address space. \n6.2 Flash memory array\nThe main Flash array is divided into uniform erase units called physical blocks (64 KB), half blocks (32 KB) and \nsectors (4 KB). \nTable 4 S25FL064L sector address map\nBlock \nsize (KB) Block \ncount Block \nrangeHalf block \nsize (KB) Half \nblock \ncount Half \nblock \nrangeSector \nsize (KB) Sector \ncount Sector \nrange Address \nrange (byte \naddress) Notes \n64 1 BA0032 1 HBA00 4 1 SA00 0000000h-\n0000FFFh \nSector \nstarting \naddress\n—\nSector \nending \naddress:: : : : :  :  \n32 2 HBA01 4 16 SA15000F000h-\n000FFFFh \n:: : : : : : :: :\n64  128 BA12732 255 HBA254 4 2032 SA203107F0000h-\n07F0FFFh \n:: : : : : :\n32 256 HBA255 4 2048 SA204707FF000h-\n07FFFFFh \nDatasheet 28 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.3 ID address space\nThe RDID command (9Fh) reads information from a separate flash memory address space for device\nidentification (ID). See "Device ID address map" on page 133 for the tables defining the contents of the ID \naddress space. The ID address space is programmed  by Infineon and read-only for the host system.\n6.3.1 Device Unique ID\nA 64-bit unique number is located in 8-bytes of the unique device ID address space see Table 44 . This Unique ID \nmay be used as a software readable serial  number that is unique for each device.\n6.4 JEDEC JESD216 serial flash disc overable parameters (SFDP) space\nThe RSFDP command (5Ah) reads information from a separate flash memory address space for device \nidentification, feature, and configuration information, in  accord with the JEDEC JESD216 standard for serial flash \ndiscoverable parameters. The ID address space is incorporated as one of the SFDP parameters. See " JEDEC \nJESD216B serial flash discoverable parameters" on page 125 for the tables defi ning the contents of the SFDP \naddress space. The SFDP address space is programmed by Infineon and read-only for the host system.\n6.5 Security Regions address space\nEach FL-L family memory device has a 1024-byte Security Regions address space that is  separate from the main \nflash array. The Security Regions area is divided into 4, individually lockable 256- byte regions. The Security \nRegions memory space is intended to hold information th at can be temporarily protected or permanently locked \nfrom further program or erase. \nThe regions data bytes are erased to FFh when ship ped from Infineon. The regions may be programmed and \nerased like any other flash memory address space when no t protected or locked. Each region can be individually \nerased. The Security Region lock bits (CR1NV[5:2]) are loca ted in the Configuration Register 1. The Security Region \nlock bits are one time programmable (OTP) and after being programmed (set to 1) a lock bit permanently protects the related region from further erase or programming. \nRegions 2 and 3 also have temporary protection from prog ram or erase by the Protection Register (PR) NVLock \nbit. The NVLock bit is volatile and set or  cleared by the IRP logic and commands. See "Protection Register (PR)" \non page 44. \nThe Security Region Password Protection bit in the IRP Register (IRP[2]) allows Regions 2 and 3 to be protected \nfrom program and erase operations until a password is pr ovided. The Security Region Read Protection bit in the \nIRP Register (IRP[6]) allows region 3 to also be prot ected from read operations until a password is provided. \nAttempting to read in a region, that is protected from read, returns invalid and undefined data. See "Individual \nand Region Protection Register (IRP)" on page 42.\nAttempting to erase or program in a region that is lock ed or protected will fail with the P_ERR or E_ERR bit in \nSR2V[6:5] set to ’1’ . (see "Status Register 2 Volatile (SR2V)" on page 32 for detail descriptions). \nTable 5 Security Region address map\nRegion Byte address range (hex) Initial delivery state (hex)\nRegion 0 000 to 0FF All bytes = FF\nRegion 1 100 to 1FF All bytes = FF\nRegion 2 200 to 2FF All bytes = FFRegion 3 300 to 3FF All bytes = FF\nDatasheet 29 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6 Registers\nRegisters are small groups of memory cells used to config ure how the FL-L family memory device operates or to \nreport the status of device operations. The register s are accessed by specific commands. The commands (and \nhexadecimal instruction codes) used for each re gister are noted in each register description.\nIn legacy SPI memory devices the individual register bits could be a mixture of volatile, non-volatile, or one time \nprogrammable (OTP) bits within the same register. In some  configuration options the type of a register bit could \nchange e.g. from non-volatile to volatile. \nThe FL-L family uses separate non-volatile or volatile memory cell groups (areas) to implement the different \nregister bit types. However, the legacy registers and commands continue to appear and behave as they always have for legacy software compatibility. There is a non-vola tile and a volatile version of each legacy register when \nthat legacy register has volatile bits or when the command to read the legacy register has zero read latency. When such a register is read the volatile version of the register is delivered. During power-on reset (POR), hardware reset, or software reset, the non-volatile version of a re gister is copied to the volatile version to provide the \ndefault state of the volatile register. When Non-volatile Register bits are written the non-volatile version of the \nregister is erased and programmed with the new bit values and the volatile version of the register is updated with \nthe new contents of the non-volatile version. When OT P bits are programmed the non-volatile version of the \nregister is programmed and the appropriat e bits are updated in the volatile version of the register. When Volatile \nregister bits are written, only the volatile versio n of the register has the appropriate bits updated.\nThe type for each bit is noted in each register descriptio n. The default state shown for each bit refers to the state \nafter power-on reset, hardware reset, or software reset if the bit is volatile. If the bit is non-volatile or OTP, the \ndefault state is the value of the bit when the device is  shipped from Infineon. Special attention must be given \nwhen writing the non-volatile registers that there is a stab le power supply with no disruption, this will guarantee \nthe correct data is written to the register\n. \nTable 6 Register description\nRegister Type Bits Abbreviation\nStatus Register 1 Non-volatile 7:0 SR1NV[7:0]\nVolatile 7:0 SR1V[7:0]\nStatus Register 1 Volatile 7:0 SR2V[7:0]\nConfiguration Register 1 Non-volatile/OTP 7:0 CR1NV[7:0]\nVolatile 7:0 CR1V[7:0]\nConfiguration Register 2 N on-volatile 7:0 CR2NV[7:0]\nVolatile 7:0 CR2V[7:0]\nConfiguration Register 3 N on-volatile 7:0 CR3NV[7:0]\nVolatile 7:0 CR3V[7:0]\nIndividual and Region Protection Register OTP 15:0 IRP[15:0]Password Register OTP 63:0 PASS[63:0]\nIndividual Block Lock Access Register Volatile 7:0 IBLAR[7:0]\nPointer Region Protection Register Non-volatile 31:0 PRPR[31:0]DDR Data Learning Registers OTP 7:0 DLRNV[7:0]\nVolatile 7:0 DLRV[7:0]\nDatasheet 30 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.1 Status Register 1\n6.6.1.1 Status Register 1 Non-volatile (SR1NV) \nRelated Commands: Non-volatile Write Enable (WREN 06h), Write Disable (WRD I 04h), Write Registers (WRR 01h), \nRead Any Register (RDAR 65h), Write Any Register (WRAR 71h)\nStatus Register Protect Non-volatile (SRP0_NV) SR1NV[7] : Provides the default state for SRP0. See "Status \nRegister Protect (SRP1, SRP0)" on page 48.\nSector / block protect (SEC_NV) SR1NV[6] : Provides the default state for SEC.\nThe type for each bit is noted in each register descriptio n. The default state shown for each bit refers to the state \nafter power-on reset, hardware reset, or software reset if the bit is volatile. If the bit is non-volatile or OTP, the \ndefault state is the value of the bit when the device is  shipped from Infineon. Special attention must be given \nwhen writing the non-volatile registers that there is a stab le power supply with no disruption, this will guarantee \nthe correct data is written to the register . \nTop or Bottom Protection (TBPROT_NV) SR1NV[5]:  Provides the default state for TBPROT . \nLegacy Block Protection (BP_NV3, BP_NV2, BP_NV1, BP_NV0) SR1NV[4:2] : Provides the default state for BP_2 \nto BP_0 bits. \nWrite Enable Latch Default (WEL_D) SR1NV[1] : Provides the default state for the WEL Status in SR1V[1]. This bit \nis programmed by Infineon and is not user programmable.\nWrite in Progress Default (WIP_D) SR1NV[0] : Provides the default state for the WIP Status in SR1V[0]. This bit is \nprogrammed by Infineon and is not user programmable.Table 7 Status Register 1 Non-volatile (SR1NV) \nBits Field name Function Type Default \nstate Description \n7 SRP0_NV Status Register \nProtect 0 Default Non-volatile 0 Provides the default state for SRP0.\n6 SEC_NV Sector / Block \nProtectNon-volatile 0 Provides the defaults state for SEC\n5 TBPROT_NV TBPROT Default Non-volatile 0 Provides the default state for TBPROT\n4 BP_NV2 Legacy Block \nProtection \nDefaultNon-volatile 000b Provides the default state for BP bits. \n3 BP_NV1 2 BP_NV0 \n1 WEL_D WEL Default Non-volatile \nread only0 Provides the default state for the WEL status. Not \nuser programmable.\n0 WIP_D WIP Default Non-volatile \nread only0 Provides the default state for the WIP status. Not \nuser programmable.\nDatasheet 31 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.1.2 Status Register 1 Volatile (SR1V) \nRelated commands: Read Status Register 1 (RDSR1 05h), Write Enable for Volatile (WRENV 50h), Write Registers \n(WRR 01h), Clear Status Register (CLSR 30h), Read Any Re gister (RDAR 65h), Write Any Register (WRAR 71h). This \nis the register displayed by the RDSR1 command.\nStatus Register Protect 0 (SRP0) SR1V[7]:  Places the device in the Hardware Protected mode when this bit is \nset to 1 and the WP# input is driven LOW. In this mode, any command that change status registers or Configu-\nration Registers are ignored and not accepted for executio n, effectively locking the state of the Status Registers \nand Configuration Registers SR1NV, SR1V, CR1N V, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV  bits, by making \nthe registers read-only. If WP# is HIGH, Status Register s and Configuration Registers SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV may be changed an d Configuration Registers SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV may be changed. WP# has no effect on the writing of any other registers. \nSRP0 tracks any changes to the non-volatile version of this bit (SRP0_NV). When QPI or QIO mode is enabled \n(CR2V[3] or CR1V[1] = ’1’) the internal  WP# signal level is = 1 because the WP # external input is used as IO2 when \neither mode is active. This effectively turns off hardwa re protection. The Register SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV are unlocked and can be written. See "Status Register Protect (SRP1, \nSRP0)" on page 48 .\nSector / Block Protect (SEC) SR1V[6]:  This bit controls if the block protect bits (BP2, BP1, BP0) protect either \n4 kB Sectors (SEC = 1) or 64kB Blocks (SEC = 0). See "Legacy block protection" on page 50 for a description of \nhow the SEC bit value select the memory array area protected.\nTBPROT SR1V[5]:  This bit defines the reference point of the legacy block protection bits BP2, BP1, and BP0 in \nthe Status Register. As described in the status register se ction, the BP2-0 bits allow the user to optionally protect \na portion of the array, ranging from 1/64, ¼, ½, etc., up to the entire array. When TBPROT is set to ’0’ the legacy \nblock protection is defined to start from the top (maximum address) of the array. When TBPROT is set to a ’1’ the \nlegacy block protection is defined to start from the bo ttom (zero address) of the array. TBPROT tracks any \nchanges to the non-volatile version of this bit (TBPROT_NV).Table 8  Status Register 1 Volatile (SR1V)\nBits Field \nname Function Type Default \nstate Description \n7 SRP0 Status \nRegister \nProtect 0 Volatile\nSR1NV1 = Locks state of SR1NV, SR1V, CR1NV, CR1V, CR2NV, \nCR2V, CR3NV, DLRNV and DLRVwhen WP# is LOW, by not executing any commands that \nwould affect SR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, \nCR3NV, DLRNV and DLRV0 = No register protection, even when WP# is LOW. \n6 SEC Sector / Block \nProtectVolatile 0 = BP2-BP0 protect 64 kB blocks\n1 = BP2-BP0 protect 4 kB sectors\n5 TBPROT Top or \nBottom \nRelative \nProtectionVolatile 1 = BP starts at bottom (Low address)\n0 = BP starts at top (High address)\n4 BP2 Legacy Block \nProtection \nVolatileVolatile Protects the selected range of sectors (blocks) from \nprogram or erase.3 BP1 \n2 BP0 \n1 WEL Write Enable \nLatch Volatile \nread only 0 = Not write enabled, no embedded operation can start\n1 = write enable, embedded operation can start\nThis bit is not affected by  WRR or WRAR, only WREN \nWRENV, WRDI and CLSR commands affect this bit. \n0 WIP Write in \nProgress Volatile \nread only1 = Device busy, an embedded operation is in progress \nsuch as program or erase\n0 = Ready device is in Standby mode and can accept \ncommands This bit is not affected by WRR or WRAR, it only provides \nWIP status.\nDatasheet 32 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\nLegacy Block Protection (B P2, BP1, BP0) SR1V[4:2] : These bits define the main flash array area to be protected \nagainst program and erase commands. See "Legacy block protection" on page 50 for a description of how the \nBP bit values select the memory array area protected.\nWrite Enable Latch (WEL) SR1V[1] : The WEL bit must be set to 1 to enable  program, write, or erase operations \nas a means to provide protection against inadvertent ch anges to memory or register values. The Write Enable \n(WREN) command execution sets the write enable latch to a ’1’ to allow any Program, Erase, or Write commands \nto execute afterwards. The Write Disable (WRDI) command ca n be used to set the write enable latch to a ’0’ to \nprevent all Program, Erase, and Write commands from exec ution. The WEL bit is cleared to 0 at the end of any \nsuccessful program, write, or erase operation. Followi ng a failed operation the WEL bit may remain set and \nshould be cleared with a CLSR command. After a power down / power up sequence, hardware reset, or software \nreset, the write enable latch is set to a WEL_D. The WRR or WRAR command does not affect this bit.\nWrite in Progress (WIP) SR1V[0] : Indicates whether the device is performing a program, write, erase operation, \nor any other operation, during which a new operation comma nd will be ignored. When the bit is set to a ’1’ the \ndevice is busy performing an operatio n. While WIP is ’1’ , only Read Status (RDSR1 or RDSR2), Read Any Register \n(RDAR), Erase / Program Suspend (EPS), Clear Status Register (CLSR), and Software Reset (RSTEN 66h followed by RST 99h) commands are accepted. EPS command will only be accepted if memory array erase or program operations are in progress. The Status Register E_ERR and P_ERR bits are updated while WIP = 1. When P_ERR or E_ERR bits are set to one, the WIP bit will remain set to  one indicating the device remains busy and unable to \nreceive new operation commands. A Clear Status Register (C LSR) command must be received to return the device \nto Standby mode. When the WIP bit is cleared to 0 no operation is in progress. This is a read-only bit. \n6.6.2 Status Register 2 Volatile (SR2V)\nRelated Commands: Read Status Register  2 (RDSR2 07h), Read Any Register (RDAR 65h). Status Register 2 does \nnot have user programmable non-volatile bits, all defined bits are volatile read only status. The default state of \nthese bits are set by hardware.\nErase Error (E_ERR) SR2V[6] : The Erase Error bit is used as an erase op eration success or failure indication. When \nthe Erase Error bit is set to a ’1’ it indicates that there was an error in the last erase operation. This bit will also be \nset when the user attempts to erase an individual prot ected main memory sector or erase a locked Security \nRegion. The Chip Erase command will set E_ERR if a prot ected sector is found during the command execution. \nWhen the Erase Error bit is set to a ’1’ this bit can be cleared to zero with the Clear Status Register (CLSR) \ncommand. This is a read-only bit and is not affected by the WRR or WRAR commands.\nProgram Error (P_ERR) SR2V[5] : The program error bit is used as a program operation success or failure \nindication. When the program error bit is set to a ’1’ it  indicates that there was an error in the last program \noperation. This bit will also be set when the user atte mpts to program within a protected main memory sector, \nor program within a locked Security Re gion. When the Program Error bit is set to a ’1’ this bit can be cleared to \nzero with the Clear Status Register (CLSR) command. This  is a read-only bit and is not affected by the WRR or \nWRAR commands.Table 9 Status Register 1 volatile (SR2V)\nBits Field name Function Type Default state Description \n7 RFU Reserved – 0 Reserved for Future Use \n6 E_ERR Erase Error \noccurred Volatile \nread only0 1 = Error occurred \n0 = No error \n5 P_ERR Programming \nError occurred Volatile \nread only0 1 = Error occurred \n0 = No Error \n4 RFU Reserved – 0 Reserved for Future Use \n3 RFU Reserved – 0 Reserved for Future Use \n2 RFU Reserved – 0 Reserved for Future Use\n1 ES Erase Suspend Volatile \nread only0 1 = In Erase Suspend mode\n0 = Not in Erase Suspend mode\n0 PS Program \nSuspend Volatile \nread only0 1 = In Program Suspend mode\n0 = Not in Program Suspend mode\nDatasheet 33 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\nErase Suspend (ES) SR2V[1] : The Erase Suspend bit is used to determine when the device is in Erase Suspend \nmode. This is a status bit that cannot be written by the user . When erase suspend bit is set to ’1’ , the device is in \nErase Suspend mode. When erase suspend bit is cleared to ’0’ , the device is not in Erase Suspend mode. Refer to "Program or Erase Suspend (PES 75h)" on page 101 for details about the Erase Suspend/Resume commands.\nProgram Suspend (PS) SR2V[0]:  The Program Suspend bit is used to determine when the device is in Program \nSuspend mode. This is a status bit that cannot be written by the user. When Program Suspend bit is set to ’1’ , the device is in Program Suspend mode. When the program suspend bit is cleared to ’0’ , the device is not in Program Suspend mode. Refer to "Program or Erase Suspend (PES 75h)" on page 101 for details.\n6.6.3 Configuration Register 1\nConfiguration register 1 controls certain interface and data protection functions. The register bits can be changed \nusing the WRR command with sixteen input  cycles or with the WRAR command.\n6.6.3.1 Configuration Register 1 Non-volatile (CR1NV)\nRelated commands: Non-volatile Write Enable (WREN 06h),  Write Registers (WRR 01h), Read Any Register (RDAR \n65h), Write Any Register (WRAR 71h).\nSuspend Erase/Program Status (SUS_D) CR1NV[7]: Provides the default state for the SUS bit in CR1V[7]. This \nbit is not user programmable.\nComplement Protect (CMP_NV) CR1NV[6]:  Provides the default state for the CMP bit in CR1V[6].\nSecurity Region Lock bits (LB3, LB2, LB1, LB0) CR1NV[5:2]: Provide the OTP write protection control of the \nSecurity Regions. When an LB bit is set to 1 the related Security Region can no longer  be programmed or erased.\nQuad Data Width Non-volatile (QUAD_NV) CR1NV[1] : Provides the default state for the quad bit in CR1V[1]. The \nWRR or WRAR command affects this bit. Programm ing CR1NV[1] = 1 will default operation to allow \nquad-data-width commands at power-on or reset. Status Register Protect 1 Default (SRP1_D) CR1NV[0] : Provides the default state for the SRP1 bit in CR1V[0]. \nWhen IRP[2:0] = ’111’ the SRP1_D OT P bit is user programmable. When SRP1_D = ’1’ Registers SR1NV, SR1V, \nCR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV are permanently locked. See "Status Register Protect \n(SRP1, SRP0)" on page 48 .Table 10 Configuration Regist er 1 Non-volatile (CR1NV)\nBits Field name Function Type Default \nstate Description \n7 SUS_D Suspend Status \nDefaultNon-volatile \nread only0 Provides the default state for the suspend status. \nNot user programmable.\n6 CMP_NV Complement \nProtection DefaultNon-volatile 0 Provides the default state for CMP .\n5 LB3 Security Region \nLock bitsOTP 0 OTP lock Bits 3:0 for Security Regions 3:0\n0 = Security Region not locked\n1 = Security Region permanently locked4 LB2 0\n3 LB1 0\n2 LB0 01 QUAD_NV Quad Default Non-volatile 0 Provides the default state for QUAD.\n0 SRP1_D Status Register \nProtect 1 DefaultOTP 0 When IRP[2:0] =’111’ SRP1_D bit is program-\nmable.\nLock current state of SR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV \n1 = Registers permanently locked\n0 = Registers not protected by SRP1 after POR\nDatasheet 34 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.3.2 Configuration Register 1 Volatile (CR1V)\nRelated Commands: Read Configuration Register 1 (RDCR1  35h), Write Enable for Volatile (WRENV 50h), Write \nRegisters (WRR 01h), Read Any Register (RDAR 65h), Write An y Register (WRAR 71h). This is the register displayed \nby the RDCR1 command.S\nSuspend Status (SUS) CR1V[7] : The Suspend Status bit is used to determine when the device is in Erase or \nProgram Suspend mode. This is a status bit that cannot be  written by the user. When Suspend Status bit is set to \n’1’ , the device is in Erase or Program Suspend mode. When Suspend Status bit is cleared to ’0’ , the device is not in Erase or Program Suspend mode. Refer to "Program or Erase Suspend (PES 75h)" on page 101 for details \nabout the Erase/Program Suspend/Resume commands. Comp lement protection (CMP) CR1V[6]: CMP is used in \nconjunction with TBPROT , BP3, BP2, BP1 and BP0 bits to pr ovide more flexibility for the array protection map, to \nprotect from 1/2 to all of the array. \nLB[3:0] CR1V[5:2]:  These bits are volatile copies of the related OTP bits of CR1NV. These bits track any changes \nto the related OTP version of these bits. \nQuad Data Width (QUAD) CR1V[1] : When set to ‘1’ , this bit switches the data width of the device to 4-bit - Quad \nmode. That is, WP# becomes IO2 and IO3 / RESET# becomes an active I/O signal when CS# is LOW or the RESET# \ninput when CS# is HIGH. The WP# input is not monitored fo r its normal function and is  internally set to HIGH \n(inactive). The commands for Serial, and Dual I/O Read still function normally but, ther e is no need to drive the \nWP# input for those commands when switching between co mmands using different data path widths. Similarly, \nthere is no requirement to drive the IO3 / RESET# during  those commands (while CS# is LOW). The Quad bit must \nbe set to one when using th e Quad Output Read, Quad I/ O Read, DDR Quad I/O Read. The Volatile Register Write \nfor QIO mode has a short and well defined time (t\nQEN) to switch the device interface into QIO mode and (tQEX) to \nswitch the device back to SPI mode. Following commands can then be immediately sent in QIO protocol. While QPI mode is entered or exited by the QPIEN and QPIEX co mmands, or by setting the CR2V[3] bit to 1, the Quad \nData Width mode is in use whether the QUAD bit is set or not. \nStatus Register Protect 1(SRP1) CR1V[0] : The SRP1 bit, when set to ‘1’ , protects the current state of the SR1NV, \nSR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV registers by preventing any write of these registers. \nSee "Status Register Protect (SRP1, SRP0)" on page 48 .\nAs long as the SRP1 bit remains cleared to logic 0 the SR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV, \nand DLRV registers are not protected by SRP1. However, these registers may be protected by SRP0 (SR1V[7]) and the WP# input.\nOnce the SRP1 bit has been written to a logic 1 it can only be cleared to a logic 0 by a power-off to power-on cycle \nor a hardware reset. Software reset will not affect the state of the SRP1 bit. \nThe CR1V[0] SRP1 bit is volatile and the default state of  SRP1 after power-on comes from SRP1_D in CR1NV[0]. \nThe SRP1 bit can be set in parallel with updating other values in CR1V  by a single WRR or WRAR command.Table 11 Configuration Register 1 Volatile (CR1V)\nBits Field name Function Type Default \nstate Description \n7 SUS Suspend Status Volatile \nread only\nCR1NV1 = Erase / program suspended\n0 = Erase / program not suspended\n6 CMP Complement \nProtectionVolatile 0 = Normal protection map\n1 = Inverted protection map\n5 LB3 Volatile Copy of \nSecurity Region \nLock bitsVolatile \nread onlyNot user writable\nSee CR1NV[5:2] OTP lock bits 3:0 for Security Regions 3:0\n0 = Security Region not locked\n1 = Security Region permanently locked4 LB2\n3 LB12 LB0\n1 QUAD Quad I/O mode Volatile 1 = Quad \n0 = Dual or serial \n0 SRP1 Status Register \nProtect 1Volatile Lock current state of SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV \n1 = Registers locked0 = Registers un-locked \nDatasheet 35 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.4 Configuration Register 2\nConfiguration Register 2 controls certain interface functions. The register bits can be read and changed using the \nRead Any Register and Write Any Register commands. The no n-volatile version of the register provides the ability \nto set the POR, hardware reset, or software reset state of the controls. The volatile version of the register controls the feature behavior during normal operation.\n6.6.4.1 Configuration Register 2 Non-volatile (CR2NV)\nRelated Commands: Non-volatile Write Enable (WREN 06h), Write Registers (WRR 01h), Read Any Register (RDAR 65h), Write Any Register (WRAR 71h).\nIO3 _Reset Non-volatile CR2NV[7]:  This bit controls the POR, hardware reset, or software reset state of the IO3 \nsignal behavior. Most legacy SPI devices do not have a ha rdware reset input signal due to the limited signal count \nand connections available in traditional SPI device packag es. The FL-L family provides  the option to use the IO3 \nsignal as a hardware reset input when the IO3 signal is not in use for transferring information between the host \nsystem and the memory. This non-volatile IO3_Reset Conf iguration bit enables the device to start immediately \n(boot) with IO3 enabled for use as a RESET# signal. \nOutput Impedance Non-volatile CR2NV[6:5]:  These bits control the POR, hardware reset, or software reset \nstate of the IO signal output impedance (drive strength).  Multiple drive strength are available to help match the \noutput impedance with the system printed circuit board environment to minimize overshoot and ringing. These \nNon-Volatile Output Impedance Configuration bits enab le the device to start im mediately (boot) with the \nappropriate drive strengthTable 12 Configuration Regist er 2 Non-volatile (CR2NV)\nBits Field \nname Function Type Default \nstate Description \n7 IO3R_NV IO3_Reset\nNon-volatile0 1 = Enabled -- IO3_RESET is used as IO3 / RESET# \ninput when CS# is HIGH or Quad mode is disabled \nCR1V[1] = 0 or QPI is disabled (CR3V[3] = 0)\n0 = Disabled -- IO3 has no alternate function, hardware reset is disabled. Provides the default \nstate for the IO3 / RESET# function enable\n6 OI_NV Output \nImpedance1 Provides the default output impedance state\nSee Table 13 .5 1\n4 RFU Reserved 0 Reserved for Future Use \n3 QPI_NV QPI 0 1 = Enabled -- QPI (4-4-4) protocol in use\n0 = Disabled -- legacy SPI protocols in use, instruction \nis always serial on SI\nProvides the default state for QPI mode.\n2W P S _ N V W r i t e  P r o t e c t  \nSelection0 Provides the default state for WPS\n0 = Legacy protection1 = Individual block lock \n1 ADP_NV Address Length \nat Power-up0 Provides the default state for address length\n1 = 4-byte address\n0 = 3-byte address\n0 RFU Reserved 0 Reserved for Future Use\nDatasheet 36 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n.\nQPI Non-volatile CR2NV[3]:  This bit controls the POR, hardware reset, or software reset state of the expected \ninstruction width for all commands. Legacy SPI commands always send the instruction one bit wide (serial I/O) \non the SI (IO0) signal. The FL-L family also supports th e QPI mode in which all transf ers between the host system \nand memory are 4 bits wide on IO0 to IO3, including al l instructions. This Non-volatile QPI Configuration bit \nenables the device to start immediatel y (boot) in QPI mode rather than th e Legacy Serial Instruction mode. The \nrecommended procedure for moving to QPI mode is to  first use the QPIEN (38h) command, the WRR or WRAR \ncommand can also set CR2V[3] = 1, QPI mode. The Volati le Register Write for QPI mode has a short and well \ndefined time (tQEN) to switch the device interface into QPI mode and (tQEX) to switch the device back to SPI mode \nFollowing commands can then be immediately sent in QPI protocol. The WRAR command can be used to program CR2NV[3] = 1, followed by polling of SR1V[0] to know wh en the programming operation is completed. Similarly, \nto exit QPI mode use the QPIEX (F5h) command. The WRR or WRAR command can also be used to clear CR2V[3] = 0.\nWrite Protect Selection Non-volatile CR2NV[2]: This bit controls the POR, hardware reset, or software reset \nstate of the write protect method. This Non-volatile Co nfiguration bit enables the device to start immediately \n(boot) with individual block lock protecti on rather than legacy block protection.\nAddress Length at Power-up Non-volatile CR2NV[1]:  This bit controls the POR, hardware reset, or software \nreset state of the expected address length for all comma nds that require address and are not fixed 3-byte or \n4-byte only address. Most commands that need an address are Legacy SPI commands that traditionally used 3-byte (24- bit) address. For device densities greater than  128 Mb a 4-byte (32-bit) address is required to access \nthe entire memory array. The Address Length Configuration bit is used to change all 3-byte address commands to expect 4-byte address. See Table 33  for command address length. This No n-volatile Address Length Configu-\nration bit enables the device to start immediately (boot) in 4-byte Address mode rather than the legacy 3-byte \nAddress mode.Table 13 Output impedance control\nCR2NV[6:5] \nimpedance selection Typical impedance to VSS \n(Ω)Typical impedance to VCC \n(Ω)Notes\n00 18 21 –\n01 26 28 –\n10 47 45 –\n11 71 64 Factory default \nDatasheet 37 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.4.2 Configuration Register 2 Volatile (CR2V)\nRelated commands: Read Configuration Register 2 (RDCR2 15h), Read Any Register (RDAR 65h), Write Enable for \nVolatile (WRENV 50h), Write Register (WRR 01h), Write An y Register (WRAR 71h), Enter 4-byte Address mode (4BEN \nB7h), Exit 4-byte Address mode (4BEX E9h), Enter QPI (38h),  Exit QPI (F5h). This is th e register displayed by the \nRDCR2 command.\nIO3 Reset CR2V[7]:  This bit controls the IO3 / RESET# signal beha vior. This Volatile IO3 Reset Configuration bit \nenables the use of IO3 as a RESET# input during normal op eration when CS# is HIGH or Quad mode is disabled \n(CR1V[1] = 0) or QPI is disabled (CR3V[3] = 0). \nOutput Impedance CR2V[6:5]:  These bits control the IO signal output impedance (drive strength). This Volatile \nOutput Impedance Configuration bit enables the user to  adjust the drive strength  during normal operation. \nQPI CR2V[3]:  This bit controls the expected instruction width for all commands. This Volatile QPI Configuration \nbit enables the device to Enter and Exit QPI mode during normal operation. When this bit is set to QPI mode, the \nQuad mode is active, independent of the setting of QIO mo de (CR1V[1]). When this bit is cleared to Legacy SPI \nmode, the Quad bit is not affected. The QPI CR2V[3] bit can also be set to ’1’ by the QPIEN (38h) command and \nset to ’0’ by the QPIEX (F5h) command.Table 14 Configuration Register 2 Volatile (CR2V)\nBits Field \nname Function Type Default \nstate Description \n7 IO3R IO3_Reset\nVolatile\nCR2NV1 = Enabled -- IO3 is used as RESET# input when CS# is \nHIGH or Quad mode is disabled CR1V[1] = 0 or QPI is disabled (CR3V[3] = 0)\n0 = Disabled -- IO3 has no alternate function, hardware \nreset through IO3 / RESET# input is disabled\n6 OI Output \nImpedanceSee Table 13 .\n5 \n4 RFU Reserved Reserved for Future Use 3 QPI QPI 1 = Enabled -- QPI (4-4-4) protocol in use\n0 = Disabled -- legacy SPI protocols in use, instruction is always serial on SI\n2 WPS Write Protect \nSelection0 = Legacy block protection\n1 = Individual block lock\n1A D P A d d r e s s  L e n g t h  \nat Power-upVolatile\nread onlyRead Status Only bit\n1 = 4-byte address0 = 3-byte address\n0 ADS Address Length \nStatusVolatile CR2NV[1] Current Address mode\n1 = 4-byte address\n0 = 3-byte address\nTable 15 QPI and QIO Mode Control bits\nQPI \nCR2V[3]QUAD \nCR1V[1]Description\n0 0 SIO mode: Single and Dual Read, WP#/IO2 input is in use as WP# pin and IO3 / RESET# input is in \nuse as RESET# pin\n0 1 QIO mode: Single, Dual, and Quad Read, WP#/IO2 in put is in use as IO2 an d IO3 / RESET# input is \nin use as IO3 or RESET# pin\n1 X QPI mode: Quad Read, WP#/IO2 input is in use as IO2 and IO3 / RESET# input is in use as IO3 or \nRESET# pin \nDatasheet 38 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\nWrite Protect Selection CR2V[2]: This bit selects which array protection method is used; "Legacy block \nprotection" on page 50) or "Individual block lock (IBL) protection" on page 52. These Volatile Configuration \nbits enable the user to change protec tion method during normal operation.\nAddress Length at Power-on (ADP) CR2V[1]:  This bit is read only and show s what the address length will be \nafter power-on reset, hardware reset, or software reset for all commands that require address and are not fixed 3-byte or 4-byte address. \nAddress Length Status (ADS) CR2V[0]:  This bit controls the expected address length for all commands that \nrequire address and are not fixed 3-byte or 4-byte address. See Table 33  for command address length. This \nVolatile Address Length Configuration bit enables the ad dress length to be changed during normal operation. \nThe 4-byte Address mode (4BEN) command directly sets  this bit into 4-byte Address mode and the (4BEX) \ncommand exits sets this bit back into 3-byte Address mo de. This bit is also updated when the address length \nnon-volatile CR2NV[1] bit is updated.\n6.6.5 Configuration Register 3\nConfiguration Register 3 controls the main flash array re ad commands burst wrap behavior and read latency. The \nburst wrap configuration does not affect commands readin g from areas other than the main flash array e.g. Read \ncommands for registers or Security Regions. The non-volatile  version of the register provides the ability to set the \nstart up (boot) state of the controls as the contents are copied to the volatile version of the register during the \nPOR, hardware reset, or software reset. The volatile vers ion of the register controls the feature behavior during \nnormal operation.\nThe register bits can be read and changed using the, Read Configuration 3 (RDCR3 33h), Write Registers (WRR \n01h), Read Any Register (RDAR 65h), Write Any Register (W RAR 71h). The volatile version of the register can also \nbe written by the Set Bu rst Length (77h) command.\n6.6.5.1 Configuration Register 3 Non-volatile (CR3NV)\nRelated commands: Non-volatile Write Enable (WREN 06h),  Write Registers (WRR 01h), Read Any Register (RDAR \n65h), Write Any Register (WRAR 71h).\nWrap Length Non-volatile CR3NV[6:5]:  These bits controls the POR, hardware reset, or software reset state of \nthe wrapped read length and alignment. \nWrap Enable Non-volatile CR3NV[4]:  This bit controls the POR, hardware reset, or software reset state of the \nwrap enable. The commands affected by Wrap Enable are:  Quad I/O Read, QPI Read, DDR Quad I/O Read and DDR \nQPI Read. This configuration bit enables the device to start immediately (boot) in  Wrapped Burst Read mode \nrather than the Legacy Sequential Read mode.Table 16 Configuration Regist er 3 Non-volatile (CR3NV)\nBits Field name Function Type Default \nstate Description \n7 RFU Reserved\nNon-volatile0 Reserved for Future Use \n6 \nWL_NVWrap Length \nDefault1 00 = 8-byte wrap\n01 = 16-byte wrap\n10 = 32-byte wrap\n11 = 64-byte wrap5 1\n4 WE_NV Wrap Enable \nDefault1 0 = Wrap enabled\n1 = Wrap disabled\n3 \nRL_NVRead Latency \nDefault1 0 to 15 latency (dummy) cycles following \nRead Address or Continuous Mode bits. 20\n1000\nDatasheet 39 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\nRead Latency Non-volatile CR3NV[3:0]:  These bits control the POR, hardware reset, or software reset state of \nthe read latency (dummy cycle) delay in all variable la tency read commands. The following read commands have \na variable latency period between the end of address or mode and the beginning of read data returning to the \nhost:\n• The latency delay per clock frequency for the foll owing commands are: One dummy cycle for all clock \nfrequency\'s. The default latency code of ’0’ is one dummy cycle. \n- Data Learning Pattern Read DLPRD (1-1-1) or (4-4-4)\n- IRP Read IRPRD (1-1-1) or (4-4-4))- Protect Register Read PRRD (1-1-1) or (4-4-4)\n- Password read PASSRD (1-1-1) or (4-4-4)\n• The latency delay per clock frequency for the following commands are shown in Table 17  and Table 18  below. \nThe default latency code of ’0’ is 8 dummy cycles. \n- Fast Read FAST_READ (1-1-1)- Quad-O Read QOR, 4QOR (1-1-4)\n- Dual-O Read DOR, 4DOR (1-1-2)\n- Dual I/O Read DIOR, 4DIOR (1-2-2)- Quad I/O Read QIOR, 4QIOR (1-4-4) or (4-4-4)\n- DDR Quad I/O Read DDRQIOR, 4DDRQIOR(1-4-4)\n- Security Regions Read SECRR (1-1-1) or (4-4-4)- Read Any Register RDAR (1-1-1) or (4-4-4)\n- Read serial flash discoverable parameters RSFDP (1-1-1) or (4-4-4)\nThe non-volatile read latency configuration bits set the number of read latency (du mmy cycles) in use so the \ndevice can start immediately (boot) with an appropriate read latency for the host system.\nTable 17 Latency code (cycles) versus frequency \nLatency \ncode 0Read command maximum frequency (MHz)\nFast Read\n(1-1-1)Dual-O Read\n(1-1-2)Dual I/O Read\n(1-2-2)Quad-O Read\n(1-1-4)Quad I/O \nRead\n(1-4-4)Quad I/O \nRead\nQPI (4-4-4)DDR \nQuad I/O \n(1-4-4)\nQPI (4-4-4)\nMode \ncycles = 0Mode \ncycles = 0Mode \ncycles = 4Mode \ncycles = 0Mode \ncycles = 2Mode \ncycles = 2Mode \ncycles = 1\nDummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8 Dummy\ncycles = 8\n15 0 5 0 7 5 3 5 3 5 3 5 2 026 5 6 5 8 5 4 5 4 5 4 5 2 5\n37 5 7 5 9 5 5 5 5 5 5 5 3 5\n4 85 85 108 65 65 65 455 95 95 108 75 75 75\n54\n6 108 105 108 85 85 85 54\n7 108 108 108 95 95 95 54\n8 108 108 108 108 108 108 54\n9 108 108 108 108 108 108 54\n10 108 108 108 108 108 108 54\n11 108 108 108 108 108 108 54\n12 108 108 108 108 108 108 54\n13 108 108 108 108 108 108 54\n14 108 108 108 108 108 108 54\n15 108 108 108 108 108 108 54\nDatasheet 40 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n.\nTable 18 Latency code (cycles) versus frequency \nLatency \ncode 0Read Command Maximum Frequency (MHz)\nRead Any \nRegister\n(1-1-1)Read Any \nRegister QPI \n(4-4-4)Security \nregion read \n(1-1-1)Security \nregion read QPI \n(4-4-4)Read SFDP \nRSFDP \n(1-1-1)Read SFDP\nRSFDP QPI\n(4-4-4)\nMode \ncycles = 0Mode \ncycles = 0Mode \ncycles = 0Mode \ncycles = 0Mode \ncycles = 0Mode \ncycles = 0\nDummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8Dummy \ncycles = 8\n15 0 1 5 5 01 5 5 0 1 5\n26 5 2 5 6 52 5 6 5 2 537 5 3 5 7 53 5 7 5 3 5\n48 5 4 5 8 54 5 8 5 4 5\n59 5 5 5 9 55 5 9 5 5 56 108 65 108 65 108 65\n7 108 75 108 75 108 75\n8 108 85 108 85 108 85\n9 108 95 108 95 108 95\n10 108 108 108 108 108 108\n11 108 108 108 108 108 108\n12 108 108 108 108 108 108\n13 108 108 108 108 108 10814 108 108 108 108 108 108\n15 108 108 108 108 108 108\nNotes\n8. SCK frequency > 108 MHz SDR, or 54 MHz DDR is not supported by these devices.\n9. The Dual I/O, Quad I/O, QPI, DDR Quad I/O, and DDR QPI command protocols include Continuous Read Mode bits \nfollowing the address. The clock cycles for these bits are not counted as part of the latency cycles shown in the Table 18 . Example: the Legacy Quad I/O command has 2 Continuo us Read mode cycles following the address. There-\nfore, the legacy quad I/O command withou t additional read latency is supported only up to the frequency shown in the \ntable for a read latency of 0 cycles. By increasing the variable read latency the frequency of the Quad I/O command can be increased to allow operation up to the maximum supported 108 MHz frequency and QPI maximum supported 108 \nMHz.\n10.Other commands have fixed latency. For example, Read alwa ys has zero read latency, read unique ID has 32 dummy \ncycles and release from deep power-down has 24 dummy cycles. \nDatasheet 41 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.5.2 Configuration Register 3 Volatile (CR3V)\nRelated commands: Read Configuration 3 (RDCR3 33h), Wr ite Enable for Volatile (WRENV 50h), Write Registers \n(WRR 01h), Read Any Register (RDAR 65h), Write Any Register  (WRAR 71h), Set Burst Length (SBL 77h). This is the \nregister displayed by the RDCR3 command.\nWrap Length CR3V[6:5]:  These bits controls the wrapped read length  and alignment during normal operation. \nThese Volatile Configuration bits enable the user to adjust the burst wrapped re ad length during normal \noperation.\nWrap Enable CR3V[4]:  This bit controls the burst wrap feature. This  Volatile Configuration bit enables the device \nto Enter and Exit Burst Wrapped Read mode during normal  operation. When CR3V[4] = 1, the Wrap mode is not \nenabled and unlimited length sequential read is perfor med. When CR3V[4] = 0, the Wrap mode is enabled and a \nfixed length and aligned group of 8-, 16-, 32-, or 64-bytes is read starting at the byte address provided by the Read \ncommand and wrapping around at the group alignment boundary.\nRead Latency CR3V[3:0]:  These bits set the read latency (dummy cycle) delay in Variable Latency Read \ncommands. These volatile configuration bits enable the us er to adjust the read latency during normal operation \nto optimize the latency for different commands or, at different operating frequencies, as needed.Table 19 Configuration Register 3 Volatile (CR3V)\nBits Field name Function Type Default \nstate Description \n7 RFU Reserved\nVolatile CR3NVReserved for Future Use\n6 \nWL Wrap Length00 = 8-byte wrap\n01 = 16-byte wrap\n10 = 32-byte wrap11 = 64-byte wrap5 \n4 WE Wrap Enable0 = Wrap enabled\n1 = Wrap disabled\n3 \nRL Read Latency0 to 15 latency (dummy) cycles following Read \nAddress or Continuous Mode bits. 2 \n1 \n0 \nDatasheet 42 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.6 Individual and Region Protection Register (IRP)\nRelated commands: IRP Read (IRPRD 2Bh) and IRP Progra m (IRPP 2Fh), Read Any Register (RDAR 65h), Write Any \nRegister (WRAR 71h).\nThe IRP Register is a 16-bit OTP memory location used to  permanently configure the behavior of individual and \nregion protection (IRP) features. IRP does not have User  Programmable Volatile bits, all defined bits are OTP .\nThe default state of the IRP bits are programmed by Infineon.\nSecurity Regions Read Password Mode Enable (SECRRP) IRP[6]: When programmed to ’0’ , SECRRP enables \nthe Security Region 3 Read Password mode when PWDMLB bit IRP[2] is program at same time or later. The SECRRP bit can only be programmed when IRP[2:0] = ’111’ , if  not programming will fail with P_ERR set to ‘1’ . See \n"Security Region read password protection" on page 58.\nIBL Lock Boot bit (IBLLBB) IRP[4]:  The default state is 1, all individual IBL bits are set to ’0’ in the protected state, \nfollowing power-up, hardware reset, or software reset. In order to Program or Erase the Array the Global IBL Unlock or the Sector / Block IBL Unlock command must be given before the Program or Erase commands. When programmed to 0, all the individual IBL bits are in the un-protected state following power-up, hardware reset, or \nsoftware reset. The IBLLBB bit can only be programmed wh en IRP[2:0] = ’111’ , if not programming will fail with \nP_ERR set to ’1’ . See "Individual block lock  (IBL) protection" on page 52.\nPassword Protection Mode Lock bit (PWDMLB) IRP[2]:  When programmed to ’0’ , the Password Protection \nmode is permanently selected to protect the Security Regions 2 and 3 and pointer region. The PWDMLB bit can only be programmed when IRP[2:0] = ’111’ , if not programming will fail with P_ERR set to 1. See "Password \nProtection mode" on page 57.\nAfter the Password Protection mode is selected by progra mming IRP[2] = ’0’ , the state of all IRP bits are locked \nand permanently protected from further programming. At tempting to program any IRP bits will result in a \nprogramming error with P_ERR set to 1.\nThe password must be programmed and verified, before the Password mode (IRP[2] = 0) is set.Table 20.  IRP Register (IRP)\nBits Field name Function Type Default \nstate Description \n15 to 7 RFU Reserved OTP All bits are 1 Reserved for Future Use \n6 SECRRP Security Region \n3 Read \nPassword \nmode enable \nbit OTP 10 = Security Region 3 Read  Password mode selected \n1 = Security Region 3 Read Password not selectedIRP[6] is programmable if IRP[2:0] = ’111’ \n5 RFU Reserved OTP 1 Reserved for Future Use\n4  IBLLBB IBL Lock Boot \nbit OTP 1 0 = All individual IBL bits are set to ’1’ at power-up in the \nunprotected state \n1 = All individual IBL bits are set to ’0’ at power-up in the protected state \nIRP[4] is programmable if IRP[2:0] = ’111’ \n3 RFU Reserved OTP 1 Reserved for future use\n2 PWDMLB Password \nProtection \nMode Lock bitOTP 1 0 = Password Protection mode permanently enabled. \n1 = Password Protection mode not permanently enabled.\nIRP[2] is programmable if IRP[2:0] = ’111’ \n1 PSLMLB Power Supply \nLock-Down \nProtection \nMode Lock bit OTP 10 = Power Supply Lock-Down Protection mode perma-\nnently enabled.\n1 = Power Supply Lock-Down Protection mode not permanently enabled.\nIRP[1] is programmable if this is enabled by \nIRP[2:0] = ’111’ \n0 PERMLBPermanent \nProtection lock OTP 1 0 = Permanent Protection mode permanently enabled. \n1 = Permanent Protection mode not permanently enabled. \nIRP[0] is programmable if IRP[2:0] = ’111’ \nDatasheet 43 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\nPower Supply Lock-Down Protection Mode Lock bit (PSLMLB) IRP[1]:  When programmed to 0, the Power \nSupply Lock-down Protection mode is permanently sele cted. The PSLMLB bit can only be programmed when \nIRP[2:0] = ’111’ , if not programming will fail with P_ERR set to ’1’ .\nAfter the Power Supply Lock-down Protection mode is sele cted by programming IRP[1] = ‘0’ , the state of all IRP \nbits are locked and permanently protected from furthe r programming. Attempting to program any IRP bits will \nresult in a programming error with P_ERR set to ’1’ . See "IRP Register" on page 56 .\nPermanent Protection Lock bit (PERMLB) IRP[0]:  When programmed to 0, the permanent Protection Lock bit \npermanently protects the Pointer Region and Security Regions 2 and 3, This bit provides a simple way to permanently protect the Pointer Region and Security Regions 2 and 3 without the use of a password or the PRL command. See "IRP Register" on page 56 .\nPWDMLB (IRP[2]), PSLMLB (IRP[1]) and PERMLB(IRP[0]) ar e mutually exclusive, only one may be programmed to \nzero. IRP bits may only be programmed while IRP[2:0] = ’ 111’ . Attempting to program IRP bits when IRP[2:0] is not \n= ’111’ will result in a programming error with P_ERR set to  ’1’ . The IRP Protection mode should be selected during \nsystem configuration to ensure that a malicious program do es not select an undesired Protection mode at a later \ntime. By locking all the protection configuration via the IRP mode selection, later alteration of the protection \nmethods by malicious programs is prevented.\n6.6.7 Password Register (PASS)\nRelated commands: Password Read (PASSRD E7h) and Password Program (PASSP E8h), Read Any Register (RDAR 65h), Write Any Register (WRAR 71h). The PASS register is a 64-bit OTP memory location used to permanently \ndefine a password for the Individual and region protection (IRP) feature. PASS does not have user programmable volatile bits, all defined bits are OTP . A volatile copy of  PASS is used to satisfy read latency requirements but the \nvolatile register is not user writable or further described. The Password can not be read or programmed after IRP[2] is programmed to ’0’ . See Table 20 .\nTable 21 Password Register (PASS)\nBits Field \nname Function Type Default state Description \n63 to 0 PWD Hidden \npassword OTP FFFFFFFF-FFFF\nFFFFh Non-volatile OTP storage of 64-bit password. The password is no \nlonger readable after the Password Protection mode is selected by \nprogramming IRP register bit 2 to zero. \nDatasheet 44 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.8 Protection Register (PR)\nRelated commands: Protection Register Read (PRRD A7h) Protection Register Lock (PRL A6h), Read Any Register \n(RDAR 65h). \nPR does not have separate user programmable non-volatile bits, all defined bits are volatile read only status. The \ndefault state of the RFU bits is set by hardware. Th ere is no non-volatile version of the PR register. \nThe NVLOCK bit is used to protect the Security Region s 2 and 3 and pointer region protection. When NVLOCK[0] \n= 0, the Security Regions 2 and 3 and poin ter region protection can not be changed.\n6.6.9 Individual Block Lock Access Register (IBLAR)\nRelated commands: IBL Read (IBLRD 3Dh or 4IBLRD E0h), IB L Lock (IBL 36h or 4IBL E1h), IBL Unlock (IBLUL 39h \nor 4IBUL E2h), Global IBL lock (GBL  7Eh), Global IBL Unlock (GBUL 98h).\nIBLAR does not have user programmable non-volatile bits, a ll bits are a representation of the volatile bits in the \nIBL array. The default state of the IBL array bits is set by  hardware. There is no non-volatile version of the IBLAR \nregister.Table 22 Protection Status Register (PR)\nBits Field name Function Type Default \nstate Description \n7 RFU Reserved \nVolatile\nread only00h Reserved for Future Use \n6 SECRRPSecurity Regions \nRead Password IRP[6]0 = Security Region 3 password protected from \nread when NVLOCK = 0\n1 = Security Region 3 not password protected \nfrom read\n5 RFU Reserved 0 Reserved for Future Use \n4 RFU Reserved 0 Reserved for Future Use\n3 RFU Reserved 0 Reserved for Future Use2 RFU Reserved 0 Reserved for Future Use \n1 RFU Reserved 0 Reserved for Future Use\n0 NVLOCK\n[11]Protect \nNon-volatile \nConfigurationIRP[2] and \nIRP[0]0 = Security Regions 2 and 3 and pointer region \nwrite protected1 = Security Regions 2 and 3 and pointer region \nmay be written\nNote\n11.The Command Protection Register Lock (PRL), sets the NVLOCK = 1.\nTable 23 IBL Access Register (IBLAR)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 IBL Read or Write \nIBL for \nIndividual \nSectors / \nBlocksVolatile IRP[4] = 1 \nthen 00h\nelse FFh 00h = IBL for the sector / block addressed is set to ’0’ by the \nIBL, 4IBL and GBL commands protecting that sector from \nprogram or erase operations. \nFFh = IBL for the sector / block addressed is cleared to ’1’ by the IBUL, 4IBUL and GBUL commands not protecting that \nsector from program or erase operations. \nNotes\n12.See Figure 25 .\n13.The IBL bits maybe read by the IBLRD and 4IBLRD commands.\nDatasheet 45 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nAddress space maps\n6.6.10 Pointer Region Protection Register (PRPR)\nRelated commands: Set Pointer Region (SPRP FBh or 4SPRP E3h), Read Any Register (RDAR 65h), Write Any \nRegister (WRAR 71h).\nPRPR contains user programmable non-volatile bits. The de fault state of the PRPR bits is set by hardware. There \nis no volatile version of the PRPR register. See "Pointer region protection (PRP)" on page 53 for additional \ndetails.\n6.6.11 DDR Data Learning Registers\nRelated commands: Program DLRNV (PDLRN V 43h), Write DLRV (WDLRV 4Ah), Da ta Learning Pattern Read (DLPRD \n41h), Read Any Register (RDAR 65h ), Write Any Register (WRAR 71h).\nThe Data Learning Pattern (DLP) resides in an 8-bit Non-vola tile Data Learning Register (DLRNV) as well as an 8-bit \nVolatile Data Learning Register (DLRV). When shipped from Infineon, the DLRNV value is 00h. Once programmed, \nthe DLRNV cannot be reprogrammed or erased; a copy of the data pattern in the DLRNV will also be written to the DLRV. The DLRV can be written to at any time, but on hardware and software reset or power cycles the data pattern will revert back to what is in the DLRNV. During  the learning phase describe d in the SPI DDR modes, the \nDLP will come from the DLRV. Each IO will output the sa me DLP value for every clock edge. For example, if the \nDLP is 34h (or binary 00110100) then during  the first clock edge all IO’s will output 0; subseque ntly, the 2nd clock \nedge all I/O’s will output 0, the 3rd will output 1, etc.\nWhen the DLRV value is 00h, no preamble data patte rn is presented during the dummy phase in the DDR \ncommands.Table 24 PRP Register (PRPR)\nBits Field \nname Function Type Default \nstate Description \nA31 to A23 RFU Reserved\nNon-volatile 11111111b Reserved for Future Use\nA22 to A16 PRPAD PRP address FFh Pointer address A22 to A16\nA15 to A12 – – Fh Pointer address A15 to A12\nA11 PRPALL PRP \nProtect All10 = Protect pointer region selected sectors\n1 = Protect all sectors\nA10 PRPEN PRP Enable10 = Enable pointer region protection\n1 = Disable pointer region protection\nA9 PRPTBPRP Top/\nBottom10 = Pointer region protection starts from the top (high \naddress)\n1 = Pointer region protection starts from the bottom \n(low address)\nA8 RFU Reserved 1 Reserved for Future Use\nA7 to A0 RFU Reserved FFh Reserved for Future Use\nTable 25 Non-volatile Data Learning Register (DLRNV)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 NVDLP Non-volatile \nData Learning \nPatternOTP 00h OTP value that may be transferred to the host during DDR Read \ncommand latency (dummy) cycles to provide a training pattern to help the host more accurately center the data capture point in \nthe received data bits.\nTable 26 Volatile Data Learning Register (DLRV)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 VDLP Volatile Data \nLearning \nPattern Volatile Takes the \nvalue of \nDLRNV \nduring POR \nor ResetVolatile copy of the NVDLP used to enable and deliver the data \nlearning pattern (DLP) to the outputs. The VDLP may be changed \nby the host during system operation.\nDatasheet 46 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7D a t a  p r o t e c t i o n\n7.1 Security Regions \nThe device has a 1024-byte address space th at is separate from the main flash ar ray. This area is divided into 4, \nindividually lockable, 256-by te length regions. See "Security Regions address space" on page 28.\nThe Security Region memory space is intended for increa sed system security. The data values can “mate” a flash \ncomponent with the system CPU/ASIC to prevent device  substitution. The Security Region address space is \nprotected by the Security Region Lock bits or the Protection Register NVLOCK bit (PR[0]). See "Security Region \nLock bits (LB3, LB2, LB1, LB0)" on page 46.\n7.1.1 Reading Security Region memory regions\nThe Security Region Read command (SECRR) uses the same  protocol as Fast Read. Read operations outside the \nvalid 1024-byte Security Region address range will yield indeterminate data. See "Security Regions Read \n(SECRR 48h)" on page 106.\nSecurity Region 3 may be password protected from read by setting the PWDMLB bit IRP[2] = 0 and SECRRP bit \nIRP[6] = 0 when NVLOCK = 0.\n7.1.2 Programming the Security Regions \nThe protocol of the Security Region programming command (SECRP) is the same as page program. See "Security \nRegion Program (SECRP 42h)" on page 105.\nThe valid address range for Security Region program is depicted in Table 5 . Security Region program operations \noutside the valid Security Region address range will be ignored, without P_ERR in SR2V[5] set to ’1’ . \nSecurity Regions 2 and 3 may be password protected from  programming by setting the PWDMLB bit IRP[2] = 0.\n7.1.3 Erasing the Security Regions \nThe protocol of the Security Region Erasing comm and (SECRE) is the same as sector erase. See "Security Region \nErase (SECRE 44h)" on page 105 .\nThe valid address range for Security Region Erase is depicted in Table 5 . Security Region erase operations outside \nthe valid Security Region address range will be  ignored, without E_ERR in SR2V set to ’1’ . \nSecurity Regions 2 and 3 may be password protected fr om erasing by setting th e PWDMLB bit IRP[2] = 0.\n7.1.4 Security Region Lock bits (LB3, LB2, LB1, LB0)\nThe Security Region lock bits (LB3, LB 2, LB1, LB0) are Non-volatile One Time  Program (OTP) bits in Configuration \nRegister 1(CR1NV[5:2]) that pr ovide the write protect control and status to the Security Regions. The default state \nof Security Regions 0 to 3 are unlocked. LB[3:0] can be set to 1 individually using the Write Status Registers or \nWrite Any Register command. LB[3:0] are one time programmable (OTP), once it’s set to ‘1’ , the corresponding 256-byte Security Region will become read-only permanently.\n7.2 Deep Power Down \nThe Deep Power Down (DPD) command offers an altern ative means of data protection as all commands are \nignored during the DPD state, except for the release fr om Deep Power Down (RES ABh) command and hardware \nreset. Thus, preventing any progra m or erase during the DPD state.\nDatasheet 47 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.3 Write Enable commands\n7.3.1 Write Enable (WREN)\nThe Write Enable (WREN) command must  be written prior to any command that modifies non-volatile data. The \nWREN command sets the Write Enable Latch (WEL) bit. The WEL bit is cleared to 0 (disables writes) during \npower-up, hardware and software reset, or after the device completes the following commands:\n•R e s e t• Page Program (PP or 4PP)• Quad Page Program (QPP or 4QPP)\n• Sector Erase (SE or 4SE)\n• Half Block Erase (HBE or 4HBE)• Block Erase (BE or 4BE)\n•C h i p  E r a s e  ( C E )\n•W r i t e  D i s a b l e  ( W R D I )•W r i t e  R e g i s t e r s  ( W R R )\n• Write Any Register (WRAR)\n• Security Region Erase (SECRE)• Security Region Byte Programming (SECRP)\n• Individual and Region Protection Register Program (IRPP)\n•P a s s w o r d  P r o g r a m  ( P A S S P\n)\n• Clear Status Register (CLSR)\n• Set Pointer Region Protection (SPRP or 4SPRP)\n• Program Non-volatile Data Learning Register (PDLRNV)\n• Write Volatile Data Learning Register (WDLRV)\n7.3.2 Write Enable for Volatile Registers (WRENV)\nThe Write Enable Volatile (WRENV) command must be written prior to Write Register (WRR) command that \nmodifies volatile registers data. \n7.4 Write Protect signal\nWhen not in Quad mode (CR1V[1] = 0)  or QPI mode (CR2V[3] = 0), the Writ e Protect (WP#) input in combination \nwith the Status Register Protect 0 (S RP0) bit (SR1NV[7]) provide hardware input signal controlled protection. \nWhen WP# is LOW and SRP0 is set to ’1’ Status Register 1 (SR1NV and SR1V), Configuration register (CR1NV, CR1V, CR2NV, CR2V and CR3NV) and DDR Data Learning Registers (DLRNV and DLRV) are protected from alteration. This prevents disabling or changing the prot ection defined by the Legacy Block Protect bits or Security Region Lock \nbits. See "Status Register 1" on page 30.\nDatasheet 48 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.5 Status Register Protect (SRP1, SRP0)\nThe Status Register Protect bits (SRP1 and SRP0) are volatile bits in the configuration and status registers \n(CR1V[0] and SR1V[7]). The SRP bits control the method of  write protection for SR1NV, SR1V, CR1NV, CR1V, CR2NV, \nCR2V, CR3NV, DLRNV and DLRV: Software Protection, Hardware Protection, or Power Supply Lock-Down.\nTable 27 Status Register Protection bits (high security)\nSRP1_D\nCR1NV[0]SRP1\nCR1V[0]SRP0\nSR1V[7]WP# Status Register Description\n00 0 X S o f t w a r e  P r o t e c t i o nWP# pin has no control. SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV can be \nwritten. [factory default]\n0 0 1 0 Hardware ProtectedWhen WP# pin is LOW SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV are locked and can not be written[14, 17].\n0 0 1 1 Hardware UnprotectedWhen WP# pin is HIGH SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV are unlocked \nand can be written[14].\n01 X XPower Supply \nLock-DownSR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, \nDLRNV and DLRV are protected and can not be \nwritten to again until the next power-down, power-up cycle[15].\n11 X X O n e  T i m e  P r o g r a mSRP1_D CR1NV[0] = 1 SR1NV, SR1V, CR1NV, CR1V, \nCR2NV, CR2V, CR3NV, DLRNV and DLRV are \npermanently protected and can not be written[16].\nNotes\n14.SRP0 is reloaded from SRP0_NV (SR1NV[7]) default state after a power-down, power-up cycle, software or hardware \nreset. To enable Hardware Protection mode by the WP# pin at power-up set the SRP0_NV bit to ’1’ .\n15.When SRP1 = 1, a power-down, power-up cycle, or hardware reset, will change SRP1 to 0 as SRP1 is reloaded from \nSRP1_D.\n16.SRP1_D can be written only when IRP[2:0] =’111’ . When SR P1_D CR1NV[0] =’1’ a power-do wn, power-up cycle, or hard-\nware reset, will reload SRP1 from SRP1_D = ‘1’ the volatile bit SRP1 is not writable, thus providing OTP protection. When SRP1_D is programmed to 1, Recommended that SRP0_NV should also be programmed to 1 as an indication that OTP \nprotection is in use.\n17.When QPI or QIO mode is enabled (CR2V[3] or CR1V[1] = ’1’) the internal WP# signal level is = 1 because the WP# external \ninput is used as IO2 when either mode is active. This effectively turns off hardware protection when SRP1-SRP0 = 01b. \nThe Register SR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV are unlocked and can be written.\n18.WIP , WEL, and SUS (SR1[1:0] and CR1[7]) are Volatile Read Only Status bits that are never affected by the Write Status \nRegisters command.\n19.The non-volatile version of SR1NV, CR1NV, CR2NV and CR3N V are not writable when protected by the SRP bits and WP# \nas shown in the table. The non-volatile version of these Status Register bits are selected for writing when the Write Enable (06h) command precedes the Write Status Register s (01h) command or the Write Any Register (71h) command.\n20.The volatile version of registers SR1V, CR1V and CR2V are not writable when protected by the SRP bits and WP# as shown \nin the Table 27 . The volatile version of these Status Register bits are selected for writing when the Write Enable for \nVolatile Status Register (50h) command precedes the Write Status Registers (01h) command or the Write Enable (06h) \ncommand precedes the Write Any Register (71h) command.\n21.The Volatile CR3V bits are not protected by the SRP bits and may be written at any time by volatile (50h) Write Enable \ncommand preceding the Write Status Registers (01h) command. The WRAR (71h) and SBL (77h) commands are \nalternative ways to Write bits in the CR3V register. \n22.During system power up and boot code execution: Truste d boot code can determine whether there is any need to \nchange SR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV values. If no changes are needed the SRP1 \nbit (CR1V[0]) can be set to 1 to protect the SR1NV, SR1V, CR1NV, CR1V, CR2NV, CR2V, CR3NV, DLRNV and DLRV registers \nfrom changes during the remainder of normal  system operation while power remains on.\nDatasheet 49 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.6 Array protection \nThere are three types of memory array protection: Legacy  block (LBP), individual block lock (IBL) and pointer \nregion (PRP). The Write Protect Selection (WPS) bit is used by the user to enable one of two protection \nmechanisms: legacy block (LBP) protection (WPS CR2V[2] = 0)or individual block lock (IBL) protection (WPS CR2V[2] = 1). See "Configuration Register 2 Volatile (CR2V)" on page 37. Only one protection mechanism can \nbe enabled at one time. The legacy bloc k protection is the default protection and is mutually exclusive with the \nIBL protection scheme. The pointer region protection is  enabled by the Set Pointer Region Protection command \nor the WRAR command by the value of A10 = 0. See "Pointer Region command" on page 112. When the pointer \nregion protection is enabled it is logically ORed with the legacy block protecti on or individual block lock \nprotection. \nFigure 24 WPS selection of LBP or IBL and PRP array protectionLegacy block\nprotection logic\n(address range compare)\nIndividual block \nprotection logic\n(IBL bit array)Mux\nORCommand \naddressBP bits\nWPS\nPointer region protection \nlogic\n(address range compare)\nNVLOCKArray \nlocation \nprotected WPS = 1IBLBOOT\nDatasheet 50 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.6.1 Legacy block protection\nThe Legacy Block Protect bits Status Register bits BP2,  BP1, BP0 -- SR1V[4:2]) in combination with the Configu-\nration Register TBPROT (SR1V[5])bit, CMP (CR1V[6] bit an d SEC (SR1V[6]) can be used to protect an address range \nof the main flash array from program and erase operations . The size of the range is determined by the value of \nthe BP bits and the upper or lower starting point of the range is selected by the TBPROT bit of the configuration \nregister (SR1V[5]). The protection is compleme nted when the CMP bit (CR1V[6]) is set to 1.\nIf the pointer region protection is enabled this region pr otection is logically ORed wi th the legacy block protection \nregion.\nTable 28 S25FL064L legacy block protection (CMP = 0)\nStatus Register 64 Mb block protection (CMP = 0) \nSEC TBPROT BP2 BP1 BP0 Protected \nblock(s)Protected \naddressesProtected \ndensityProtected \nportion \nX X 0 0 0 None None None None\n0 0 0 0 1 126 and 127 7E0000h – 7FFFFFh 128 kB Upper 1/64 \n0 0 0 1 0 124 thru 127 7C0000h  – 7FFFFFh 256 kB Upper 1/32 \n0 0 0 1 1 120 thru 127 780000h – 7FFFFFh 512 kB Upper 1/16 \n0 0 1 0 0 112 thru 127 700000h – 7FFFFFh 1 MB Upper 1/8 \n0 0 1 0 1 96 thru 127 600000h – 7FFFFFh 2 MB Upper 1/4 0 0 1 1 0 64 thru 127 400000h – 7FFFFFh 4 MB Upper 1/2 \n0 1 0 0 1 0 and 1 000000h – 01FFFFh 128 kB Lower 1/64 \n0 1 0 1 0 0 thru 3 000000h – 03FFFFh 256 kB Lower 1/32 \n0 1 0 1 1 0 thru 7 000000h – 07FFFFh 512 kB Lower 1/16 \n0 1 1 0 0 0 thru 15 000000h – 0FFFFFh 1 MB Lower 1/8 0 1 1 0 1 0 thru 31 000000h – 1FFFFFh 2 MB Lower 1/4 \n0 1 1 1 0 0 thru 63 000000h – 3FFFFFh 4 MB Lower 1/2 \nX X 1 1 1 0 thru 127 000000h – 7FFFFFh 8 MB All\n1 0 0 0 1 127 7FF000h – 7FFFFFh 4 kB Upper 1/2048 \n1 0 0 1 0 127 7FE000h – 7FFFFFh 8 kB Upper 1/1024 \n1 0 0 1 1 127 7FC000h – 7FFFFFh 16 kB Upper 1/512 1 0 1 0 X 127 7F8000h – 7FFFFFh 32 kB Upper 1/256 \n1 1 0 0 1 0 000000h – 000FFFh 4 kB Lower 1/2048 \n1 1 0 1 0 0 000000h – 001FFFh 8 kB Lower 1/1024 1 1 0 1 1 0 000000h – 003FFFh 16 kB Lower 1/512 \n1 1 1 0 X 0 000000h – 007FFFh 32 kB Lower 1/256 \nNote\n23.X = don’t care.\nDatasheet 51 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\nTable 29 S25FL064L legacy compleme nt block protection (CMP = 1)\nStatus Register 64 Mb legacy block protection (CMP = 1) \nSEC TBPORT BP2 BP1 BP0 Protected \nblock(s)Protected \naddressesProtected \ndensityProtected \nportion \nX X 0 0 0 0 thru 127 000000h – 7FFFFFh 8 MB ALL \n0 0 0 0 1 0 thru 125 000000h – 7DFFFFh 8,064 kB Lower 63/64 \n0 0 0 1 0 0 thru 123 000000h – 7BFFFFh 7,936 kB Lower 31/32 \n0 0 0 1 1 0 thru 119 000000h – 77FFFFh 7,680 kB Lower 15/16 0 0 1 0 0 0 thru 111 000000h – 6FFFFFh 7 MB Lower 7/8 \n0 0 1 0 1 0 thru 95 000000h – 5FFFFFh 5 MB Lower 3/4 \n0 0 1 1 0 0 thru 63 000000h – 3FFFFFh 4 MB Lower 1/2 0 1 0 0 1 2 thru 127 020000h – 7FFFFFh 8,064 kB Upper 63/64 \n0 1 0 1 0 4 thru 127 040000h – 7FFFFFh 7,936 kB Upper 31/32 \n0 1 0 1 1 8 thru 127 080000h – 7FFFFFh 7,680 kB Upper 15/16 0 1 1 0 0 16 thru 127 100000h – 7FFFFFh 7 MB Upper 7/8 \n0 1 1 0 1 32 thru 127 200000h – 7FFFFFh 5 MB Upper 3/4 \n0 1 1 1 0 64 thru 127 400000h – 7FFFFFh 4 MB Upper 1/2 \nX X 1 1 1 None None None None\n1 0 0 0 1 0 thru 127 000000h – 7FEFFFh 8,188 kB Lower 2047/2048\n1 0 0 1 0 0 thru 127 000000h – 7FDFFFh 8,184 kB Lower 1023/1024\n1 0 0 1 1 0 thru 127 000000h – 7FBFFFh 8,176 kB Lower 511/512 \n1 0 1 0 X 0 thru 127 000000h – 7F7FFFh 8,160 kB Lower 255/256 1 1 0 0 1 0 thru 127 001000h – 7FFFFFh 8,188 kB Upper 2047/2048\n1 1 0 1 0 0 thru 127 002000h – 7FFFFFh 8,184 kB Upper 1023/1024\n1 1 0 1 1 0 thru 127 004000h – 7FFFFFh 8,176 kB  Upper 511/512 \n1 1 1 0 X 0 thru 127 008000h – 7FFFFFh 8,160 kB  Upper 255/256 \nNote\n24.X = don’t care.\nDatasheet 52 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.6.2 Individual block lock (IBL) protection\nIndividual block lock bits (IBL) are volatile, with one bit for each sector / block, and each bit can be individually \nmodified. By issuing the IBL or GBL commands, a IBL bit is set to ’0’ protecting each related sector / block. By issuing the IBUL or GUL commands, a IBL bit is cleared to ’1’ unprotecting each related sector or block. By issuing the IBLRD command the state of each IBL bit can be read. This feature allows software to easily protect individual sectors / blocks against inadvertent changes, yet does no t prevent the easy removal of protection when changes \nare needed. The IBL’s can be set or cleared as often as needed as they are volatile bits. \nEvery main 64 KB block and the 4 KB sectors in bottom and top blocks has a volatile individual block lock bit (IBL) \nassociated with it. When a sector / block IBL bit is ’0’ ,  the related sector/block is protected from program and \nerase operations. \nIf the pointer region protection is  enabled this protected region is logically ORed with the IBL bits. \nFollowing power-up, hardware reset, or software reset the default state [IBLLBB = 1] (see Table 20 ) all individual \nIBL bits are set to ’0’ in the protected state. In order to  program or erase the array the global IBL unlock or the \nSector / Block IBL Unlock command must be given before the Program or Erase commands. When [IBLLBB = 0], all the individual IBL bits are set to ’1’ in the un-protected state following power-up, hardware reset, or software reset.\nFigure 25 Individual block lock / pointer region protection control\nNotes\n25.The ‘M’ is the top 64 KB block.26.The ‘N’ is the top 4 KB sector.Pointer region  \nprotection \nenabled\nA10 = \x1fIndividual  block bock \nbits (IBL) array\nWPS = \x1fᾀ\nSector N\nLogical ORFlash \nmemory \narray\nSector N\nSector N-15 Sector N-15\nLogical ORBlock M\nBlock M-1\n.........\nBlock M-1\nLogical OR\nBlock 1Block 1\nLogical OR\n.........\nSector 15\nSector 0Block 0\n...Sector 15\nLogical OR\nSector 0\nLogical OR ......\n... ...... ... ...\nDatasheet 53 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.6.3 Pointer region protection (PRP)\nThe pointer region protection is defined by a non-volatile address pointer that selects any 4 KBsector as the \nboundary between protected and unprotected regions in the memory. This provides a protection scheme with \nindividual sector granularity that remains in effect ac ross power cycles and reset operations. PRP settings can \nalso be protected from modification until the next power cycle, until a password is supplied, or can be permanently locked. PRP can be used in combination with either the legacy block protection or individual block \nlock protection methods. When enabled, PRP protection is logically ORed with the protection method selected \nby the WPS bit (CR2V[2])\nThe set pointer region protection (S PRP FBh or 4SPRP E3h) command (see "Pointer Region command" on page \n112) or Write Any Register (WRAR 71h) co mmand to write the PRPR register (see "Write Any Register (WRAR \n71h)" on page 82) is used to enable or disable PRP , and set the pointer value.\nAfter the set block/pointer protection command is given or Write Any Register (WRAR 71h) command to write the \nPRPR register, the value of A10 enables or disables the pointer protection mechanism. If A10 = 1, then the pointer protection region is disabled. This is the default state, and the rest of pointer values are don’t care. If A10 = 0, then \nthe pointer protection region is enabled. The value of A10 is written in the Non-volatile Pointer bit in the PRPR. \nThe pointer address values for RFU bits are don’t care  but these bit locations will read back as ones. See "Pointer \nRegion Protection Register (PRPR)" on page 45 for additional information on the PRPR.\nIf the pointer protection mechanism is enabled, the po inter value determines the block boundary between the \nprotected and the unprotected regions in the memory. The pointer boundary is set by the three (A23-A12) or four (A31-A12) address bytes written to the non-volatile pointe r value in the PRPR. The area that is unprotected will \nbe inclusive of the 4KB sector selected by the pointer value. \nThe value of A9 is used to determine whether the region that is unprotected will start from the top (highest \naddress) or bottom (lowest address) of the memory array to  the location of the pointer.  If A9 = 0 when the SPRP \nor 4SPRP command is issued followed by a the address, th en the 4 kB sector which includes that address and all \nthe sectors from the bottom up (zero to higher address) will be unprotected. If A9 = 1 when the SPRP or 4SPRP-\ncommand is issued followed by address then the 4 kB sect or which includes that address and all the sectors from \nthe top down (max to lower address) will be unprotected. The value of A9 is in the non-volatile pointer value in \nthe PRPR. \nThe A11 bit can be used to protect all sectors. If A11 = 1, then all sectors are protected. If A11 = 0, then the unpro-\ntected range will be determined by Amax-A12. The value of  A11 is in the non-volatile pointer value in the PRPR. \nThe SPRP or 4SPRP command is ignored during a suspend operation because the pointer value cannot be erased \nand re-programmed during a suspend.\nThe SPRP or 4SPRP command is ignored if NVLOCK PR[0] = 0.\nThe Read Any Register 65h command (see "Read Any Register (RDAR 65h)" on page 79) reads the contents of \nPRP access register. This allows th e contents of the pointer to be read out for test and verification.\nTable 30 PRP table\nA11 A10 A9Protect \naddress \nrangeUnprotect \naddress rangeComment\nx 1 x None All A10 = 1 is PRP disabled (this is the default state and the rest of pointer \nvalue is don\'t care).\n0 0 0 1FFFFFF to \n(A[31:12]+1)A[31:12] \nto 0000000The 4 kB sector which includes that address and all the sectors from \nthe bottom up (zero to higher address) will be unprotected.\n0 0 1 (A[31;12]-1) \nto 00000001FFFFFF\nto A[31:12]The 4kB sector which includes that address and all the sectors from \nthe Top down (max to lower address) will be unprotected.\n1 0 x 1FFFFFF to \n000000Not \nApplicableA10 = 0 and A11 = 1 means protect all sectors and Amax-A12 are don\'t \ncare.\nDatasheet 54 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\nIf the pointer protect scheme is active (A10 = 0), and the pointer  protects any portion of the address space to \nwhich an Erase command is applied, the Erase command fails. For example, if the pointer protection is protecting \n4 KB of the array that would be affected by a Block Er ase command, that erase command fails. Chip Erase (CEh) \ncommand is ignored if PRP is enabled (A10 = 0) and this will set the E_ERR status bit.\nIf the pointer region protection is enabled this protection is logically ORed with either the legacy block protection \nregion if WPS CR2V[2] = 0 or individual bloc k lock protection if WPS CR2V[2] = 1 (See Figure 24 ).\n7.7 Individual and region protection\nIndividual and region protection (IRP) is the name used for a set of independent hardware and software methods \nused to disable or enable programming or erase operatio ns on Security Regions 2 and 3 and the Pointer Region \nProtection Register.\nEach method manages the state of the NVLOCK bit (PR[0] ). When NVLOCK = 1, the Security Regions 2 and 3 and \nthe Pointer Region Protection Register (PRPR) may be programmed and erased. When NVLOCK = 0, the Security \nRegions 2 and 3 and PRPR can not be programmed or erased. Note, the Security Regions 2 and 3 are also protected respectively by LB2 or LB3 = 1 (CR1NV[4:5]). \nPower supply lock-down protection is the default method. This method sets the NVLOCK bit to ’1’ during POR or \nhardware reset so that the NVLOCK related areas and registers are unprotected by a device reset. The PRL (A6h) command clears the NVLOCK bit to ’0’ to protect the NV LOCK related areas and registers. There is no command \nin the power supply lock-down method to set the NVLOCK bi t to ’1’ , therefore the NVLOCK bit will remain at ’0’ \nuntil the next power-off or hardware reset. The power su pply lock-down method allows boot code the option of \nchanging Security Regions 2 and 3 or the value in PRPR, by  programming or erasing these non-volatile areas, then \nprotecting these non-volatile areas from further chan ge for the remainder of normal system operation by \nclearing the NVLOCK bit to ’0’ . This is some times called boot-code controlled protection. \nThe password method clears the Protection Register NVLOCK bit to 0 and sets the SECRRP bit = IRP[6] during POR \nor hardware reset to protect the NVLOCK related area s and registers. The SECRRP bit determines whether \nSecurity Region 3 is readable. A 64-bit password may be permanently programmed and hidden for the password \nmethod. The PASSU (EAh) command can be used to pr ovide a password for comparison with the hidden \npassword. If the password matches, the NVLOCK bit is set to ’1’ to unprotect the NVLOCK related areas and registers. The PRL (A6h) command can be used to clear the NVLOCK bit to ’0’ to turn on protection again. \nThe permanent method permanently sets the SECRRP bit = 1 and clears NVLOCK to 0. This permanently protects \nthe Security Regions 2 and 3 and the PRPR.The selectio n of the NVLOCK bit management method is made by \nProgramming OTP bits in the IRP Register (IRP[2 or 1 or  0] so as to permanently select the method used. An \noverview of all methods is shown in Figure 26 .\nDatasheet 55 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\nFigure 26 Permanent, password and power supply lock-down protection overviewPower on reset  or\nhardware reset\nPassword \nprot ect ion enabled\nIRP[2]=0\nSecurit y \nRegion 3 read \npass word prot ect ion \nenabled\nIRP[6]=0Power s upply \nlock -down \nprot ect ion enabled\nIRP[1]=0\n NVLOCK = 0\nSecurit y Region 3 \nread & write locked\nSecurit y Region 2\nwrite locked\npoint er region prot ect ion \nwrite locked\nPassword unlock\n NVLOCK = 1\nSecurity Regions 2 & 3 \nand point er region \nprot ect ion are unlocked\nreadable, erasable and \nprog ra mma bl e\nNV LOCK bit  writ eNo\nNoYes\nYes NV LOCK = 0\nSecurity Regions 2 & 3 \n Writ e Locked\nPoint er Region Prot ect ion \nWrit e Locked\nPassword Unlock\n NV LOCK = 1\nSecurity Regions 2 & 3 \nand point er region \nprot ect ion are unlocked\nerasable and \nprogrammable\nNVLOCK bit  writ eNo\nNoYes\nYes NVLOCK = 1\nSecurity Regions 2 & 3   \nand point er region \nprot ect ion are unlocked\nreadable, erasable and \nprog ra mma bl e\nNV LOCK bit  writ e\n NVLOCK = 0\n Security Regions 2 & 3 \n write locked\npoint er region prot ect ion \nwrite lockedNo\nYesYes\nYesNoDefault power lock \nprot ect ion\nIRP Register bits locked\nStatus Register Protect  \nLockedIRP Register bits locked\nStatus Register protect \nlockedIRP Register bits \nprogrammable\n status register protect \nOTP opt ion programmable\nRead Password Protection Mode\nP r o tec ts S ec u r i ty  R egio n s 3 fr o m  r ead ,  \nerase and programming, Securit y \nRegion 2 and point er region \nprot ect ion from eras e and \nprogramming aft er powerup. A \nPassword Unlock Com m and will \nenable changes to Security Region 2 & \n3 and point er region prot ect ion.  A \nN VLO C K  B it W r i te c o m m an d  tu r n s th e \nprot ect ion back on. Password Protection mode\nP r o tec ts S ec u r i ty R egio n s 2 & 3 an d  \npoint er region prot ect ion from eras e \nand programming aft er power -up. A Password Unlock com m and will \nenable changes to Security Region 2 & \n3 and point er region prot ect ion.  A \nN VLO C K  B it W r i te c o m m an d  tu r n s th e \nprot ect ion back on. Po w er S u pp ly  L o ck-D o w n   \nProtection mode\nDo es n o t p r o tec t S ec u r ity  R egi o n s 2 & \n3 and point er region prot ect ion f rom erase and program m ing after power -\nup. The NVLOCK bit write com m and \np r o tec ts S ec u r i ty  R egio n s 2 & 3 an d  \np o in ter  r egi o n  p r o tec ti o n  u n ti l th e \nnext power off or reset . De fa ul t   mode\nDo es n o t p ro tect S ec u rity R egio n s 2 & \n3 and point er region prot ect ion from \nerase and program m ing after power -\nup.  The  NV L OCK B i t  Writ e  comma nd \nprotects Security Regions 2 & 3 and \npoint er region prot ect ion unt il t he \nnext  power of f or res et . \nThe OTP Opt ion for St at us  Regis t er \nProt ect  is available t o be \nprog ra mme d.Permanent protection \nenabled\nIRP[0]=0\nIRP Register bits locked\nStatus Register protect\n locked\nNV LOCK =0\nperm anent erase and \nprogram prot ect ion of  \nSecurity Regions 2 & 3 and \npoint er region prot ect ionNo No\nPerm anent Protection m ode\nP er m an en tly p r o tec ts S ec u r ity \nRegions 2 & 3 and pointer region \nprot ect ion from eras e and \nprog ra mmi ng  Note\nIf S ecu rity Regio n  lo ck b its LB 2 & 3 \nare protected CR1NV[5:4]=1, this \noverrides  t he NVLOCK and t he \nS ec u r i ty  R egio n s p r o tec ted  b y  th e LB  \nbit s  will be permanent ly prot ect ed \nfrom  erase and program m ing.  If read \npass word is  enabled Securit y Region 3 \ncan still be read passwo rd pro tected.Yes Yes\nNoNV LOCK = 1\nSecurity Regions 2 & 3  \nand point er region \nprot ect ion are unlocked\nreadable, erasable and \nprogrammable\nNVLOCK bit  writ e\n NV LOCK = 0\nSecurit y Regions  2 & 3\n write locked\npoint er region prot ect ion \nwrite lockedNo\nYes\nDatasheet 56 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.7.1 IRP Register\nThe IRP register is used to permanently configure the beha vior of individual and region protection (IRP) features, \nsee Table 20 .\nAs shipped from the factory, all devices default to the Power Supply Lock-Down Protection mode, with all regions \nunprotected. \nThe device programmer or host system must then choose which protection method to use by programming one \nof the One-time Programmable bits, permanent, Powe r Supply Lock-Down or Password Protection mode. \nProgramming one of these bits locks the part permanently in the selected mode:\nFactory defaults IRP Register\n• IRP[6] = ’1’ = Read Password Protection mode not enabled.• IRP[4] = ’1’ = IBL bits power-up in protected state.\n• IRP[2] = ’1’ = Password Protection mode not enabled.\n• IRP[1] = ’1’ = Power Supply Lock-Down Protection mode not enabled but is the default mode.• IRP[0] = ’1’ = Permanent Protection mode not enabled.\nIRP register programming rules:\n• If the Read Password mode is chosen, the SECRRP bit must be programmed prior or at the same time as setting \nthe Password Protection mode lock bits IRP[2].\n• If the IBL bits power-up in Unprotected mode is chosen, the IBLLBB bit must be programmed prior or at the \nsame time as setting one of the Protection Mode Lock bits IRP[2:0].\n• If the Password mode is chosen, the password must be programmed prior to setting the Password Protection \nMode Lock bits IRP[2].\n• The Protection modes are mutually exclusive, only one may be selected. Once one of the Protection modes is \nselected IPRP[2:0], the IRP Register bits are permanen tly protected from programming and no further changes \nto the OTP Register bits is allowed. If an attempt to change any of the register bits above, after the Protection mode is selected, the operation will fail and P_ERR (SR2V[5]) will be set to 1.\nThe programming time of the IRP Register is the same as the typical page progra mming time. The system can \ndetermine the status of the IRP register programming oper ation by reading the WIP bit in the Status Register. See \n"Status Register 1" on page 30 for information on WIP . See "Password Protection mode" on page 57.\n7.7.1.1 IBL Lock Boot bit\nThe default IBL Lock bit IRP[4] = 1, all the IBL bits on powe r-up or reset (after a hardware reset or software reset) \nto the “protected state” . If the IBL Lock bit IRP[4] = 0 (p rogrammed), the IBL power-up or reset to the “unprotected \nstate” .\nDatasheet 57 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n7.7.2 Protection Register (PR)\n7.7.2.1 NVLOCK bit (PR[0])\nThe NVLOCK bit is a volatile bit for protecting:\n• Pointer Region Protection Register•S e c u r i t y  R e g i o n s  2  a n d  3\nWhen cleared to ’0’ , NVLOCK locks the related regions. When set to ’1’ , it allows the related regions to be changed. \nSee "Protection Register (PR)" on page 44 for more information.\nThe PRL command is used to clear the NVLOCK bit to ’0’ . Th e NVLOCK bit should be cleared to ’0’ only after all the \nrelated regions are configured to the desired settings.\nIn Power Supply Lock-Down Protection mode, the NVLOCK is set to ’1’ during POR or a hardware reset. A Software \nReset command does not affect the NVLOCK bit. When cleared to ’0’ , no Software command sequence can set the NVLOCK bit to ’1’ , only another hardware  reset or power-up can set the NVLOCK bit.\nIn the Password Protection mode, the NVLOCK bit is cleared to ’0’ during POR, or a hardware reset. The NVLOCK \nbit can only be set to ’1’ by the Password Unlock command.\nThe permanent method permanently clears NVLOCK to 0. This permanently protects the Security Regions 2 and \n3 and the PRPR.\n7.7.2.2 Security Region Read Password Lock bit (SECRRP , PR[6])\nThe SECRRP bit is a volatile bit for read protecting Securi ty Region 3. When SECRRP[6] = 0, the Security Region 3 \ncan not be read, See "Protection Register (PR)" on page 44 for more information.\nIn the Password Protection mode, the SECRRP bit is set equal to IRP[6] during POR or software or hardware reset. \nThe NVLOCK bit can only be set to ’1’ by the Password  Unlock command. A software reset does not affect the \nNVLOCK bit.\nThe permanent method permanently sets the SECRRP bi t = 1. This permanently leaves Security Region 3 \nreadable.\n7.7.3 Password Protection mode\nPassword Protection mode allows an even higher level of  security than the Power Su pply Lock-Down Protection \nmode, by requiring a 64-bit password for unlocking the NVLO CK bit. In addition to this password requirement, \nafter power up, hardware reset, the NVLOCK bit is cleared to ’0’ to ensure protection after power-up or reset. Successful execution of the password unlock command by entering the entire password sets the NVLOCK bit to \n1, allowing for sector NVLOCK related areas and registers modifications.\nPassword protection notes:\n• Once the password is programmed and verified, the Password mode (IRP[2] = 0) must be set in order to prevent \nreading the password.\n• The Password Program command is only capable of programming ’0’s. Programming a ’1’ after a cell is \nprogrammed as a ’0’ results in the cell left as a ’0’ with no programming error set.\n• The password is all ’1’s when shipped from Infineon. It is located in its own memory space and is accessible \nthrough the use of the Password Program, Password Read, RDAR, and WRAR commands.\n• All 64-bit password combinations are valid as a password.\n• The Password mode, once programmed, prevents reading the 64-bit password and further password \nprogramming. All further Program and Read commands to the password region are disabled and these \ncommands are ignored or return undefined data. There is no means to verify what the password is after the Password mode lock bit is selected. Password verifi cation is only allowed before selecting the password \nProtection mode.\n• The Protection mode lock bits are not erasable.\nDatasheet 58 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData protection\n• The exact password must be entered in order for the unlocking function to occur. If the Password Unlock \ncommand provided password does not match the hidden in ternal password, the unlock operation fails in the \nsame manner as a programming operation on a protected sector. The P_ERR bit is set to one, the WIP bit remains set, and the NVLOCK bit remains cleared to 0.\n• The Password Unlock command cannot be accepted any faster than once every 100 µs ± 20 µs. This makes it \ntake an unreasonably long time (58 million years) for a hacker to run through all the 64-bit combinations in an attempt to correctly match a password. The Read Status Register 1 command may be used to read the WIP bit to determine when the device has completed the Pass word Unlock command or is ready to accept a New \nPassword command. When a valid password is provided  the Password Unlock command does not insert the \n100 µs delay before returning the WIP bit to zero.\n• If the password is lost after selecting the Password mode, there is no way to set the NVLOCK bit = 1.\n7.7.4 Security Region read password protection\nThe Security Region read password protection enables protecting Security Region 3 from read, program and \nerase.\nSecurity Region read password protection is an optional  addition to the Password Protection mode (described \nabove). The Security Regions read password protection is  enabled when the user prog rams SECRRP bit ‘IRP[6] = \n0. The SECRRP bit IRP[6] must be programmed prior or at  the same time as setting the Password Protection mode \nlock bits IRP[2].\nThe Security Regions read password protection is no t active until the password is programmed, IRP[2] is \nprogrammed to 0. \nWhen the SECRRP (PR[6]) bit is set to 0 the Security Region  3 is not readable. If these regions are read the resulting \ndata is invalid and undefined.\n7.7.5 Recommended IRP protection process\nDuring system manufacture, the Flash device configuration should be defined by: \n• Programming the Security Regions as desired.\n• Set Pointer Region Protection Register as desired• Program the Password register (PASS) if password protection will be used.\n• Program the IRP Register as desired, including the selection of permanent, Power Supply Lock-Down or \nPassword IRP Protection mode in IRP[2:0]. It is very important to explicitly select a Protection mode so that later accidental or malicious programming of the IRP register is  prevented. This is to ensure that only the intended \nprotection features are enabled. Before or while programming the IRP register:\n- The IBLLBB bit (IRP[4]) may be used to cause all the IBL bits to power up in the unprotected state.\n- The SECRRP bit (IRP[6]) may be programmed to select Security Regions read password protection to use the \npassword to control read access to the Security Region 3.\nDuring system power up and boot code execution: If the Power Supply Lock-Down Protection mode is in use, \ntrusted boot code can determine whether there is any need to modify the NVLOCK related areas or registers. If no changes are needed the NVLOCK bit can be cleared to  0 via the PRL command to protect the NVLOCK related \nareas or registers from changes during the remainder of normal system operation while power remains on.\nDatasheet 59 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8C o m m a n d s\nAll communication between the host system and FL-L fami ly memory devices is in the form of units called \ncommands. See "Command protocol" on page 17 for details on command protocols. \nAlthough host software in some cases is used to directly  control the SPI interface signals, the hardware interfaces \nof the host system and the memory device generally handle  the details of signal relationships and timing. For this \nreason, signal relationships and timing are not covered in detail within this software interface focused section of \nthe document. Instead, the focus is on the logical sequence  of bits transferred in each command rather than the \nsignal timing and relationships. Following are some genera l signal relationship descriptions to keep in mind. For \nadditional information on the bit level format an d signal timing relationships of commands, see "Command \nprotocol" on page 17.\n• The host always controls the Chip Select (CS#), Serial Clock (SCK), and Serial Input (SI) - SI for single bit wide \ntransfers. The memory drives Serial Output (SO) for sing le bit read transfers. The host and memory alternately \ndrive the IO0-IO3 signals during dual and quad transfers. \n• All commands begin with the host selecting the memory by driving CS# LOW before the first rising edge of SCK. \nCS# is kept low throughout a command and when CS# is returned HIGH the command ends. Generally, CS# remains LOW for eight bit transfer multiples to transfer  byte granularity information. No commands will be \naccepted if CS# is returned HIGH not at an 8-bit boundary.\n8.1 Command set summary\n8.1.1  Extended addressing\n• Instructions that always require a 4-byte address, used to access up to 32 Gb of memory:\n• A 4 -byte Address mode for backward compatibility to the 3-byte address instructions. The standard 3-byte \ninstructions can be used in conjunction with a 4-byte Address mode controlled by the Address Length Config-\nuration bit (CR2V[0]). The default value of CR2V[0] is load ed from CR2NV[1] (following power up, hardware reset, \nor software reset), to enable default 3-byte (24-bit) or 4-byte (32-bit) addressi ng. When the address length \n(CR2V[0]) set to 1, the legacy comm ands are changed to require 4-bytes (32 bits) for the address field. The \nfollowing instructions can be used in conjunction with the 4-byte Address mode configuration to switch from \n3-bytes to 4-bytes of address field.Table 31 Extended address 4-byte address commands\nCommand name Function Instruction (hex)\n4READ Read 13\n4FAST_READ Read fast 0C\n4DOR Dual output read 3C\n4QOR Quad output read 6C\n4DIOR Dual I/O read BC\n4QIOR Quad I/O read EC\n4DDRQIOR DDR quad I/O read EE\n4PP Page program 12\n4QPP Quad page program 34\n4SE  Sector erase 21\n4HBE Half block erase 53\n4BE Block erase DC\n4IBLRD IBL read E0\n4IBL IBL lock E1\n4IBUL IBL unlock E2\n4SPRP Set pointer region protection E3\nDatasheet 60 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nTable 32 Extended address 4-byte Address mode with 3-byte Address commands\nCommand name Function Instruction (hex)\nRSFDP Read SFDP 5A\nREAD Read 03\nFAST_READ Read Fast 0B\nDOR Dual Output Read 3B\nQOR Quad Output Read 6B\nDIOR Dual I/O Read BB\nQIOR Quad I/O Read EB\nDDRQIOR DDR Quad I/O Read ED\nPP Page Program 02\nQPP Quad Page Program 32\nSE  Sector Erase 20\nHBE Half Block Erase 52\nBE Block Erase D8\nRDAR Read Any Register 65\nWRAR Write Any Register 71\nSECRE Security Region Erase 44\nSECRP Security Region Program 42\nSECRR Security Region Read 48\nIBLRD IBL Read 3D\nIBL IBL Lock 36\nIBUL IBL Unlock 39\nSPRP Set Pointer Region Protection FB\nDatasheet 61 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.1.2 Command summary by function\nTable 33 FL-L family command set (sorted by function)\nFunctionCommand \nname Command description Instruction \nvalue (hex)Maximum \nfrequency \n(MHz)Address \nlength \n(bytes)QPI\nRead device \nIDRDID Read ID (JEDEC Manufacturer ID) 9F 108 0 Yes\nRSFDP Read JEDEC serial flash discoverable \nparameters 5A 108 3 or 4 Yes\nRDQID Read Quad ID AF 108 0 Yes\nRUID Read Unique ID 4B 108 0 Yes\nRegister \naccessRDSR1 Read Status Register 1 05 108 0 Yes\nRDSR2 Read Status Register 2 07 108 0 No\nRDCR1 Read Configuration Register 1 35 108 0 NoRDCR2 Read Configuration Register 2 15 108 0 No\nRDCR3 Read Configuration Register 3 33 108 0 No\nRDAR Read Any Register 65 108 3 or 4 Yes\nWRR Write Register (Status-1 and \nConfiguration-1,2,3) 01 108 0 Yes\nRegister \naccessWREN Write Enable for Non-volatile Data Change 06 108 0 Yes\nWRENV Write Enable for Volatile Status and \nConfiguration Registers50 108 0 Yes\nWRAR Write Any Register 71 108 3 or 4 Yes\nCLSR Clear Status Register 30 108 0 Yes\n4BEN Enter 4-byte Address mode B7 108 0 Yes\n4BEX Exit 4-byte Address mode E9 108 0 Yes\nSBL Set Burst Length 77 108 0 Yes\nQPIEN Enter QPI 38 108 0 No\nQPIEX Exit QPI F5 108 0 Yes\nDLPRD Data Learning Pattern Read 41 108 0 Yes\nPDLRNV Program NV Data Learning Register 43 108 0 Yes\nWDLRV Write Volatile Data Learning Register 4A 108 0 Yes\nNote\n27.Commands not supported in QPI mode have undefined be havior if sent when the device is in QPI mode.\nDatasheet 62 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nRead flash \narrayREAD Read 03 50 3 or 4 No\n4READ Read 13 50 4 No\nFAST_READ Fast Read 0B 108 3 or 4 No\n4FAST_READ Fast Read 0C 108 4 No\nDOR Dual Output Read 3B 108 3 or 4 No\n4DOR Dual Output Read 3C 108 4 No\nQOR Quad Output Read 6B 108 3 or 4 No\n4QOR Quad Output Read 6C 108 4 No\nDIOR Dual I/O Read BB 108 3 or 4 No\n4DIOR Dual I/O Read BC 108 4 No\nQIOR Quad I/O Read (CR1V[1] = 1) or \nCR2V[3] = 1EB 108 3 or 4 Yes\n4QIOR Quad I/O Read (CR1V[1] = 1) or\nCR2V[3] = 1EC 108 4 Yes\nDDRQIOR DDR Quad I/O Read (CR1V[1] = 1 or \nCR2V[3] = 1)ED 54 3 or 4 Yes\n4DDRQIOR DDR Quad I/O Read (CR1V[1] = 1 or \nCR2V[3] = 1)EE 54 4 Yes\nProgram \nflash arrayPP Page Program 02 108 3 or 4 Yes\n4PP Page Program 12 108 4 Yes\nQPP Quad Page Program 32 108 3 or 4 No\n4QPP Quad Page Program 34 108 4 No\nErase flash \narraySE Sector Erase 20 108 3 or 4 Yes\n4SE Sector Erase 21 108 4 Yes\nHBE Half Block Erase 52 108 3 or 4 Yes\n4HBE Half Block Erase 53 108 4 Yes\nBE Block Erase D8 108 3 or 4 Yes\n4BE Block Erase DC 108 4 Yes\nCE Chip Erase 60 108 0 YesCE Chip Erase (alternate instruction) C7 108 0 Yes\n Erase \n/program\nsuspend \n/resumeEPS Erase / Program Suspend 75 108 0 Yes\nEPR Erase / Program Resume 7A 108 0 Yes\nSecurity \nRegion arraySECRE Security Region Erase 44 108 3 or 4 Yes\nSECRP Security Region Program 42 108 3 or 4 Yes\nSECRR Security Region Read 48 108 3 or 4 YesTable 33 FL-L family command set (sorted by function)\n (continued)\nFunctionCommand \nname Command description Instruction \nvalue (hex)Maximum \nfrequency \n(MHz)Address \nlength \n(bytes)QPI\nNote\n27.Commands not supported in QPI mode have undefined be havior if sent when the device is in QPI mode.\nDatasheet 63 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.1.3 Read Device identification\nThere are multiple commands to read information about the device manufacturer, device type, and device \nfeatures. SPI memories from different vendors have used different commands and formats for reading infor-\nmation about the memories. The FL-L family supports the three device information commands.\n8.1.4 Register read or write\nThere are multiple registers for reporting embedded op eration status or controlling device configuration \noptions. There are commands for reading or writing th ese registers. Registers contain both volatile and \nnon-volatile bits. non-volatile bits in registers are automatically erased and programmed as a single (write) \noperation.\n8.1.4.1 Monitoring operation status\nThe host system can determine when a write, program, er ase, suspend or other embedded operation is complete \nby monitoring the Write-In Progress (WIP) bit in the Stat us Register. The Read from Status Register 1 command \nor Read Any Register command provides the state of the WIP bit. The Read from Status Register 1 or Read Any \nRegister command provides the state of the program erro r (P_ERR) and erase error (E _ERR) bits in the status \nregister indicate whether the most recent program or  erase command has not completed successfully. When \nP_ERR or E_ERR bits are set to one, the WIP bit will re main set to one indicating the device remains busy and Array \nprotectionIBLRD IBL Read 3D 108 3 or 4 Yes\n4IBLRD IBL Read E0 108 4 Yes\nIBL IBL Lock 36 108 3 or 4 Yes\n4IBL IBL Lock E1 108 4 Yes\nIBUL IBL Unlock 39 108 3 or 4 Yes\n4IBUL IBL Unlock E2 108 4 Yes\nGBL Global IBL Lock 7E 108 0 Yes\nGBUL Global IBL Unlock 98 108 0 Yes\nSPRP Set Pointer Region Protection FB 108 3 or 4 Yes\n4SPRP Set Pointer Region Protection E3 108 4 Yes\nIndividual \nand region \nprotectionIRPRD IRP Register Read 2B 108 0 Yes\nIRPP IRP Register Program 2F 108 0 Yes\nPRRD Protection Register Read A7 108 0 Yes\nPRL Protection Register Lock (NVLOCK bit \nWrite) A6 108 0 Yes\nPASSRD Password Read E7 108 0 Yes\nPASSP Password Program E8 108 0 Yes\nPASSU Password Unlock EA 108 0 Yes\nReset RSTEN Software Reset Enable 66 108 0 Yes\nRST Software Reset 99 108 0 Yes\nMBR Mode Bit Reset FF 108 0 Yes\nDeep power \ndownDPD Deep Power-down B9 108 0 Yes\nRES Release from Deep Power down / Device \nIdAB 108 0 YesTable 33 FL-L family command set (sorted by function)  (continued)\nFunctionCommand \nname Command description Instruction \nvalue (hex)Maximum \nfrequency \n(MHz)Address \nlength \n(bytes)QPI\nNote\n27.Commands not supported in QPI mode have undefined be havior if sent when the device is in QPI mode.\nDatasheet 64 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nunable to receive most new operation commands. Only status reads (RDSR1 05h, RDSR2 07h), Read Any Register \n(RDAR 65h), Read Configuration RDCR1,  RDCR2 and RDCR3, Status Clear (CLS R 30h), and Software Reset (RSTEN \n66h followed by RST 99h) are valid comman ds when P_ERR or E_ERR is set to 1. A Clear Status Register (CLSR) \ncommand must be sent to return the device to STANDBY state. Alternatively, Hardware Reset, or Software Reset (RSTEN 66h followed by RST 99h) may be used to return the device to STANDBY state.\n8.1.4.2 Configuration\nThere are commands to read, write, and protect registers that control interface path width, interface timing, interface address length, and some aspects of data protection.\n8.1.5 Read flash array\nData may be read from the memory starting at any byte boundary. Data bytes are sequentially read from incre-mentally higher byte addresses until the host ends the data  transfer by driving CS# input High. If the byte address \nreaches the maximum address of the memory array, the read will continue at address zero of the array.\nBurst wrap read can be enabled by the Set burst leng th (SBL 77h) command with the requested wrapped read \nlength and alignment, see "Set Burst Length (SBL 77h)" on page 83. Burst Wrap read is only for Quad I/O and \nQPI modes.\nThere are several different read commands to specify diff erent access latency and data path widths. Double data \nrate (DDR) commands also define the address and Data bit relationship to both SCK edges:\n• The Read command provides a single address bit per SCK rising edge on the SI/IO0signal with read data returning \na single bit per SCK falling edge on the SO/IO1signal. This command has zero latency between the address and \nthe returning data but is limited to a maximum SCK rate of 50 MHz.\n• Other Read commands have a latency period between th e address and returning data but can operate at higher \nSCK frequencies. The latency depends on a configuration register read latency value.\n• The Fast Read command provides a single address bit per SCK rising edge on the SI/IO0 signal with read data \nreturning a single bit per SCK falling edge on the SO/IO1 signal.\n• Dual or Quad Output Read commands provide address on  SI/IO0 pin on the SCK rising edge with read data \nreturning two bits, or four bits of data pe r SCK falling edge on the IO0 - IO3 signals. \n• Dual or Quad I/O Read commands provide address two bits or four bits per SCK rising edge with read data \nreturning two bits, or four bits of data per SCK falling edge on the IO0 - IO3 signals. Continuous read feature is enabled if the mode bits value is Axh. \n• Quad Double Data Rate Read commands provide address four bits per every SCK edge with read data returning \nfour bits of data per every SCK edge on the IO0 - IO3 sign als. Continuous read feature is enabled if the Mode bits \nvalue is Axh. \n8.1.6 Program flash array\nProgramming data requires two commands: Write enable (WREN), and Page Program (PP , 4PP , QPP , 4QPP). The \nPage Program command accepts from 1-byte up to 256 co nsecutive bytes of data (page) to be programmed in \none operation. Programming means that bits can either be left at 1, or programmed from 1 to 0. Changing bits \nfrom 0 to 1 requires an erase operation.\n8.1.7 Erase flash array\nThe Sector Erase, Half Block Erase, Bloc k Erase, or Chip Erase commands set all the bits in a sector or the entire \nmemory array to 1. A bit needs to be first erased to 1 before programming can change it to a 0. While bits can be individually programmed from a 1 to 0, erasing bits from 0 to 1 must be done on a sector-wide, half block-wide, \nblock-wide or array-wide (chip) level. The Write En able (WREN) command must precede an erase command.\nDatasheet 65 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.1.8 Security Regions, legacy block pr otection, and indivi dual and region \nprotection\nThere are commands to read and program a separate one time protection (OTP) array for permanently protected \ndata such as a serial number. There are commands to control a contiguous group (block) of flash memory array sectors that are protected from program and erase oper ations.There are commands to control which individual \nflash memory array sectors are protected from program and erase operations. There is a mode to limit read \naccess of Security Region 3 until a password is supplied.\n8.1.9 Reset\nThere are commands to reset to the default conditions present after power on to the device. However, the Software Reset commands do not affect the current state of the SRP1 or NVLOCK bits. In all other respects a Software Reset is the same as a Hardware Reset. \nThere is a command to reset (exit from) the Continuous Read mode.\n8.1.10 Reserved\nSome instructions are reserved for future use. In this  generation of the FL-L family some of these command \ninstructions may be unused and not affect device  operation, some may have undefined results. \nSome commands are reserved to ensure  that a legacy or alternate source  device command is allowed without \neffect. This allows legacy software to issue some commands that are not relevant for the current generation FL-L family with the assurance these commands do not cause some unexpected action. \nSome commands are reserved for use in special versions of the FL-L not addressed by this document or for a \nfuture generation. This allows new host memory controller designs to plan the flexibility to issue these command instructions. The command format is defined if known at the time this document revision is published.\nDatasheet 66 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.2 Identification commands\n8.2.1 Read identification (RDID 9Fh)\nThe Read Identification (RDID) command provides read access to manufacturer identification, device \nidentification. The manufacturer identification is assi gned by JEDEC. The device identification values are \nassigned by Infineon.\nAny RDID command issued while a progra m, erase, or write cycle is in prog ress is ignored and has no effect on \nexecution of the program, erase, or  write cycle that is in progress.\nThe RDID instruction is shifted on SI / IO 0. After the last bit of the RDID instru ction is shifted into the device, a byte \nof manufacturer identification, two bytes of device identifi cation, will be shifted sequenti ally out on SO / IO1, As \na whole this information is referred to as ID. See "Device ID address map" on page 133 for the detail description \nof the ID contents. \nContinued shifting of output beyond the end of the de fined ID address space will provide undefined data. The \nRDID command sequence is terminated by driving CS# to the logic HIGH st ate anytime during data output. The \nRDID command is supported up to 108 MHz.\nFigure 27 Read Identification (RDID) command sequence\nThis command is also supported in QPI mode. In QPI mo de, the instruction is shif ted in on IO0-IO3 and the \nreturning data is shif ted out on IO0-IO3. \nFigure 28 Read Identification (RDID) QPI mode command \n8.2.2 Read Quad Identification (RDQID AFh)\nThe Read Quad Identification (RDQID) command provides  read access to manufacturer identification, device \nidentification. This command is an alternate way of reading the same information provided by the RDID \ncommand while in QPI mode. In all other respects the command behaves the same as the RDID command.\nThe command is recognized only when the device is in QP I mode (CR2V[3] = 1) or Qu ad mode (CR1V[1] = 1). The \ninstruction is shifted in on IO0-IO3 fo r QPI mode and IO0 for Quad mode. After the last bit of the instruction is \nshifted into the device, a byte of manufacturer identifica tion, two bytes of device identification will be shifted \nsequentially out on IO0-IO3. As a whole th is information is referred to as ID. See "Device ID address map" on \npage 133 for the detail description of the ID contents. \nContinued shifting of output beyond the end of the de fined ID address space will provide undefined data. The \ncommand sequence is terminated by driving CS# to the logic HIGH state anytime during data output.CS#\nSCK\nSI_ IO0\nSO_IO1\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nCS#\nSCLK\nIO0IO1\nIO2\nIO3\nPhase \n                         \n4 0 4 0 4 0 4 0 4 0 4 0  \n5 1 5 1 5 1 5 1 5 1 5 1  \n6 2 6 2 6 2 6 2 6 2 6 2  \n7 3 7 3 7 3 7 3 7 3 7 3  \nInstruction D1 D2 D3 D4 Data N\nDatasheet 67 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nFigure 29 Read Quad Identification  (RDQID) command sequence QPI mode\nFigure 30 Read Quad Identification (RDQID) command sequence Quad mode\n8.2.3 Read serial flash discover able parameters (RSFDP 5Ah)\nThe command is initiated by shifting on SI the instruct ion code “5Ah” , followed by a 24-bit (3-byte) address or \n32-bit (4-byte) address (depending on the current addre ss length configuration of CR2V[0]), followed by the \nnumber of read latency (dummy cycles) set by the variable read latency configuration in CR3V[3:0]. \nThe SFDP bytes are then shifted out on SO/IO1 starting at the falling edge of SCK after the dummy cycles. The \nSFDP bytes are always shifted out with the MSb first. If th e 24-bit (3-byte) address or 32- bit (4-byte) address is set \nto any non-zero value, the selected location in the SFDP space is the starting point of the data read. This enables \nrandom access to any parameter in the SFDP space. In SPI mode the RSFDP command is supported up to 108 MHz.\nThe variable read latency should be set to 8 cycles for compliance with the JEDE C JESD216 SFDP standard. The \nnon-volatile default variable read la tency in CR3NV is set to 8 dummy cycles when the device is shipped from \nInfineon. However, because the RSFDP command uses th e same implementation as other variable address \nlength and latency read commands, users are free to mo dify the address length and latency of the command if \ndesired. \nContinuous (sequential) read is su pported with the Re ad SFDP command.\nFigure 31 RSFDP command sequence[28]CS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                         \n4 0 4 0 4 0 4 0 4 0 4 0  \n5 1 5 1 5 1 5 1 5 1 5 1  \n6 2 6 2 6 2 6 2 6 2 6 2  \n7 3 7 3 7 3 7 3 7 3 7 3  \nInstruction D1 D2 D3 D4 Data N\nCS#\nSCLK\nIO0\nIO1\nIO2\nIO3\nPhase \n                         \n7 6 5 4 3 2 1 0 4 0 4 0  \n5 1 5 1  \n6 2 6 2  \n7 3 7 3  \nInstruction D1 Data N\nNote\n28.MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command 13h.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210A 10  \n76543210 \nInstruction          Address Dummy Cycles Data 1\nDatasheet 68 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nThis command is also supported in QPI mode. In QPI mo de, the instruction is shif ted in on IO0-IO3 and the \nreturning data is shif ted out on IO0-IO3. \nFigure 32 RSFDP QPI mode command sequence\n8.2.4 Read Unique ID (RUID 4Bh)\nThe Read Identification (RUID) comman d provides read access to factory se t read only 64-bit number that is \nunique to each device. \nThe RUID instruction is shifted on SI followed by four dummy bytes or 16 dummy bytes QPI (32 clock cycles). This \nlatency period (i.e., dummy bytes) allows the device’s inte rnal circuitry enough time to access data at the initial \naddress. During latency cycles, the data value on IO0-IO3 are “don’t care” and may be high impedance. \nThen the 8-bytes of Unique ID will be shifted sequentially out on SO / IO1. \nContinued shifting of output beyond the end of the defi ned Unique ID address space will provide undefined data. \nThe RUID command sequence is terminated by driving CS # to the logic HIGH state anytime during data output.\nFigure 33 Read Unique ID (RUID) command sequence\nThis command is also supported in QPI mode. In QPI mo de, the instruction is shif ted in on IO0-IO3 and the \nreturning data is shif ted out on IO0-IO3. \nFigure 34 Read Unique ID (RUID) QPI mode command CS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                         \n4 020  4 0 4 0 4 0 4 0 4 0  \n5 121  5 1 5 1 5 1 5 1 5 1  \n6 222  6 2 6 2 6 2 6 2 6 2  \n7 323  7 3 7 3 7 3 7 3 7 3  \nInstruct.                Address Dummy D1 D2 D3 D4\nCS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                                        \n76543210  \n636261605958575655 543210 \nInstruction Dummy Byte 1 Dummy Byte 4 64 bit Unique Serial Number\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                                 \n40 6056 4840 \n51 6157 5951 \n62 6258 610 62 \n73 6359 711 73 \nInstruction Dummy 1 Dummy 2 Dummy 3 Dummy 13 Dummy 14 Dummy 15 Dummy 16 64 bit Unique Serial Number\nDatasheet 69 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3 Register Access commands\n8.3.1 Read Status Register 1 (RDSR1 05h)\nThe Read Status Register 1 (RDSR1) command allows the Status Register 1 contents to be read from SO/IO1. \nThe volatile version of Status Register 1 (SR1V) contents  may be read at any time, even while a program, erase, \nor write operation is in progress. It is possible to read Status Register 1 continuously by providing multiples of \neight clock cycles. The status is updated for each eight cycle read.\nFigure 35 Read Status Register 1 (RDSR1) command sequence\nThis command is also supported in QPI mode. In QPI mo de, the instruction is shif ted in on IO0-IO3 and the \nreturning data is shif ted out on IO0-IO3. \nFigure 36 Read Status Register 1 (RDSR1) QPI mode command \n8.3.2 Read Status Register 2 (RDSR2 07h)\nThe Read Status Register 2 (RDSR2) command allows the Status Register 2 contents to be read from SO/IO1. \nThe volatile Status Register 2 SR2V contents may be re ad at any time, even while a program, erase, or write \noperation is in progress. It is possible to read the Status  Register 2 continuously by providing multiples of eight \nclock cycles. The status is updated for each eight cycle read. \nFigure 37 Read Status Register 2 (RDSR2) commandCS#\nSCK\nSI_IO0\nSO_IO1\nPhase76543210\n7654321076543210\nInstruction Status    Updated Status\nCS#\nSCLK\nIO0\nIO1IO2\nIO3\nPhase \n                  \n4 0 4 0 4 0 4 0\n5 1 5 1 5 1 5 1\n6 2 6 2 6 2 6 2\n7 3 7 3 7 3 7 3\nInstruct. Status Updated Status Updated Status\nCS#\nSCK\nSI_IO0\nSO_IO1\nPhase76543210\n7654321076543210\nInstruction Status    Updated Status\nDatasheet 70 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nIn QPI mode, status register 2 may be read  via the Read Any Register command, see "Read Any Register (RDAR \n65h)" on page 79 .\n8.3.3 Read Configuration Registers (RDC R1 35h) (RDCR2 15h) (RDCR3 33h)\nThe Read Configuration Register (RDCR1, RDCR2, RDCR3) commands allows the volatile Configuration Registers \n(CR1V, CR2V, CR3V) contents to be read from SO/IO1.\nIt is possible to read CR1V, CR2V and CR3V continuous ly by providing multiples of eight clock cycles. The \nConfiguration Registers contents may be read at any time, even while a program, erase,  or write operation is in \nprogress.\nFigure 38 Read Configuration Register (RDCR1) (RDCR2) (RDCR3) command sequence\nIn QPI mode, configuration register 1, 2 and 3 may be read via the Read Any Register command, see "Read Any \nRegister (RDAR 65h)" on page 79 .\n8.3.4 Write Registers (WRR 01h)\nThe Write Registers (WRR) command allows new values to  be written to the Status Register 1, Configuration \nRegister 1, Configuration Register 2 and Configuration Register 3. Before the Write Registers (WRR) command can \nbe accepted by the device, a Write Enable (WREN) or Wr ite Enable for Volatile Registers (WRENV) command must \nbe received. After the Write Enable (W REN) command has been decoded successfully, the device will set the write \nenable latch (WEL) in the Status Register to enable Non- volatile Write operations and direct the values in the \nfollowing WRR command to the Non-volatile SR1NV, CR1N V, CR2NV and CR3NV registers. After the Write Enable \nfor Volatile Registers (WRENV) command has been decode d successfully, the device directs the values in the \nfollowing WRR command to the volatile SR1V, CR1V, CR2V and CRV3 registers.\nThe Write Registers (WRR) command is entered by shifti ng the instruction and the data bytes on SI/IO0. The \nStatus Register is one data byte in length.\nA WRR operation directed to non-volatile registers by a preceding WREN command, first erases non-volatile \nregisters then programs the new value as a single operation, then copies the new non-volatile values to the volatile version of the registers. A WRR operation direct ed to volatile registers by  a preceding WRENV command, \nupdates the volatile registers without affecting the relate d non-volatile register values. The Write Registers (WRR) \ncommand will set the P_ERR or E_ERR bits if there is a failure in the WRR operation. See "Status Register 2 \nVolatile (SR2V)" on page 32 for a description of the Error bits. Th e device hangs busy until Clear Status Register \n(CLSR) is used to clear the error and WIP for return to Standby. Any Status or Configuration Register bit reserved for the future must be written as a ’0’ .\nCS# must be driven to the logic HIGH state after the eighth , sixteenth, twenty-fourth, or thirty-second bit of data \nhas been latched. If not, the Write Registers (WRR) comm and is not executed. If CS# is driven HIGH after the:\n• eighth cycle then only the St atus Register 1 is written\n• sixteenth cycle both the Status 1 and Configuration 1 Registers are written; \n• twenty-fourth cycle Status 1 and Configuration 1 and 2 Registers are written; • thirty-second cycle Status 1 and Configuration 1, 2, and 3 Registers are written.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nDatasheet 71 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nAs soon as CS# is driven to the logic HIGH state, the se lf-timed Write Registers (WRR) operation is initiated. While \nthe Write Registers (WRR) operation is in progress, the Stat us Register may still be read  to check the value of the \nWrite-in Progress (WIP) bit. The Writ e-in Progress (WIP) bit is a ’1’ durin g the Self-Timed Write Registers (WRR) \noperation, and is a ’0’ when it is completed. When the Writ e Registers (WRR) operation is completed, the write \nenable latch (WEL) is set to ’0’ . \nThe WRR command is protected from a hardware and software reset, the Hardware Reset and Software Reset \ncommand are ignored and have no effect on the execution of the WRR command.\nFigure 39 Write Registers (WRR) command sequence\nThis command is also supported in QPI mode. In QPI mode , the instruction and data is  shifted in on IO0-IO3. \nFigure 40 Write Register (WRR) command sequence QPI mode \nThe Write Registers (WRR) command allows the user to chan ge the values of the Legacy Block Protection bits in \neither the non-volatile Status Register 1 or in the volatile St atus Register 1, to define the size of the area that is to \nbe treated as read-only. \nThe Write Registers (WRR) command also allows the user to set the Status Register Protect 0 (SRP0) bit to a ’1’ or \n’0’ . The Status Register Protect 0 (SRP0) bit and Write Protect (WP#) signal allow the BP bits to be hardware \nprotected. \nWhen the Status Register Protect 0 (SRP0 SR1V[7]) bit is a ’0’ ,  it is possible to write to the Status Register provided \nthat the WREN or WRENV command has previously been se nt, regardless of whether Write Protect (WP#) signal \nis driven to the logic HIGH or logic LOW state.\nWhen the Status Register Protect 0 (SRP0) bit is set to ’1’ , two cases need to be considered, depending on the \nstate of Write Protect (WP#):\n• If Write Protect (WP#) signal is driven to the logic HIGH stat e, it is possible to write to  the Status and Configuration \nRegisters provided that the WREN or WRENV command has previously been sent before the WRR command.\n• If Write Protect (WP#) signal is driven to the logic LOW state, it is not possible to write to the Status and \nConfiguration Registers even if the WREN or WRENV command has previously been sent before the WRR \ncommand. Attempts to write to the Status and Configurat ion Registers are rejected, not accepted for execution, \nand no error indication is provided. As a consequence, al l the data bytes in the memory area that are protected \nby the Legacy Block Protection bits of the Status Register, are also hardware protected by WP#.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7654321076543210765432107654321076543210\nInstruction Input Status Register-1 Input Conf  Register-1 Input Conf Register-2 Input Conf Register-3\nCS#\nSCLK\nIO0\nIO1\nIO2\nIO3\nPhase \n                      \n4 0 4 0 4 0 4 0 4 0\n5 1 5 1 5 1 5 1 5 1\n6 2 6 2 6 2 6 2 6 2\n7 3 7 3 7 3 7 3 7 3\nInstruct. Input Status 1 Input Config 1 Input Config 2 Input Config 3\nDatasheet 72 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nNote  The WP# hardware protection can be provided:\n• by setting the Status Register Protect 0 (SRP0) bit after driving write protect (WP#) signal to the logic LOW state;\n• or by driving Write Protect (WP#) signal to the logic LOW state after setting the Status Register Protect 0 (SRP0) \nbit to a ’1’ .\nThe only way to release the hardware protection is to pu ll the Write Protect (WP#) signal to the logic HIGH state. \nIf WP# is permanently tied HIGH, hardware protection of the BP bits can never be activated.\nHardware protection is disabled when Quad mode is enab led (CR1V[1] = 1) or QPI mode  is enabled (CR2V[3] = 1) \nbecause WP# becomes IO2; therefore, it cannot be utilized.\nSee "Status Register Protect (SRP1, SRP0)" on page 48 for a table showing the SRP and WP# control of Status \nand Configuration protection.\n8.3.5 Write Enable (WREN 06h)\nThe Write Enable (WREN) command sets the write enable la tch (WEL) bit of the Status Register 1 (SR1V[1]) to a \n’1’ . The Write Enable Latch (WEL) bit must be set to a ’1 ’ by issuing the Write Enable  (WREN) command to enable \nWrite, Program and Erase commands.\nCS# must be driven into the logic HIGH state after the ei ghth bit of the instruction byte has been latched in on \nSI/IO0. Without CS# being driven to the logic HIGH state after the eighth bit of the instruction byte has been \nlatched in on SI/IO0, the write enable operation will not be executed.\nFigure 41 Write Enable (WREN) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 42 Write Enable (WREN) command sequence QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 73 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.6 Write Disable (WRDI 04h)\nThe Write Disable (WRDI) command clears  the Write Enable Latch (WEL) bit of the Status Register 1 (SR1V[1]) to a \n’0’ .\nThe Write Enable Latch (WEL) bit may be cleared to a ’0’ by issuing the Write Disable (WRDI) command to disable \nPage Program (PP , 4PP , QPP , 4QPP), Sector Erase (SE), Ha lf Block Erase (HBE), Block Erase (BE), Chip Erase (CE), \nWrite Registers (WRR or WRAR), Security Region Erase (SECRE), Security Region Program (SECRP), and other \ncommands, that require WEL be set to ’1’ for execution. The WRDI command can be used by the user to protect \nmemory areas against inadvertent writes that can poss ibly corrupt the contents of the memory. The WRDI \ncommand is ignored during an embe dded operation while WIP bit = 1.\nCS# must be driven into the logic HIGH state after the ei ghth bit of the instruction byte has been latched in on \nSI/IO0. Without CS# being driven to the logic HIGH state after the eighth bit of the instruction byte has been \nlatched in on SI/IO0, the write disa ble operation will not be executed.\nFigure 43 Write Disable (WRDI) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 44 Write Disable (WRDI) command sequence QPI mode\n8.3.7 Write Enable for Volatile Registers (WRENV 50h)\nThe volatile SR1V, CR1V, CR2V and CR3V registers described in "Registers" on page 29, can be written by sending \nthe WRENV command followed by the WRR command. This gi ves more flexibility to change the system configu-\nration and memory protection schemes quickly without wa iting for the typical non-volatile bit write cycles or \naffecting the endurance of the status or configuration non-volatile register bits. The WRENV command will not \nset the Write Enable Latch (WEL) bit, WRENV is used on ly to direct the following WRR command to change the \nvolatile status and configuration register bit values.\nCS# must be driven into the logic HIGH state after the ei ghth bit of the instruction byte has been latched in on \nSI/IO0. Without CS# being driven to the logic HIGH state after the eighth bit of the instruction byte has been \nlatched in on SI/IO0, the write enable operation will not be executed.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 74 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nFigure 45 Write Enable for Volatile Registers (WRENV) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 46 Write Enable for Volatile Registers (WRENV) command sequence QPI mode \n8.3.8 Clear Status Register (CLSR 30h)\nThe Clear Status Register command clears the WIP (S R1V[0]), WEL (SR1V[1]), P_ ERR (SR2V[5]), and E_ERR \n(SR2V[6]) bits to ’0’ . It is not necessary to set the WEL bit before a Clear Status Register command is executed. The \nClear Status Register command will be accepted even wh en the device remains busy with WIP set to 1, as the \ndevice does remain busy when either Error bit is set. \nFigure 47 Clear Status Register (CLSR) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 48 Clear Status Register (CLSR) QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 75 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.9 Program DLRNV (PDLRNV 43h)\nBefore the Program DLRNV (PDLRNV) command can be acce pted by the device, a Write Enable (WREN) command \nmust be issued and decoded by the device. After the Write Enable (WREN) command has been decoded success-fully, the device will set the write enable latch (WEL) to enable the PDLRNV operation.\nThe PDLRNV command is entered by shifting th e instruction and the data byte on SI/IO0. \nCS# must be driven to the logic HIGH state after the eighth  (8th) bit of data has been latched. If not, the PDLRNV \ncommand is not executed. As soon as CS# is driven to th e logic HIGH state, the self -timed PDLRNV operation is \ninitiated. While the PDLRNV operation is  in progress, the Status Register ma y be read to check the value of the \nWrite-in Progress (WIP) bit. The write-in  progress (WIP) bit is a ’1’ during the self-timed PDLRNV cycle, and a is 0 \nwhen it is completed. The PDLRNV op eration can report a program error in the P_ERR bit of the Status Register. \nWhen the PDLRNV operation is completed, the Write Enab le Latch (WEL) is set to a ’0’ . The maximum clock \nfrequency for the PDLRNV command is 108 MHz.\nFigure 49 Program DLRNV (PDLRNV) command sequence\nThis command is also supported in QPI mode. In QPI mode , the instruction and data is  shifted in on IO0-IO3. \nFigure 50 Program DLRNV (PDLRNV) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Input Data\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n          \n4 0 4 0\n5 1 5 1\n6 2 6 2\n7 3 7 3\nInstruct. Input Data\nDatasheet 76 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.10 Write DLRV (WDLRV 4Ah)\nBefore the Write DLRV (WDLRV) command can be accepted  by the device, a Write Enable (WREN) command must \nbe issued and decoded by the device. After the Write Enable (WREN) command has been decoded successfully, the device will set the Write Enable Latch (WEL) to enable WDLRV operation.\nThe WDLRV command is entered by shifting th e instruction and the data byte on SI/IO0.\nCS# must be driven to the logic HIGH state after the eighth  (8th) bit of data has been latched. If not, the WDLRV \ncommand is not executed. As soon as CS# is driven to th e logic HIGH state, the WDLRV operation is initiated with \nno delays. The maximum clock frequency for the WDLRV command is 108 MHz.\nFigure 51 Write DLRV (WDLRV) command sequence\nThis command is also supported in QPI mode. In QPI mode , the instruction and data is  shifted in on IO0-IO3. \nFigure 52 Write DLRV (WDLRV) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Input Data\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n          \n4 0 4 0\n5 1 5 1\n6 2 6 2\n7 3 7 3\nInstruct. Input Data\nDatasheet 77 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.11 Data Learning Pattern Read (DLPRD 41h)\nThe instruction 41h is shifted into SI/IO0 by the rising ed ge of the SCK signal followed by one dummy cycle. This \nlatency period allows the device’s internal circuitry enou gh time to access data at the initial addr ess. During \nlatency cycles, the data value on IO0-IO3 are “don’t ca re” and may be high impedance. Then the 8-bit DLP is \nshifted out on SO/IO1. It is possible to read the DLP cont inuously by providing multiple s of eight clock cycles. The \nmaximum operating clock frequency for the DLPRD command is 108 MHz.\nFigure 53 DLP Read (DLPRD) command sequence\nThis command is also supported in QPI mode. In QPI mode, the instruction is shifted in and returning data out on \nIO0-IO3. \nFigure 54 DLP Read (DLPRD) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210  \n7654321076543210\nInstruction DY Register Read Repeat Register Read\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n               \n4 0 4 0 4 0  \n5 1 5 1 5 1  \n6 2 6 2 6 2\n7 3 7 3 7 3  \nInstruct. Dummy Register Read Register Read\nDatasheet 78 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.12 Enter 4-byte Address mode (4BEN B7h)\nThe Enter 4-byte Address mode (4BEN) command sets the vo latile address length status (ADS) bit (CR2V[0]) to 1 \nto change all 3-byte Address commands to require 4-byte s of address. This command will not affect 4-byte only \ncommands which will still continue to expect 4-bytes of address.\nTo return to 3-byte Address mode the 4BEX command clears the Volatile Address Length bit CR2V[0] = 0). The \nWRAR command can also clear the volatile address length bit CR2V[0] = 0). Also, a hardware or software reset may \nbe used to return to the 3-byte Address mode if  the Non-Volatile Address Length bit CR2NV[1] = 0.\nFigure 55 Enter 4-byte Address mode (4BEN B7h) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 56 Enter 4-byte Address QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 79 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.13 Exit 4-byte Address mode (4BEX E9h)\nThe exit 4-byte Address Mode (4BEX) command sets the vola tile address length status (ADS) bit (CR2V[0]) to 0 to \nchange most 4-byte Address commands to require 3-bytes of address. This command will not affect 4-byte only \ncommands which will still continue to expect 4-bytes of address.\nFigure 57 Exit 4-byte Address mode (4BEX E9h) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 58 Exit 4-byte Address QPI mode \n8.3.14 Read Any Register (RDAR 65h)\nThe Read Any Register (RDAR) command provides a way to read device registers. The instruction is followed by a \n3 or 4-byte address (depending on th e address length configuration CR2V[0]) , followed by a number of latency \n(dummy) cycles set by CR3V[3:0]. Then the selected register contents are retu rned. If the read access is continued \nthe same addressed register contents are returned until the command is terminated - only one register is read \nby each RDAR command.\nReading undefined locations provides undefined data.The RDAR command may be used during embedded op erations to Read Status Register 1 (SR1V).\nThe RDAR command is not used for reading registers that act as a window into a larger array: IBLAR. There are \nseparate commands required to select and read the location in the array accessed.\nThe RDAR command will read invalid data from the PASS register locations if the IRP Password Protection mode \nis selected by programming IRP[2] to 0.\nTable 34 Register address map\nByte Address \n(hex)Register name Description \n000000 SR1NV Non-volatile Status and Configuration Registers \nreading of Non-volatile Status and Configuration Registers \nactually reads the volatile registers000001 N/A\n000002 CR1NV\n000003 CR2NV000004 CR3NV\n000005 NVDLPCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 80 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n... N/A –\n000020 PASS[7:0]\nNon-volatile Password Register000021 PASS[15:8]\n000022 PASS[23:16]\n000023 PASS[31:24]\n000024 PASS[39:32]000025 PASS[47:40]\n000026 PASS[55:48]\n000027 PASS[63:56]\n... N/A –\n000030 IRP[7:0]Non-volatile 000031 IRP[15:8]\n... N/A –\n000039 PRPR[A15:A8] Pointer Region Protection Register A15:A8\n00003A PRPR[A23:A16] Pointer Region Protection Register A23:A16\n00003B N/A –\n... N/A –\n800000 SR1V\nVolatile Status and Configuration Registers800001 SR2V\n800002 CR1V800003 CR2V\n800004 CR3V\n800005 VDLP\n... N/A –\n800040 PR Volatile Protection Register\n... N/A –Table 34 Register address map\n (continued)\nByte Address \n(hex)Register name Description \nDatasheet 81 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nFigure 59 Read Any Register Read command sequence[29]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in and returning \ndata out on IO0-IO3. \nFigure 60 Read Any Register, QPI mode, command sequence[29]CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210A 10  \n76543210 \nInstruction          Address     Dummy Cycles Data\nNote\n29.A = MSb of address = 23 fo r address length CR2V[0] = 0, or 31 for CR2V[0] = 1.CS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                         \n4 0A-3  4 0 4 0 4 0 4 0 4 0  \n5 1A-2  5 1 5 1 5 1 5 1 5 1  \n6 2A-1  6 2 6 2 6 2 6 2 6 2  \n7 3 A  7 3 7 3 7 3 7 3 7 3  \nInstruct.                Address Dummy Data Data Data Data\nDatasheet 82 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.15 Write Any Register (WRAR 71h)\nThe Write Any Register (WRAR) command provides a way to Write Any Device Register - non-volatile or volatile. \nThe instruction is followed by a 3 or  4-byte address (depending on the ad dress length configuration CR2V[0]), \nfollowed by one byte of data to write in the address selected register. \nBefore the WRAR command can be accepted by the device , a Write Enable (WREN) command must be issued and \ndecoded by the device, which sets the write enable latch (WEL) in the Status Register to enable any write opera-tions. The WIP bit in SR1V may be checked to determin e when the operation is comp leted. The P_ERR and E_ERR \nbits in SR2V may be checked to determine if an error occurred during the operation.\nSome registers have a mixture of bit types and individual rules controlling which bits may be modified. Some bits \nare read only, some are OTP . \nRead Only bits are never modified and the related bits  in the WRAR command data byte are ignored without \nsetting a program or erase error indication (P_ERR or E_ERR in SR2V). Hence, the value of these bits in the WRAR \ndata byte do not matter. \nOTP bits may only be programmed to the level opposite of their default state. Writing of OTP bits back to their \ndefault state is ignored and no error is set.\nNon-volatile bits which are changed by the WRAR data, require non-volatile register write time (t\nW) to be updated. \nThe update process involves an erase and a program operation on the non-volatile register bits. If either the erase \nor program portion of the update fails the related Erro r bit in SR2V and WIP in SR1V will be set to 1. \nVolatile bits which are changed by the WRAR data, require the volatile register write time (tCS) to be updated.\nStatus Register 1 may be repeatedly read (polled) to  monitor the Write-in Progress (WIP) bit (SR1V[0]) to \ndetermine when the register write is completed and Status  Register 1 for the Error bits (SR2V[6,5]) to determine \nif there is write failure. If there is a write failure, the Clear Status command is used to clear the error status and \nenable the device to return to STANDBY state. When th e WRAR operation is completed, the write enable latch \n(WEL) is set to a ’0’ .\nHowever, the PR register can not be written by the WRAR command. The PR register contents are treated as read \nOnly bits. Only the NVLOCK Bit Write (P RL) command can write the PR register.\nThe WRAR command to write the SR1NV, CR1NV CR2NV an d CR3NV is protected from a Hardware and Software \nReset, the WRAR command to all other register are reset from a Hardware or Software Reset.\nThe WRAR command sequence and behavior is the same as  the PP or 4PP command with only a single byte of \ndata provided. See "Page Program (PP 02h or 4PP 12H)" on page 95.\nThe address map of the register s is the same as shown for Table 34 .\nDatasheet 83 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.16 Set Burst Length (SBL 77h)\nThe Set Burst Length (SBL) command is used to config ure the burst wrap feature. Burst wrap is used in \nconjunction with Quad I/O Read and DDR Quad I/O read, in QIO or QPI modes, to access a fixed length and \nalignment of data. Certain applications can benefit from  this feature by improving the overall system code \nexecution performance. The Burst Wrap feature allows appl ications that use cache, to start filling a cache line \nwith instruction or data from a critical address first, th en fill the remainder of the cache line afterwards within a \nfixed length (8/16/32/64-bytes) of data, without issuing multiple read commands.\nThe Set burst length command is initiated by driving the CS# pin LOW and then shifting  the instruction code “77h” \nfollowed by 24 dummy bits and 8 “wrap length bits (WL[7]-WL[0])” . The command sequence is shown in\nFigure 61  and Figure 62 . Wrap Length bit WL[7] and the lower nibble WL[3:0] are not used. See Configuration \nRegister 3 (CR3V[6:4]) for the encoding of WL[6]-WL[4] in "Configuration Register 3" on page 38.\nOnce WL[6:4] is set by a Set Burst Length command, all the following “Quad I/O Read” commands will use the \nWL[6:4] setting to access the 8/16/32/64-byte section of da ta. Note, Configuration Register 1 Quad bit CR1V[1] or \nConfiguration Register 2 QPI bit CR2V[3] must be set to 1 in order to use the Quad I/O Read and Set Burst Length \ncommands. To exit the “wrap around” function and return  to normal Read operation, another Set Burst with \nWrap command should be issued to set WL4 = 1. The default value of WL[6:4] upon power on, hardware or software reset as set in the CR2NV[6:4]. Use WRR or WRAR  command to set the default wrap length in CR2NV[6;4].\nThe Set Burst Length (SBL) command writes only to CR3V[6:4] bits to enable or disable the wrapped read feature \nand set the wrap boundary. The SBL command cannot be us ed to set the read latency in CR3V[3:0]. The WRAR \ncommand must be used to set the read latency in CR3V or CR3NV. \nSee Table 35  for CR3V[6:5] values for wrap boundary\'s and start address. When enabled the wrapped read feature \nchanges the related read commands from sequentially re ading until the command ends, to reading sequentially \nwrapped within a group of bytes. \nWhen the Wrap mode is not enabled ( Table 16  and Table 19 ), an unlimited length sequential read is performed.\nWhen the Wrap mode is enabled ( Table 16  and Table 19 ) a fixed length and aligned group of 8-, 16-, 32-, or \n64-bytes is read starting at the byte address provided by the read command and wrapping around at the group \nalignment boundary.\nThe group of bytes is of length and aligned on an 8-, 16- , 32-, or 64-byte boundary. CR3V[6:5] selects the boundary. \nSee "Configuration Register 3 Volatile (CR3V)" on page 41.\nThe starting address of the Read command selects the gro up of bytes and the first data returned is the addressed \nbyte. Bytes are then read sequentially until the end of th e group boundary is reached. If the Read continues the \naddress wraps to the beginning of the group and contin ues to read sequentially. This wrapped read sequence \ncontinues until the command is ended by CS# returning HIGH.\nDatasheet 84 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nThe power-on reset, hardware reset, or software rese t default burst length can be changed by programming \nCR3NV with the desired valu e using the WRAR command.\nFigure 61 Set Burst Length command sequence Quad I/O mode\nFigure 62 Set Burst Length command sequence QPI modeTable 35 Example burst wrap sequences\nCR3V \nvalue \n(hex)Wrap \nboundary \n(bytes)Start \naddress \n(hex)Address sequence (hex)\n1X Sequential XXXXXX03 03, 04, 05, 06, 07 , 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10, 11, 12, 13, 14, 15 , 16, 17, 18, ...\n00 8 XXXXXX00 00, 01, 02, 03, 04 , 05, 06, 07, 00,  01, 02, ...\n00 8 XXXXXX07 07, 00, 01, 02, 03 , 04, 05, 06, 07,  00, 01, ...\n01 16 XXXXXX02 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 00, 01, 02, 03, ...\n01 16 XXXXXX0C 0C, 0D, 0E, 0F, 00, 01, 02, 03, 02, 03,  04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, ...\n02 32 XXXXXX0A 0A, 0B, 0C, 0D, 0E, 0F, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F, 00, \n01, 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, ...\n02 32 XXXXXX1E 1E, 1F, 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10, 11, 12, 13, 14, 15,\n16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F, 00, ...\n03 64 XXXXXX03 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D , 0E, 0F, 10, 11, 12, 13, 14,  15, 16, 17, 18, 19, 1A, \n1B, 1C, 1D, 1E, 1F, 20, 21, 22, 23, 24, 25, 26,  27, 28, 29, 2A, 2B, 2C, 2D, 2E, 2F, 30, 31, \n32, 33, 34, 35, 36, 37, 38, 39, 3A, 3B, 3C, 3D, 3E, 3F, 00, 01, 02, ...\n03 64 XXXXXX2E 2E, 2F, 30, 31, 32, 33, 34, 35, 36, 37, 38 , 39, 3A, 3B, 3C, 3D, 3E, 3F , 00, 01, 02, 03, 04, 05, \n06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10, 11,  12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, \n1D, 1E, 1F, 20, 21, 22, 23, 24, 25, 26 , 27, 28, 29, 2A, 2B, 2C, 2D,, ...\nCS\nSCLK\nIO0IO1IO2IO3\nPhase \n                                  \n7 6 5 4 3 2 1 0 X X X X X X WL4 X \nX X X X X X WL5 X \nX X X X X X WL6 X \nX X X X X X X X \nInstruction Don\'t Care Wrap\nCS\nSCLK\nIO0\nIO1\nIO2\nIO3\nPhase \n                     \n4 0 X X  X X X X WL4 X \n5 1 X X  X X X X WL5 X \n6 2 X X X X X X WL6 X \n7 3 X X X X X X X X \nInstruct. Don\'t Care Wrap\nDatasheet 85 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.3.17 Enter QPI mode (QPIEN 38h)\nThe Enter QPI Mode (QPIEN) command enables the QPI mode  by setting the Volatile QPI bit (CR2V[3] = 1). See \nTable 14 . The time required to enter QPI mode is tQEN, see Table 54 , no other commands are allowed during the \ntQEN transition time to QPI mode.\nTo return to SPI mode the QPIEX command or a write to register (CR2V[3] = 0) is required. A power on reset, \nhardware, or software reset will also return the part to SPI mode if the non-volatile QPI (CR2NV[3] = 0). See Table 12 .\nFigure 63 Enter QPI Mode (QPIEN 38h) command sequence\n8.3.18 Exit QPI mode (QPIEX F5h)\nThe Exit QPI mode (QPIEX) command di sables the QPI mode by setting the Volatile QPI bit (CR2V[3] = 0) and \nreturning to SPI mode. See Table 14 . The time required to exit QPI mode is tQEX, see Table 54 , no other commands \nare allowed during the tQEX transition time to exit the QPI mode.\nFigure 64 Exit QPI (QPIEX F5h) command sequence CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 86 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.4 Read Memory Array commands\nRead commands for the main flash array provide many options for prior generation SPI compatibility or \nenhanced performance SPI:\n• Some commands transfer address or data on each risi ng edge of SCK. These are called Single Data Rate \ncommands (SDR).\n• Some SDR commands transfer address one bit per falling ed ge of SCK and return data 1-bit of data per rising \nedge of SCK. These are called Single Width commands. \n• Some SDR commands transfer both address and data 2 or 4 bits per rising edge of SC K. These are called Dual \nI/O for 2-bit, Quad I/O, and QPI for 4-bit. QPI also transfers instructions 4 bits per rising edge.\n• Some commands transfer address and data on both the rising edge and falling edge of SCK. These are called \nDouble Data Rate (DDR) commands.\n• There are DDR commands for 4 bits of address or da ta per SCK edge. These are called Quad I/O DDR and QPI \nDDR for 4 bit per edge transfer.\nAll of these commands, except QPI Read, begin with an inst ruction code that is transferred one bit per SCK rising \nedge. QPI Read transfers the instruction 4 bits per SCK risi ng edge. The instruction is followed by either a 3- or \n4-byte address transferred at SDR or DDR. Commands transferring address or data 2 or 4 bits per clock edge are called Multiple I/O (MIO) commands. For FL -L family devices at 256 Mb or higher  density, the traditional SPI 3-byte \naddresses are unable to directly address all location s in the memory array. Separate 4-byte Address Read \ncommands are provided for access to the entire address sp ace. These devices may be configured to take a 4-byte \naddress from the host system with the traditional 3-byte Address commands. The 4-byte Address mode for \ntraditional commands is activated by setting the Address Le ngth bit in Configuration Register 2 to ’1’ . In the \nS25FL128L higher order address bits above A22 in the 4-byte address commands, or commands using 4-byte \nAddress mode are not relevant and are ignored because the flash array is only 64 Mb in size.\nThe Dual I/O, Quad I/O and QPI commands provide a performance improvement option controlled by mode bits \nthat are sent following the address bits. The mode bits  indicate whether the command following the end of the \ncurrent read will be another read of the same type, with out an instruction at the beginning of the read. These \nmode bits give the option to eliminate the instruction cycl es when doing a series of dual or quad read accesses.\nSome commands require delay cycles following the address or mode bits to allow time to access the memory \narray - read latency. The delay or read latency cycles are traditionally called dummy  cycles. The dummy cycles \nare ignored by the memory thus any data provided by th e host during these cycles is  “don’t care” and the host \nmay also leave the SI signal at high  impedance during the dummy cycles. Wh en MIO commands are used the host \nmust stop driving the IO si gnals (outputs are high impedance) before  the end of last dummy cycle. When DDR \ncommands are used the host must not drive the I/O si gnals during any dummy cycle. The number of dummy \ncycles varies with the SCK frequency or performance opti on selected via the Configuration Register 2 (CR3V[3:0]) \nlatency code. Dummy cycles are measured from SCK falling edge to next SCK falling edge. SPI outputs are tradi-tionally driven to a new value on the falling edge of ea ch SCK. Zero dummy cycles means the returning data is \ndriven by the memory on the same falling edge of SC K that the host stops driving address or mode bits.\nThe DDR commands may optionally have an 8 edge Data Learning Pattern (DLP) driven by the memory, on all \ndata outputs, in the dummy cycles immediately before the start of data. The DLP can help the host memory \ncontroller determine the phase shift from SCK to data ed ges so that the memory controller can capture data at \nthe center of the data eye.\nWhen using SDR I/O commands at higher  SCK frequencies (>50 MHz), an LC that  provides 1 or more dummy cycles \nshould be selected to allow additional time for the host to stop driving before the memory starts driving data, to \nminimize I/O driver conflict. When using DDR I/O commands with the DLP enabled, an LC  that provides 5 or more \ndummy cycles should be selected to allow 1 cycle of ad ditional time for the host to stop driving before the \nmemory starts driving the 4 cycle DLP .\nEach Read command ends when CS# is returned High at any point during data return . CS# must not be returned \nHigh during the mode or dummy cycles before data returns as this may cause Mode bits to be captured incorrectly; making it indeterminate as to whet her the device remains in Continuous Read mode.\nDatasheet 87 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.4.1 Read (read 03h or 4READ 13h)\nThe instruction \n• 03h (CR2V[0] = 0) is followed  by a 3-byte address (A23-A0) or\n• 03h (CR2V[0] = 1) is followed  by a 4-byte address (A31-A0) or\n• 13h is followed by a 4-byte address (A31-A0)\nThen the memory contents, at the addr ess given, are shifted out on SO/IO1. \nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFigure 65 Read command sequence[30]\n8.4.2 Fast Read (FAST_READ 0Bh or 4FAST_READ 0Ch)\nThe instruction\n• 0Bh (CR2V[0] = 0) is followed  by a 3-byte address (A23-A0) or\n• 0Bh (CR2V[0] = 1) is followed  by a 4-byte address (A31-A0) or\n• 0Ch is followed by a 4-byte address (A31-A0)\nThe address is followed by dummy cycles depending on the latency code set in the Configuration Register \nCR3V[3:0]. The dummy cycles allow the device internal ci rcuits additional time for accessing the initial address \nlocation. During the dummy cycles the data value on SO/I O1 is “don’t care” and may be high impedance. Then \nthe memory contents, at the address given, are shifted out on SO/IO1.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFigure 66 Fast Read (FAST_READ) command sequence \nNote\n30.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command 13h.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210A 10  \n7654321076543210 \nInstruction          Address Data 1 Data N\nCS#\nSCK\nSI_IO0\nSO_IO1\nIO2-IO3\nPhase \n                                                \n76543210A 10  \n76543210 \nInstruction          Address Dummy Cycles Data 1\nDatasheet 88 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.4.3 Dual Output Read (DOR 3Bh or 4DOR 3Ch)\nThe instruction \n• 3Bh (CR2V[0] = 0) is followed  by a 3-byte address (A23-A0) or\n• 3Bh (CR2V[0] = 1) is followed  by a 4-byte address (A31-A0) or\n• 3Ch is followed by a 4-byte address (A31-A0)\nThe address is followed by dummy cycles depending on the latency code set in the Configuration Register \nCR3V[3:0]. The dummy cycles allow the device internal ci rcuits additional time for accessing the initial address \nlocation. During the dummy cycles the data value on IO 0 (SI) and IO1 (S0) is “don’t care” and may be high \nimpedance. \nThen the memory contents, at the address given, is shifte d out two bits at a time through IO0 (SI) and IO1 (SO). \nTwo bits are shifted out at the SCK frequenc y by the falling edge of the SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFor Dual Output Read commands, there are dummy cycles required after the la st address bit is shifted into IO0 \n(SI) before data begins shifting out of IO0 and IO1.\nFigure 67 Dual Output Read command sequence[31]\nNote\n31.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command 3Ch.CS#\nSCK\nIO0\nIO1\nPhase76543210A 10 64206420\n75317531\nInstruction       Address Dummy Cycles Data 1 Data 2\nDatasheet 89 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.4.4 Quad Output Read (QOR 6Bh or 4QOR 6Ch)\nThe instruction \n• 6Bh (CR2V[0] = 0) is followed  by a 3-byte address (A23-A0) or\n• 6Bh (CR2V[0] = 1) is followed  by a 4-byte address (A31-A0) or\n• 6Ch is followed by a 4-byte address (A31-A0)\nThe address is followed by dummy cycles depending on the latency code set in the Configuration Register \nCR3V[3:0]. The dummy cycles allow the device internal ci rcuits additional time for accessing the initial address \nlocation. During the dummy cycles the data value on IO0 - IO3 is “don’t care” and may be high impedance. \nThen the memory contents, at the address given, is shifte d out four bits at a time th rough IO0 - IO3. Each nibble \n(4 bits) is shifted out at the SCK frequenc y by the falling edge of the SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFor quad output read commands, there are dummy cycles required after the la st address bit is shifted into IO0 \nbefore data begins shifting out of IO0 - IO3.\nFigure 68 Output Read command sequence[32]\n8.4.5 Dual I/O Read (DIOR BBh or 4DIOR BCh)\nThe instruction \n• BBh (CR2V[0] = 0) is followed by a 3-byte address (A23-A0) or\n• BBh (CR2V[0] = 1) is followed by a 4-byte address (A31-A0) or• BCh is followed by a 4-byte address (A31-A0)\nThe Dual I/O Read commands improve throughput with tw o I/O signals — IO0 (SI) an d IO1 (SO). This command \ntakes input of the address and returns read data two bits  per SCK rising edge. In some applications, the reduced \naddress input and data output time mi ght allow for code execution in place (XIP) i.e. directly from the memory \ndevice.\nThe Dual I/O Read command has Continuous Read Mode bits  that follow the address so, a series of Dual I/O Read \ncommands may eliminate the 8-bit instruction after the fi rst Dual I/O Read command sends a mode bit pattern \nof Axh that indicates the following command will also be a Dual I/O Read command. The first Dual I/O Read \ncommand in a series starts with the 8-bit instruction, foll owed by address, followed by  four cycles of mode bits, \nfollowed by an optional latency period. If the mode bit pattern is Axh the next command is assumed to be an \nadditional Dual I/O Read command that does not provid e instruction bits. That command starts with address, \nfollowed by mode bits, followed by optional latency.CS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                              \n76543210A 10 40404040404\n51515151515\n62626262626\n73737373737\nInstruction Address Dummy D1 D2 D3 D4 D5\nNote\n32.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command 6Ch.\nDatasheet 90 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nVariable latency may be added after the Mode bits are shif ted into SI and SO before data begins shifting out of \nIO0 and IO1. This latency period (dummy cycles) allows the device internal circuitry enough time to access data at the initial address. Duri ng the dummy cycles, the data value on SI and SO are “don’t care” and may be high \nimpedance. The number of du mmy cycles is determined by the frequenc y of SCK. The latency is configured in \nCR3V[3:0].\nThe continuous read feature removes the need for the Instru ction bits in a sequence of read accesses and greatly \nimproves code execution (XIP) performance. The upper nibble (bits 7-4) of the mode bits control the length of the \nnext Dual I/O Read command through the inclusion or exclusion of the first byte instruction code. The lower \nnibble (bits 3-0) of the mode bits are “don’t care” (“x”) and may be high impedance. If the Mode bits equal Axh, \nthen the device remains in dual I/O Continuous Read mo de and the next address can be entered (after CS# is \nraised high and then asserted low) withou t the BBh or BCh instruction, as shown in Figure 70 ; thus, eliminating \neight cycles of the command sequence. The following seque nces will release the device from dual I/O Continuous \nRead mode; after which, the device can accept standard SPI commands:\n• During the dual I/O continuous read command sequence, if the Mode bits are any value other than Axh, then \nthe next time CS# is raised HIGH the device will be released from dual I/O Continuous Read mode.\n• Send the Mode Reset command. \nNote that the four mode bit cycles are part of the device ’s internal circuitry latency time to access the initial \naddress after the last address cycle that is clocked into IO0 (SI) and IO1 (SO).\nIt is important that the I/O signals be set to high-impedance at or before the falling edge of the first data out clock. \nAt higher clock speeds the time availabl e to turn off the host outputs before the memory device begins to drive \n(bus turn around) is diminished. It is allowed and may be helpful in preventing I/O signal contention, for the host system to turn off the I/O signal ou tputs (make them high impedance) during the last two “don’t care” mode \ncycles or during any dummy cycles.\nFollowing the latency period the memory content, at the ad dress given, is shifted out two bits at a time through \nIO0 (SI) and IO1 (SO). Two bits are shifted out at the SCK frequency at the falling edge of SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nCS# should not be driven HIGH during mode or dummy bits as this may make the mode bits indeterminate.\nFigure 69 Dual I/O Read command sequence\n[33, 34]\nFigure 70 Dual I/O Continuo us Read command sequence[33] CS#\nSCK\nIO0IO1\nPhase \n                                                      \n76543210A-1  206420 64206420  \nA  317531 75317531  \nInstruction Address Mode Dum Data 1 Data 2\nCS#\nSCK\nIO0IO1\nPhase  \n                                                 \n6 4 2 0 A-1  2 06 4 2 0 64 2 0 6 4 20 \n7 5 3 1 A  3 17 5 3 1 75 3 1 7 5 31 \nData N Address Mode Dum Data 1 Data 2\nNotes\n33.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command BCh.\n34.Least significant 4 bits of mode are don’t care and it is optional for the host to drive these bits. The host may turn off \ndrive during these cycles to increase bus turn around time between mode bits from host and returning data from the \nmemory.\nDatasheet 91 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.4.6 Quad I/O Read (QIOR EBh or 4QIOR ECh)\nThe instruction,\n• EBh (CR2V[0] = 0) is followed by a 3-byte address (A23-A0) or\n• EBh (CR2V[0] = 1) is followed by a 4-byte address (A31-A0) or\n• ECh is followed by a 4-byte address (A31-A0)\nThe Quad I/O Read command improves throughput with four I/O signals IO0-IO3. It allows input of the address \nbits four bits per serial SCK clock. In some applications, the reduced instruction overhead might allow for code execution (XIP) directly from FL-L family devices. The Quad bit of the Configuration Register 1 must be set \n(CR1V[1] = 1) or the QPI bit of Configuration Register 2 mu st be set (CR2V[1] = 1 to enable the quad capability of \nFL-L family devices.\nFor the Quad I/O Read command, there is a latency required  after the mode bits (described below) before data \nbegins shifting out of IO0-IO3. This latency period (i.e., dummy cycles) allows the device’s internal circuitry \nenough time to access data at the initial address. During  latency cycles, the data value on IO0-IO3 are “don’t care” \nand may be high impedance. The number of dummy cycles  is determined by the frequency of SCK. The latency \nis configured in CR3V[3:0].\nFollowing the latency period, the memory contents at the a ddress given, is shifted out four bits at a time through \nIO0-IO3. Each nibble (4 bits) is shifted out at the SCK frequency by the falling edge of the SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nAddress jumps can be done without the need for additional Quad I/O Read instructions. This is controlled through \nthe setting of the Mode bits (after  the address sequence, as shown in Figure 71 . This added feature removes the \nneed for the instruction sequ ence and greatly improves code execution (X IP). The upper nibble (bits 7-4) of the \nMode bits control the length of the next Quad I/O instru ction through the inclusion or exclusion of the first byte \ninstruction code. The lower nibble (bits 3-0) of the mode bits are “don’t care” (“x”). If the mode bits equal Axh, then the device remains in Quad I/O High Performance Read mode and the next address can be entered (after \nCS# is raised HIGH and then asserted low) without requiring the EBh or ECh instruction, as shown in Figure 73 ; \nthus, eliminating eight cycles for th e command sequence. The following sequences will release the device from \nQuad I/O High Performance Read mode; after whic h, the device can accept standard SPI commands:\n• During the Quad I/O Read command sequence, if the Mode bits are any value other than Axh, then the next time \nCS# is raised HIGH, the device will be released from quad I/O high Performance Read mode.\n• Send the mode Reset command.\nNote that the two Mode bit clock cycles  and additional WAIT states (i.e., dummy cycles) allow the device’s internal \ncircuitry latency time to access the initial address afte r the last address cycle that is clocked into IO0-IO3.\nIt is important that the IO0-IO3 signals be set to high-imped ance at or before the falling edge of the first data out \nclock. At higher clock speeds the time available to turn off the host ou tputs before the memory device begins to \ndrive (bus turn around) is diminished. It is allowed and may be helpful in preventing IO0-IO3 signal contention, \nfor the host system to turn off the IO0-IO3 signal outputs (make them high impedance) during the last “don’t care” \nmode cycle or during any dummy cycles.\nCS# should not be driven HIGH during mode or dummy bits as this may make the Mode bits indeterminate.\nIn QPI mode, (CR2V[3] = 1) the quad I/O instructions are sent 4 bits per SCK rising edge. The remainder of the \ncommand protocol is identical to the Quad I/O commands.\nDatasheet 92 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nFigure 71 Quad I/O Read Initial Access command sequence[35]\nFigure 72 Quad I/O Read Initial Access command sequence QPI mode[35]\nFigure 73 Continuous Quad I/O Read command sequence[35, 37]CS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                                     \n76543210A-3  4040 40404040 \nA-2  5151 51515151 \nA-1  6262 62626262 \nA 7373 73737373 \nInstruction            Address Mode      Dummy D1 D2 D3 D4\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                         \n4 0A-3  4 0 4 0 4 0 4 0 4 0 4 0  \n5 1A-2  5 1 5 1 5 1 5 1 5 1 5 1  \n6 2A-1  6 2 6 2 6 2 6 2 6 2 6 2  \n7 3 A  7 3 7 3 7 3 7 3 7 3 7 3  \nInstruct.                Address Mode Dummy D1 D2 D3 D4\nNotes\n35.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command ECh.\n36.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command ECh.37.The same sequence is used in QPI mode.CS#\nSCK\nIO0\nIO1IO2IO3\nPhase  \n                                                  \n4 0 4 0 A-3  4 0 4 0 4 0 4 0 6 4 2 0  \n5 1 5 1 A-2  5 1 5 1 5 1 5 1 7 5 3 1  \n6 2 6 2 A-1  6 2 6 2 6 2 6 1 7 5 3 1  \n7 3 7 3 A  7 3 7 3 7 3 7 1 7 5 3 1 \nDN-1 DN          Address Mode Dummy D1 D2 D3 D4\nDatasheet 93 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.4.7 DDR Quad I/O Read (EDh, EEh)\nThe DDR Quad I/O Read command improves throughput with fo ur I/O signals IO0-IO3. It is similar to the Quad I/O \nRead command but allows input of the address four bits on every edge of the clock. In some applications, the \nreduced instruction overhead might allow for code executio n (XIP) directly from FL-L Family devices. The Quad \nbit of the Configuration Register 1 must be set (CR1V[1] = 1) or the QPI bit of  Configuration Register 2 must be set \n(CR2V[1] = 1 to enable the Quad capability of FL-L family devices.\nThe instruction \n• EDh (CR2V[0] = 0) is followed by a 3-byte address (A23-A0) or• EDh (CR2V[0] = 1) is followed by a 4-byte address (A31-A0) or\n• EEh is followed by a 4-byte address (A31-A0)\nThe address is followed by Mode bits. Then the memory co ntents, at the address given,  is shifted out, in a DDR \nfashion, with four bits at a time on each clock edge through IO0-IO3.\nThe maximum operating clock frequency fo r DDR quad I/O read command is 54 MHz.\nFor DDR Quad I/O Read, there is a latency required after th e last address and Mode bits are shifted into the IO0-IO3 \nsignals before data begins shifting out of IO0-IO3. This latency period (dummy cycles) allows the device’s internal \ncircuitry enough time to access the initial address. During th ese latency cycles, the data value on IO0-IO3 are \n“don’t care” and may be high impedance. When the data learning pattern (DLP) is enabled the host system must \nnot drive the IO signals during the dummy cycles. The IO signals must be left high impedance by the host so that the memory device can drive the DLP during the dummy cycles.\nThe number of dummy cycles is determ ined by the frequency of SCK. The la tency is configured in CR3V[3:0]. \nMode bits allow a series of Quad I/O DDR commands to  eliminate the 8-bit instruction after the first command \nsends a complementary mode bit pattern. This featur e removes the need for the eight bit SDR instruction \nsequence and dramatically reduces initial access times (improves XIP performance). The mode bits control the length of the next DDR Quad I/O Read operation through the inclusion or exclusion of the first byte instruction \ncode. If the upper nibble (IO[7:4]) and lower nibble (IO[3:0]) of the Mode bits are complementary (i.e. 5h and Ah) the device transitions to Continuous DDR Quad I/O Read mode and the next address can be entered (after CS# is \nraised HIGH and then asserted low) without requiring the EDh or EEh instru ction, thus elimin ating eight cycles \nfrom the command sequence. The following sequences wi ll release the device from Continuous DDR Quad I/O \nRead mode; after which, the device can accept standard SPI commands:\n• During the DDR Quad I/O Read command sequence, if th e mode bits are not complementary the next time CS# \nis raised HIGH and then asserted low the device will be released from DDR Quad I/O Read mode.\n• Send the Mode Reset command.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nCS# should not be driven HIGH during mode or dummy bits as this may make the mode bits indeterminate. Note \nthat the memory devices may drive the IOs with a preamble prior to the first data value. The preamble is a data \nlearning pattern (DLP) that is used by  the host controller to optimize data capture at higher frequencies. The \npreamble drives the IO bus for the four  clock cycles immediately before data is output. The host must be sure to \nstop driving the IO bus prior to the time that  the memory starts outputting the preamble.\nThe preamble is intended to give the host controller an indication about the round trip time from when the host \ndrives a clock edge to when the corresponding data valu e returns from the memory device. The host controller \nwill skew the data capture point during the preamble pe riod to optimize timing margins and then use the same \nskew time to capture the data during the rest of the re ad operation. The optimized capture point will be deter-\nmined during the preamble period of every read operation.  This optimization strategy is intended to compensate \nfor both the PVT (process, voltage, temperature) of both  the memory device and the host controller as well as \nany system level delays caused by flight time on the PCB.\nDatasheet 94 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nAlthough the data learning pattern (DLP) is programmab le, the following example shows example of the DLP of \n34h. The DLP 34h (or 00110100) will be driven on each of th e active outputs (i.e. all four IOs). This pattern was \nchosen to cover both “DC” and “AC” data transition scen arios. The two DC transition scenarios include data low \nfor a long period of time (two half clocks) followed by  a high going transition (001) and the complementary low \ngoing transition (110). The two AC transi tion scenarios include data low for a sh ort period of time (one half clock) \nfollowed by a high going transition (101) and the complementary low going transition (010). The DC transitions will typically occur with a starting po int closer to the supply rail than the AC transitions that may not have fully \nsettled to their steady state (DC) levels. In many cases the DC transitions will bound the beginning of the data \nvalid period and the AC transitions will bound the ending of the data valid period. These transitions will allow the \nhost controller to identify the beginning and ending of the valid data eye. Once the data eye has been charac-\nterized the optimal data capture point can be chosen. See "DDR Data Learning Registers" on page 45 for more \ndetails.\nIn QPI mode, (CR2V[3] = 1) the DDR quad  I/O instructions are sent 4 bits at SCK rising edge. The remainder of the \ncommand protocol is identical to the DDR Quad I/O commands.\nFigure 74 DDR Quad I/O Read initial access[38, 39]\nFigure 75 DDR Quad I/O Read initial access QPI mode[38, 39]\nFigure 76 Continuous DDR Quad  I/O Read subsequent access[38, 39, 40]CS#\nSCK\nIO0\nIO1\nIO2IO3\nPhase \n                                          \n7 6 5 4 3 2 1 0A-3 84040 765432104040\nA-2 95151 765432105151\nA-1 106262 765432106262\nA 117373 765432107373\nInstruction       Address Mode Dummy DLP D1 D2\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                             \n4 0 A-3 84040 765432104040\n5 1 A-2 95151 765432105151\n6 2 A-1 10 6262 765432106262\n7 3 A 11 7373 765432107373\nInstruct.   Address Mode Dummy DLP D1 D2\nNotes\n38.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1 or command EEh.\n39.Example DLP of 34h (or 00110100).40.The same sequence is used in QPI mode.CS#\nSCK\nIO0IO1IO2IO3\nPhase \n                          \nA-3 8 4 0 4 0 7 6 5 4 3 2 1 0 4 0 4 0\nA-2 9 5 1 5 1 7 6 5 4 3 2 1 0 5 1 5 1\nA-1 10 6 2 6 2 7 6 5 4 3 2 1 0 6 2 6 2\nA 11 7 3 7 3 7 6 5 4 3 2 1 0 7 3 7 3\n  Address Mode Dummy DLP D1 D2\nDatasheet 95 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.5 Program Flash Array commands\n8.5.1 Program Granularity\n8.5.1.1 Page Programming\nPage Programming is done by loading a page buffer with data to be programmed and issuing a Programming \ncommand to move data from the buffer to the memory array.  This sets an upper limit on the amount of data that \ncan be programmed with a single Programming command. Page Programming allows up to a page size 256bytes \nto be programmed in one operation. The page is aligned on the page size address boundary. It is possible to program from one bit up to a page size in each page programming operation. For the very best performance, programming should be done in full pages of 256bytes  aligned on 256byte boundaries with each page being \nprogrammed only once.\n8.5.1.2 Single byte programming\nSingle byte Programming allows full backward compatibil ity to the legacy standard SPI page programming (PP) \ncommand by allowing a single byte to be programmed anywhere in the memory array. \n8.5.2 Page Program (PP 02h or 4PP 12H)\nThe Page Program (PP) command allows bytes to be pr ogrammed in the memory (changing bits from 1 to 0). \nBefore the Page Program (PP) commands can be accepted  by the device, a Write Enable (WREN) command must \nbe issued and decoded by the device. After the Write Enable (WREN) command has been decoded successfully, the device sets the write enable latch (WEL) in th e Status Register to enable any write operations.\nThe instruction \n• 02h (CR2V[0] = 0) is followed  by a 3-byte address (A23-A0) or\n• 02h (CR2V[0] = 1) is followed  by a 4-byte address (A31-A0) or\n• 12h is followed by a 4-byte address (A31-A0)\nand at least one data byte on SI/IO0. Up to a page ca n be provided on SI/IO0 after the 3-byte address with \ninstruction 02h or 4-byte address with instruction 12h ha s been provided. As with the Write and Erase commands, \nthe CS# pin must be driven HIGH after the eighth bit of the last byte has been latched. If this is not done the Page Program command will not be executed. After CS# is driven HIGH, the self-timed Page Program command will commence for a time duration of t\nPP.\nUsing the Page Program (PP) command to load an enti re page, within the page boundary, will save overall \nprogramming time versus loading less than a page into the program buffer.\nThe programming process is managed by the Flash memory  device internal control logic. After a Programming \ncommand is issued, the programming operation status can be checked using the Read Status Register 1 \ncommand. The WIP bit (SR1V[0]) will indicate when th e programming operation is completed. The P_ERR bit \n(SR2V[5]) will indicate if an error occurs in the prog ramming operation that preven ts successful completion of \nprogramming. This includes attempted programming of a protected area.\nFigure 77 Page Program (PP 02h or 4PP 12h) command sequence[41]CS#\nSCK\nSI_IO0\nSO_IO1\nPhase76543210A 5432107654321076543210\nInstruction Address Input Data 1 Input Data 2\nNote\n41.A = MSb of address = A23 for PP 02h with CR2V[0] = 0, or A31 for PP 02h  with CR2V[0] = 1, or for 4PP 12h.\nDatasheet 96 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nThis command is also supported in QPI mode. In QPI mode, the instruction address and data is shifted in on \nIO0-IO3. \nFigure 78 Page Program (PP 02h or 4PP 12h) QPI mode command sequence[42]\n8.5.3 Quad Page Program (QPP 32h or 4QPP 34h)\nThe Quad-Input Page Program (QPP) command allows by tes to be programmed in the memory (changing bits \nfrom 1 to 0). The Quad-Input Page Program (QPP) command allows up to a page of data to be loaded into the page buffer using four signals: IO 0-IO3. QPP can improve performance for PROM programmer and applications \nthat have slower clock speeds (< 12 MHz) by loading 4 bits  of data per clock cycle. Systems with faster clock \nspeeds do not realize as much benefit for the QPP co mmand since the inherent page program time becomes \ngreater than the time it takes to clock-in the data . The maximum frequency for the QPP command is 108MHz.\nTo use Quad Page Program the Quad Enable bit in the Configuration Register must be set (QUAD = 1). A Write \nEnable command must be executed before the device will  accept the QPP command (Status Register 1, WEL = 1). \nThe instruction \n• 32h (CR2V[0] = 0) is followed  by a 3-byte address (A23-A0) or\n• 32h (CR2V[0] = 1) is followed  by a 4-byte address (A31-A0) or\n• 34h is followed by a 4-byte address (A31-A0)\nand at least one data byte, into the IO signals. Data must be programmed at previously erased (FFh) memory \nlocations. \nAll other functions of QPP are identical to Page Progra m. The QPP command sequence is shown in the figure \nbelow.\nFigure 79 Quad Page Program command sequence[42]CS#\nSCLK\nIO0\nIO1IO2IO3\nPhase \n                             \n4 0 A-3  4 0 4 0 4 0 4 0 4 0  \n5 1 A-2  5 1 5 1 5 1 5 1 5 1  \n6 2 A-1  6 2 6 2 6 2 6 2 6 2  \n7 3 A  7 3 7 3 7 3 7 3 7 3  \nInstruct.                Address Input D1 Input D2 Input D3 Input D4\nNotes\n42.A = MSb of address = A23 for QPP 32h with CR2V[0] = 0, or A31 for QPP 32h with CR2V[0] = 1, or for 4QPP 34h.CS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                               \n7 6 5 4 3 2 1 0 A  1 0 4 0 4 0 4 0 4 0 4 0 4\n5 1 5 1 5 1 5 1 5 1 5\n6 2 6 2 6 2 6 2 6 2 6\n7 3 7 3 7 3 7 3 7 3 7\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nDatasheet 97 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.6 Erase Flash Array commands\n8.6.0.1 Sector Erase (SE 20h or 4SE 21h)\nThe Sector Erase (SE) command sets all bits in the addressed sector to 1 (all bytes are FFh). Before the Sector \nErase (SE) command can be accepted by the device, a Write Enable (WREN) command must be issued and \ndecoded by the device, which sets the write enable latch (WEL) in the Status Register to enable any write opera-tions.\nThe instruction\n• 20h [CR2V[0] = 0] is followed by a 3-byte address (A23-A0), or\n• 20h [CR2V[0] = 1] is followed by a 4-byte address (A31-A0), or\n• 21h is followed by a 4-byte address (A31-A0)\nCS# must be driven into the logic HIGH state after the tw enty-fourth or thirty-second bit of the address has been \nlatched in on SI/IO0. This will initiate the beginning of internal erase cycle, which involves the pre-programming \nand erase of the chosen sector of the flash memory array. If CS# is not driven HIGH af ter the last bit of address, \nthe sector erase operation will not be executed.\nAs soon as CS# is driven HIGH, the internal erase cycle will  be initiated. With the internal erase cycle in progress, \nthe user can read the value of the Write in Progress (WIP) bit to determine when the operation has been \ncompleted. The WIP bit will indicate a ’1’ . when the erase cycle is in progress and a ’0’ when the erase cycle has \nbeen completed.\nA SE or 4SE command applied to a sector that has been write protected through the legacy block protection, \nIndividual block lock or pointer region protection will not be executed and will set the E_ERR status. \nFigure 80 Sector Erase (SE 20h or 4SE 21h) command sequence[43]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in on IO0-IO3.\nFigure 81 Sector Erase (SE 20h or 4SE 21h) QPI mode command sequence[43]\nNote\n43.A = MSb of address = A23 for SE 20h with CR2V[0] = 0,  or A31 for SE 20h with CR2V[0] = 1 or for 4SE 21h.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                         \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n              \n4 0 A-3  4 0\n5 1 A-2  5 1\n6 2 A-1  6 2\n7 3 A  7 3\nInstructtion                Address\nDatasheet 98 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.6.1 Half Block Erase (HBE 52h or 4HBE 53h)\nThe Half Block Erase (HBE) command sets all bits in the addressed half block to 1 (all bytes are FFh). Before the \nHalf Block Erase (HBE) command can be accepted by the device, a Write Enable (WREN) command must be issued and decoded by the device, which sets the write enable la tch (WEL) in the Status Register to enable any write \noperations.\nThe instruction \n• 52h [CR2V[0] = 0] is followed by a 3-byte address (A23-A0), or\n• 52h [CR2V[0] = 1] is followed by a 4-byte address (A31-A0), or\n• 53h is followed by a 4-byte address (A31-A0)\nCS# must be driven into the logic HIGH state after the twenty-fourth or thirty-secon d bit of address has been \nlatched in on SI/IO0. This will initiate the erase cycl e, which involves the pre-programming and erase of each \nsector of the chose block. If CS# is not driven HIGH after the last bit of address, the half block erase operation will \nnot be executed. \nAs soon as CS# is driven into the logic HIGH state, the in ternal erase cycle will be initiated. With the internal erase \ncycle in progress, the user can read the value of the Writ e-in Progress (WIP) bit to check if the operation has been \ncompleted. The WIP bit will indicate a ’1’ when the erase cy cle is in progress and a ’0’ when the erase cycle has \nbeen completed.\nA Half Block Erase (HBE) command applied to a block th at has been write protected through the legacy block \nprotection, individual block lock or pointer region protec tion will not be executed and will set the E_ERR status.\nIf a Half Block Erase command is applied and if any region, sector or block in the half block erase area is protected \nthe erase will not be executed on the 32 KB range and will set the E_ERR status.\nFigure 82 Half Block Erase (HBE 52h  or 4HBE 53h) command sequence[44, 45]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in on IO0-IO3.\nFigure 83 Half Block Erase (HBE 52h or  4HBE 53h) QPI mode command sequence[44, 45]\nNotes\n44.A = MSb of address = A23 for HBE 52h with CR2V[0] = 0, or A31 for HBE 52h with CR2V[0] = 1 or 4HBE 53h.\n45.When A[15] = 0 the sectors 0-7 of block are erased and A[15] = 1 then sectors 8-15 of Block are erased.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                         \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCLK\nIO0\nIO1IO2\nIO3\nPhase \n              \n4 0 A-3  4 0\n5 1 A-2  5 1\n6 2 A-1  6 2\n7 3 A  7 3\nInstructtion                Address\nDatasheet 99 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.6.2 Block Erase (BE D8h or 4BE DCh)\nThe Block Erase (BE) command sets all bits in the addresse d block to 1 (all bytes are FFh). Before the Block Erase \n(BE) command can be accepted by the device, a Write En able (WREN) command must be issued and decoded by \nthe device, which sets the write enable latch (WEL) in the Status Register to enable any write operations.\nThe instruction \n• D8h [CR2V[0] = 0] is followed by a 3-byte address (A23-A0), or\n• D8h [CR2V[0] = 1] is followed by a 4-byte address (A31-A0), or\n• DCh is followed by a 4-byte address (A31-A0)\nCS# must be driven into the logic HIGH state after the twenty-fourth or thirty-secon d bit of address has been \nlatched in on SI/IO0. This will initiate the erase cycl e, which involves the pre-programming and erase of each \nsector of the chosen bl ock. If CS# is not driven HIGH after the last  bit of address, the block erase operation will \nnot be executed. \nAs soon as CS# is driven into the logic HIGH state, the in ternal erase cycle will be initiated. With the internal erase \ncycle in progress, the user can read the value of the Write- in Progress (WIP) bit to check if the operation has been \ncompleted. The WIP bit will indicate a ’1’ when the erase cy cle is in progress and a ’0’ when the erase cycle has \nbeen completed.\nA Block Erase (BE) command applied to a block that has been write protected through the legacy block \nprotection, individual block lock or pointer region protec tion will not be executed and will set the E_ERR status.\nIf a Block Erase command is applied and if any region or sector area is protected the erase will not be executed \non the 64 KB range and will set the E_ERR status.\nFigure 84 Block Erase (BE D8h or 4BE DCh) command sequence[46]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in on IO0-IO3. \nFigure 85 Block Erase (BE D8h or 4BE DCh) QPI mode command sequence[46]\nNote\n46.A = MSb of address = A23 for BE D8h with CR2V[0] = 0, or A31 for BE D8h with CR2V[0] = 1 or 4BE DCh.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                         \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCLK\nIO0IO1IO2\nIO3\nPhase \n              \n4 0 A-3  4 0\n5 1 A-2  5 1\n6 2 A-1  6 2\n7 3 A  7 3\nInstructtion                Address\nDatasheet 100 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.6.3 Chip Erase (CE 60h or C7h)\nThe Chip Erase (CE) command sets all bits to 1 (all bytes are FFh) inside the entire flash memory array. Before the \nCE command can be accepted by the device, a Write Enable (WREN) command must be issued and decoded by the device, which sets the write enable latch (WEL) in the Status Register to enable any write operations.\nCS# must be driven into the logic HIGH state after the ei ghth bit of the instruction byte has been latched in on \nSI/IO0. This will initiate the erase cycl e, which involves the pre-programming and erase of the entire flash memory \narray. If CS# is not driven HIGH after the last bit of  instruction, the CE operation will not be executed.\nAs soon as CS# is driven into the logic HIGH state, the eras e cycle will be initiated. With  the erase cycle in progress, \nthe user can read the value of the Write-in Progress  (WIP) bit to determine when the operation has been \ncompleted. The WIP bit will indicate a ’1’ when the erase cy cle is in progress and a ’0’ when the erase cycle has \nbeen completed.\nA CE command will not be executed when the legacy bloc k protection, individual block lock or pointer region \nprotection set to protect any sector or block and this will set the E_ERR status bit.\nFigure 86 Chip Erase command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 87 Chip Erase command sequence QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0\nIO1IO2\nIO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 101 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.6.4 Program or Erase Suspend (PES 75h)\nThe PES command allows the system to interrupt a prog ramming or erase operation and then read from any \nother non-erase-suspended sector or non-program-susp ended-page. Program or Erase Suspend is valid only \nduring a programming or sector erase, half block erase or  block erase operation. A chip erase operation cannot \nbe suspended.\nThe Write-in Progress (WIP) bit in Status Register 1 (S R1V[0]) must be checked to know when the programming \nor erase operation has stopped. The program suspend status bit in the Status Register 1 (SR2[0]) can be used to \ndetermine if a programming operation has been suspended or was completed at the time WIP changes to 0. The \nErase Suspend Status bit in the Status Register 1 (SR2[1]) can be used to determine if an erase operation has been \nsuspended or was completed at the time WIP changes to 0. The time required for the suspend operation to complete is t\nSL, see Table 57 .\nAn erase can be suspended to allow a program operation or  a read operation. During an erase suspend, the IBL \narray may be read to examine sector protection and written to remove or restore protection on a sector to be programmed. The Protection bits will not be rechecked wh en the operation is resumed so any changes made will \nnot impact current in progress operation. \nA program operation may be suspended to allow a read operation. \nA new suspend operation is not allowed with-in an alre ady suspended erase or prog ram operation. The suspend \ncommand is ignored in this situation.\nTable 36 Commands allowed during Program or Erase Suspend  \nInstruction \nnameInstruction \ncode (hex)Allowed \nduring \nErase \nSuspendAllowed \nduring \nProgram \nSuspendComment\nREAD 03 X X All array reads allowed in suspend\nRDSR1 05 X X Needed to read WIP to determine end of suspend process\nRDAR 65 X X Alternate way to read WIP to determine end of suspend process\nRDSR2 07 X X Needed to read suspend status to determine whether the operation \nis suspended or complete.\nRDCR1 35 X X Needed to read Configuration Register 1\nRDCR2 15 X X Needed to read Configuration Register 2RDCR3 33 X X Needed to read Configuration Register 3\nRUID 4B X X Needed to read Unique Id\nRDID 9F X X Needed to read Device Id\nRDQID AF X X Needed to read Quad Device Id\nRSFDP 5A X X Needed to read SFDP\nSBL 77 X X Needed to set burst length\nWREN 06 X X Required for program command within Erase Suspend\nWRDI 04 X X Required for program command within Erase Suspend\nPP 02 X – Required for array program during Erase Suspend. Only allowed if \nthere is no other program suspended program operation (SR2V[0] = \n0). A program command will be ignored while there is a suspended \nprogram. If a program command is sent for a location within an erase suspended sector the program operation will fail with the P_ERR bit \nset.\nNote\n47.For all Quad commands the Quad Enable CR1V[1] bit (See Table 11 ) needs to be set to ’1’ before initial program or erase, \nsince the WRR/WRAR commands are not allowed inside of the suspend state.\nDatasheet 102 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nAll command not included in Table 36  are not allowed during erase or pr ogram suspend. The WRR, WRAR, or \nSPRP commands are not allowed during erase or program su spend, it is therefore not possible to alter the legacy \nblock protection bits or pointer re gion protection during erase suspend.\nReading at any address within an erase-suspended sect or or program-suspended page produces undetermined \ndata. \nAfter an erase-suspended program operation is complete , the device returns to the Erase-Suspend mode. The \nsystem can determine the status of the program operation by reading the WIP bit in the Status Register, just as \nin the standard program operation.QPP 32 X – Required for array program during erase suspend. Only allowed if \nthere is no other program suspended program operation (SR2V[0] = \n0). A program command will be ignored while there is a suspended program. If a program command is sent for a location within an erase \nsuspended sector the program operation will fail with the P_ERR bit \nset.\nCLSR 30 X X Clear status may be used if a program operation fails during erase \nsuspend.\nEPR 7A X X Required to resume from erase or program suspend\nRSTEN 66 X X Reset allowed anytime\nRST 99 X X Reset allowed anytime\nFAST_READ 0B X X All array reads allowed in suspend\nDOR 3B X X All array reads allowed in suspend\nDIOR BB X X All array reads allowed in suspend\nIBLRD 3D X X It may be necessary to remove and restore individual block lock \nduring erase suspend to allow pr ogramming during erase suspend.\nIBL 36 X X It may be necessary to restore individual block lock during erase \nsuspend to allow programming during erase suspend. \nIBUL 39 X X It may be necessary to remove  individual block lock during erase \nsuspend to allow programming during erase suspend.\nQOR 6B X X Read Quad output (3-byte Address)[47]\nQIOR EB X X All array reads allowed in suspend[47]\nMBR FF X X May need to reset a re ad operation during suspend\nSECRP 42 X – All Security Regions program allowed in erase suspend\nSECRR 48 X X All Security Regions reads allowed in suspendTable 36 Commands allowed during Program or Erase Suspend   (continued)\nInstruction \nnameInstruction \ncode (hex)Allowed \nduring \nErase \nSuspendAllowed \nduring \nProgram \nSuspendComment\nNote\n47.For all Quad commands the Quad Enable CR1V[1] bit (See Table 11 ) needs to be set to ’1’ before initial program or erase, \nsince the WRR/WRAR commands are not allowed inside of the suspend state.\nDatasheet 103 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nFigure 88 Program or Erase Suspend command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 89 Program or Erase Suspend command sequence QPI mode \nFigure 90 Program or Erase Suspend command wi th continuing instruction commands sequenceCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nCS#\nSCK\nSI_IO0\nSO\nPhasePhase   \n                                                                        \n76543210 76543210 76543210\n76543210\nSuspend Instruction Read Status Instruction Status Instr. During Suspend\nRepeat Status Read Until SuspendedtSL\nDatasheet 104 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.6.5 Erase or Program Resume (EPR 7Ah)\nAfter program or read operations are completed duri ng a Program or Erase Suspend the erase or Program \nResume command is sent to continue the suspended operation. \nAfter an Erase or Program Resume command is issued, the WIP bit in the Status Register 1 will be set to a 1 and \nthe suspended operation will resume if one is suspende d. If there is no suspended program or erase operation \nthe Resume command is ignored. \nProgram or erase operations may be interrupted as of ten as necessary e.g. a Program Suspend command could \nimmediately follow a Program Resume command but, but in order for a program or erase operation to progress \nto completion there must be some periods of time between resume and the next suspend command greater than or equal to t\nRNS. See Table 57 .\nThe Program Suspend Status bit in the Status Register 1 (SR2[0]) can be used to determine if a programming \noperation has been suspended or was completed at the ti me WIP changes to 0. The Erase Suspend Status bit in \nthe Status Register 1 (SR2[1]) can be used to determ ine if an erase operation has been suspended or was \ncompleted at the time WIP changes to 0. See "Status Register 2 Volatile (SR2V)" on page 32.\nAn erase or program resume command must be written to resume a suspended operation. \nFigure 91 Erase or Program Resume command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 92 Erase or Program Resume command sequence QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 105 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.7 Security Regions Array commands\nThe Security Regions commands select which region  to use by address A15 to A8 as shown below.\n• Security Region 0: A23-16 = 00h; A15-8 = 00h; A7-0 = Byte address• Security Region 1: A23-16 = 00h; A15-8 = 01h; A7-0 = Byte address\n• Security Region 2: A23-16 = 00h; A15-8 = 02h; A7-0 = Byte address\n• Security Region 3: A23-16 = 00h; A15-8 = 03h; A7-0 = Byte address\n8.7.1 Security Region Erase (SECRE 44h)\nThe Security Region Erase command erases data in the Secu rity Region, which is in a different address space from \nthe main array data. The Security Region is 1024 bytes so, the address bits for S25FL064L (A22 to A10) must be \nzero for this command. Each region can be individually erased. Refer to "Security Regions address space" on \npage 28 for details on the Security Region. \nBefore the Security Region Erase command can be acce pted by the device, a Write Enable (WREN) command \nmust be issued and decoded by the device, which sets th e write enable latch (WEL) in the Status Register to \nenable any write operations. The WIP bi t in SR1V may be checked to determ ine when the operation is completed. \nThe E_ERR bit in SR2V may be checked to determine if an error occurred during the operation.\nThe Security Region Lock bits (CR1NV[2-5]) in the Config uration Register 1 can be used to protect the Security \nRegion for erase. Once a Lock bit is set to 1, the co rresponding Security Regions will be permanently locked, \nAttempting to erase a region that is locked wi ll fail with the E_ERR bit in SR2V[6] set to ’1’ .\nWhen the Protection Register NVLOCK bit = ’0’ , Security Region 2 and 3 are protected from program or erase. \nAttempting to erase in a region that locked will fa il with the E_ERR bits in SR2V[6] set to ’1’ . See "NVLOCK bit \n(PR[0])" on page 57.\nThe Password Protection Mode Lock bit (IRP[2]) allows regions 2 and 3 to be protected from erase operations \nuntil the correct password is provided to enable erasing of  these Security Regions. Atte mpting to erase in a region \nthat is password locked will fail with the E_ERR bit in SR2V[6] set to ’1’ . \nThe protocol of the Security Region erase command  is the same as the Sector Erase command. See "Sector Erase \n(SE 20h or 4SE 21h)" on page 97 for the command sequence. QPI mode is supported.\n8.7.2 Security Region Program (SECRP 42h)\nThe Security Region Program command programs data in the Security Region, which is in a different address \nspace from the main array data. The Security Region is  1024 bytes so, the Address bi ts for S25FL064L (A22 to A10) \nmust be zero for this command. Refer to "Security Regions address space" on page 28 for details on the Security \nRegion. \nBefore the Security Region Program command can be accepted by the device, a Write Enable (WREN) command \nmust be issued and decoded by the device, which sets th e write enable latch (WEL) in the Status Register to \nenable any write operations. The WIP bi t in SR1V may be checked to determ ine when the operation is completed. \nThe P_ERR bit in SR2V may be checked to determ ine if any error occurred during the operation.\nTo program the Security Region array in bit granularity, th e rest of the bits within a data byte can be set to ’1’ .\nEach region in the Security Region memory space can be programmed one or more times, provided that the \nregion is not locked. However, for the best data integrity, it is recommended that one or more 16-byte length and aligned groups of bytes be programed together and pr ogrammed only once between erase operations within \neach region. \nThe Security Region Lock bits (CR1NV[2-5]) in the Config uration Register 1 can be used to protect the Security \nRegions for programming. Once a Lock bit is set to 1, the corresponding Security Re gion will be permanently \nlocked. Attempting to program zeros or ones in a region th at is locked (protected) will fail with the P_ERR bit in \nSR2V[5] set to ’1’ . Programming ones in a un-protected area does not cause an error and does not set P_ERR (see \n"Configuration Register 1" on page 33 for detail descriptions). \nDatasheet 106 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nWhen the Protection Register NVLOCK bit = ’0’ , Security  Regions 2 and 3 are protected from program or erase. \nAttempting to program in a region that locked will fail with the P_ERR bit in SR2V[5] set to ’1’ . See "NVLOCK bit \n(PR[0])" on page 57.\nThe Password Protection Mode Lock bit (IRP[2]) allo ws regions 2 and 3 to be protected from programming \noperations until the correct password is provided to enable programming of these Security Regions 2 and 3. \nAttempting to program in a region that is password locked will fail with the P_ERR bit in SR2V[5] set to ’1’ . See \n"Password Protection mode" on page 57.\nThe protocol of the Security Region program comm and is the same as the Page Program command. See "Page \nProgramming" on page 95 for the command sequence. QPI mode is supported.\n8.7.3 Security Regions Read (SECRR 48h)\nThe Security Region Read (SECRR) command provides a way to read data from the Security Regions. The Security \nRegion is 1024 bytes so, the address bits forS25FL064L (A22 to A10) must be zero for this command. Refer to "Security Regions address space" on page 28 for details on the Security Regions. \nThe instruction is followed by a 3 or 4 byte address (d epending on the address length configuration CR2V[0], \nfollowed by a number of latency (dummy) cycles set by CR 3V[3:0]. Then the selected register data are returned. \nThe protocol of the Security Region read command will no t wrap to the starting addre ss after the Security Region \naddress is at its maximum; instead, the data beyond the maximum address will be undefined. The Security Region read command read latency is set by the latency value in CR3V[3:0]. \nThe Security Region Read Password Mode Enable bit (IRP[6]) allows regions 3 to be protected from read \noperations until the correct password is provided to enab le reading of this Security Region. Attempting to read \nin region 3 that is password locked will return invalid and undefined data. See "Security Region read password \nprotection" on page 58 .\nFigure 93 Security Regions Read command sequence\n[48]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in and returning \ndata out on IO0-IO3. \nFigure 94 Security Regions Read command sequence QPI mode[49]CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210A 10  \n76543210 \nInstruction          Address Dummy Cycles Data 1\nNotes\n48.A = MSb of address = 23 fo r address length CR2V[0] = 0, or 31 for CR2V[0] = 1.\n49.A = MSb of address = 23 for CR2V[0] = 0, or 31 for CR2V[0] = 1.CS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                                     \n4 0 A-3  4 0 4 0 4 0 4 0 4 0  \n5 1 A-2  5 1 5 1 5 1 5 1 5 1  \n6 2 A-1  6 2 6 2 6 2 6 2 6 2  \n7 3 A  7 3 7 3 7 3 7 3 7 3  \nInstruct.                Address Dummy D1 D2 D3 D4\nDatasheet 107 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.8 Individual Block Lock commands\nIn order to use Individual Block Lock, the IBL protection scheme must be selected by the WPS bit in Configuration \nRegister 2 CR2V[2] = 1. If if IBL protection scheme is  not selected CR2V[2] = 0 the IBL commands are ignored. \nindividual block Lock bits (IBL) are volatile, with one for each sector / block, and can be individually modified. By \nissuing the IBL or GBL commands, a IBL bit is set to ’0’ prot ecting each related sector / block. By issuing the IBUL \nor GUL commands, a IBL bit is cleared to ’1’ unprotecting each related sector or block. By issuing the IBLRD command the state of each IBL bit protection can be read.\n8.8.1 IBL Read (IBLRD 3Dh or 4IBLRD E0h)\nThe IBLRD/4IBLRD command allows reading the state of each IBL bit protection.\nThe instruction is latched into SI by the rising edge of the SCK signal. The instruction is followed by the \n24- or 32- bit address, depending on the address length co nfiguration CR2V[0], selectin g location zero within the \ndesired sector. \nThen the 8-bit IBL access register contents are shifted out on the serial output SO/IO1.Each bit is shifted out at \nthe SCK frequency by the falling edge of the SCK signal. It is possible to read the same IBL access register \ncontinuously by providing multiples of  eight clock cycles. The address of th e IBL register does not increment so \nthis is not a means to read the entire IBL array. Each location must be read with a separate IBL read command. \nFigure 95 IBLRD command sequence[50, 51]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in and returning \ndata out on IO0-IO3. \nFigure 96 IBLRD command sequence QPI[50, 51]\nNotes\n50.A = MSb of address = 23 for Address length CR2V [0] = 0, or 31 for CR2V[0] = 1 with command 3Dh.\n51.A = MSb of address = 31 with command E0h.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210A 10  \n76543210 \nInstruction          Address     Dummy Cycles Output IBL\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                             \n4 0 A-3  4 0 4 0 4 0  \n5 1 A-2  5 1 5 1 5 1  \n6 2 A-1  6 2 6 2 6 2  \n7 3 A  7 3 7 3 7 3  \nInstruct.                Address      Dummy IBL Repeat IBL\nDatasheet 108 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.8.2 IBL Lock (IBL 36h or 4IBL E1h)\nThe IBL/4IBL commands sets the selected IBL bit to ’0’ protecting each related sector / block. \nThe IBL command is entered by driving CS# to the logic LOW state, followed by the instruction, followed by the \n24- or 32-bit address, depending on the address length configuration CR2V[0]. The IBL command affects the WIP \nbits of the Status and Configuration Registers in th e same manner as any other programming operation. \nCS# must be driven to the logic HIGH state after the 24- or 32-bit address (depending on the address length \nconfiguration CR2V[0]) has been latched in. As soon as CS # is driven to the logic HIGH state, the self-timed IBL \noperation is initiated. While the IBL operation is in progre ss, the Status Register may be read to check the value \nof the Write-in Progress (WIP) bit. The Write-in Progress (W IP) bit is a ’1’ during the self-timed IBL operation, and \nis a ’0’ when it is completed. \nFigure 97 IBL command sequence[52, 53]\nThis command is also supported in QPI mode. In QPI mode , the instruction and address is shifted in on IO0-IO3.\nFigure 98 IBL command sequence QPI mode[52, 53]\nNotes\n52.A = MSb of address = 23 for Address length CR2V[0] = 0, or 31 for CR2V[0] = 1 with command 36h.\n53.A = MSb of address = 31 with command E1h.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                         \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n              \n4 0 A-3  4 0\n5 1 A-2  5 1\n6 2 A-1  6 2\n7 3 A  7 3\nInstructtion                Address\nDatasheet 109 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.8.3 IBL Unlock (IBUL 39h or 4IBUL E2h)\nThe IBUL/4IBULcommands clears the selected IBL bit to ’1’ unprotecting each related sector / block. \nThe IBUL command is entered by driving CS# to the logic LOW state, followed by the instruction, followed by the \n24- or 32- bit address, depending on the address length  configuration CR2V[0]. The IBUL command affects the \nWIP bits of the Status and Configuration Registers in  the same manner as any other programming operation. \nCS# must be driven to the logic HIGH state after the 24- or 32-bit address (depending on the address length \nconfiguration CR2V[0]) has been latched in. As soon as CS # is driven to the logic HIGH state, the self-timed IBL \noperation is initiated. While the IBUL operation is in prog ress, the Status Register may be read to check the value \nof the Write-in Progress (WIP) bit. The Write-in Progress (WIP ) bit is a ’1’ during the self-timed IBUL operation, and \nis a ’0’ when it is completed. \nFigure 99 IBUL command sequence[53, 54]\nThis command is also supported in QPI mode. In QPI mode, the instruction and address is shifted in on IO0-IO3.  \nFigure 100 IBUL command sequence QPI mode[54, 55]CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                         \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n              \n4 0 A-3  4 0\n5 1 A-2  5 1\n6 2 A-1  6 2\n7 3 A  7 3\nInstructtion                Address\nNotes\n54.A = MSb of address = 23 for Address length (CR2V[ 0] = 0, or 31 for CR2V[0] = 1 with command 39h.\n55.A = MSb of address = 31 with command E2h.\nDatasheet 110 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.8.4 Global IBL Lock (GBL 7Eh)\nThe GBL commands sets all the IBL bits to ’0’ protecting all sectors / blocks. \nCS# must be driven into the logic HIGH state after the eigh th bit of the instruction byte has been latched in on SI. \nThis will initiate the GBL. If CS# is not driven HIGH after the la st bit of instruction, th e GBL operation will not be \nexecuted.\nAs soon as CS# is driven into the logic HIGH state, the GB L will be initiated. With the GBL in progress, the user can \nread the value of the Write-in Progress (WIP) bit to de termine when the operation ha s been completed. The WIP \nbit will indicate a ’1’ when the GBL is in progress and a ’0’ when the GBL has been completed.\nFigure 101 Global IBL lock (GBL) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 102 Global IBL lock (GBL) command sequence QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0\nIO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 111 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.8.5 Global IBL Unlock (GBUL 98h)\nThe GBUL commands clears all the IBL bits to ’1’ unprotecting all sectors / blocks. \nCS# must be driven into the logic HIGH state after the eigh th bit of the instruction byte has been latched in on SI. \nThis will initiate the GBUL If CS# is not driven HIGH after the last bit of instruction, the GBUL operation will not be \nexecuted.\nAs soon as CS# is driven into the logic HIGH state, the GB L will be initiated. With the GBL in progress, the user can \nread the value of the Write-in Progre ss (WIP) bit to determine when the op eration has been completed. The WIP \nbit will indicate a ’1’ when the GBUL is in progress and a ’0’ when the GBUL has been completed.\nFigure 103 Global IBL Unlock (GBUL) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 104 Global IBL Unlock (GBUL) command sequence QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0\nIO1\nIO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 112 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.9 Pointer Region command\n8.9.1 Set Pointer Region Protec tion (SPRP FBh or 4SPRP E3h)\nThe SPRP or 4SPRP command is ignored during a suspend operation because the pointer value cannot be erased \nand re-programmed during a suspend.\nThe SPRP or 4SPRP command is ignored if default power supply lock-down protection NVLOCK PR[0] = 0 or power \nsupply lock-down protection enabled IRP[1] = 0 or passwo rd protection enabled IRP[2] = 0 and NVLOCK PR[0] = 0.\nBefore the SPRP or 4SPRP command can be accepted by the device, a Write Enable (WREN) command must be \nissued. After the Write Enable (WREN)  command has been decoded, the device will set the write enable latch \n(WEL) in the Status Register to enable any write operations.\nThe SPRP or 4SPRP command is entere d by driving CS# to the logic LOW st ate, followed by the instruction, \nfollowed by the 24- or 32-bit address, depending on the address length configuration CR2V[0], see "Pointer \nregion protection (PRP)" on page 53 for details on address values to select protection options.\nCS# must be driven to the logic HIGH state after the last  bit of address has been latched in. If not, the SPRP \ncommand is not executed. As soon as CS# is driven to the logic HIGH state, the se lf-timed SPRP operation is \ninitiated. While the SPRP operation is in progress, the St atus Register may be read to check the value of the \nWrite-in Progress (WIP) bit. The WIP bit is a ’1’ during the self-timed SPRP operation, and is a ’0’ when it is \ncompleted. When the SPRP operation is completed, the write enable latch (WEL) is set to a ’0’. The SPRP or 4SPRP \ncommand will set the P_ERR or E_ERR bits if there is a failure in the set pointer region protection operation.\nFor details on the address pointer defining a sector bo undary between protected and unprotected regions in the \nmemory, see "Pointer region protection (PRP)" on page 53.\nFigure 105 SPRP command sequence[56, 57]\nThis command is also supported in QPI mode. In QPI mode, the instruction and address is shifted in on IO0-IO3.   \nFigure 106 SPRP command sequence QPI mode[56, 57]\nNotes\n56.A = MSb of address = 23 for addre ss length (CR2V[0] = 0,  or 31 for CR2V[0] = 1 with command FDh.\n57.A = MSb of address = 31 with command E3h.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                         \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n              \n4 0 A-3  4 0\n5 1 A-2  5 1\n6 2 A-1  6 2\n7 3 A  7 3\nInstructtion                Address\nDatasheet 113 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10 Individual and Region Protection (IRP) commands\n8.10.1 IRP Register Read (IRPRD 2Bh)\nThe IRP Register Read instruction 2Bh is shifted into SI/I O0 by the rising edge of the SCK signal followed by one \ndummy cycle. This latency period allows the device’s internal circuitry enough time to access data at the initial address. During latency cycles, the data value on IO0-IO3 are “don’t care” and may be high impedance. \nThen the 16-bit IRP Register contents are shifted out on the serial output S0/IO1,least significant byte first. Each \nbit is shifted out at the SCK frequency by the falling edge of  the SCK signal. It is possible to read the IRP register \ncontinuously by providing mu ltiples of 16 clock cycles. \nFigure 107 IRPRD command sequence\nThis command is also supported in QPI mode. In QPI mode, the instruction is shifted in and returning data out on \nIO0-IO3.  \nFigure 108 IRPRD command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210  \n7654321076543210\nInstruction DY Output IRP Low Byte Output IRP High Byte\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n               \n4 0 4 0 4 0  \n5 1 5 1 5 1  \n6 2 6 2 6 2\n7 3 7 3 7 3  \nInstruct. Dummy IRP Low Byte IRP High Byte\nDatasheet 114 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10.2 IRP Program (IRPP 2Fh)\nBefore the IRP program (IRPP) command can be accepted  by the device, a Write En able (WREN) command must \nbe issued. After the Write Enable (WREN) command has been  decoded, the device will set the write enable latch \n(WEL) in the Status Register to enable any write operations.\nThe IRPP command is entered by driving CS# to the logi c LOW state, followed by the instruction and two data \nbytes on SI, least significant byte first. The IRP Register is two data bytes in length. \nThe IRPP command affects the P_ERR and WIP bits of the St atus and Configuration Registers in the same manner \nas any other programming operation.\nCS# input must be driven to the logic HIGH state after the sixteenth bit of data has been latched in. If not, the IRPP \ncommand is not executed. As soon as CS# is driven to the logic HIGH state, the se lf-timed IRPP operation is \ninitiated. While the IRPP operation is in  progress, the Status Register may be read to check the value of the \nWrite-in Progress (WIP) bit. The Write- in Progress (WIP) bit is a ’1’ during the self-timed IRPP operation, and is a \n’0’ when it is completed. When the IRPP operation is completed, the write enable latch (WEL) is set to a ’0’ .\nFigure 109 IRP Program (IRPP) command\nThis command is also supported in QPI mode. In QPI mode , the instruction and data is shifted in on IO0-IO3. \nFigure 110 IRP Program (IRPP) command QPICS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 65 4 32 10 76 54 3 21 07 65 43 2 10\nInstruction Input IRP Low Byte Input IRP High Byte\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n              \n4 0 4 0 C 8\n5 1 5 1 D 9\n6 2 6 2 E A\n7 3 7 3 F B\nInstruct. IRP Low Byte IRP High Byte\nDatasheet 115 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10.3 Protection Register Read (PRRD A7h)\nThe Protection Register Read (PRRD) command allows the Pr otection Register contents to be read out of SO/IO1. \nThe read instruction A7h is shifted into SI by the rising edge of the SCK signal follow ed by one dummy  cycle. This \nlatency period allows the device’s internal circuitry enou gh time to access data at the initial addr ess. During \nlatency cycles, the data value on IO0-IO3 are “don’t care” and may be high impedance. \nThen the 8-bit Protection Register contents are shifted out on the serial output SO/IO1. Each bit is shifted out at \nthe SCK frequency by the falling edge of the SCK signal. It is possible to read the Protection register continuously \nby providing multiples of eight clock cycles. \nThe Protection Register contents may only be read when the device is in STANDBY state with no other operation \nin progress.\nFigure 111 Protection Register Read (PRRD) command sequence\nThis command is also supported in QPI mode. In QPI mode, the instruction is shifted in and returning data out on \nIO0-IO3.  \nFigure 112 Protection Register Read (PRRD) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase \n                                                \n76543210  \n7654321076543210\nInstruction DY Register Read Repeat Register Read\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n               \n4 0 4 0 4 0  \n5 1 5 1 5 1  \n6 2 6 2 6 2\n7 3 7 3 7 3  \nInstruct. Dummy Register Read Register Read\nDatasheet 116 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10.4 Protection Register Lock (PRL A6h)\nThe Protection Register Lock (PRL) command clears the NV LOCK bit (PR[0]) to zero and loads the IRP[6] value in \nto SECRRP (PR[6]). See "Protection Register (PR)" on page 44. Before the PRL command can be accepted by the \ndevice, a Write Enable (WREN) command must be issued and decoded by the device, which sets the write enable \nlatch (WEL) in the Status Register to enable any write operations.\nThe PRL command is entered by driving CS# to th e logic LOW state, followed by the instruction.\nCS# must be driven to the logic HIGH state after the eighth  bit of instruction has been latched in. If not, the PRL \ncommand is not executed. As soon as CS# is driven to the logic HIGH state, the se lf-timed PRL operation is \ninitiated. While the PRL operation is in progress, the Status  Register may still be read to check the value of the \nWrite-in Progress (WIP) bit. The WIP bit is a ’1’ during the self-timed PRL operation, and is a ’0’ when it is \ncompleted. When the PRL operation is completed, the write enable latch (WEL) is set to a ’0’ . \nFigure 113 Protection Register Lock (PRL) command sequence\nThis command is also supported in QPI mode. In QP I mode the instruction is shifted in on IO0-IO3. \nFigure 114 Protection Register Lock (PRL) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 117 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10.5 Password Read (PASSRD E7h)\nThe correct password value may be read only after it is programmed and before the Password mode has been \nselected by programming the Password Protection Mode bi t to 0 in the IRP Register (IRP[2]). After the Password \nProtection mode is selected the password is no long er readable, the PASSRD command will output undefined \ndata.\nThe PASSRD command is shifted into SI followed by one dummy cycle. This latency period allows the device’s \ninternal circuitry enough time to access data at the init ial address. During latency cycles, the data value on are \n“don’t care” and may be high impedance. \nThen the 64-bit password is shifted out on the serial output, least significant byte first, most significant bit of each \nbyte first. Each bit is shifted out at the SCK frequency by the falling edge of the SCK signal. It is possible to read the password continuously by prov iding multiples of 64 clock cycles. \nFigure 115 Password Read (PASSRD) command sequence\nThis command is also supported in QPI mode. In QPI mode, the instruction is shifted in and returning data out on \nIO0-IO3.\nFigure 116 Password Read (PASSRD) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nIO2-IO3\nPhase \n                                                \n7 6 5 4 3 2 1 0  \n7 6 5 4 3 2 1 0 7 6 5 4 3 21 0\nInstruction DY Data 1 Data 8\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n                   \n4 0 4 0 4 0 4 0  \n5 1 5 1 5 1 5 1  \n6 2 6 2 6 2 6 2\n7 3 7 3 7 3 7 3  \nInstruct. Dummy Data 1 Data 8\nDatasheet 118 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10.6 Password Program (PASSP E8h)\nBefore the Password Program (PASSP) command can be  accepted by the device, a Write Enable (WREN) \ncommand must be issued and decoded by the device . After the Write Enable (WREN) command has been \ndecoded, the device sets the write enable latch (WEL) to enable the PASSP operation.\nThe password can only be programmed before the Passwo rd mode is selected by programming the Password \nProtection Mode bit to 0 in the IRP Register (IRP[2]). Af ter the Password Protection mode is selected the PASSP \ncommand is ignored.\nThe PASSP command is entered by driving CS# to the logic LOW state, followed by the instruction and the \npassword data bytes on SI/IO0, least significant byte first, most significant bit of each byte first. The password is sixty-four (64) bits in length. \nCS# must be driven to the logic HIGH state after the sixty-fourth (64th) bit of data has been latched. If not, the \nPASSP command is not executed. As soon as CS# is driven to the logic HIGH state, the self-timed PASSP operation \nis initiated. While the PASSP operation is in progress, th e Status Register may be read to check the value of the \nWrite-in Progress (WIP) bit. The Write- in Progress (WIP) bit is a ’1’ during th e self-timed PASSP cycle, and is a ’0’ \nwhen it is completed. The PASSP command can report a program error in the P_ERR bit of the status register. \nWhen the PASSP operation is completed, the write enable latch (WEL) is set to a ’0’ . \nFigure 117 Password Program (PASSP) command sequence \nThis command is also supported in QPI mode. In QPI mode , the instruction and data is  shifted in on IO0-IO3. \nFigure 118 Password Program (PASSP) command sequence QPI modeCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Password Byte 1 Password Byte 8\nCS#\nSCLK\nIO0\nIO1\nIO2\nIO3\nPhase \n                  \n4 0 4 0 4 0 4 0\n5 1 5 1 5 1 5 1\n6 2 6 2 6 2 6 2\n7 3 7 3 7 3 7 3\nInstruct. Password Byte 1 Password Byte 8\nDatasheet 119 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.10.7 Password Unlock (PASSU EAh)\nThe PASSU command is entered by driving CS# to the lo gic LOW state, followed by the instruction and the \npassword data bytes on SI, least significant byte first, most significant bit of each byte first. The password is sixty-four (64) bits in length. \nCS# must be driven to the logic HIGH state after the sixty-fourth (64th) bit of data has been latched. If not, the \nPASSU command is not executed. As soon as CS# is driven to the logic HIGH state, the self-timed PASSU operation \nis initiated. While the PASSU operation is in progress, th e Status Register may be read to check the value of the \nWrite-in Progress (WIP) bit. The Write- in Progress (WIP) bit is a ’1’ during the self-timed PASSU cycle, and is a ’0’ \nwhen it is completed. \nIf the PASSU command supplied password does not match the hidden password in the Password Register, an \nerror is reported by setting the P_ERR bit to 1. The WIP bit of  the status register also remains set to 1. It is necessary \nto use the CLSR command to clear the Status Register, the Software Reset command (RSTEN 66h followed by RST 99h) to reset the device, or drive the RESET# and IO3 / RESET#  input to initiate a hardware reset, in order to return \nthe P_ERR and WIP bits to 0. This returns the device to standby STANDBY, ready for new commands such as a \nretry of the PASSU command.\nIf the password does match, the NVLOCK bit is set to ’1’ . \nFigure 119 Password Unlock (PASSU) command sequence \nThis command is also supported in QPI mode. In QPI mode , the instruction and data is  shifted in on IO0-IO3. \nFigure 120 Password Unlock (PASSU) command sequence QPI modeCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Password Byte 1 Password Byte 8\nCS#\nSCLK\nIO0\nIO1\nIO2\nIO3\nPhase \n                  \n4 0 4 0 4 0 4 0\n5 1 5 1 5 1 5 1\n6 2 6 2 6 2 6 2\n7 3 7 3 7 3 7 3\nInstruct. Password Byte 1 Password Byte 8\nDatasheet 120 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.11 Reset commands\nSoftware controlled Reset commands restore the device to  its initial power up state, by reloading volatile \nregisters from non-volatile default values. If a software re set is initiated during a erase, program or writing of a \nregister operation the data in that sector, page or Register is not stable, the operation that was interrupted needs to be initiated again.\nHowever, the volatile SRP1 bit in the Configuration Regist er CR1V[0] and the volatile NVLOCK bit in the Protection \nRegister are not changed by a software reset. The software reset cannot be used to circumvent the SRP1 or NVLOCK bit protection mechanisms for the other security configuration bits. \nThe SRP1 bit and the NVLOCK bit will remain set at their la st value prior to the software reset. To clear the SRP1 \nbit and set the NVLOCK bit to its Protection mode selected power on state, a full power-on-reset sequence or hardware reset must be done. \nA Software Reset command (RSTEN 66h followed by RST 99h ) is executed when CS# is brought HIGH at the end \nof the instruction and requires t\nRPH time to execute.\nIn the case of a previous power-up reset (POR) failure to complete, a Reset command triggers a full power up \nsequence requiring tPU to complete.\nFigure 121 Software Reset / Mode Bit Reset command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 122 Software Reset / Mode Bit command sequence – QPI mode \n8.11.1 Software Reset Enable (RSTEN 66h)\nThe Reset Enable (RSTEN) command is required immediat ely before a Software Reset command (RST 99h) such \nthat a Software Reset is a sequence of the two comm ands. Any command other than RST following the RSTEN \ncommand, will clear the reset enable condition and prevent a later RST command from being recognized. \n8.11.2 Software Reset (RST 99h)\nThe Reset (RST) command immediately following a RSTEN command, initiates the Software Reset process. Any command other than RST following the RSTEN command, will clear the reset enable condition and prevent a later RST command from being recognized.CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 121 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.11.3 Mode Bit Reset (MBR FFh)\nThe Mode Bit Reset (MBR) command is used to return the device from Continuous High Performance Read mode \nback to normal Standby awaiting any new command. Be cause the hardware RESET# input may be disabled and \na device that is in a Continuous High Performance Read mode may not recognize any normal SPI command, a \nSystem Hardware Reset or Software Reset command may not be recognized by the device. It is recommended to use the MBR command after a system reset when the RESET# signal is not available or, before sending a Software \nReset, to ensure the device is released fr om Continuous High Performance Read mode.\nThe MBR command sends ones on SI/IO0for eight SCK cy cles. IO1-IO3 are “don’t care” during these cycles.\n8.11.4 Deep Power Down commands\n8.11.5 Deep Power Down (DPD B9h)\nAlthough the standby current during normal operation is relatively low, standby current can be further reduced \nwith the Deep Power Down command . The lower power consumption makes the Deep Power Down (DPD) \ncommand especially useful for battery powered applications (see ICC1 and ICC2 in ("DC characteristics" on page \n138). The command is initiated by driving the CS# pin LOW and shifting the instruction code “B9h” .\nThe CS# pin must be driven HIGH after the eighth bit has been latched. If this is not done the Deep Power Down \ncommand will not be executed. After CS# is driven HIGH , the power-down state will be entered within the time \nduration of tDP (Table 54 ). While in the power-down state only the release from Deep Power Down / Device ID \ncommand, which restores the device to normal operation, will be recognized. All other commands are ignored. This includes the Read Status Register  command, which is always  available during normal operation. Ignoring all \nbut one command also makes the power down state a usef ul condition for securing maximum write protection. \nWhile in the Deep Power Down mode the device will only accept a hardware reset which will initiate a power on \nreset that will restore the device to normal operation. The device always powers-up in the normal operation with the standby current of I\nCC1.\nFigure 123 Deep Power Down (DPD) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 124 Deep Power Down (DPD) command sequence – QPI mode CS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nDatasheet 122 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\n8.11.6 Release from Deep Power Down / Device ID (RES ABh)\nThe release from Deep Power Down / Device ID command is a multi-purpose command. It can be used to release \nthe device from the deep power-down state, or obtain  the devices electronic identification (ID) number.\nTo release the device from the deep power-down state,  the command is issued by driving the CS# pin LOW, \nshifting the instruction code “ABh” and driving CS# HI GH. Release from deep power-down will take the time \nduration of tRES (Table 54 ) before the device will resume normal operation and other commands are accepted. \nThe CS# pin must remain HIGH during the tRES time duration.\nWhen used only to obtain the Device  ID while not in the deep power-down state, the command is initiated by \ndriving the CS# pin LOW and shifting the instruction code “ABh” followed by 3-dummy bytes. The Device ID bits \nare then shifted out on the falling edge of CLK with most significant bit (MSb) first. The Device ID values for the \nS25FL-L family is listed in and Table 43 . Continued shifting of output beyond the end of the defined ID address \nspace will provide undefined data. The command is completed by driving CS# HIGH.\nWhen used to release the device from the deep power-down state and obtain the device ID, the command is the \nsame as previously described, and shown in Figure 127  and Figure 128 , except that after CS# is driven HIGH it \nmust remain HIGH for a time duration of tRES. After this time duration the device will resume normal operation \nand other commands will be accepted. If the release from Deep Power-down / Device ID command is issued while an erase, program or write cycle is in process (when BU SY equals 1) the command is ignored and will not have \nany effects on the current cycle.\nFigure 125 Release from Deep Power Down (RES) command sequence\nThis command is also supported in QPI mode. In QP I mode, the instruction is shifted in on IO0-IO3. \nFigure 126 Release from Deep Power Down (RES) command sequence – QPI mode \nFigure 127 Read Identification (RES) command sequenceCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCLK\nIO0IO1IO2IO3\nPhase \n      \n4 0\n5 1\n6 2\n7 3\nInstruction\nCS#\nSCK\nSI_IO0\nSO_IO1\nPhase7654321023 10\n765432107 10\nInstruction Dummy Dev ID Dev ID\nDatasheet 123 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nCommands\nThis command is also supported in QPI mode. In QPI mo de, the instruction is shif ted in on IO0-IO3 and the \nreturning data is sh ifted out on IO0-IO3.\nFigure 128 Read Identification (RES) QPI mode command CS#\nSCLK\nIO0\nIO1\nIO2\nIO3\nPhase \n                      \n4 0 23 22 4 0 4 0 4 0 4\n5 1 5 5 1 5 1 5\n6 2 6 6 2 6 2 6\n7 3 7 7 3 7 3 7\nInstruction Dummy Dev ID Dev ID\nDatasheet 124 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nData integrity\n9D a t a  i n t e g r i t y\n9.1 Erase endurance\n9.2 Data retention\nContact Infineon and FAE for further information on the data integrity. An application note is available at: \nwww.infineon.com/support .Table 37 Erase endurance\nParameter Minimum Unit \nProgram/erase cycles per main flash array sectors 100 K PE cycle\nProgram/erase cycles Security Region or Non-volatile Register Array[58]1 K PE cycle\nNote\n58.Each write command to a Non-volatile Register causes a PE cycle on the entire Non-volatile Register Array. \nTable 38 Data retention\nParameter Test conditions Minimum time Unit \nData retention time 10 K program/erase cycles 20 Years\n100 K program/erase cycles 2 Years\nDatasheet 125 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n10 Software interface reference\n10.1 JEDEC JESD216B serial flash discoverable parameters\nThis document defines the serial flash discoverable parameters (SFDP) revision B data structure used in the \nfollowing Infineon serial flash devices:\n• S25FL-L family\nThese data structure values are an update to the earlier revision SFDP data structure currently existing in the \nabove devices.\nThe Read SFDP (RSFDP) command (5Ah) reads informatio n from a separate flash memory address space for \ndevice identification, feature, and configuration inform ation, in accord with the JEDEC JESD216B standard for \nserial flash discoverable parameters. \nThe SFDP data structure consists of a header table that identifies the revision of th e JESD216 header format that \nis supported and provides a revision number and pointer for each of the SFDP parameter tables that are provided. The parameter tables follow the SFDP header. However, the parameter tables may be placed in any physical location and order within the SFDP address space. The ta bles are not necessarily adjacent nor in the same order \nas their header table entries.\nThe SFDP header points to the following parameter tables:\n•B a s i c  f l a s h\n- This is the original SFDP table. It has a few modified fi elds and new additional field added at the end of the table.\n• 4-byte address instruction\n- This is the original SFDP table. It has a few modified fi elds and new additional field added at the end of the table.\nThe physical order of the tables in the SFDP address sp ace is: SFDP header, Basic flash sector map, 4-byte \nInstruction.\nThe SFDP address space is programmed by In fineon and read-only for the host system.\n10.1.1 Serial flash discoverable parameters (SFDP) address map\nThe SFDP address space has a header starting at address zero that identifies the SFDP data structure and provides \na pointer to each parameter. One basic flash parameter is mandated by the JEDEC JESD216B standard. Optional \nparameter tables for 4-byte address instructions follow the basic flash table.\nTable 39 SFDP overview map\nByte \naddressDescription \n0000h Location zero within JEDEC JESD216B SFDP space - start of SFDP header\n... Remainder of SFDP header followed by undefined space\n0300h Start of SFDP parameter\n... Remainder of SFDP JEDEC parameter followed by undefined space\nDatasheet 126 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n10.1.2 SFDP header field definitions\nTable 40 SFDP header\nSFDP byte \naddressSFDP Dword \nnameData Description \n00h\nSFDP header 1st \nDWORD53hThis is the entry point for read SFDP (5Ah) command i.e. location zero within \nSFDP space\nASCII “S”\n01h 46h ASCII “F”\n02h 44h ASCII “D”\n03h 50h ASCII “P”04h\nSFDP header 2nd \nDWORD06hSFDP minor revision (06h = JEDEC JESD216 Revision B) \n- This revision is backward compatible  with all prior minor revisions. SFDP \nreading and parsing software will work with higher minor revision numbers \nthan the software was designed to ha ndle. Software designed for a higher \nrevisions must know how to handle earlier revisions. Example: SFDP reading and parsing software for minor revision 0 will still work with minor \nrevision 6. SFDP reading and parsing software for minor revision 6 must be \ndesigned to also read minor revision 0 or 5. Do not do a simple compare on the minor revision number, looking on ly for a match with the revision \nnumber that the software is designed to handle. There is no problem with \nusing a higher number minor revision.\n05h\n01hSFDP major revision\nThis is the original major revision. This  major revision is compatible with all \nSFDP reading and parsing software.\n06h 01h Number of parameter headers (zero based, 01h = 2 parameters)\n07h FFh Unused\n08h\nParameter \nheader 0\n1st DWORD00h Parameter ID LSB (00h = JEDEC SFDP Basic SPI flash parameter)\n09h 06h Parameter minor revision (06h = JESD216 revision B)\n0Ah01hParameter major revision (01h = The original major revision - all SFDP \nsoftware is compatible with this major revision.\n0Bh10hParameter table length (in double word s = Dwords = 4-byte units) 10h = 16 \nDwords\n0Ch\nParameter \nheader 0\n2nd DWORD00hParameter table pointer byte 0 (Dword = 4-byte aligned)\nJEDEC Basic SPI flash parameter byte offset = 0300h address\n0Dh 03h Parameter table pointer byte 1\n0Eh 00h Parameter table pointer byte 2\n0Fh FFh Parameter ID MSB (FFh = JEDEC defined parameter)\n10h\nParameter \nheader 1\n1st DWORD84h Parameter ID LSB (84h = SFDP 4-byte address instructions parameter)\n11h00hParameter minor revision (00h = Init ial version as defined in JESD216 \nRevision B)\n12h\n01hParameter major revision (01h = The original major revision - all SFDP \nsoftware that recognizes this paramete r’s ID is compatible with this major \nrevision.\n13h02hParameter table length (in double word s = Dwords = 4-byte units) (2h = 2 \nDwords)\n14h\nParameter \nheader 1\n2nd DWORD40hParameter table pointer byte 0 (Dword = 4-byte aligned)\nJEDEC parameter byte offset = 0340h\n15h 03h Parameter table pointer byte 1\n16h 00h Parameter table pointer byte 217h FFh Parameter ID MSB (FFh = JEDEC defined Parameter)\nDatasheet 127 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n10.1.3 JEDEC SFDP basic SPI flash parameter\nTable 41 Basic SPI flash parameter, JEDEC SFDP Rev B\nSFDP parameter \nrelative byte \naddress SFDP Dword \nnameData Description \n00h\nJEDEC basic \nflash parameter \nDword-1E5hStart of SFDP JEDEC parameter\nBits 7:5 = unused = 111bBit 4:3 = 05h is volatile status register write instruction and status \nregister is default non-volatile= 00b\nBit 2 = Program buffer > 64 bytes = 1Bits 1:0 = Uniform 4 KB erase is su pported through out the device = 01b\n01h 20h Bits 15:8 = Uniform 4 KB erase instruction = 20h02h\nFBhBit 23 = Unused = 1b\nBit 22 = Supports QOR (1-1-4)read, Yes = 1bBit 21 = Supports QIO (1-4-4) read, Yes = 1b\nBit 20 = Supports DIO (1-2-2) read, Yes = 1b\nBit19 = Supports DDR, Yes = 1bBit 18:17 = Number of address bytes, 3 or 4 = 01b\nBit 16 = Supports fast read SIO and DIO Yes = 1b\n03h FFh Bits 31:24 = Unused = FFh\n04h\nJEDEC basic \nflash parameter \nDword-2FFh Density in bits, zero based, \n64Mb = 03FFFFFFh05h FFh\n06h FFh\n07h 03h \n64Mb\n08h\nJEDEC basic \nflash parameter \nDword-348hBits 7:5 = number of QIO mode cycles = 010b\nBits 4:0 = number of fast read QI O Dummy cycles = 01000b for default \nlatency code\n09h EBh Fast Read QIO instruction code\n0Ah\n08hBits 23:21 = number of quad out mode cycles = 000b \nBits 20:16 = number of quad out dummy cycles = 01000b for default \nlatency code\n0Bh 6Bh Quad out instruction code\n0Ch\nJEDEC basic \nflash parameter \nDword-408hBits 7:5 = number of dual  out mode cycles = 000b\nBits 4:0 = number of dual out dummy  cycles = 01000b for default latency \ncode\n0Dh 3Bh Dual out instruction code\n0Eh\n88 h Bits 23:21 = number of dual I/O mode cycles = 100b \nBits 20:16 = number of dual I/O dummy cycles = 01000b for default latency code \n0Fh BBh Dual I/O instruction code10h\nJEDEC basic \nflash parameter \nDword-5FEhBits 7:5 RFU = 111b\nBit 4 = QPI supported = 1bBits 3:1 RFU = 111b\nBit 0 = Dual all not supported = 0b\n11h FFh Bits 15:8 = RFU = FFh\n12h FFh Bits 23:16 = RFU = FFh13h FFh Bits 31:24 = RFU = FFh\n14h\nJEDEC basic \nflash parameter \nDword-6FFh Bits 7:0 = RFU = FFh\n15h FFh Bits 15:8 = RFU = FFh16hFFhBits 23:21 = number of dual all mode cycles = 111b\nBits 20:16 = number of dual all dummy cycles = 11111b\n17h FFh Dual all instruction code\nDatasheet 128 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n18h\nJEDEC basic \nflash parameter \nDword-7FFh Bits 7:0 = RFU = FFh\n19h FFh Bits 15:8 = RFU = FFh\n1Ah\n48hBits 23:21 = number of QPI mode cycles = 010b\nBits 20:16 = number of QPI dummy cycles = 01000b for default latency \ncode\n1Bh EBh QPI fast read instruction code (Same as QIO when QPI is enabled)\n1Ch\nJEDEC basic \nflash parameter \nDword-80Ch Sector type 1 size 2^N bytes = 4 KB = 0Ch (for uniform 4KB)\n1Dh 20h Sector type 1 instruction\n1Eh 0Fh Sector type 2 size 2^N bytes = 32 KB = 0Fh (for uniform 32KB)\n1Fh 52h Sector type 2 instruction\n20h\nJEDEC basic \nflash parameter \nDword-910h Sector type 3 size 2^N bytes = 64 KB = 10h (for uniform 64KB)\n21h D8h Sector type 3 instruction\n22h 00h Sector type 4 size 2^N bytes = not supported = 00h\n23h FFh Sector type 4 instruction = not supported = FFh24h\nJEDEC basic \nflash parameter \nDword-1031h Bits 31:30 = Sector type 4 erase, ty pical time units (00b: 1 ms, 01b: 16 \nms, 10b: 128 ms, 11b: 1 s) = RFU = 11bBits 29:25 = Sector type 4 erase, typi cal time count = RFU = 1_1111b (typ \nerase time = count +1 * units = RFU = 11111)\nBits 24:23 = Sector type 3 erase, ty pical time units (00b: 1 ms, 01b: 16 \nms, 10b: 128 ms, 11b: 1 s) = 16mS = 10bBits 22:18 = Sector type 3 erase, typical time count = 0_0011b (typ erase \ntime = count +1 * units = 4*128ms = 512ms)\nBits 17:16 = Sector type 2 erase, ty pical time units (00b: 1 ms, 01b: 16 \nms, 10b: 128 ms, 11b: 1 s) = 16ms = 01b\nBits 15:11 = Sector type 2 erase, typical time count = 1_0010b (typ erase \ntime = count +1 * units = 19*16ms = 304mS)Bits 10:9 = Sector type 1 erase, typical time units (00b: 1 ms, 01b: 16 ms, \n10b: 128 ms, 11b: 1 s) = 16ms = 01b\nBits 8:4 = Sector type 1 erase, typical time count = 0_0011b (typ erase time = count +1 * units = 4*16mS = 64ms)\nBits 3:0 = Count = (max erase time / (2 * typical erase time))- 1 = 0001b \nMultiplier from typical erase time to maximum erase time = 4x multi-\nplier\nMax erase time = 2*(Count +1)*typ erase time\nBinary fields: 11-11111-10-00011-01-10010-01-00011-0001\nNibble format: 1111_1111_0000_1101_1001_0010_0011_0001\nHex format: FF_0D_92_3125h 92h\n26h 0Dh\n27h\nFFhTable 41 Basic SPI flash parameter, JEDEC SFDP Rev B\n (continued)\nSFDP parameter \nrelative byte \naddress SFDP Dword \nnameData Description \nDatasheet 129 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n28h\nJEDEC basic \nflash parameter \nDword-1181h Bits 23 = Byte program typical time, additional byte units (0b:1us, \n1b:8us) = 1us = 0b\nBits 22:19 = Byte program typical time, additional byte count, \n(count+1)*units, count = 1001b, (typ Program time = count +1 * units = 10*1us = 10us\nBits 18 = Byte program typical time, first byte units (0b:1us, 1b:8us) = \n1us = 1bBits 17:14 = Byte program typical time, first byte count, (count+1)*units, \ncount = 1001b, (typ program time = count +1 * units = 10*8us = 80us\nBits 13 = Page program typical time units (0b:8us, 1b:64us) = 64us = 1b\nBits 12:8 = Page program typical time count, (count+1)*units, count = \n00110b, ( typ Program time = count +1 * units = 7*64us = 450us)\nBits 7:4 = N = 1000b, page size= 2^N = 256B pageBits 3:0 = Count = 0001b = (max page program time / (2 * typ page \nprogram time))- 1\nMultiplier from typical page program time to maximum page program time = 4x multiplier\nMax page program time = 2*(cou nt +1)*typ page program time\nBinary fields: 0-1001-1-1001-1-00110-1000-0001\nNibble format: 0100_1110_0110_0110_1000_0001\nHex format: 4E_66_8129h 66h\n2Ah\n4Eh\n2Bh\nCDh \n64Mb64Mb = 1100_1101 = CD\nBit 31 Reserved = 1bBits 30:29 = Chip erase, typical time units (00b: 16 ms, 01b: 256 ms, 10b: 4 s, 11b: 64 s) = 4s = 10b\nBits 28:24 = Chip erase, typical ti me count, (count+1)*units, count = \n01100b, (typ program time = count +1 * units = 14*4s = 56s\n2Ch\nJEDEC Basic \nFlash Parameter \nDword-12CCh Bit 31 = Suspend and resume supported = 0b\nBits 30:29 = Suspend in-progress erase max latency units (00b: 128ns, \n01b: 1us, 10b: 8us, 11b: 64us) = 8us= 10b\nBits 28:24 = Suspend in-progress erase max latency count = 00100b, max erase suspend latency = count +1 * units = 5*8us = 40us\nBits 23:20 = Erase resume to suspend interval count = 0001b, interval = \ncount +1 * 64us = 2 * 64us = 128usBits 19:18 = Suspend in-progress program max latency units (00b: \n128ns, 01b: 1us, 10b: 8u s, 11b: 64us) = 8us= 10b\nBits 17:13 = Suspend in-progress program max latency count = 00100b, max erase suspend latency = count +1 * units = 5*8us = 40us\nBits 12:9 = Program resume to suspend interval count = 0001b, interval \n= count +1 * 64us = 2 * 64us = 128usBit 8 = RFU = 1b\nBits 7:4 = Prohibited operations during erase suspend\n= xxx0b: May not initiate a new er ase anywhere (erase nesting not \npermitted)\n+ xx0xb: May not initiate a page program anywhere\n+ x1xxb: May not initiate a read in the erase suspended sector size\n+ 1xxxb: The erase and program restrictions in bits 5:4 are sufficient\n= 1100b\nBits 3:0 = Prohibited operations during program suspend= xxx0b: May not initiate a new er ase anywhere (erase nesting not \npermitted)\n+ xx0xb: May not initiate a new page program anywhere (program nesting not permitted)\n+ x1xxb: May not initiate a read in the program suspended page size\n+ 1xxxb: The erase and program restrictions in bits 1:0 are sufficient= 1100b\nBinary fields: 0-10-00100-0001-10-00100-0001-1-1100-1100\nNibble format: 0100_0100_0001_1000_1000_0011_1100_1100\nHex format: 44_18_83_CC2Dh 83h\n2Eh 18h\n2Fh\n44hTable 41 Basic SPI flash parameter, JEDEC SFDP Rev B\n (continued)\nSFDP parameter \nrelative byte \naddress SFDP Dword \nnameData Description \nDatasheet 130 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n30h\nJEDEC basic \nflash parameter \nDword-137Ah Bits 31:24 = Erase suspend instruction = 75h\nBits 23:16 = Erase resume instruction = 7Ah\nBits 15:8 = Program suspend instruction = 75h\nBits 7:0 = Program resume instruction = 7Ah31h 75h\n32h 7Ah\n33h 75h34h\nJEDEC basic \nflash parameter \nDword-14F7h Bit 31 = Deep power down supported = supported = 0\nBits 30:23 = Enter deep power down instruction = B9h = 1011_1001bBits 22:15 = Exit deep power down instruction = ABh = 1010_1011b\nBits 14:13 = Exit deep power down to  next operation delay units = (00b: \n128ns, 01b: 1us, 10b: 8u s, 11b: 64us) = 1us = 01b\nBits 12:8 = Exit deep power down to next operation delay count = \n00010b, Exit deep power down to next operation delay = \n(count+1)*units = 3*1us=3usBits 7:4 = RFU = Fh\nBit 3:2 = Status Register polling device  busy = 01b: Legacy status polling \nsupported = Use legacy polling by reading the Status Register with 05h instruction and checking WIP bi t[0] (0 = ready; 1 = busy).\nBits 1:0 = RFU = 11b\nBinary fields: 0-10111001-10101011-01-00010-1111-01-11\nNibble format: 0101_1100_1101_0101_1010_0010_1111_0111\nHex format: 5C_D5_A2_F735h A2h\n36h D5h\n37h 5Ch\n38h\nJEDEC basic \nflash parameter \nDword-1522h Bits 31:24 = RFU = FFh\nBit 23 = Hold and WP disable = not supported = 0b\nBits 22:20 = quad enable requirements= 101b: QE is bit 1 of the status register 2. Status register 1 is read using \nRead Status instruction 05h. Status register 2 is read using instruction \n35h. QE is set via Write Status instru ction 01h with two data bytes where \nbit 1 of the second byte is one. It is cleared via write status with two data \nbytes where bit 1 of the second byte is zero.\nBits 19:16 0-4-4 mode entry method= xxx1b: mode bits[7:0] = A5h Note: QE  must be set prior to using this \nmode + x1xxb: mode bits[7:0] = Axh+ 1xxxb: RFU= 1101b\nBits 15:10 0-4-4 mode exit method = xx_xxx1b: mode bits[7:0] = 00h will \nterminate this mode at the end of the current read operation\n+ xx_1xxxb: Input Fh (mode bit reset) on DQ0-DQ3 for 8 clocks. This will \nterminate the mode prior to the next read operation.+ 11_x1xx: RFU= 111101\nBit 9 = 0-4-4 mode supported = 1\nBits 8:4 = 4-4-4 mode  enable sequences\n= 0_0010b: issue instruction 38h\nBits 3:0 = 4-4-4 mode disable sequences\n= 0010b: 4-4-4 issues F5h instruction\nBinary fields: 11111111-0-101-1101-111101-1-00010-0010\nNibble format: 1111_1111_0101_1101_1111_0110_0010_0010Hex format: FF_5D_F6_2239h F6h\n3Ah 5Dh\n3Bh FFhTable 41 Basic SPI flash parameter, JEDEC SFDP Rev B\n (continued)\nSFDP parameter \nrelative byte \naddress SFDP Dword \nnameData Description \nDatasheet 131 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n3Ch\nJEDEC basic \nflash parameter \nDword-16E8h Bits 31:24 = Enter 4-byte addressing\n= xxxx_xxx1b:issue instruction B7 (p receding write enable not required\n= xxxx_1xxxb: 8-bit Volatile Bank Regi ster used to define A[30:24] bits. \nMSb (bit[7]) is used to enable/disable 4-byte Address mode. When MSb is set to ‘1’ , 4-byte Address mode is active and A[30:24] bits are don’t \ncare. Read with instruction 16h. Write instruction is 17h with 1 byte of \ndata. When MSb is cleared to ‘0’ , select the active 128 Mb segment by setting the appropriate A[30:24] bits and use 3-byte addressing.\n+ xx1x_xxxxb: Supports dedicated 4-byte address instruction set. \nConsult vendor data sheet for the inst ruction set definition or look for \n4-byte address parameter table.\n+ 1xxx_xxxxb: Reserved = 10100001b\nBits 23:14 = Exit 4-byte addressing= xx_xxxx_xxx1b:issue instruction E9h to exit 4-byte Address mode \n(write enable instruction 06h is not required)\n= xx_xxxx_1xxxb: 8-bit Volatile Bank Register used to define A[30:24] bits. MSb (bit[7]) is used to enable/disable 4-byte Address mode. When \nMSb is cleared to ‘0’ , 3-byte Address mode is active and A30:A24 are \nused to select the active 128 Mb memory segment. Read with instruction 16h. Write instruction is 17h, data length is 1 byte.\n+ xx_xx1x_xxxxb: Hardware reset\n+ xx_x1xx_xxxxb: Software reset (see bits 13:8 in this DWORD)+ xx_1xxx_xxxxb: Power cycle+ x1_xxxx_xxxxb: Reserved\n+ 1x_xxxx_xxxxb: Reserved\n= 1111100001bBits 13:8 = Soft reset and rescue sequence support\n= x1_xxxxb: issue reset enable instruction 66h, then issue reset \ninstruction 99h. The reset enable, reset sequence may be issued on 1,2, or 4 wires depending on the device operating mode = 010000b\nBit 7 = RFU = 1\nBits 6:0 = Volatile or Non-volatile Register and write enable instruction for Status Register 1 = xxx_1xxxb: Non- volatile/Volatile Status register \n1 powers-up to last written value in the Non-volatile Status register, use \ninstruction 06h to enable write to Non-volatile Status register. Volatile Status register may be activated after power-up to override the \nNon-volatile Status register, use instruction 50h to enable write and \nactivate the volatile status register.+ x1x_xxxxb: Reserved\n+ 1xx_xxxxb: Reserved\n= 1101000b\nBinary fields: 10100001-1111100001-010000-1-1101000\nNibble format: 1010_0001_1111_1000_0101_0000_1110_1000Hex format: A1_F8_60_E83Dh 50h\n3Eh F8h\n3Fh A1hTable 41 Basic SPI flash parameter, JEDEC SFDP Rev B\n (continued)\nSFDP parameter \nrelative byte \naddress SFDP Dword \nnameData Description \nDatasheet 132 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n10.1.4 JEDEC SFDP 4-byte address instruction table\nTable 42 4-byte address instruction, JEDEC SFDP Rev B\nSFDP parameter \nrelative byte \naddressSFDP Dword name Data Description\n40h\nJEDEC 4-byte \naddress \ninstructions \nparameter \nDword-1hFBh Supported = 1, not supported = 0\nBits 31:20 = RFU = FFFhBit 19 = Support for Non-volatile Individual Sector Lock Write \ncommand, Instruction = E3h = 0\nBit 18 = Support for Non-volatile Individual Sector Lock Read command, Instruction = E2h = 0\nBit 17 = Support for Volatile Individual Sector Lock Write command, \nInstruction = E1h = 1Bit 16 = Support for Volatile Individual Sector lock Read command, \nInstruction = E0h = 1\nBit 15 = Support for (1-4-4) DTR_Read command, instruction = EEh = 1Bit 14 = Support for (1-2-2) DTR_Read command, instruction = BEh = 0\nBit 13 = Support for (1-1-1) DTR_Read command, instruction = 0Eh = 0\nBit 12 = Support for Erase command – Type 4 = 0Bit 11 = Support for Erase command – Type 3 = 1\nBit 10 = Support for Erase command – Type 2 = 1\nBit 9 = Support for Erase command – Type 1 = 1Bit 8 = Support for (1-4-4) Page Program command, \ninstruction = 3Eh = 0\nBit 7 = Support for (1-1-4) Page Program command, instruction = 34h = 1Bit 6 = Support for (1-1-1) Page Program command, \ninstruction = 12h = 1\nBit 5 = Support for (1-4-4) FAST_READ command, instruction = ECh = 1Bit 4 = Support for (1-1-4) FAST_READ command, instruction = 6Ch = 1\nBit 3 = Support for (1-2-2) FAST_READ command, instruction = BCh = 1\nBit 2 = Support for (1-1-2) FAST_READ command, instruction = 3Ch = 0Bit 1 = Support for (1-1-1) FAST_READ command, instruction = 0Ch = 1\nBit 0 = Support for (1-1-1) READ command, Instruction = 13h = 1\nNibble format: 1111_1111_1111_0011_1000_1110_1111_1011\nHex format: FF_F3_8E_FB41h 8Eh\n42h F3h\n43h FFh\n44hJEDEC4-byte \naddress \ninstructions \nparameter \nDword-2h21h Bits 31:24 = FFh = Instruction for erase type 4: RFU\nBits 23:16 = DCh = Instruction for erase type 3 block \nBits 15:8 = 52h = Instruction for erase type 2 half block Bits 7:0 = 21h = Instruction for erase type 1 sector45h 52h\n46h DCh\n47h FFh\nDatasheet 133 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nSoftware interface reference\n10.2 Device ID address map\n10.2.1 Field definitions\n10.3 Initial delivery state\nThe device is shipped from Infineon wi th non-volatile bits set as follows:\n• The entire memory array is erased: all bits are set to 1 (each byte contains FFh).\n• The Security Region address space has all bytes erased to FFh.• The SFDP address space contains the values as de fined in the description of the SFDP address space.\n• The ID address space contains the values as de fined in the description of the ID address space.\n• The Status Register 1 non-volatile contains 00h (all SR1NV bits are cleared to 0’s).• The Configuration Register 1 non-volatile contains 00h.\n• The Configuration Register 2 non-volatile contains 60h.\n• The Configuration Register 3 non-volatile contains 78h.• The Password Register contains FFFFFFFF-FFFFFFFFh\n• The IRP Register bits are FFFDh for standa rd part and FFFFh for high security part.\n• The PRPR Register bits are FFFFFFhTable 43 Manufacturer device type\nByte address Data Description \n00h 01h Manufacturer ID for Infineon01h 60h Device ID most significant byte - Memory interface type\n02h 17h (64 Mb) Device ID least significant byte - Density and features\n03h Undefined Reserved for future use\nTable 44 Unique device ID\nByte address Data Description \n00h to 07 8-byte unique Device ID 64-bit unique ID number. \nSee section "Device Unique ID" on page 28.\nDatasheet 134 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\n11 Electrical specifications\n11.1 Absolute maximum ratings[61]\nStorage temperature plastic packages........................................................................................... .–65°C to +150°C\nAmbient temperature with power applied......................................................................................–65 °C to +125°C\nVCC............................................................................................................................... .......................–0.5 V to +4.0 V\nInput voltage with respect to ground (VSS)[60]................................................................................–0.5 V to VCC + 0.5 V\nOutput short circuit current[59]............... ............... ............... .............. ............. ............ ............ ........100 mA\n11.2 Latchup characteristics\n11.3 Thermal resistanceTable 45 Latchup specification[62]\nDescription Min Max Unit\nInput voltage with respect to VSS on all input only connections –1.0 VCC + 1.0 V \nInput voltage with respect to VSS on all I/O connections –1.0 VCC + 1.0 V\nVCC current –100 +100 mA \nTable 46 Thermal resistance\nParameter Description Test Condition SL3016 SOC008 FAB024 FAC024 WND008 UNF008 Unit\nTheta JA Thermal \nresistance \n(junction to \nambient)Test conditions \nfollow standard \ntest methods \nand procedures \nfor measuring \nthermal \nimpedance in \naccordance with \nEIA/JESD51. \nwith still air \n(0 m/s).45.7 65.8 46.9 46.9 32.9 34.0 °C/W\nTheta JB Thermal \nresistance \n(junction to \nboard)26.6 39.6 30.4 30.4 9.1 8.0 °C/W\nTheta JC Thermal \nresistance \n(junction to \ncase)13.1 33.8 20.9 20.9 25.2 28.0 °C/W\nNotes\n59.See "Input signal overshoot" on page 135 for allowed maximums during signal transition. \n60.No more than one output may be shorted to ground at a ti me. Duration of the short circuit should not be greater than \none second.\n61.Stresses above those listed under "Absolute maximum ratings[61]" on page 134 may cause permanent damage to the \ndevice. This is a stress rating only; functional operation of the device at these or any other conditions above those \nindicated in the operational sections of this data sheet is  not implied. Exposure of the device to absolute maximum \nrating conditions for extended periods may affect device reliability.\n62.Excludes power supply VCC. Test conditions: VCC = 3.0 V, one connection at a time tested, connections not being tested \nare at VSS.\nDatasheet 135 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\n11.4 Operating ranges\nOperating ranges define those limits between whic h the functionality of the device is guaranteed.\n11.4.1 Power supply voltages\nVCC ……............................................................................................................................ ..................... 2.7 V to 3.6 V\n11.4.2 Temperature ranges\n11.4.3 Input signal overshoot\nDuring DC conditions, input or I/O signal s should remain equal to or between VSS and VCC. During voltage transi-\ntions, inputs or I/Os may overshoot VSS to –1.0 V or overshoot to VCC +1.0 V, for periods up to 20 ns.\nFigure 129 Maximum negative overshoot waveform\nFigure 130 Maximum positive overshoot waveformParameter Symbol DevicesSpecUnitMin Max\nAmbient temperature TA Industrial (I) –40 +85 °C\nIndustrial Plus (V) –40 +105 °C\nAutomotive, AEC-Q100 grade 3 (A) –40 +85 °C\nAutomotive, AEC-Q100 grade 2 (B) –40 +105 °C\nAutomotive, AEC-Q100 grade 1 (M) –40 +125 °C\nVSS to VCC\n–1.0 V\n< = 20 ns\nVCC + 1.0 V< = 20 ns\nVSS to VCC\nDatasheet 136 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\n11.5 Power-up and power-down\nThe device must not be selected at power-up or power-down (that is, CS# must follow the voltage applied on VCC) \nuntil VCC reaches the correct value as follows:\n•VCC (min) at power-up, and then for a further delay of tPU\n•VSS at power-down\nUser is not allowed to enter any command until a valid delay of tPU has elapsed after the moment that VCC rises \nabove the minimum VCC threshold. See Figure 131 . However, correct operation of the device is not guaranteed \nif VCC returns below VCC (min) during tPU. No command should be sent to  the device until the end of tPU.\nThe device draws IPOR during tPU. After power-up (tPU), the device is in Standby mode, draws CMOS standby \ncurrent (ISB), and the WEL bit is reset.\nDuring power-down or if supply voltage drops below VCC(cut-off), the supply voltage must stay below VCC(low) \nfor a period of tPD for the part to initialize correctly on power-up. See Figure 132 . If during a voltage drop the VCC \nstays above VCC(cut-off) the part will stay initialized and will work correctly when VCC is again above VCC(min). In \nthe event power-on reset (POR) did not complete correctly after power up, the assertion of the RESET# signal or \nreceiving a Software Reset command (RSTEN 66h followed by RST 99h) will restart the POR process.\nIf VCC drops below the VCC (Cut-off) during an embedded program or erase operation the embedded operation may \nbe aborted and the data in that memory area may be incorrect. \nNormal precautions must be taken for supply rail decoupling to stabilize the VCC supply at the device. Each device \nin a system should have the VCC rail decoupled by a suitable capacitor close to the package supply connection \n(this capacitor is generally of the order of 0.1 µf).\nTable 47 Power-up / power-down voltage and timing\nSymbol Parameter Min Max Unit\nVCC (min) VCC (minimum operation voltage) 2.7  – V \nVCC (cut-off) VCC (cut off where re-initialization is needed) 2.4[63]–\nVCC (low) VCC (low voltage for initialization to occur) 1.0[64]–\ntPU VCC(min) to read operation – 300 µs \ntPD VCC(low) time 10.0 –\nNotes\n63.Re-initialization is needed if VCC drops below 2.4 V.\n64.VCC need to go below 1.0 V for initialization to occur.\nDatasheet 137 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\nFigure 131 Power-up[65, 66]\nFigure 132 Power-down and voltage droptPU Full device accessVCC (min)VCC (max)\nTime\nNotes\n65.Re-initialization is needed if VCC drops below 2.4 V.\n66.VCC need to go below 1.0 V for initialization to occur.VCC (max)\nVCC (min)\nVCC (cut-off)\nVCC (low)tPUNo device access allowed\ntPD\nTime\nDatasheet 138 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\n11.6 DC characteristics\nTable 48 DC characteristics — Operating temperature range –40°C to +85°C\nSymbol Parameter Test conditions Min Typ[67]Max Unit\nVIL Input low voltage  –0.5 – 0.3 \uf0b4 VCC V\nVIH Input high voltage  0.7 \uf0b4 VCC – VCC+0.4 V\nVOL Output low voltage IOL = 0.1 mA, VCC=VCC min  – 0.2 V\nVOH Output high voltage IOH = –0.1 mA VCC - 0.2 –  V\nILI Input leakage \ncurrent VCC=VCC Max, VIN=VIH or VSS, CS# = VIH  –  – ±2 µA \nILO Output leakage \ncurrent VCC=VCC Max, VIN=VIH or VSS, CS# = VIH –  ±2µA\nICC1 Active power supply \ncurrent (READ)[68]Serial SDR@5 MHz\nSerial SDR@10MHzSerial SDR@20 MHz\nSerial SDR@50 MHz\nSerial SDR@108MhzQIO/QPI SDR@108MHz\nQIO/QPI DDR@30MHz\nQIO/QPI DDR@54 MHz– 10\n1010\n15\n2020\n15\n1715\n1515\n20\n2530\n20\n25mA \nI\nCC2 Active power supply \ncurrent (page program) CS#=V\nCC – 17 25\nmA\nICC3 Active power supply \ncurrent (WRR or WRAR) CS#=V\nCC  – 11 20\nmA\nICC4 Active power supply \ncurrent (SE) CS#=VCC – 17 25mA\nICC5 Active power supply \ncurrent (HBE, BE) CS#=VCC – 15 25mA\nISB Standby current RESET#, CS#=VCC; SI, SCK = VCC or VSS: \nSPI, dual I/O and Quad I/O modes– 20 30 µA\nRESET#, CS#=VCC; SI, SCK = VCC or VSS: \nQPI mode– 35 55µA\nIDPD Deep power down \ncurrentRESET#, CS# = VCC, VIN = GND or VCC – 22 0µA\nIPOR[69]Power on reset \ncurrentRESET#, CS#=VCC; SI, SCK = VCC or VSS – 35 m A\nNotes\n67.Typical values are at TAI = 25°C and VCC = 3.0 V.\n68.Outputs unconnected during read data return . Output switching curr ent is not included.\n69.In-rush/peak current up to 25 mA during POR with current specified represent time average for tPU duration.\nDatasheet 139 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\nTable 49 DC Characteristics — Operating temperature range –40°C to +105°C\nSymbol Parameter Test conditions Min Typ[70]Max Unit\nVIL Input low voltage – –0.5 – 0.3 \uf0b4 VCC V\nVIH Input high voltage – 0.7 \uf0b4 VCC – VCC+0.4 V\nVOL Output low voltage IOL = 0.1 mA, VCC = VCC min  – 0.2 V\nVOH Output high voltage IOH = –0.1 mA VCC - 0.2 –  V\nILI Input leakage \ncurrent VCC=VCC Max, VIN = VIH or VSS, CS# = VIH  ––  ±4 µA \nILO Output leakage \ncurrent VCC=VCC Max, VIN = VIH or VSS, CS# = VIH  ––  ±4 µA\nICC1 Active power supply \ncurrent (READ)[71]Serial SDR@5 MHz\nSerial SDR@10MHzSerial SDR@20 MHz\nSerial SDR@50 MHz\nSerial SDR@108MhzQIO/QPI SDR@108MHz\nQIO/QPI DDR@30MHz\nQIO/QPI DDR@54 MHz – 10\n1010\n15\n2020\n15\n1715\n1520\n25\n3030\n15\n25mA \nI\nCC2 Active power supply \ncurrent (page program) CS#=V\nCC  – 17 25\nmA\nICC3 Active power supply \ncurrent (WRR or WRAR) CS# = V\nCC  – 11 20\nmA\nICC4 Active power supply \ncurrent (SE) CS# = VCC  – 17 25mA\nICC5 Active power supply \ncurrent (HBE, BE) CS# = VCC  – 15 25mA\nISB Standby current RESET#, CS# = VCC; SI, SCK = VCC or VSS: \nSPI, dual I/O and Quad I/O modes – 20 40 µA\nRESET#, CS# = VCC; SI, SCK = VCC or VSS: \nQPI mode–3 5 7 0µA\nIDPD Deep power down \ncurrentRESET#, CS# = VCC, VIN = GND or VCC  – 23 0µA\nIPOR[72]Power on reset \ncurrentRESET#, CS# = VCC; SI, SCK = VCC or VSS –37 m A\nNotes\n70.Typical values are at TAI = 25 °C and VCC = 3.0 V.\n71.Outputs unconnected during read data return . Output switching curr ent is not included.\n72.In-rush/peak current up to 25 mA during POR with current specified represent time average for tPU duration.\nDatasheet 140 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nElectrical specifications\n11.6.1 Active Power and Standby Power modes\nThe device is enabled and in the Active Power mode when Chip Select (CS#) is Low. When CS# is HIGH, the device \nis disabled, but may still be in an Active Power mode  until all program, erase, and write operations have \ncompleted. The device then goes into the Standby Power mode, and power consumption drops to ISB.\n11.6.2 Deep Power Down Power mode (DPD)\nThe Deep Power Down mode is enabled by inputing  the command instruction code “B9h” and the power \nconsumption drops to IDPD. In DPD mode the device responds only to the resume from DPD command (RES ABh) \nor Hardware reset (RESET# and IO3 / RESET#). All other commands are ignored during DPD mode.Table 50 DC Characteristics — Operating temperature range –40°C to +125°C\nSymbol Parameter Test conditions Min Typ[73]Max Unit\nVIL Input low voltage – –0.5 – 0.3 \uf0b4 VCC V\nVIH Input high voltage – 0.7 \uf0b4 VCC – VCC+0.4 V\nVOL Output low voltage IOL = 0.1 mA, VCC = VCC min  – 0.2 V\nVOH Output high voltage IOH = –0.1 mA VCC - 0.2 –  V\nILI Input leakage \ncurrent VCC = VCC Max, VIN = VIH or VSS, \nCS# = VIH  ––  ±4 µA \nILO Output leakage \ncurrent VCC = VCC Max, VIN = VIH or VSS, \nCS# = VIH  ––  ±4 µA\nICC1 Active power supply \ncurrent (READ)[74]Serial SDR@5 MHz\nSerial SDR@10MHzSerial SDR@20 MHz\nSerial SDR@50 MHz\nSerial SDR@108MhzQIO/QPI SDR@108MHz\nQIO/QPI DDR@30MHz\nQIO/QPI DDR@54 MHz– 10\n1010\n15\n2020\n15\n1715\n1520\n25\n3030\n15\n25mA \nI\nCC2 Active power supply \ncurrent (Page Program) CS# = V\nCC  – 17 25\nmA\nICC3 Active power supply \ncurrent (WRR or WRAR) CS# = V\nCC – 11 20\nmA\nICC4 Active power supply \ncurrent (SE) CS# = VCC – 17 25mA\nICC5 Active power supply \ncurrent (HBE, BE) CS# = VCC – 15 25mA\nISB Standby current RESET#, CS# = VCC; SI, SCK = VCC or VSS: \nSPI, dual I/O and Quad I/O modes– 20 60 µA\nRESET#, CS# = VCC; SI, SCK = VCC or VSS: \nQPI mode– 35 70 µA\nIDPD Deep power down \ncurrentRESET#, CS# = VCC, VIN = GND or VCC – 24 0 µ A\nIPOR[75]Power on reset \ncurrentRESET#, CS# = VCC; SI, \nSCK = VCC or VSS– 39 m A\nNotes\n73.Typical values are at TAI = 25°C and VCC = 3.0 V.\n74.Outputs unconnected during read data return . Output switching curr ent is not included. \n75.In-rush/peak current up to 25 mA during POR with current specified represent time average for tPU duration.\nDatasheet 141 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n12 Timing specifications\n12.1 Key to switching waveforms\nFigure 133 Waveform element meanings\n12.2 AC test conditions\nFigure 134 Test setup\nFigure 135 Input, output, and timing reference levelsTable 51 AC measurement conditions\nSymbol Parameter Min Max Unit\nCL Load capacitance – 15 / 30[76]pF\n– Input pulse voltage 0.2 \uf0b4 VCC 0.8 VCC V\n– Input timing ref Voltage 0.5 VCC\n– Output timing ref voltage 0.5 VCC\nNotes\n76.Load capacitance depends on the oper ation frequency or mode of operation.\n77.AC characteristics tables assume clock and data  signals have the same slew rate (slope). See "SDR AC characteris-\ntics[81]" on page 145 note 86 for slew Rates at operating frequency\'s.Input\nSymbol\nOutputValid at logic high or lowValid at logic high or low High Impedance Any change permitted Logic high Logic low\nValid at logic high or lowValid at logic high or low High Impedance Changing, state unknown Logic high Logic low\nDevice \nunder \ntest\nCL\nVCC + 0.4 V\n0.8 x VCC\n0.2 x VCC\n- 0.5 VTiming reference level0.5 x VCC VCC - 0.2 V \n0.2 VInput levelsOutput levels\nDatasheet 142 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n12.2.1 Capacitance characteristics\n12.3 Reset\nIf a hardware reset is initiated during a erase, program or  writing of a register operation the data in that sector, \npage or register is not stable, the operation that was inte rrupted needs to be initiated again. If a hardware reset \nis initiated during a software reset operation, the hardware reset might be ignored.\n12.3.1 Power-on (cold) reset\nThe device executes a power-on reset (POR) process until a time delay of tPU has elapsed after the moment that \nVCC rises above the minimum VCC threshold. See Figure 131  and Table 47 . The device must not be selected (CS# \nto go HIGH with VCC) during power-up (tPU), i.e. no commands may be sent to the device until the end of tPU.\nRESET# and IO3 / RESET# reset function is ignored during POR. If RESET# or IO3 / RE SET# is LOW during POR and \nremains low through and beyond the end of tPU, CS# must remain HIGH until tRH after RESET# and IO3 / RESET# \nreturns HIGH. RESET# and IO3 / RESET# must return HIGH for greater than tRS before returning low to initiate a \nhardware reset.\nThe IO3 / RESET# input functions as the RESET#  signal when CS# is HIGH for more than tCS time or when Quad or \nQPI mode is not enabled CR1V[1] = 0 or CR2V[3] = 0.\nFigure 136 Reset LOW at the end of POR\nFigure 137 Reset HIGH at the end of PORTable 52 Capacitance\nSymbol Parameter Test conditions Min Max Unit\nCIN Input capacitance (applies to SCK, CS#, RESET#, \nIO3 / RESET#) 1 MHz – 8 pF \nCOUT Output capacitance (applies to All I/O) 1 MHz  – 8 pF\nVCC\nRESET#\nCS#If RESET# is low at tPU end\nCS# must be high at tPU endtPU\ntRH\nVCC\nRESET#\nCS#If RESET# is high at tPU end\nCS# may stay high or go low at tPU endtPU\ntPU\nDatasheet 143 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\nFigure 138 POR followed by hardware reset\n12.3.2 RESET # and IO3 / RESET# inpu t initiated hardware (warm) reset\nThe RESET# and IO3 / RESET# inputs can function as th e RESET# signal. Both inputs can initiate the reset\noperation under conditions.\nThe RESET# input initiates the reset operation when transitions from VIH to VIL for > tRP, the device will reset\nregister states in the same manner as power-on reset but, does not go through the full reset process that is\nperformed during POR. The hardware reset process requires a period of tRPH to complete. The RESET# input is\navailable only on the SOIC 16 lead and BGA ball packages.\nThe IO3 / RESET# input initiates the reset operation un der the following when CS# is HIGH for more than tCS time\nor when quad or QPI mode is not enable d CR1V[1] = 0 or CR2V[3] = 0. The IO3 / RESET# input has an internal pull-up\nto VCC and may be left unconnected if quad or QPI mode is not used. The tCS delay after CS# goes HIGH gives the\nmemory or host system time to drive IO3 HIGH after its use as a quad or QPI mode I/O signal while CS# was LOW.The internal pull-up to V\nCC will then hold IO3 / RESET# HIGH until th e host system begins driving IO3 / RESET#.\nThe IO3 / RESET# input is ignored while CS# remains HIGH during tCS, to avoid an unintended reset operation. If\nCS# is driven LOW to start a new comm and, IO3 / RESET# is used as IO3.\nWhen the device is not in quad or QPI mode or, when CS# is HIGH, and IO3 / RESET# transitions from VIH to VIL for\n> tRP, following tCS, the device will reset register states in the sa me manner as POR but, does not go through the\nfull reset process that is performed during POR. \nThe hardware reset process requires a period of tRPH to complete. If the POR process did not complete correctly\nfor any reason during power-up (tPU), RESET# going LOW will initiate the full POR process instead of the hardware\nreset process and will require tPU to complete the POR process.\nThe Software Reset command (RSTEN 66h followed by RST 99h) is independent of the state of RESET # and IO3 /\nRESET#. If RESET# and IO3 / RESET# is HIGH or unconnect ed, and the software reset instructions are issued, the\ndevice will perform software reset.\nAdditional notes:\n• If both RESET# and IO3 / RESET# input options are avai lable use only one reset option in your system. IO3 / \nRESET# input reset operation can be disable by setting CR2NV[7] = 0 (See Table 12 ) setting the IO3_RESET to \nonly operate as IO3. The RESET# in put can be disable by not connecting  or tying the RESET# input to VIH. RESET# \nand IO3 / RESET# must be high for tRS following tPU or tRPH, before going low again to initiate a hardware reset.\n• When IO3 / RESET# is driven LOW for at least a minimum period of time (tRP), following tCS, the device terminates \nany operation in progress, makes all outputs high impe dance, and ignores all read/write commands for the \nduration of tRPH. The device resets the interface to STANDBY state.\n• If Quad or QPI mode and the IO3 / RESET# feature are enabled, the host system shou ld not drive IO3 low during \ntCS, to avoid driver contention on IO3. Immediately following commands that transfer data to the host in quad \nor QPI mode, e.g. Quad I/O read, the me mory drives IO3 / RESET# HIGH during tCS, to avoid an unintended reset \noperation. Immediately following commands that transf er data to the memory in Quad mode, e.g. page \nprogram, the host system should drive IO3 / RESET# HIGH during tCS, to avoid an unintended reset operation.\n• If Quad or QPI mode is not enabled, and if CS# is LOW at the time IO3 / RESET# is asserted LOW, CS# must return \nHIGH during tRPH before it can be asserted low again after tRH.VCC\nRESET#\nCS#tRS tPU\ntPU\nDatasheet 144 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\nFigure 139 Hardware reset using RESET# input\nFigure 140 Hardware reset when Quad or QPI mode  is not enabled and IO3 / RESET# is enabled\nFigure 141 Hardware reset when Quad or QPI mode and IO3 / RESET# are enabledTable 53 Hardware reset parameters[78, 79, 80]\nParameter Description Limit Time Unit\ntRS Reset setup - prior reset end and RESET# HIGH before \nRESET# LOWMin 50 ns\ntRPH Reset pulse hold - RESET# LOW to CS# LOW Min 100 µs\ntRP RESET# pulse width Min 200 ns \ntRH Reset hold - RESET# HIGH before CS# LOW Min 150 ns\nNotes\n78.RESET# and IO3 / RESET# Low is ignored during power-up (tPU). If RESET# is asserted during the end of tPU, the device \nwill remain in the reset state and tRH will determine when CS# may go Low.\n79.If quad or QPI mode is enabled, IO3 / RESET# Low is ignored during tCS.\n80.Sum of tRP and tRH must be equal to or greater than tRPH.\nRESET#\nCS#Any prior reset\ntRStRP\ntRH tRH\ntRPH tRPH\nIO3_RESET#\nCS#Any prior reset\ntRStRP\ntRH tRH\ntRPH tRPH\nIO3_RESET#\nCS#Reset Pulse\nPrior access using IO3 for datatRH\ntCStDIS tRP\ntRPH\nDatasheet 145 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n12.4 SDR AC characteristics\nTable 54 SDR AC characteristics[81]\nSymbol Parameter Min Max Unit\nFSCK, R  SCK clock frequency for READ and 4READ instructions DC 50 MHz\nFSCK, C  SCK Clock frequency for the following dual and quad \ncommands: QOR, 4QOR, DIOR, 4DIOR, QIOR, 4QIORDC 108MHz\nPSCK SCK clock period 1/ FSCK –  MHz\ntWH, tCH Clock high time 50% PSCK -5% – ns \ntWL, tCL Clock Low time 50% PSCK -5% – ns \ntCRT, tCLCH  Clock rise time (slew rate)[82]0.1 – V/ns\ntCFT, tCHCL Clock fall time (slew rate)[82]0.1 – V/ns\ntCS CS# high time (any read instructions) 20 – ns \nCS# high time (All other non-read instructions) 50 – ns\ntCSS CS# active setup time (relative to SCK) 3 – ns\ntCSH CS# active hold time (relative to SCK) 5 – ns \ntSU Data in setup time 3 – ns\ntHD Data in hold time 2 – ns\ntV Clock low to output valid 8[82]\n6[83]ns \ntHO Output hold time 1  ns\ntDIS Output disable time[84]\nOutput disable time (when reset feature and Quad mode are \nboth enabled)– 8\n20[85]ns\n tWPS  WP# setup time[86]20 – ns \n tWPH  WP# hold time[86]100 – ns\nTDP CS# High to Deep Power Down mode – 3µ s\nTRES CS# High to release from Deep Power Down mode – 5 µs\ntQEN QIO or QPI Enter mode, time needed to issue next command – 1.5 µs\ntQEXN QIO or QPI Exit mode, time needed to issue next command – 1 µs\nNotes\n81.tCRT, tCLCH clock rise and fall slew rate for fast clock (108 MHz) min is 1.5 V/ns and for slow clock (50 MHz) min is 1.0 V/ns.\n82.Full VCC range and CL = 30 pF.\n83.Full VCC range and CL = 15 pF.\n84.Output HI-Z is defined as the point where data is no longer driven.85.t\nDIS require additional time when the reset feature and Qu ad mode are enabled (CR2V[7] = 1 and CR1V[1] = 1).\n86.Only applicable as a constr aint for WRR or WRAR instruct ion when SRP0 is set to a 1.\nDatasheet 146 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n12.4.1 Clock timing\nFigure 142 Clock timing\n12.4.2 Input / output timing\nFigure 143 SPI single bit input timing\nFigure 144 SPI single bit output timingVIL maxVIH mintCH\ntCRT tCFTtCL\nVCC / 2PSCK\nCS#\nSCK\nSI_IO0\nSOMSb IN LSb INtCSStCSHtCS\ntSU\ntHD\nCS#\nSCK\nSI\nSO MSb OUT LSb OUTtCS\ntHO tV tDIS\nDatasheet 147 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\nFigure 145 SDR MIO timing\nFigure 146 WP# input timingCS#\nSCLK\nIO MSB IN LSB IN MSB OUT . LSB OUTtCSH\ntCSS\ntSU\ntHD tHOtCS\ntDIS tV tV\nCS#\nWP#\nSCLK\nSI\nSO\nPhase7 6 54 3 2 1 0 76 5 4 3 2 1 0\nWRR or WRAR Instruction Input DatatWPS tWPH\nDatasheet 148 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n12.5 DDR AC characteristics\n12.5.1 DDR input timing\nFigure 147 SPI DDR input timingTable 55 DDR AC characteristics 54 MHz operation\nSymbol Parameter Min Max Unit \nFSCK, R  SCK clock frequency for DDR READ instruction DC 54 MHz\nPSCK, R  SCK clock period for DDR READ instruction 1/ FSCK – ns \ntcrt Clock rise time (slew rate) 1.5 – V/ns\ntcft Clock fall time (slew rate) 1.5 – V/ns\ntWH, tCH Clock high time 50% PSCK -5% – ns \ntWL, tCL Clock low time 50% PSCK -5% – ns\ntCS CS# high time (read instructions) \nCS# high time (read instructions when reset feature is \nenabled)20\n50 – ns \ntCSS CS# active setup time (relative to SCK) 3 – ns\ntSU IO in setup time 3 – ns \ntHD IO in hold time 2 – ns\ntV Clock low to output valid – 8[87]\n6[88]ns \ntHO Output hold time 1 – ns\ntDIS Output disable time\nOutput disable time (when reset feature is enabled)– 8\n20 ns \ntO_skew  First IO to last IO data valid time – 600[89]ps \nNotes\n87.Full VCC range and CL = 30 pF.\n88.Full VCC range and CL = 15 pF.\n89.Not tested.\nCS#\nSCK\nIO\'s Inst. MSb MSb IN LSb INtCSStCS\ntSU\ntSUtHD\ntHD\nDatasheet 149 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n12.5.2 DDR output timing\nFigure 148 SPI DDR output timing\n12.5.3\nFigure 149 SPI DDR data valid window\nThe minimum data valid window (tDV) and tV minimum can be calculated as follows:\ntDV = minimum half clock cycle time (tCLH[90]) - tOTT[92] - tIO_SKEW[91]\ntV _min = tHO + tIO_SKEW + tOTT\nExample: \n• 66 MHz clock frequency = 15 ns clock period, DDR operations and duty cycle of 45% or higher\n-tCLH = 0.45 x PSCK = 0.45 x 15 ns = 6.75 ns\n•tOTT calculation[93] is bus impedance of 45 ohm and capacitance of 37 pf, with timing reference of 0.75 VCC, the \nrise time from 0 to 1 or fall time 1 to 0 is 1.4[96] x RC time constant (Tau)[95] = 1.4 x 1.67 ns = 2.34 ns\n-tOTT = rise time or fall time = 2.34 ns.\n•D a t a  v a l i d  w i n d o wCS#\nSCK\nIO\'s MSB LSBtCS\ntV tV tDIS tHO\nSCK\nIO Slow\nIO Fast\nIO_validSlow D1 Slow D2\nFast D1 Fast D2\nD1 D2 tV tIO_SKEW\n tDV  tCL  tCH \ntOTT pSCK \ntHO tV_min  tV \nNotes\n90.tCLH is the shorter duration of tCL or tCH.\n91.tIO_SKEW  is the maximum difference (delta) between the minimum and maximum tV (output valid) across all IO signals.\n92.tOTT is the maximum output transition time from one valid data value to the next valid data value on each IO.\n93.tOTT is dependent on system le vel considerations including:\na. Memory device output impedance (drive strength).\nb. System level parasitics on the IOs (primarily bus capacitance).c. Host memory controller input V\nIH and VIL levels at which 0 to 1 and 1 to 0 transitions are recognized.\nd. tOTT is not a specification tested by Infineon, it is system  dependent and must be deri ved by the system designer \nbased on the above considerations.\n94.tDV is the data valid window.\n95.Tau = R (output impedance) x C (load capacitance).\n96.Multiplier of Tau time for voltage to rise to 75% of VCC.\nDatasheet 150 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nTiming specifications\n-tDV = tCLH - tIO_SKEW - tOTT = 6.75 ns - 600 ps - 2.34ns = 3.81ns\n•tV minimum\n-tV _min = tHO + tIO_SKEW + tOTT = 1.0 ns + 600 ps + 2.34ns = 3.94ns\n12.6 Embedded algorithm performance tables\nTable 56 Program and erase performance\nSymbol Parameter Min Typ[97]Max Unit\ntW Non-volatile Register write time – 220 1200 ms \ntPP Page programming (256 bytes) – 450 1350 µs\ntBP1 Byte programming (first byte) – 75 90 µs\ntBP2 Additional byte programming (after first byte) – 10 30 µs\ntSE Sector erase time (4 KB physical sectors) – 65 320 ms\ntHBE Half block erase time (32KB physical sectors) – 300 600 ms\ntBE Block erase time (64KB physical sectors) – 450 1150 ms\ntCE Chip erase time (S25FL064L) – 55 150 sec\nNotes\n97.Typical program and erase times assu me the following conditions: 25°C, VCC = 3.0 V; checkerboard data pattern.\n98.The programming time for any OTP programming command is the same as tPP. This includes IRPP 2Fh, PASSP E8h and \nPDLRNV 43h.\nTable 57 Program or erase suspend AC parameters\nParameter Typical Max Unit Comments \nSuspend latency (tSL) – 40 µs The time from suspend command until the \nWIP bit is 0.\nResume to next suspend (tRNS) 100 – µsIs the time needed to issue the next \nsuspend command.\nDatasheet 151 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nOrdering information\n13 Ordering information\nThe ordering part number is formed by a valid combination of the following:\nS25FL 064 L AB M F I 00 1\nPacking type0 = Tray \n1 = Tube\n3 = 13” Tape and reel\nModel number (additional ordering options)\n00 = SOIC16 (300 mil) \n01 = SOIC8 (208 mil) / 8-contact WSON footprint\n02 = 5x5 ball BGA footprint\n03 = 4x6 ball BGA footprint04 = USON (4 x 4mm)\nTemperature range\nI = Industrial (–40 °C to +85 °C)\nV = Industrial Plus (–40 °C to +105 °C)\nA = Automotive, AEC-Q100 grade 3 (–40 °C to +85 °C)\nB = Automotive, AEC-Q100 grade 2 (–40 °C to +105 °C)\nM = Automotive, AEC-Q100 grade 1 (–40 °C to +125 °C)\nPackage materials\n[98]\nF = Halogen free, lead (Pb)-free \nH = Halogen free, lead (Pb)-free\nPackage type\nM = 8-lead SOIC / 16-lead SOIC\nN = USON 4 x 4 mm / WSON 5 x 6 mmB = 24-ball BGA 6 x 8 mm package, 1.00 mm pitch\nSpeed\nAB =108 MHz SDR and 54 MHz DDR\nDevice technology\nL = Floating gate process technology\nDensity\n064 = 64 Mb\nDevice family\nS25FL memory 3.0 V-only, SPI flash memory\nNote\n99.tHalogen free definition is in accordance with IEC 61249-2-21 specification.\nDatasheet 152 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nOrdering information\n13.1 Valid combinations — Standard\nValid combinations list configurations planned to be supp orted in volume for this device. Contact your local sales \noffice to confirm availability of specific valid comb inations and to check on newly released combinations.\n13.2 Valid combinations — Automotive grade / AEC-Q100\nThe Table 59  lists configurations that are automotive grade / AEC-Q100 qualified and are planned to be available \nin volume. The table will be updated as new combinations are released. Consult your local sales representative to confirm availability of specific combinations  and to check on newly released combinations.\nProduction part approval process (PPAP) suppor t is only provided for AEC-Q100 grade products.\nProducts to be used in end-use applications that require ISO/TS-16949 compliance must be AEC-Q100 grade \nproducts in combination with PPAP . Non–AEC-Q100 grade pr oducts are not manufactured or documented in full \ncompliance with ISO/TS-16949 requirements.\nAEC-Q100 grade products are also offered without PPAP support for end-use applications that do not require \nISO/TS-16949 compliance.Table 58 Valid Combinations — Standard\nBase ordering \npart numberSpeed \noptionPackage and \ntemperatureModel \nnumberPacking type Package marking\nS25FL064L AB MFI, MFV 00, 01 0, 1, 3 FL0 64L + (temp) + F + (model number)\nAB NFI, NFV 01, 04 0, 1, 3 FL064L + (temp) + F + (model number)\nAB BHI, BHV 02, 03 0, 3 FL064L + (temp) + H + (model number)\nTable 59 Valid combinations — Automotive grade / AEC-Q100\nBase ordering \npart numberSpeed \noptionPackage and \ntemperatureModel number Packing type Package marking\nS25FL064L AB MFA, MFB, \nMFM00, 01 0, 1, 3 FL064L + (temp) + F + (model number)\nAB NFA, NFB, NFM 01, 04 0, 1, 3 FL064L + (temp) + F + (model number)\nAB BHA, BHB, \nBHM02, 03 0, 3 FL064L + (temp) + H + (model number)\nDatasheet 153 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPhysical diagrams\n14 Physical diagrams\nFigure 150 SOIC 8-lead, 208 mil body width (SOC008)5.28 BSC D\n0.51\n20100NL1\nL2E1\nLeE\n15°0°\n5°8°0.765.28 BSC8.00 BSC\n1.36 REF\n0.25 BSC\n81.27 BSC1.701.75\n0.05\n0.330.36\n0.150.19\nc1cb1bA2A1A\n1.902.16\n0.25\n0.48\n0.46\n0.200.24\n0-8° REF2. DIMENSIONING AND TOLERANCING PER ASME Y14.5M - 1994.\n3.  DIMENSION D DOES NOT INCLUDE MOLD FLASH, PROTRUSIONS OR GATE BURRS. \nEND. DIMENSION E1 DOES NOT INCLUDE INTERLEAD FLASH OR PROTRUSION.\nINTERLEAD FLASH OR PROTRUSION SHALL NOT EXCEED 0.25 mm PER SIDE. 1.  ALL DIMENSIONS ARE IN MILLIMETERS.NOTES: \nD AND E1 DIMENSIONS ARE DETERMINED AT DATUM H.\n FLASH, BUT INCLUSIVE OF ANY MISMATCH BETWEEN THE TOP AND BOTTOM OFEXCLUSIVE OF MOLD FLASH, TIE BAR BURRS, GATE BURRS AND INTERLEAD4.  THE PACKAGE TOP MAY BE SMALLER THAN THE PACKAGE BOTTOM. DIMENSIONS\n5. DATUMS A AND B TO BE DETERMINED AT DATUM H.\n6.  "N" IS THE MAXIMUM NUMBER OF TERMINAL POSITIONS FOR THE SPECIFIED \n7.  THE DIMENSIONS APPLY TO THE FLAT SECTION OF THE LEAD BETWEEN 0.10 TO\n  MAXIMUM MATERIAL CONDITION. THE DAMBAR CANNOT BE LOCATED ON THE8.  DIMENSION "b" DOES NOT INCLUDE DAMBAR PROTRUSION. ALLOWABLE DAMBAR\n  LOWER RADIUS OF THE LEAD FOOT.\nIDENTIFIER MUST BE LOCATED WITHIN THE INDEX AREA INDICATED.9.  THIS CHAMFER FEATURE IS OPTIONAL. IF IT IS NOT PRESENT, THEN A PIN 1 \n10.  LEAD COPLANARITY SHALL BE WITHIN 0.10 mm AS MEASURED FROM THE MOLD FLASH, PROTRUSIONS OR GATE BURRS SHALL NOT EXCEED 0.15 mm PER\n D AND E1 ARE DETERMINED AT THE OUTMOST EXTREMES OF THE PLASTIC BODY \n0.25 mm FROM THE LEAD TIP.\n PROTRUSION SHALL BE 0.10 mm TOTAL IN EXCESS OF THE "b" DIMENSION AT THE PLASTIC BODY.\nPACKAGE LENGTH.\nSEATING PLANE.DIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n-\n--\n-\n-\n-\n-\n-\n-\n-\n002-15548 Rev. **\nDatasheet 154 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPhysical diagrams\nFigure 151 SOIC 16-lead, 300  mil body wi dth (SO3016)0.33  C\n0.25  M D CA - B0.20  C A-B\n0.10  C\n0.10  C0.10  C D\n2X\n2.  DIMENSIONING AND TOLERANCING PER ASME Y14.5M - 1994.\n3.  DIMENSION D DOES NOT INCLUDE MOLD FLASH, PROTRUSIONS OR GATE BURRS. \n END. DIMENSION E1 DOES NOT INCLUDE INTERLEAD FLASH OR PROTRUSION.\nINTERLEAD FLASH OR PROTRUSION SHALL NOT EXCEED 0.25 mm PER SIDE. 1.  ALL DIMENSIONS ARE IN MILLIMETERS.NOTES: \nD AND E1 DIMENSIONS ARE DETERMINED AT DATUM H.\n FLASH, BUT INCLUSIVE OF ANY MISMATCH BETWEEN THE TOP AND BOTTOM OFEXCLUSIVE OF MOLD FLASH, TIE BAR BURRS, GATE BURRS AND INTERLEAD4.  THE PACKAGE TOP MAY BE SMALLER THAN THE PACKAGE BOTTOM. DIMENSIONS\n5.  DATUMS A AND B TO BE DETERMINED AT DATUM H.\n6.  "N" IS THE MAXIMUM NUMBER OF TERMINAL POSITIONS FOR THE SPECIFIED \n7.  THE DIMENSIONS APPLY TO THE FLAT SECTION OF THE LEAD BETWEEN 0.10 TO\n   MAXIMUM MATERIAL CONDITION. THE DAMBAR CANNOT BE LOCATED ON THE8.  DIMENSION "b" DOES NOT INCLUDE DAMBAR PROTRUSION. ALLOWABLE DAMBAR\n  LOWER RADIUS OF THE LEAD FOOT.\nIDENTIFIER MUST BE LOCATED WITHIN THE INDEX AREA INDICATED.9.  THIS CHAMFER FEATURE IS OPTIONAL. IF IT IS NOT PRESENT, THEN A PIN 1 \n10.  LEAD COPLANARITY SHALL BE WITHIN 0.10 mm AS MEASURED FROM THE \nh\n0D\nL2\nNeA1\nb\nc\nE\nE1A\n0.7510.30 BSC\n1.27 BSC0.30\n10.30 BSC0.33\n0°0.25160.20\n7.50 BSC0.10\n0.31\n8°0.512.65 2.35\nA2 2.05 2.55\nb1 0.27 0.48\n0.30 0.20 c1\nL10.40 L 1.27\n1.40 REF\n0.25 BSC\n0 5° 15°\n0 0°1\n2 -DIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n-----------\n-MOLD FLASH, PROTRUSIONS OR GATE BURRS SHALL NOT EXCEED 0.15 mm PER\n D AND E1 ARE DETERMINED AT THE OUTMOST EXTREMES OF THE PLASTIC BODY \n 0.25 mm FROM THE LEAD TIP.\n PROTRUSION SHALL BE 0.10 mm TOTAL IN EXCESS OF THE "b" DIMENSION AT THE PLASTIC BODY.\nPACKAGE LENGTH.\nSEATING PLANE.\n002-15547 Rev. *A\nDatasheet 155 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPhysical diagrams\nFigure 152 USON 4 x 4 mm (UNF008)JEDEC SPECIFICATION NO. REF: N/ACOPLANARITY ZONE APPLIES TO THE EXPOSED HEAT SINKPIN #1 ID ON TOP WILL BE LOCATED WITHIN THE INDICATED ZONE.DIMENSION "b" APPLIES TO METALLIZED TERMINAL AND IS MEASURED    N IS THE TOTAL NUMBER OF TERMINALS.    ALL DIMENSIONS ARE IN MILLIMETERS.NOTES:\n5.4.1.\n3.2.\n6.\n7. THE OPTIONAL RADIUS ON THE OTHER END OF THE TERMINAL, THE \nDIMENSION "b" SHOULD NOT BE MEASURED IN THAT RADIUS AREA.ND REFERS TO THE NUMBER OF TERMINALS ON D SIDE.8\n40.80 BSC.\n0.30\n4.00 BSC4.00 BSC2.30\n3.00\n0.200.55\n0.0350.40\nA1\nKAE2\nD\nED2bLNDNe\n0.002.90\n0.502.200.250.35\n3.10\n0.050.602.400.350.45\nA3 0.152 REFDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\nBETWEEN 0.15 AND 0.30mm FROM TERMINAL TIP. IF THE TERMINAL HAS\nSLUG AS WELL AS THE TERMINALS.\n--\n002-16243 Rev. *A\nDatasheet 156 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPhysical diagrams\nFigure 153 WSON 5 x 6 mm (WND008)A MAXIMUM 0.15mm PULL BACK (L1) MAY BE PRESENT.BILATERAL COPLANARITY ZONE APPLIES TO THE EXPOSED HEAT SINKPIN #1 ID ON TOP WILL BE LOCATED WITHIN THE INDICATED ZONE.MAXIMUM ALLOWABLE BURR IS 0. 076mm IN ALL DIRECTIONS.DIMENSION "b" APPLIES TO METALLIZED TERMINAL AND IS MEASURED    N IS THE TOTAL NUMBER OF TERMINALS.    ALL DIMENSIONS ARE IN MILLIMETERS.    DIMENSIONING AND TOLERANCING CONFORMS TO ASME Y14.5M-1994.NOTES:\nMAX. PACKAGE WARPAGE IS 0.05mm.\n87.6.52.\n43.1.\n9\n10 THE OPTIONAL RADIUS ON THE OTHER END OF THE TERMINAL, THE \nDIMENSION "b" SHOULD NOT BE MEASURED IN THAT RADIUS AREA.\nND REFERS TO THE NUMBER OF TERMINALS ON D SIDE.8\n41.27 BSC.\n0.40\n6.00 BSC5.00 BSC4.00\n3.40\n0.20 MIN.0.75\n0.020.60\nA1\nKAE2\nD\nED2bLNDNe\n0.003.30\n0.703.900.350.55\n3.50\n0.050.804.100.450.65\nA3 0.20 REFDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\nBETWEEN 0.15 AND 0.30mm FROM TERMINAL TIP. IF THE TERMINAL HAS\nSLUG AS WELL AS THE TERMINALS.\n002-18755 Rev. **\nDatasheet 157 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPhysical diagrams\nFigure 154 Ball grid array, 24-ball 6 x 8 mm (FAB024)METALLIZED MARK INDENTATION OR OTHER MEANS.A1 CORNER TO BE IDENTIFIED BY CHAMFER, LASER OR INK MARK,N IS THE NUMBER OF POPULATED SOLDER BALL POSITIONS FOR MATRIX SIZE MD X ME.\nWHEN THERE IS AN EVEN NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" = eD/2 ANDWHEN THERE IS AN ODD NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" OR "SE" = 0.POSITION OF THE CENTER SOLDER BALL IN THE OUTER ROW. "SD" AND "SE" ARE MEASURED WITH RESPECT TO DATUMS A AND B AND DEFINE THESYMBOL "ME" IS THE BALL MATRIX SIZE IN THE "E" DIRECTION. SYMBOL "MD" IS THE BALL MATRIX SIZE IN THE "D" DIRECTION. e REPRESENTS THE SOLDER BALL GRID PITCH.\nDIMENSION "b" IS MEASURED AT THE MAXIMUM BALL DIAMETER IN A PLANE  BALL POSITION DESIGNATION PER JEP95, SECTION 3, SPP-020.  DIMENSIONING AND TOLERANCING METHODS PER ASME Y14.5M-1994.\n"+" INDICATES THE THEORETICAL CENTER OF DEPOPULATED BALLS. 8.\n9.7   ALL DIMENSIONS ARE IN MILLIMETERS.\nPARALLEL TO DATUM C.5.\n64.3.2.1.NOTES:\nSDb\neDeEME\nN\n0.35\n0.00 BSC1.00 BSC1.00 BSC0.40245\n0.45D1\nMDE1EDA\nA1 0.20-\n4.00 BSC\n4.00 BSC\n56.00 BSC8.00 BSC-- 1.20\n-\nSE 0.00 BSCDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n"SE" = eE/2.\n002-15534 Rev. **\nDatasheet 158 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nPhysical diagrams\nFigure 155 Ball grid array, 24-ball 6 x 8 mm (FAC024)METALLIZED MARK INDENTATION OR OTHER MEANS.A1 CORNER TO BE IDENTIFIED BY CHAMFER, LASER OR INK MARK,N IS THE NUMBER OF POPULATED SOLDER BALL POSITIONS FOR MATRIX SIZE MD X ME.\nWHEN THERE IS AN EVEN NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" = eD/2 ANDWHEN THERE IS AN ODD NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" OR "SE" = 0.POSITION OF THE CENTER SOLDER BALL IN THE OUTER ROW. "SD" AND "SE" ARE MEASURED WITH RESPECT TO DATUMS A AND B AND DEFINE THESYMBOL "ME" IS THE BALL MATRIX SIZE IN THE "E" DIRECTION. SYMBOL "MD" IS THE BALL MATRIX SIZE IN THE "D" DIRECTION. e    REPRESENTS THE SOLDER BALL GRID PITCH.\nDIMENSION "b" IS MEASURED AT THE MAXIMUM BALL DIAMETER IN A PLANE     BALL POSITION DESIGNATION PER JEP95, SECTION 3, SPP-020.    DIMENSIONING AND TOLERANCING METHODS PER ASME Y14.5M-1994.\n"+" INDICATES THE THEORETICAL CENTER OF DEPOPULATED BALLS. 8.\n9.7    ALL DIMENSIONS ARE IN MILLIMETERS.\nPARALLEL TO DATUM C.5.\n64.3.2.1.NOTES:\nSDb\neDeEME\nN\n0.35\n0.50 BSC1.00 BSC1.00 BSC0.40244\n0.45D1\nMDE1EDA\nA1 0.25-\n5.00 BSC\n3.00 BSC\n66.00 BSC8.00 BSC-- 1.20\n-\nSE 0.50 BSCDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n "SE" = eE/2.\n002-15535 Rev. **\nDatasheet 159 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nRevision history\n160Revision history\nDocument \nversionDate Description of changes\n** 2016-07-27 Initial release\n*A 2016-09-26 Changed status from Advance to Preliminary.\nUpdated "Features" on page 1\nAdded Automotive Grade related information.Updated "Data integrity" on page 124\nUpdated "Data retention" on page 124\nUpdated Table 38 .\nUpdated "Ordering information" on page 151\nUpdated details corresponding to “01” under “Model Number (Additional Ordering Options)” .Added Automotive Grade related information.Added Valid combinations — Automotive grade / AEC-Q100  on page 152.\nUpdated Physical diagrams  on page 153\nUpdated Package Drawings to Cypress release.\n*B 2017-01-13 Updated "Data retention" on page 124\nAdded Cypress application notes website URL.Updated Table 47\nUpdated Table 47\nAdded notes for VCC (cut-off) and VCC (low) min values.Updated "DC characteristics" on page 138 \nAdded notes for I\nPOR in-rush current for all temperature ranges.\nPOR current for typical and maximum reduced.Updated "Ordering information" on page 151\nAdded “04” under “Model Number” .Updated Table 33\nUpdated DDRQIOR and 4DDRQIOR Max Frequency.Updated Table 34\nUpdated Byte Address 00003B Register NameDatasheet converted from Preliminary to Final\n*C 2017-05-15 Removed Extended Temperature Range Options (–40 °C to +125 °C) from \ndatasheet.Updated Table 1\nAdded Figure 1\nUpdated Table 33\nCorrected Command Description for RDSR2 to Read Status Register 2.Updated "Register Access commands" on page 69\nUpdated "Read Status Register 2 (RDSR2 07h)" on page 69\nCorrected all mention of Status Register 1 to Status Register 2.Updated Table 41\nCorrected Bit 22 description at address 02h from “DOR” to “QOR”Corrected data at address 3Dh from 60h to 50h.Updated "Ordering information" on page 151\nAdded WSON 5 x 6mm package option.Added 16-Lead SOIC package option.Updated Table 58\nUpdated Table 59\nRemoved Model 04 option for MF* Package and Temperature option.Added Model 01 option for 16-Lead SOIC package.Added "SOIC 8-lead, 208 mil body width (SOC008)" on page 153\nAdded "" on page 156.\nUpdated Cypress logo, Sales page, and Copyright information.1\nDatasheet 160 002-12878 Rev. *G\n2022-07-2164 Mb (8 MB) FL-L flash\nSPI multi-I/O, 3.0 V\nRevision history\n160*D 2018-04-04 Updated "DDR data valid timing using DLP" on page 149\nUpdated Figure 74  \nUpdated Figure 75  \nUpdated Figure 76  \nUpdated Figure 22  and Figure 23\nUpdated Table 44\nUpdated Table 45\nUpdated Table 48  improved ICC & ISB current specifications.\nUpdated Table 49  improved ICC & ISB current specifications.\nUpdated Table 50  improved ICC & ISB current specifications.\n*E 2018-07-11 Updated the "DDR data valid timing using DLP" on page 149 section.\nChanged Low-halogen to Halogen free in "Ordering information" on page 151 \nand added a Note ” Halogen free definition is in accordance with IEC 61249-2-21 specification” added to Section 6.6.Updated “Glossary” Definition of MSb & LSb\n*F 2019-01-29 Updated “Typical Current Consumption” table in "Performance summary" on \npage 3.Updated Table 41 : Dword-10.\nUpdated Table 47 .\nUpdated template.Updated Copyright information in Sales,  Solutions, and Legal Information on \npage 146.\n*G 2022-07-21 Updated Table 46 : Added  Theta JB and Theta JC.\nMigrated to Infineon template.Document \nversionDate Description of changes\nTrademarks\nAll referenced product or service names and trademarks are the proper ty of their respective owners.\nEdition 2022-07-21\nPublished by Infineon Technologies AG81726 Munich, Germany\n© 2022 Infineon Technologies AG.\nAll Rights Reserved.\nDo you have a question about any \naspect of this document?\nGo to\n www.infineon.com/support\nDocument reference002-12878 Rev. *GIMPORTANT NOTICE\nThe information given in this document shall in no\nevent be regarded as a guarantee of conditions orcharacteristics ("Beschaffenheitsgarantie"). \nWith respect to any examples, hints or any typical\nvalues stated herein and/or any information regardingthe application of the product, Infineon Technologieshereby disclaims any and all warranties and liabilitiesof any kind, including without limitation warranties ofnon-infringement of intellectual property rights of anythird party. \nIn addition, any information given in this document is\nsubject to customer\'s comp liance with its obligations\nstated in this document and any applicable legalrequirements, norms and standards concerningcustomer\'s products and any use of the product ofInfineon Technologies in customer\'s applications. \nThe data contained in this document is exclusively\nintended for technically trained staff. It is theresponsibility of customer\'s technical departments toevaluate the suitability of the product for the intendedapplication and the completeness of the productinformation given in this document with respect tosuch application.  For further information on technology, delivery terms\nand conditions and prices, please contact the nearestInfineon Technologies Office (\nwww.infineon.com ).\nWARNINGS\nDue to technical requirements products may contain\ndangerous substances. For information on the types\nin question please contact your nearest Infineon\nTechnologies office.\nExcept as otherwise explicitly approved by Infineon\nTechnologies in a written document signed byauthorized representatives of Infineon Technologies,\nInfineon Technologies’ products may not be used inany applications where a failure of the product or anyconsequences of the use thereof can reasonably beexpected to result in personal injury.Please read the Important Notice and Warnings at the end of this document\n'}]
!==============================================================================!
### Component Summary: S25FL064LABNFV040

**Manufacturer:** Infineon Technologies  
**Product Code:** S25FL064LABNFV040  
**Description:** The S25FL064L is a 64 Mb (8 MB) FL-L flash memory device utilizing SPI multi-I/O interface. It employs floating gate technology and is manufactured using a 65-nm process.

#### Key Specifications:
- **Voltage Ratings:**
  - Operating Voltage (VCC): 2.7 V to 3.6 V
- **Current Ratings:**
  - Typical Read Current: 10 mA (at 50 MHz)
  - Typical Program Current: 17 mA
  - Typical Erase Current: 17 mA
  - Standby Current: 20 µA (SPI), 35 µA (QPI)
  - Deep Power Down Current: 2 µA
- **Power Consumption:**
  - Active Power Supply Current (READ): Up to 20 mA at 108 MHz
  - Active Power Supply Current (Page Program): Up to 25 mA
- **Operating Temperature Range:**
  - Industrial: -40°C to +85°C
  - Industrial Plus: -40°C to +105°C
  - Automotive AEC-Q100 Grade 1: -40°C to +125°C
- **Package Type:**
  - Available in multiple packages: SOIC (8-lead, 16-lead), WSON (5x6 mm), USON (4x4 mm), BGA (24-ball)
- **Special Features:**
  - Supports Single, Dual, Quad I/O, and QPI modes.
  - 100,000 program-erase cycles minimum.
  - 20 years data retention minimum.
  - Security features including status and configuration register protection, individual block lock, and password protection.
- **Moisture Sensitive Level (MSL):** MSL 3 per JEDEC J-STD-020E.

#### Description:
The S25FL064L is a high-density, non-volatile flash memory device designed for embedded applications. It connects to a host system via a Serial Peripheral Interface (SPI) and supports various modes of operation, including Single I/O, Dual I/O, Quad I/O, and Quad Peripheral Interface (QPI). The device features a page programming buffer that allows programming of up to 256 bytes in a single operation, and it supports multiple erase sizes (4 KB, 32 KB, 64 KB, and chip erase).

#### Typical Applications:
- **Embedded Systems:** Ideal for applications requiring code shadowing to RAM and executing code directly from flash (XIP).
- **Mobile Devices:** Suitable for use in smartphones, tablets, and other portable devices due to its low power consumption and compact size.
- **Automotive Applications:** Compliant with AEC-Q100 standards, making it suitable for automotive electronics.
- **Consumer Electronics:** Used in various consumer devices for data storage and firmware updates.

This summary provides a comprehensive overview of the S25FL064LABNFV040 flash memory device, highlighting its key specifications, features, and typical applications.