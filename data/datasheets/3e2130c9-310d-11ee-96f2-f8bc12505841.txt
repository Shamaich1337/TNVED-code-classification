[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of ATTINY45V-10SUR production of MICROCHIP TECHNOLOGY from the text: 2586Q–AVR–08/2013Features\n•High Performance, Low Power AVR® 8-Bit Microcontroller\n•Advanced RISC Architecture\n– 120 Powerful Instructions – Most Single Clock Cycle Execution\n– 32 x 8 General Purpose Working Registers– Fully Static Operation\n•Non-volatile Program and Data Memories\n– 2/4/8K Bytes of In-System Programmable Program Memory Flash\n• Endurance: 10,000 Write/Erase Cycles\n– 128/256/512 Bytes In-System Programmable EEPROM\n• Endurance: 100,000 Write/Erase Cycles\n– 128/256/512 Bytes Internal SRAM\n– Programming Lock for Self-Programming Flash Program and EEPROM Data Security\n•Peripheral Features\n– 8-bit Timer/Counter with Prescaler and Two PWM Channels\n– 8-bit High Speed Timer/Counter with Separate Prescaler\n• 2 High Frequency PWM Outputs with Separate Output Compare Registers\n• Programmable Dead Time Generator\n– USI – Universal Serial Interface with Start Condition Detector– 10-bit ADC\n• 4 Single Ended Channels\n• 2 Differential ADC Channel Pairs with Programmable Gain (1x, 20x)• Temperature Measurement\n– Programmable Watchdog Timer with Separate On-chip Oscillator\n– On-chip Analog Comparator\n•Special Microcontroller Features\n– debugWIRE On-chip Debug System\n– In-System Programmable via SPI Port– External and Internal Interrupt Sources\n– Low Power Idle, ADC Noise Reduction, and Power-down Modes\n– Enhanced Power-on Reset Circuit– Programmable Brown-out Detection Circuit\n– Internal Calibrated Oscillator\n•I/O and Packages\n– Six Programmable I/O Lines\n– 8-pin PDIP, 8-pin SOIC, 20-pad QFN/ML F, and 8-pin TSSOP (only ATtiny45/V)\n•Operating Voltage\n– 1.8 - 5.5V for ATtiny25V/45V/85V\n– 2.7 - 5.5V for ATtiny25/45/85\n•Speed Grade\n– ATtiny25V/45V/85V: 0 – 4 MHz @ 1.8 - 5.5V, 0 - 10 MHz @ 2.7 - 5.5V\n– ATtiny25/45/85: 0 – 10 MHz @ 2.7 - 5.5V, 0 - 20 MHz @ 4.5 - 5.5V\n•Industrial Temperature Range\n•Low Power Consumption\n– Active Mode: \n• 1 MHz, 1.8V: 300 µA\n– Power-down Mode:\n• 0.1 µA at 1.8VAtmel 8-bit AVR Microcontroller with 2/4/8K \nBytes In-System Programmable Flash\nATtiny25/V / ATtiny45/V / ATtiny85/V\nRev. 2586Q–AVR–08/2013\n2 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20131. Pin Configurations\nFigure 1-1. Pinout ATtiny25/45/85\n1.1 Pin Descriptions\n1.1.1 VCC\nSupply voltage.\n1.1.2 GND\nGround.\n1.1.3 Port B (PB5:PB0)\nPort B is a 6-bit bi-directional I/O port with internal pull- up resistors (selected for each bi t). The Port B output buffers\nhave symmetrical drive characteristics with both high sink and source capability. As inputs, Port B pins that are\nexternally pulled low will source current if the pull-up resistor s are activated. The Port B pins are tri-stated when a\nreset condition becomes active, even if the clock is not running.1\n2348\n765\n(PCINT5/RESET/ADC0/dW) PB5\n(PCINT3/XTAL1/CLKI/OC1B/ADC3) PB3\n(PCINT4/XTAL2/CLKO/OC1B/ADC2) PB4\nGNDVCC\nPB2 (SCK/USCK/SCL/ADC1/T0/INT0/PCINT2)PB1 (MISO/DO/AIN1/OC0B/OC1A/PCINT1)PB0 (MOSI/DI/SDA/AIN0/OC0A/OC1A/AREF/PCINT0)PDIP/SOIC/TSSOP\n12345QFN/MLF\n15141312112019181716 678910 DNCDNC\nGND\nDNCDNCDNC\nDNCDNCDNCDNC\nNOTE: Bottom pad should be soldered to ground.DNC: Do Not ConnectNOTE: TSSOP only for ATtiny45/V\n(PCINT5/RESET/ADC0/dW) PB5\n(PCINT3/XTAL1/CLKI/OC1B/ADC3) PB3\nDNCDNC\n(PCINT4/XTAL2/CLKO/OC1B/ADC2) PB4VCC\nPB2 (SCK/USCK/SCL/ADC1/T0/INT0/PCINT2)DNCPB1 (MISO/DO/AIN1/OC0B/OC1A/PCINT1)PB0 (MOSI/DI/SDA/AIN0/OC0A/OC1A/AREF/PCINT0)\n3 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Port B also serves the functions of various spec ial features of the ATti ny25/45/85 as listed in “Alternate Functions\nof Port B” on page 60 .\nOn ATtiny25, the programmable I/O ports PB3 and PB4 (pins 2 and 3) are exchanged in ATtiny15 Compatibility\nMode for supporting the backward compatibility with ATtiny15.\n1.1.4 RESET\nReset input. A low le vel on this pin for longer than  the minimum pulse le ngth will generate a reset,  even if the clock\nis not running and provided the reset pin has not bee n disabled. The minimum pulse length is given in Table 21-4\non page 165 . Shorter pulses are not guaranteed to generate a reset.\nThe reset pin can also be used as a (weak) I/O pin.\n4 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20132. Overview\nThe ATtiny25/45/85 is a low-power CMOS 8-bit microcont roller based on the AVR enhanced RISC architecture. By\nexecuting powerful instructions in a single clock cycle,  the ATtiny25/45/85 achieves throughputs approaching 1\nMIPS per MHz allowing the system designer to opt imize power consumption versus processing speed.\n2.1 Block Diagram\nFigure 2-1. Block Diagram\nThe AVR core combines a rich instruction set with 32 general purpose working registers. All 32 registers are\ndirectly connected to the Ar ithmetic Logic Unit (ALU),  allowing two independent regi sters to be accessed in one\nsingle instruction executed in one clock cycle. The result ing architecture is more c ode efficient wh ile achieving\nthroughputs up to ten times faster th an conventional CISC microcontrollers.PROGRAM\nCOUNTERCALIBRATED\nINTERNAL\nOSCILLATOR\nWATCHDOG\nTIMERSTACK\nPOINTER\nPROGRAM\nFLASHSRAMMCU  CONTROL\nREGISTER\nGENERAL\nPURPOSE\nREGISTERSINSTRUCTION\nREGISTER\nTIMER/\nCOUNTER0\nSERIALUNIVERSAL\nINTERFACETIMER/\nCOUNTER1INSTRUCTION\nDECODER\nDATA  DIR.\nREG.PORT BDATA  REGISTER\nPORT  BPROGRAMMING\nLOGICTIMING  AND\nCONTROL\nMCU  STATUS\nREGISTER\nSTATUS\nREGISTERALU\nPORT  B  DRIVERS\nPB[0:5]VCC\nGND\nCONTROL\nLINES8-BIT DATABUS\nZ\nADC / \nANALOG  COMPARATORINTERRUPT\nUNIT\nDATA\nEEPROMOSCILLATORSYX\nRESET\n5 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The ATtiny25/45/85 provides the following features: 2/ 4/8K bytes of In-System Pr ogrammable Flash, 128/256/512\nbytes EEPROM, 128/256/256 bytes SRAM, 6 general purpose I/O li nes, 32 general purpose working registers, one\n8-bit Timer/Counter with compare modes, one 8-bit high spee d Timer/Counter, Universal Serial Interface, Internal\nand External Interrupts, a 4-channel, 10-bit ADC, a pr ogrammable Watchdog Timer with internal Oscillator, and\nthree software selectable po wer saving modes. Idle mode stops the CP U while allowing the SRAM, Timer/Counter,\nADC, Analog Comparator, and Interrupt system to continue  functioning. Power-down mode saves the register con-\ntents, disabling all chip functions un til the next Interrupt or  Hardware Reset. ADC Nois e Reduction mode stops the\nCPU and all I/O modules except ADC, to mini mize switching noise during ADC conversions.\nThe device is manufactured using Atmel’s high density non- volatile memory technology. The On-chip ISP Flash\nallows the Program memory to be re-programmed In-System through an SPI serial interface, by a conventionalnon-volatile memory programmer or by an On-chip boot code running on the AVR core.\nThe ATtiny25/45/85 AVR is supported wit h a full suite of program and system development tools including: C Com-\npilers, Macro Assemblers, Program Debugger/Simulators and Evaluation kits.\n6 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20133. About\n3.1 Resources\nA comprehensive set of development tools, application notes and datasheet s are available for download on\nhttp://www.atmel.com/avr.\n3.2 Code Examples\nThis documentation contains simple co de examples that briefly show how to use various parts of the device. These\ncode examples assume that the part specific header file is included before compilation. Be aware that not all C\ncompiler vendors include bit definitions in the header files and interrupt handling in C is compiler dependent.\nPlease confirm with the C compile r documentation for more details.\nFor I/O Registers located in the extended I/O map, “IN”, “O UT”, “SBIS”, “SBIC”, “CBI”, and “SBI” instructions must\nbe replaced with instructions  that allow access to extended I/O. Typica lly, this means “LDS” and “STS” combined\nwith “SBRS”, “SBRC”, “SBR”, and “C BR”. Note that not all AVR devices include an extended I/O map.\n3.3 Capacitive Touch Sensing\nAtmel QTouch Library provides a simple to use solution for touch sensitive interfac es on Atmel AVR microcon-\ntrollers. The QTouch Library includes support for QTouch® and QMatrix® acquisition methods.\nTouch sensing is easily added to any application by linki ng the QTouch Library and using the Application Program-\nming Interface (API) of the library to  define the touch channels and sensors. The applicati on then calls the API to\nretrieve channel information and determine the state of the touch sensor.\nThe QTouch Library is free and can be downloaded from  the Atmel website. For more  information and details of\nimplementation, refer to the QTouch Library User Guide – also available from the Atmel website.\n3.4 Data Retention\nReliability Qualification results show that  the projected data retention failure ra te is much less than 1 PPM over 20\nyears at 85°C or 100 years at 25°C.\n7 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20134. AVR CPU Core\n4.1 Introduction\nThis section discusses the AVR core ar chitecture in general. The main function of the CPU core is to ensure cor-\nrect program execution. The CPU mu st therefore be able to access memo ries, perform calculations, control\nperipherals, and handle interrupts.\n4.2 Architectural Overview\nFigure 4-1. Block Diagram of the AVR Architecture \nIn order to maximize performance and parallelism, the AVR  uses a Harvard architecture – with separate memories\nand buses for program and data. Instructions in the Program memory are executed with a single level pipelining.\nWhile one instruction is being executed , the next instruction is pre-fetched from the Program memory. This concept\nenables instructions to be executed in  every clock cycle. The Program me mory is In-System Reprogrammable\nFlash memory.\nThe fast-access Register File contai ns 32 x 8-bit general purpose work ing registers with a single clock cycle\naccess time. This allows singl e-cycle Arithmetic Logic Unit  (ALU) operation. In a typi cal ALU operation, two oper-Flash\nProgram\nMemory\nInstruction\nRegister\nInstruction\nDecoderProgram\nCounter\nControl Lines32 x 8\nGeneral\nPurpose\nRegistrers\nALUStatus\nand Control\nI/O LinesEEPROMData Bus 8-bit \nData\nSRAMDirect Addressing Indirect AddressingInterrupt\nUnit\nWatchdog\nTimer\nAnalog\nComparator\nI/O Module 2I/O Module1\nI/O Module n\n8 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013ands are output from the Register File, the operation is ex ecuted, and the result is stored back in the Register File\n– in one clock cycle.\nSix of the 32 registers can be used as  three 16-bit indirect address register pointers for Data Space addressing –\nenabling efficient address calculations. One of the these address pointers can also be used as an address pointer\nfor look up tables in Flash Program memory. These added f unction registers are the 16-bit X-, Y-, and Z-register,\ndescribed later in this section.\nThe ALU supports arithmetic and logi c operations between registers or bet ween a constant and a register. Single\nregister operations can also be executed in the ALU. Afte r an arithmetic operation, t he Status Regist er is updated\nto reflect information about the result of the operation.\nProgram flow is provided by conditional and unconditional jump and call instructions, able to directly address the\nwhole address space. Most AVR instructions have a single 16-bit word format, but there are also 32-bit\ninstructions.\nDuring interrupts and subroutine calls, the return address Program Counter (PC) is stored on the Stack. The Stack\nis effectively allocated in the general data SRAM, and c onsequently the Stack size is only limited by the total\nSRAM size and the usage of the SRAM. All user programs must initialize the SP in the Reset routine (before sub-\nroutines or interrupts are executed). The Stack Pointer (SP) is read/write accessible in the I/O space. The data\nSRAM can easily be accessed through the five different addressing modes supported in the AVR architecture.\nThe memory spaces in the AVR  architecture are all linear and regular memory maps.\nA flexible interrupt module has its contro l registers in the I/O space with an additional Global Interrupt Enable bit in\nthe Status Register. All interrupts have a separate In terrupt Vector in  the Interrupt Vector table. The interrupts have\npriority in accordance with their Interrupt Vector positio n. The lower the Interrupt Vector address, the higher the\npriority.\nThe I/O memory space contains 64 addresses for CPU peripheral functions as Control Registers, SPI, and other\nI/O functions. The I/O memory can be accessed directly, or  as the Data Space locations following those of the Reg-\nister File, 0x20 - 0x5F.\n4.3 ALU – Arithm etic Logic Unit\nThe high-performance AVR ALU operates in direct connection with all the 32 general purpose working registers.\nWithin a single clock cycle, arithmetic  operations between general purpose re gisters or between a register and an\nimmediate are executed. The ALU operat ions are divided into three main cat egories – arithmetic, logical, and bit-\nfunctions. Some implementations of the architecture  also provide a powerful multiplier supporting both\nsigned/unsigned multiplication and fractional format. See the “Instruction Set” section for a detailed description.\n4.4 Status Register\nThe Status Register contains information about the result of the most re cently executed arithmetic instruction. This\ninformation can be used for altering program flow in order  to perform conditional operations. Note that the Status\nRegister is updated afte r all ALU operations, as specif ied in the Instruction Set Refe rence. This will in many cases\nremove the need for using the dedicated compare instruct ions, resulting in faster and more compact code.\nThe Status Register is not automatically stored when entering an inte rrupt routine and restored when returning\nfrom an interrupt. This must  be handled by software.\n9 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20134.4.1 SREG – AVR Status Register\nThe AVR Status Register – SREG – is defined as:\n• Bit 7 – I: Global Interrupt Enable\nThe Global Interrupt Enable bit must be set for the interrup ts to be enabled. The individual interrupt enable control\nis then performed in separate control registers. If the Glob al Interrupt Enable Register is cleared, none of the inter-\nrupts are enabled independent of the individual interrupt e nable settings. The I-bit is cleared by hardware after an\ninterrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts. The I-bit can also be set\nand cleared by the application with the SEI and CLI inst ructions, as described in the instruction set reference.\n• Bit 6 – T: Bit Copy Storage\nThe Bit Copy instructions BLD (Bit LoaD) and BST (Bit ST ore) use the T-bit as source or destination for the oper-\nated bit. A bit from a register in the Register File can be  copied into T by the BST inst ruction, and a bit in T can be\ncopied into a bit in a register in the Register File by the BLD instruction.\n• Bit 5 – H: Half Carry Flag \nThe Half Carry Flag H indicates a Half Carry in some arithmetic operations. Ha lf Carry is useful in BCD arithmetic.\nSee the “Instruction Set Descrip tion” for detaile d information.\n• Bit 4 – S: Sign Bit, S = N \uf020\uf0c5 V\nThe S-bit is always an exclusive or between the Negative  Flag N and the Two’s Comple ment Overflow Flag V. See\nthe “Instruction Set Description” for detailed information.\n• Bit 3 – V: Two’s Complement Overflow Flag\nThe Two’s Complement Overflow Flag V supports two’s co mplement arithmetics. See t he “Instruction Set Descrip-\ntion” for detailed information.\n• Bit 2 – N: Negative Flag\nThe Negative Flag N indicates a negative result in an ar ithmetic or logic operation. See the “Instruction Set\nDescription” for det ailed information.\n• Bit 1 – Z: Zero Flag\nThe Zero Flag Z indicates a zero result in an arithmetic or  logic operation. See the “Ins truction Set Description” for\ndetailed information.\n• Bit 0 – C: Carry Flag\nThe Carry Flag C indicates a carry in an arithmetic or l ogic operation. See the “Instruction Set Description” for\ndetailed information.B i t 76543210\n0x3F IT H S V N Z C S R E G\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\n10 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20134.5 General Purpose Register File\nThe Register File is optimized for the AVR Enhanced RISC instruction set. In order to achieve the required perfor-\nmance and flexibility, the followin g input/output scheme s are supported by the Register File:\n• One 8-bit output operand and one 8-bit result input\n• Two 8-bit output operands and one 8-bit result input\n• Two 8-bit output operands and one 16-bit result input\n• One 16-bit output operand and one 16-bit result input\nFigure 4-2  shows the structure of the 32 genera l purpose working registers in the CPU.\nFigure 4-2. AVR CPU General Purpose Working Registers\nMost of the instructions oper ating on the Register File have direct access to all registers, and most of them are sin-\ngle cycle instructions.\nAs shown in Figure 4-2 , each register is also assigned a Data memory  address, mapping them directly into the first\n32 locations of the user Data Space. Although not bei ng physically implemented as SRAM locations, this memory\norganization provides great flexibility in  access of the registers, as the X-, Y- and Z-pointer registers can be set to\nindex any register  in the file.\n4.5.1 The X-register, Y-register, and Z-register\nThe registers R26..R31 have some added functions to their general purpos e usage. These registers are 16-bit\naddress pointers for indirect addressing of the data space. The three indirect address registers X, Y, and Z are\ndefined as described in Figure 4-3 .7 0 Addr.\nR0 0x00\nR1 0x01R2 0x02\n…\nR13 0x0D\nGeneral R14 0x0E\nPurpose R15 0x0F\nWorking R16 0x10\nRegisters R17 0x11\n…\nR26 0x1A X-register Low ByteR27 0x1B X-register High ByteR28 0x1C Y-register Low ByteR29 0x1D Y-register High ByteR30 0x1E Z-register Low ByteR31 0x1F Z-register High Byte\n11 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 4-3. The X-, Y-, and Z-registers\nIn the different addressing modes thes e address registers have functions as fixed displacement, automatic incre-\nment, and automatic decrement (see the instruction set reference for details).\n4.6 Stack Pointer\nThe Stack is mainly used for storing temporary data, for storing local variables and for storing return addresses\nafter interrupts and subroutine calls. The Stack Pointer Register alwa ys points to the top of th e Stack. Note that the\nStack is implemented as growing from higher memory loca tions to lower memory loca tions. This implies that a\nStack PUSH command decr eases the Stack Pointer.\nThe Stack Pointer points to the data SRAM Stack area where the Subroutine and Interrupt Stacks are located. This\nStack space in the data SRAM must be defined by the pr ogram before any subroutine calls are executed or inter-\nrupts are enabled. The Stack Pointer must be set to poi nt above 0x60. The Stack Po inter is decremented by one\nwhen data is pushed onto the Stack with the PUSH instru ction, and it is decremented  by two when the return\naddress is pushed onto the Stack with s ubroutine call or interrupt. The Stack Pointer is incremented by one when\ndata is popped from the Stack with the POP instruction, an d it is incremented by two when data is popped from the\nStack with return from subroutine RE T or return from  interrupt RETI.\nThe AVR Stack Pointer is implemented as two 8-bit registers in the I/O space. The number of bits actually used is\nimplementation dependent. Note that the data space in so me implementations of the AVR architecture is so small\nthat only SPL is needed. In this case , the SPH Register will not be present.\n4.6.1 SPH and SPL — Stack Pointer Register\n4.7 Instruction Execution Timing\nThis section describes the general acce ss timing concepts for instruction exec ution. The AVR CPU is driven by the\nCPU clock clkCPU, directly generated from the selected clock source for the chip. No internal clock division is used.\nFigure 4-4  shows the parallel instruction fetches and instruct ion executions enabled by the Harvard architecture\nand the fast access Register File concept. This is the ba sic pipelining concept to obtain up to 1 MIPS per MHz with\nthe correspondin g unique results for functions per cost, functions per clocks, and functions per power-unit.15 XH XL 0\nX-register 7 0 7 0\nR27 (0x1B) R26 (0x1A)\n15 YH YL 0\nY-register 7 0 7 0\nR29 (0x1D) R28 (0x1C)\n15 ZH ZL 0\nZ-register 7 0 7 0\nR31 (0x1F) R30 (0x1E)\nB i t 1 51 41 31 21 11 0 9 80x3E SP15 SP14 SP13 SP12 SP11 SP10 SP9 SP8 SPH\n0x3D SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 SPL\n76543210\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value\nRAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND\nInitial Value RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND RAMEND\n12 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 4-4. The Parallel Instruction Fetches and Instruction Executions\nFigure 4-5  shows the internal timing concept for the Register  File. In a single clock cycle an ALU operation using\ntwo register operands is executed, and the result  is stored back to the destination register.\nFigure 4-5. Single Cycle ALU Operation\n4.8 Reset and In terrupt Handling\nThe AVR provides several different interrupt sources. Thes e interrupts and the separate Reset Vector each have a\nseparate Program Vector in the Program memory space. All interrupts are assigned individual enable bits which\nmust be written logic one together with the Global Interrupt Enable bit in the Status Register in order to enable the\ninterrupt.\nThe lowest addresses in the Program memory space ar e by default defined as the Reset and Interrupt Vectors.\nThe complete list of vectors is shown in “Interrupts” on page 48 . The list also determines the priority levels of the\ndifferent interrupts. The lower the address the hi gher is the priority level. RESET  has the highest priority, and next\nis INT0 – the External Interrupt Request 0.\nWhen an interrupt occurs, the Global Interrupt Enable I-bit is cleared and all interrupts are disabled. The user soft-\nware can write logic one to the I-bit to enable nested inte rrupts. All enabled interrupts can then interrupt the current\ninterrupt routine. The I-bit is automatically set when a Return from Interrupt instruction – RETI – is executed. \nThere are basically two types of interrupts. The first type is triggered by an event that sets the Interrupt Flag. For\nthese interrupts, the Program Counter is vectored to the ac tual Interrupt Vector in order to execute the interrupt\nhandling routine, and hardware clears the corresponding Inte rrupt Flag. Interrupt Flags can also be cleared by writ-\ning a logic one to the flag bit position(s) to be cleared.  If an interrupt condition occurs while the corresponding\ninterrupt enable bit is cleared,  the Interrupt Flag will be se t and remembered un til the interrupt is enabled, or the\nflag is cleared by software. Similarly, if one or more interrupt conditions occu r while the Global Interrupt Enable bit\nis cleared, the corresponding Interrupt Flag(s) will be set and remembered until the Glo bal Interrupt Enable bit is\nset, and will then be executed  by order of priority. clk\n1st Instruction Fetch\n1st Instruction Execute\n2nd Instruction Fetch\n2nd Instruction Execute\n3rd Instruction Fetch\n3rd Instruction Execute\n4th Instruction FetchT1 T2 T3 T4\nCPU\nTotal Execution Time\nRegister Operands Fetch\nALU Operation Execute\nResult Write BackT1 T2 T3 T4\nclkCPU\n13 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The second type of interrupts will trigger as long as the interrupt condition is present. These inte rrupts do not nec-\nessarily have Interrupt Flags. If the interrupt condition disappears before  the interrupt is ena bled, the interrupt will\nnot be triggered.\nWhen the AVR exits from an inte rrupt, it will always return to the main program and  execute one more instruction\nbefore any pending interrupt is served.\nNote that the Status Regist er is not automatically stored when enteri ng an interrupt routine, nor restored when\nreturning from an interrupt routine. This must be handled by software.\nWhen using the CLI instruction to disabl e interrupts, the in terrupts will be immediately disabled. No interrupt will be\nexecuted after the CLI instru ction, even if it occurs simultaneously wit h the CLI instruction. The following example\nshows how this can be used to avoid interrupts during the timed EEPROM write sequence.\nWhen using the SEI instruction to enabl e interrupts, the instruct ion following SEI will be ex ecuted before any pend-\ning interrupts, as shown in this example.\n4.8.1 Interrupt Response Time\nThe interrupt execution response for all the enabled AVR inte rrupts is four clock cycles minimum. After four clock\ncycles the Program Vector address for the actual interrupt handling routine is executed. During this four clock cycle\nperiod, the Program Counter is  pushed onto the Stack. The vector is norma lly a jump to the interrupt routine, and\nthis jump takes three clock cycles. If an  interrupt occurs during execution of a multi-cycle instruction,  this instruction\nis completed before the interrupt is served. If an interrup t occurs when the MCU is in sleep mode, the interrupt exe-\ncution response time is increased by four  clock cycles. This increase comes in addition to the start-up time from the\nselected sleep mode.Assembly Code Example\ninr16, SREG ; store SREG value\ncli ; disable interrupts during timed sequence\nsbiEECR, EEMPE ; start EEPROM write\nsbiEECR, EEPE\noutSREG, r16 ; restore SREG value (I-bit)\nC Code Example\nchar cSREG;\ncSREG = SREG; /* store SREG value */\n/* disable interrupts during timed sequence */\n_CLI(); EECR |= (1<<EEMPE); /* start EEPROM write */\nEECR |= (1<<EEPE);\nSREG = cSREG; /* restore SREG value (I-bit) */\nAssembly Code Example\nsei; set Global Interrupt Enable\nsleep; enter sleep, waiting for interrupt\n; note: will enter sleep before any pending \n; interrupt(s)\nC Code Example\n_SEI(); /* set Global Interrupt Enable */\n_SLEEP(); /* enter sleep, waiting for interrupt */\n/* note: will enter sleep before any pending interrupt(s) */\n14 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013A return from an interrupt handling routine takes four clock cycles. During these four clock cycles, the Program\nCounter (two bytes) is popped back from the Stack, the St ack Pointer is incremented by two, and the I-bit in SREG\nis set.\n15 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20135. AVR Memories\nThis section describes the different memories in the AT tiny25/45/85. The AVR architecture has two main memory\nspaces, the Data memo ry and the Progra m memory space. In a ddition, the ATtiny25/4 5/85 features an EEPROM\nMemory for data storage. All three memory spaces are linear and regular.\n5.1 In-System Re-programma ble Flash Program Memory \nThe ATtiny25/45/85 contains 2/4/8K bytes On-chip In-System Reprogrammable Flash memory for program stor-\nage. Since all AVR instructions are 16 or 32 bits wide, the Flash is organized as 1024/2048/4096 x 16.\nThe Flash memory has an endurance of at least 10,000 write/erase cycles. The ATtiny25/45/85 Program Counter\n(PC) is 10/11/12 bits wide, thus addressin g the 1024/2048/4096 Program memory locations. “Memory Program-\nming” on page 147  contains a detailed description on Flash data serial downloading using the SPI pins.\nConstant tables can be allocated within the entire Program memory address space (see the LPM – Load Program\nmemory instruction description).\nTiming diagrams for instruction fetc h and execution are presented in “Instruction Executio n Timing” on page 11 .\nFigure 5-1. Program Memory Map\n5.2 SRAM Data Memory\nFigure 5-2  shows how the ATtiny25/45/85 SRAM Memory is organized.\nThe lower 224/352/607 Data memory locations address both the Register File, the I/O memory and the internal\ndata SRAM. The first 32 locations addr ess the Register File, the next 64 locations the standard I/O memory, and\nthe last 128/256/512 locations address the internal data SRAM.\nThe five different addressing modes for the Data memory co ver: Direct, Indirect with Displacement, Indirect, Indi-\nrect with Pre-decrement, and Indirect wi th Post-increment. In the Register Fi le, registers R26 to R31 feature the\nindirect addressing pointer registers.\nThe direct addressing reaches the entire data space.\nThe Indirect with Displacement mode reaches 63 address lo cations from the base address given by the Y- or Z-\nregister.\nWhen using register indirect addressing modes with au tomatic pre-decrement and post-increment, the address\nregisters X, Y, and Z are decremented or incremented.\nThe 32 general purpose working register s, 64 I/O Registers, and the 128/256/512 bytes of internal data SRAM in\nthe ATtiny25/45/85 are all accessible through all these addressing modes. The Register File is described in “Gen-\neral Purpose Register File” on page 10 .0x0000\n0x03FF/0x07FF/0x0FFFProgram Memory\n16 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 5-2. Data Memory Map\n5.2.1 Data Memory Access Times\nThis section describes the general acce ss timing concepts for internal memo ry access. The internal data SRAM\naccess is performed in two clkCPU cycles as described in Figure 5-3 .\nFigure 5-3. On-chip Data SRAM Access Cycles\n5.3 EEPROM Data Memory\nThe ATtiny25/45/85 contains 128/256/512 bytes of data EE PROM memory. It is organized as a separate data\nspace, in which single bytes can be read and writt en. The EEPROM has an endurance of at least 100,000\nwrite/erase cycles. The access betw een the EEPROM and the CPU is described in the following, specifying the\nEEPROM Address Registers, the EEPROM  Data Register, and the EEPROM Control Register. For details see\n“Serial Downloading” on page 151 .\n5.3.1 EEPROM Read/Write Access\nThe EEPROM Access Registers are accessible in the I/O space.\nThe write access times for the EEPROM are given in Table 5-1 on page 21 . A self-timing function, however, lets\nthe user software detect when the next byte can be written. If the user code contains instructions that write the\nEEPROM, some precautions must  be taken. In heavily filtered power supplies, VCC is likely to rise or fall slowly on\nPower-up/down. This causes the device for some period of time to run at a voltage lower than specified as mini-mum for the clock frequency used. See “Preventing EEPROM Corruption” on page 19  for details on how to avoid\nproblems in these situations. \nIn order to prevent unintentional EE PROM writes, a specific write pr ocedure must be followed. Refer to “Atomic\nByte Programming” on page 17  and “Split Byte Programming” on page 17  for details on this. 32 Registers\n64 I/O Registers\nInternal SRAM\n(128/256/512 x 8)0x0000 - 0x001F\n0x0020 - 0x005F\n0x0DF/0x015F/0x025F0x0060Data Memory\nclk\nWR\nRDData\nDataAddress Address validT1 T2 T3\nCompute Address\nReadWriteCPU\nMemory Access Instruction Next Instruction\n17 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013When the EEPROM is read, the CPU is ha lted for four clock cycles before t he next instruction is executed. When\nthe EEPROM is written,  the CPU is halted for two clock cycles before the next  instruction is executed.\n5.3.2 Atomic Byte Programming\nUsing Atomic Byte Programming is the simplest mode. When writing a byte to the EEPROM, the user must write\nthe address into  the EEAR Register and data into  EEDR Register. If the EEPMn bi ts are zero, writing EEPE (within\nfour cycles after EEMPE is wr itten) will trigger the erase/wr ite operation. Both the eras e and write cycle are done in\none operation and the total programming time is given in Table 5-1 on page 21 . The EEPE bit remains set until the\nerase and write operations are complete d. While the device is busy with program ming, it is not possible to do any\nother EEPROM operations.\n5.3.3 Split Byte Programming\nIt is possible to split the erase and write cycle in two different operatio ns. This may be useful if the system requires\nshort access time for some limited period of time (typically if the power supply voltage falls). In order to take advan-\ntage of this method, it is required th at the locations to be written have been erased before the write operation. But\nsince the erase and write operations are split, it is poss ible to do the erase operations when the system allows\ndoing time-critical operations  (typically after Power-up).\n5.3.4 Erase\nTo erase a byte, the address must be written to EEAR. If the EEPMn bits are 0b01, writing the EEPE (within four\ncycles after EEMPE is written)  will trigger the eras e operation only (program ming time is given in Table 5-1 on\npage 21 ). The EEPE bit remains set until the erase operation co mpletes. While the device  is busy programming, it\nis not possible to do any other EEPROM operations.\n5.3.5 Write\nTo write a location, the user must write the address in to EEAR and the data into EEDR. If the EEPMn bits are\n0b10, writing the EEPE (within four cycles after EEMPE is written) will trigger the writ e operation only  (program-\nming time is given in Table 5-1 on page 21 ). The EEPE bit remains set until the write operation completes. If the\nlocation to be written has not been erased before write, the data that is stored must be considered as lost. While\nthe device is busy with programming, it is not possible to do any other EEPROM operations.\nThe calibrated Oscillator is used to ti me the EEPROM accesses. Make sure t he Oscillator frequency is within the\nrequirements described in “OSCCAL – Oscillator Calibrati on Register” on page 31 . \n18 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The following code examples show one assembly and one C function for erase, write, or atomic write of the\nEEPROM. The examples assume that interrupts are controlled (e.g., by disabling interrupts globally) so that no\ninterrupts will occur during exec ution of thes e functions.\nAssembly Code Example\nEEPROM_write:\n; Wait for completion of previous write\nsbic EECR,EEPE\nrjmp EEPROM_write \n; Set Programming modeldir16, (0<<EEPM1)|(0<<EEPM0)\noutEECR, r16\n; Set up address (r18:r17) in address registerout EEARH, r18\nout EEARL, r17\n; Write data (r19) to data registerout EEDR, r19\n; Write logical one to EEMPE\nsbi EECR,EEMPE\n; Start eeprom write by setting EEPE\nsbi EECR,EEPE\nret\nC Code Example\nvoid EEPROM_write( unsigned char  ucAddress, unsigned char  ucData)\n{\n/* Wait for completion of previous write  */\nwhile(EECR & (1<<EEPE))\n;\n/* Set Programming mode */\nEECR = (0<<EEPM1)|(0<<EEPM0);\n/* Set up address and data registers */\nEEAR = ucAddress;EEDR = ucData;\n/* Write logical one to EEMPE */\nEECR |= (1<<EEMPE);/* Start eeprom write by setting EEPE */\nEECR |= (1<<EEPE);\n}\n19 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The next code examples show assembly and C functions  for reading the EEPROM. The examples assume that\ninterrupts are controlled so th at no interrupts will occur during execution of th ese functions.\n5.3.6 Preventing EEPR OM Corruption\nDuring periods of low VCC, the EEPROM data can be corrupted because the supply voltage is too low for the CPU\nand the EEPROM to operate properly. These issues are the same as for board level systems using EEPROM, and\nthe same design solutions should be applied.\nAn EEPROM data corruption can be caused by two situatio ns when the voltage is too low. First, a regular write\nsequence to the EEPROM requires a mini mum voltage to operate co rrectly. Second ly, the CPU itself can execute\ninstructions incorrectly, if the supply voltage is too low.\nEEPROM data corruption can easily be avoi ded by following this design recommendation:\nKeep the AVR RESET active (low) dur ing periods of insufficient power supply voltage. This can be done by\nenabling the internal Brown-out Detector (BOD). If the detection level of the internal BOD does not match the\nneeded detection level, an external low VCC reset protection circuit can be used.  If a reset occurs while a write\noperation is in progress, the write operation will be comple ted provided that the power supply voltage is sufficient.\n5.4 I/O Memory\nThe I/O space definition of the ATtiny25/45/85 is shown in “Register Summary” on page 200 .Assembly Code Example\nEEPROM_read:\n; Wait for completion of previous writesbic EECR,EEPE\nrjmp EEPROM_read\n; Set up address (r18:r17) in address register\nout EEARH, r18\nout EEARL, r17\n; Start eeprom read by writing EERE\nsbi EECR,EERE\n; Read data from data registerin r16,EEDR\nret\nC Code Example\nunsigned char  EEPROM_read( unsigned char  ucAddress)\n{\n/* Wait for completion of previous write */\nwhile(EECR & (1<<EEPE))\n;\n/* Set up address register */\nEEAR = ucAddress;/* Start eeprom read by writing EERE */\nEECR |= (1<<EERE);\n/* Return data from data register */return EEDR;\n}\n20 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013All ATtiny25/45/85 I/Os and peripheral s are placed in the I/O space. All I/O locations may be accessed by the\nLD/LDS/LDD and ST/STS/STD instructio ns, transferring data between the 32 general purpose working registers\nand the I/O space. I/O Registers within the address range 0x 00 - 0x1F are directly bit-accessible using the SBI and\nCBI instructions. In these registers, the value of single bits can be checked by using the SBIS and SBIC instruc-tions. Refer to the instruction set section for more deta ils. When using the I/O specif ic commands IN and OUT, the\nI/O addresses 0x00 - 0x3F must be used. When addressing  I/O Registers as data space using LD and ST instruc-\ntions, 0x20 must be adde d to these addresses. \nFor compatibility with future devices, reserved bits sh ould be written to zero if accessed. Reserved I/O memory\naddresses should never be written.\nSome of the Status Flags are cleared by writing a logica l one to them. Note that the CBI and SBI instructions will\nonly operate on the specified bit, and can therefore be used on register s containing such Stat us Flags. The CBI\nand SBI instructions work with registers 0x00 to 0x1F only.\nThe I/O and Peripherals Control Registers are explained in later sections.\n5.5 Register Description\n5.5.1 EEARH – EEPROM Address Register\n• Bits 7:1 – Res: Reserved Bits\nThese bits are reserved for future use and will always read as zero.\n• Bits 0 – EEAR8: EEPROM Address\nThis is the most significant EEPROM address bit of ATtiny85. In devices with less EEPROM, i.e.\nATtiny25/ATtiny45, this  bit is reserved and will alwa ys read zero. The initial value of t he EEPROM Address Regis-\nter (EEAR) is undefined and a proper value must ther efore be written before the EEPROM is accessed.\n5.5.2 EEARL – EEPROM  Address Register\n• Bit 7 – EEAR7: EEPROM Address\nThis is the most significan t EEPROM address bit of ATtiny 45. In devices with  less EEPROM, i.e. ATtiny25, this bit\nis reserved and will always re ad zero. The initial value of  the EEPROM Address Regist er (EEAR) is undefined and\na proper value must th erefore be written before  the EEPROM is accessed.\n• Bits 6:0 – EEAR[6:0]: EEPROM Address\nThese are the (low) bits of  the EEPROM Address Register . The EEPROM data bytes ar e addressed lin early in the\nrange 0...(128/256/512-1). The initial value of EEAR is u ndefined and a proper value must be therefore be written\nbefore the EEPROM may be accessed.B i t 76543210\n0x1F  –   –   – – –   – – E E A R 8 EEARH\nR e a d / W r i t e RRRRRRR R / WI n i t i a l  V a l u e0000000 X / 0\nBit\n0x1E EEAR7 EEAR6 EEAR5 EEAR4 EEAR3 EEAR2 EEAR1 EEAR0 EEARL\nRear/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e XXXXXXXX\n21 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20135.5.3 EEDR – EEPROM Data Register\n• Bits 7:0 – EEDR[7:0]: EEPROM Data\nFor the EEPROM write operation the EEDR Register contains the data to be written to the EEPROM in the address\ngiven by the EEAR Register. For the EEPROM read opera tion, the EEDR contains the data read out from the\nEEPROM at the address given by EEAR.\n5.5.4 EECR – EEPROM Control Register\n• Bit 7 – Res: Reserved Bit\nThis bit is reserved for future use and will always read as  0 in ATtiny25/45/85. For compatibility with future AVR\ndevices, always write this bit to ze ro. After reading, mask out this bit.\n• Bit 6 – Res: Reserved Bit\nThis bit is reserved in the ATtiny25 /45/85 and will always read as zero.\n• Bits 5:4 – EEPM[1:0]: EEPROM Programming Mode Bits\nThe EEPROM Programming mode bits setting defines whic h programming action that will be triggered when writ-\ning EEPE. It is possible to program data in one atomic operation (e rase the old value and program the new value)\nor to split the Erase and Write operations in two different operations. The Programming times for the differentmodes are shown in Table 5-1 . While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn\nbits will be reset to 0b00 unless  the EEPROM is busy programming.\n• Bit 3 – EERIE: EEPROM Ready Interrupt Enable\nWriting EERIE to one enables the EEPROM Ready Interrupt if the I-bit in SREG is set. Writing EERIE to zero dis-\nables the interrupt. The EEPROM Ready Interrupt generates  a constant interrupt when  Non-volatile memory is\nready for programming.\n• Bit 2 – EEMPE: EEPROM Master Program Enable\nThe EEMPE bit determines whether writing EEPE to one will have effect or not.\nWhen EEMPE is set, setting EEPE within four clock cycles wi ll program the EEPROM at the selected address. If\nEEMPE is zero, setting EEPE will have no effect. When EEMPE has been wr itten to one by software, hardware\nclears the bit to zero after four clock cycles.B i t 76543210\n0x1D EEDR7 EEDR6 EEDR5 EEDR4 EEDR3 EEDR2 EEDR1 EEDR0 EEDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\nB i t 765432100x1C – – EEPM1 EEPM0 EERIE EEMPE EEPE EERE EECR\nRead/Write R R R/W R/W R/W R/W R/W R/WInitial Value 0 0 X X 0 0 X 0\nTable 5-1. EEPROM Mode Bits\nEEPM1 EEPM0Programming \nTime Operation\n0 0 3.4 ms Erase and Write in one operation (Atomic Operation)\n0 1 1.8 ms Erase Only1 0 1.8 ms Write Only\n1 1 – Reserved for future use\n22 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 1 – EEPE: EEPROM Program Enable\nThe EEPROM Program Enable  Signal EEPE is the prog ramming enable si gnal to the EEPROM. When EEPE is\nwritten, the EEPROM will be programm ed according to the EEPMn bits settin g. The EEMPE bit must be written to\none before a logical one is written to EEPE, otherwise no  EEPROM write takes place.  When the write access time\nhas elapsed, the EEPE bit is  cleared by hardware. When EEPE has be en set, the CPU is halted for two cycles\nbefore the next instruction is executed.\n• Bit 0 – EERE: EEPROM Read Enable\nThe EEPROM Read Enable Signal – EERE – is the read strobe to th e EEPROM. When the corr ect address is set\nup in the EEAR Register, the EERE bit must be written to one to trigger the EEPROM read. The EEPROM read\naccess takes one instruction, and the requested data is available immediately. When the EEPROM is read, the\nCPU is halted for four cycles before the next instruction is executed. The user should poll the EEPE bit before start-\ning the read operation. If a writ e operation is in progress, it is neither possible to read th e EEPROM, nor to change\nthe EEAR Register.\n23 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20136. System Clock and Clock Options\n6.1 Clock Systems and their Distribution\nFigure 6-1  presents the principal clock systems in the AVR and their distribution. All of the clocks need not be\nactive at a given time. In order to reduce power consumpt ion, the clocks to modules not being used can be halted\nby using different sleep modes, as described in “Power Management and Sleep Modes” on page 34 . The clock\nsystems are detailed below.\nFigure 6-1. Clock Distribution\n6.1.1 CPU Clock – clkCPU\nThe CPU clock is routed to parts of the system concerned  with operation of the AVR core. Examples of such mod-\nules are the General Purpose Register File, the Status Register and the Data memory holding the Stack Pointer.\nHalting the CPU clock inhibits the core from performing general operations and calculations.\n6.1.2 I/O Clock – clkI/O\nThe I/O clock is used by the majority of the I/O modules, like Timer/Counter. The I/O clock is also used by the\nExternal Interrupt module, but note that some external  interrupts are detected by asynchronous logic, allowing\nsuch interrupts to be  detected even if the I/O clock is halted.\n6.1.3 Flash Clock – clkFLASH\nThe Flash clock controls operation of th e Flash interface. The Flas h clock is usually active  simultaneously with the\nCPU clock.General I/O\nModulesCPU Core RAM\nclkI/O AVR Clock\nControl UnitclkCPUFlash and\nEEPROM\nclkFLASH\nSource clockWatchdog Timer\nWatchdog\nOscillatorReset Logic\nClock\nMultiplexerWatchdog clock\nCalibrated RC\nOscillatorCalibrated RC\nOscillatorExternal ClockADC\nclkADC\nCrystal\nOscillatorLow-Frequency\nCrystal OscillatorSystem Clock\nPrescaler\nPLL\nOscillator\nclkPCKclkPCK\n24 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20136.1.4 ADC Clock – clkADC\nThe ADC is provided with a dedicated clock domain. This a llows halting the CPU and I/O clocks in order to reduce\nnoise generated by digital circuitry. This gives more accurate ADC conversion results.\n6.1.5 Internal PLL for Fast Peripheral Clock Generation - clkPCK\nThe internal PLL in ATtiny25/45/85 generates a clock frequency that is 8x multiplied from a source input. By\ndefault, the PLL uses the output of th e internal, 8.0 MHz RC oscillator as source. Alternatively, if bit LSM of\nPLLCSR is set the PLL will use the outpu t of the RC oscillator divided by two. Thus the output of  the PLL, the fast\nperipheral clock is 64 MHz. The fast peripheral clock, or  a clock prescaled from that, can be selected as the clock\nsource for Timer/Counter1 or as a system clock. See Figure 6-2 . The frequency of the fast peripheral clock is\ndivided by two when LSM of PLLCSR is  set, resulting in a clock frequency of 32 MHz. Note, that LSM can not be\nset if PLLCLK is used as system clock.\nFigure 6-2. PCK Clocking System.\nThe PLL is locked on the RC oscillator and adjusting the RC oscillator via OSCCAL register will  adjust the fast\nperipheral clock at the same time. However, even if the RC oscillator is taken to a higher frequency than 8 MHz,\nthe fast peripheral clock frequency saturates at 85 MHz (w orst case) and remains oscillating at the maximum fre-\nquency. It should be noted  that the PLL in this case is not locked an y longer with the RC osc illator clock. Therefore,\nit is recommended not to take the OSCCAL adjustments to a higher frequency than 8 MHz in order to keep the PLL\nin the correct operating range.\nThe internal PLL is enabled when:\n• The PLLE bit in the register PLLCSR is set.\n• The CKSEL fuse is programmed to ‘0001’. \n• The CKSEL fuse is programmed to ‘0011’. \nThe PLLCSR bit PLOCK is set when PLL is locked.\nBoth internal RC osc illator and PLL are switched off in pow er down and stand-by sleep modes.\n6.1.6 Internal PLL in ATtiny15 Compatibility Mode\nSince ATtiny25/45/85 is a migr ation device for ATtiny15 users there is an ATtiny15 compatibility mode for back-\nward compatibility. The ATti ny15 compatibility mode is  selected by progr amming the CKSEL fuses to ‘0011’.\nIn the ATtiny15 compatibility mode the frequency of the inte rnal RC oscillator is calibra ted down to 6.4 MHz and the\nmultiplication factor of t he PLL is set to 4x. See Figure 6-3 . With these adjustments the clocking system is\nATtiny15-compatible and the resulting fast peripheral cl ock has a frequency of 25.6 MHz (same as in ATtiny15).1/2\n8 MHzLSM\n8.0 MHz\nOSCILLATOR PLL\n8xCKSEL[3:0] PLLE OSCCAL\n4 MHz\n1/4LOCK\nDETECTOR\nPRESCALERCLKPS[3:0]\nSYSTEM\nCLOCKPLOCK\nPCK\nOSCILLATORSXTAL1\nXTAL264 / 32 MHz\n8 MHz16 MHz\n25 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 6-3. PCK Clocking System in AT tiny15 Compatibility Mode.\nNote that low speed mode is not impl emented in ATtiny15 compatibility mode.\n6.2 Clock Sources\nThe device has the following clock sour ce options, selectable by Flash Fuse bits as shown below. The clock from\nthe selected source is input to the AVR clock generator, and routed to the appropriate modules.\nNote: 1. For all fuses “1” means unprogrammed while “0” means programmed.\n2. The device is shipped with this option selected.\n3. This will select ATtiny15 Compatibility Mode, where system clock is divided by four, resulting in a 1.6 MHz clock fre-\nquency. For more inormation, see “Calibrated Internal Oscillator” on page 27 .\nThe various choices for each clocking  option is given in the followin g sections. When the CPU wakes up from\nPower-down, the selected clock source is used to time the start-up, ensuring stable Oscillator operation beforeinstruction execution starts. When the CPU starts from re set, there is an additional delay allowing the power to\nreach a stable level before commencing  normal operation. The Wa tchdog Oscillator is used for timing this real-time\npart of the start-up time . The number of WDT Oscillator cycles used for each time-o ut is shown in Table 6-2 .1/2\n1.6 MHz6.4 MHz\nOSCILLATORPLL\n8xPLLE OSCCAL\n3.2 MHz\nLOCK\nDETECTOR\nSYSTEM\nCLOCKPLOCKPCK 25.6 MHz\n1/4\nTable 6-1. Device Clocking Options Select\nDevice Clocking Option  CKSEL[3:0](1)\nExternal Clock (see page 26 ) 0000\nHigh Frequency PLL Clock (see page 26 ) 0001\nCalibrated Internal Oscillator (see page 27 ) 0010(2)\nCalibrated Internal Oscillator (see page 27 ) 0011(3)\nInternal 128 kHz Oscillator (see page 28 ) 0100\nLow-Frequency Crystal Oscillator (see page 29 )0 1 1 0\nCrystal Oscillator / Ceramic Resonator (see page 29 ) 1000 – 1111\nReserved 0101, 0111\nTable 6-2. Number of Watchdog Oscillator Cycles\nTyp Time-out Number of Cycles\n4 ms 512\n64 ms 8K (8,192)\n26 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20136.2.1 External Clock\nTo drive the device from an external clock source, CLKI should be driven as shown in Figure 6-4 . To run the device\non an external clock, the CKSEL Fu ses must be programmed to “00”.\nFigure 6-4. External Clock Drive Configuration\nWhen this clock source is selected, start-up times are determined by the SUT Fuses as shown in Table 6-3 .\nWhen applying an external clock, it is required to avoid sudden changes in  the applied clock frequency to ensure\nstable operation of the MCU. A variation in frequency of more than 2% from one clock cycle to the next can lead to\nunpredictable behavior. It is required to ensure that the MCU is kept in Reset during such changes in the clock\nfrequency.\nNote that the System Clock Prescaler can be used to im plement run-time changes of the internal clock frequency\nwhile still ensuring stabl e operation. Refer to “System Clock Prescaler” on page 31  for details.\n6.2.2 High Frequency PLL Clock\nThere is an internal PLL that provides nominally 64 MHz clock rate locked to the RC Oscillator for the use of the\nPeripheral Timer/Counter1 and for the system clock sour ce. When selected as a system clock source, by program-\nming the CKSEL fuses to ‘0001’, it is divided by four like shown in Table 6-4 . \nWhen this clock source is selected, start-up times are determ ined by the SUT fuses as shown in Table 6-5 .Table 6-3. Start-up Times for the External Clock Selection\nSUT[1:0]Start-up Time from\nPower-downAdditional Delay from \nReset Recommended Usage\n00 6 CK 14CK BOD enabled\n01 6 CK 14CK + 4 ms Fast rising power\n10 6 CK 14CK + 64 ms Slowly rising power\n11 ReservedEXTERNAL\nCLOCK\nSIGNALCLKI\nGND\nTable 6-4. High Frequency PLL Clock Operating Modes\n CKSEL[3:0] Nominal Frequency\n0001 16 MHz\nTable 6-5. Start-up Times for the High Frequency PLL Clock\nSUT[1:0]Start-up Time from\nPower DownAdditional Delay from\nPower-On Reset (VCC = 5.0V)Recommended \nusage\n00 14CK + 1K (1024) CK + 4 ms 4 ms BOD enabled\n27 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20136.2.3 Calibrated In ternal Oscillator\nBy default, the Internal RC Oscillator provides an a pproximate 8.0 MHz clock. Though voltage and temperature\ndependent, this clock can be very accurately calibrated by the user. See “Calibrated Internal RC Oscillator Accu-\nracy” on page 164  and “Internal Oscillator Speed” on page 192  for more details. The device is shipped with the\nCKDIV8 Fuse programmed. See “System Clock Prescaler” on page 31  for more details.\nThis clock may be selected as  the system clock by programming  the CKSEL Fuses as shown in Table 6-6 on page\n27. If selected, it will operate with no external components. During reset, hardware loads the pre-programmed cali-\nbration value into the OSCCAL Register and thereby automati cally  calibrates the RC Oscillator. The accuracy of\nthis calibration is shown as Factory calibration in Table 21-2 on page 164 .\nBy changing the OSCCAL register from SW, see “OSCCAL – Oscillator Calibra tion Register” on page 31 , it is pos-\nsible to get a higher calibration accuracy than by using th e factory calibration. The accu racy of this calibration is\nshown as User calibration in Table 21-2 on page 164 .\nWhen this Oscillator is used as the chip clock, the Watchdog Oscillator will still be used for the Watchdog Timer\nand for the Reset Time-out. For more information on the pre-programmed calibration value, see the section “Cali-\nbration Bytes” on page 150 .\nThe internal oscillator can also be set to provide a 6.4 MHz clock by writing CKSEL fuses to “0011”, as shown in\nTable 6-6  below. This setting is reffered to as ATtiny15 Comp atibility Mode and is inten ded to provide a calibrated\nclock source at 6.4 MHz, as in ATtiny15. In ATtiny15 Com patibility Mode the PLL uses the internal oscillator run-\nning at 6.4 MHz to generate a 25.6 MHz peri pheral clock signal for Timer/Counter1 (see “8-bit Timer/Counter1 in\nATtiny15 Mode” on page 95 ). Note that in this mode of operation the 6.4 MHz clock signal is always divided by\nfour, providing a 1.6 MHz system clock.\nNote: 1. The device is shipped with this option selected.\n2. This setting will select ATtiny15 Compatibility Mode, wher e system clock is divided by four, resulting in a 1.6 MHz \nclock frequency.01 14CK + 16K (16384) CK + 4 ms 4 ms Fast rising power\n10 14CK + 1K (1024) CK + 64 ms 4 ms Slowly rising power\n11 14CK + 16K (16384) CK + 64 ms 4 ms Slowly rising powerTable 6-5. Start-up Times for the High Frequency PLL Clock\nSUT[1:0]Start-up Time from\nPower DownAdditional Delay from\nPower-On Reset (VCC = 5.0V)Recommended \nusage\nTable 6-6. Internal Calibrated RC O scillator Operating Modes\n CKSEL[3:0] Nominal Frequency\n0010(1)8.0 MHz\n0011(2)6.4 MHz\n28 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013When the calibrated 8 MHz internal osc illator is selected as clock source t he start-up times ar e determined by the\nSUT Fuses as shown in Table 6-7  below.\nNote: 1. If the RSTDISBL fuse is programmed, this start-up ti me will be increased to 14CK + 4 ms to ensure programming \nmode can be entered.\n2. The device is shipped with this option selected.\nIn ATtiny15 Compatibility Mode start-up times are determined by SUT fuses as shown in Table 6-8  below.\nNote: 1. If the RSTDISBL fuse is programmed, this start-up ti me will be increased to 14CK + 4 ms to ensure programming \nmode can be entered.\nIn summary, more informatio n on ATtiny15 Compatibility Mo de can be found in sections “Port B (PB5:PB0)” on\npage 2 , “Internal PLL in ATtiny15 Compatibility Mode” on page 24 , “8-bit Timer/Counter1 in ATtiny15 Mode” on\npage 95 , “Limitations of debugWIRE” on page 140 , “Calibration Bytes” on page 150  and in table “Clock Prescaler\nSelect” on page 33 .\n6.2.4 Internal 128 kHz Oscillator\nThe 128 kHz internal Oscillato r is a low power Oscillator providing a cloc k of 128 kHz. The fr equency is nominal at\n3V and 25 \uf0b0C. This clock may be select as the system clock by programming the CKSEL Fuses to “0100”.\nWhen this clock source is selected, start-up times are determined by the SUT Fuses as shown in Table 6-9 .Table 6-7. Start-up Times for Internal Calibrated RC Oscillator Clock\nSUT[1:0]Start-up Time \nfrom Power-downAdditional Delay from \nReset (VCC = 5.0V) Recommended Usage\n00 6 CK 14CK(1)BOD enabled\n01 6 CK 14CK + 4 ms Fast rising power\n10(2)6 CK 14CK + 64 ms Slowly rising power\n11 Reserved\nTable 6-8. Start-up Times for In ternal Calibrated RC Oscillato r Clock (in ATtiny15 Mode)\nSUT[1:0]Start-up Time \nfrom Power-downAdditional Delay from \nReset (VCC = 5.0V) Recommended Usage\n00 6 CK 14CK + 64 ms\n01 6 CK 14CK + 64 ms\n10 6 CK 14CK + 4 ms\n11 1 CK 14CK(1)\nTable 6-9. Start-up Times for the 128 kHz Internal Oscillator\nSUT[1:0]Start-up Time from\nPower-downAdditional Delay from \nReset Recommended Usage\n00 6 CK 14CK(1)BOD enabled\n01 6 CK 14CK + 4 ms Fast rising power\n10 6 CK 14CK + 64 ms Slowly rising power\n11 Reserved\n29 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Note: 1. If the RSTDISBL fuse is programmed, this start-up ti me will be increased to 14CK + 4 ms to ensure programming \nmode can be entered.\n6.2.5 Low-Frequency Crystal Oscillator\nTo use a 32.768 kHz watch crystal as the clock source fo r the device, the Lo w-frequency Crystal Oscillator must be\nselected by setting CKSEL fuses to ‘0110’. T he crystal should be connected as shown in Figure 6-5 . To find suit-\nable load capacitance for a 32.768 kHz crysal,  please consult the manufacturer’s datasheet.\nWhen this oscillator is selected, start-up time s are determined by the SUT fuses as shown in Table 6-10 .\nNote: 1. These options should be used only if fr equency stability at start-up is not important.\nThe Low-frequency Crystal O scillator provides an  internal load capacitance, see Table 6-11  at each TOSC pin.\n6.2.6 Crystal Oscillator / Ceramic Resonator\nXTAL1 and XTAL2 are input and output, respectively, of an  inverting amplifier which c an be configured for use as\nan On-chip Oscillator, as shown in Figure 6-5 . Either a quartz crystal or a ceramic resonator may be used.\nFigure 6-5. Crystal Oscillator Connections\nC1 and C2 should always be equal fo r both crystals and resonators. The optimal value of the capacitors depends\non the crystal or resonator in use, the amount of stra y capacitance, and the electrom agnetic noise of the environ-Table 6-10. Start-up Times for the Lo w Frequency Crystal Osc illator Clock Selection\nSUT[1:0]Start-up Time from \nPower DownAdditional Delay from \nReset (VCC = 5.0V) Recommended usage\n00 1K (1024) CK(1)4 ms Fast rising power or BOD enabled\n01 1K (1024) CK(1)64 ms Slowly rising power\n10 32K (32768) CK 64 ms Stable frequency at start-up\n11 Reserved\nTable 6-11. Capacitance of Low-Frequ ency Crystal Oscillator\nDevice 32 kHz Osc. Type Cap (Xtal1/Tosc1) Cap (Xtal2/Tosc2)\nATtiny25/45/85 System Osc. 16 pF 6 pF\nXTAL2\nXTAL1\nGNDC2\nC1\n30 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013ment. Some initial guidelines for choosing ca pacitors for use with crystals are given in Table 6-12  below. For\nceramic resonators, the capaci tor values given by the manufacturer should be used.\nNotes: 1. This option should not be used wit h crystals, only with ceramic resonators.\nThe Oscillator can operate in three diff erent modes, each optimized for a s pecific frequenc y range. T he operating\nmode is selected by the fu ses CKSEL[3:1] as shown in Table 6-12 .\nThe CKSEL0 Fuse together  with the SUT[1:0] Fuses select the start-up time s as shown in Table 6-13 .\nNotes: 1. These options should only be used when not operating close to the maximum frequency of the device, and only if \nfrequency stability at start-up is not important for the applicat ion. These options are not suitable for crystals.\n2. These options are intended for use wit h ceramic resonators and will ensure frequency stability at start-up. They can \nalso be used with crystals when not operating close to the maximum frequency of the device, and if frequency sta-\nbility at start-up is not important for the application.\n6.2.7 Default Clock Source\nThe device is shipped with CKSEL = “0 010”, SUT = “10”, and CK DIV8 programmed.  The default cl ock source set-\nting is therefore the Internal RC Oscillator running at 8 MHz with longest start-up time and an initial system clock\nprescaling of 8, resulting in 1.0 MHz system clock. This  default setting ensures that all users can make their\ndesired clock source setting using an In-System or High-voltage Programmer.Table 6-12. Crystal Oscillator Operating Modes\nCKSEL[3:1]  Freque ncy Range (MHz)Recommended Range for Capacitors C1 and \nC2 for Use with Crystals (pF)\n100(1)0.4 - 0.9 –\n101 0.9 - 3.0 12 - 22\n110 3.0 - 8.0 12 - 22\n111 8.0 - 12 - 22\nTable 6-13. Start-up Times for the Crystal  Oscillator Clock Selection\nCKSEL0 SUT[1:0]Start-up Time from \nPower-downAdditional Delay \nfrom Reset Recommended Usage\n0 00 258 CK(1)14CK + 4 msCeramic resonator,\nfast rising power\n0 01 258 CK(1)14CK + 64 msCeramic resonator,\nslowly rising power\n0 10 1K (1024) CK(2)14CKCeramic resonator,\nBOD enabled\n0 11 1K (1024)CK(2)14CK + 4 msCeramic resonator,\nfast rising power\n1 00 1K (1024)CK(2)14CK + 64 msCeramic resonator,\nslowly rising power\n1 01 16K (16384) CK 14CKCrystal Oscillator,\nBOD enabled\n1 10 16K (16384) CK 14CK + 4 msCrystal Oscillator,\nfast rising power\n1 11 16K (16384) CK 14CK + 64 msCrystal Oscillator,\nslowly rising power\n31 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20136.3 System Clock Prescaler\nThe ATtiny25/45/85 system clock can be divided by setting the “CLKPR – Clock Prescale Register” on page 32 .\nThis feature can be used to decrease power consumption when the requirement for processing power is low. This\ncan be used with all clock source options, and it will a ffect the clock frequency of  the CPU and all synchronous\nperipherals. clkI/O, clkADC, clkCPU, and clkFLASH  are divided by a factor as shown in Table 6-15 on page 33 .\n6.3.1 Switching Time\nWhen switching between prescaler settings, the System Clock  Prescaler ensures that no glitches occur in the clock\nsystem and that no intermediate frequency is higher than  neither the clock frequency corresponding to the previous\nsetting, nor the clock frequency corresponding to the new setting.\nThe ripple counter that implements the prescaler runs at  the frequency of the undivided clock, which may be faster\nthan the CPU’s clock frequency. Hence, it is not possible to determine the state of the prescaler – even if it were\nreadable, and the exact time it takes to switch from on e clock division to another cannot be exactly predicted.\nFrom the time the CLKPS values are written, it takes between T1 + T2 and T1 + 2*T2 before the new clock fre-\nquency is active. In this interval, 2 active clock edges are produced. Here, T1 is the previous clock period, and T2\nis the period corresponding to the new prescaler setting.\n6.4 Clock Output Buffer\nThe device can output the system clock on the CLKO pi n (when not used as XTAL2 pin). To enable the output, the\nCKOUT Fuse has to be programmed. This mode is suitable when the chip clock is used to drive other circuits on\nthe system. Note that the clock will not be output during reset and that the normal operation of the I/O pin will beoverridden when the fuse is programmed. Internal RC Osci llator, WDT Oscillator, PLL, and external clock (CLKI)\ncan be selected when the clock is output  on CLKO. Crystal oscillators (XTAL1 , XTAL2) can not be used for clock\noutput on CLKO. If the System Clock  Prescaler is used, it is the di vided system clock that is output.\n6.5 Register Description\n6.5.1 OSCCAL – Oscillato r Calibration Register\n• Bits 7:0 – CAL[7:0]: Oscillator Calibration Value\nThe Oscillator Calibration Register is used to trim the Calibrated Internal RC Oscillator to remove process varia-\ntions from the oscillator frequency. A pre-programmed cali bration value is automatically written to this register\nduring chip reset, giving the Factory calibrated frequency as specified in Table 21-2 on page 164 . The application\nsoftware can write this register to change the oscillato r frequency. The oscillator can be calibrated to frequencies\nas specified in Table 21-2 on page 164 . Calibration outside that range is not guaranteed.\nNote that this oscillator is used to  time EEPROM and Flash write accesses,  and these write times will be affected\naccordingly. If the EEPROM or Flash are written, do not calibrate to more than 8.8 MHz. Otherwise, the EEPROM\nor Flash write may fail.\nThe CAL7 bit determines the range of op eration for the oscillator. Setting this  bit to 0 gives the lowest frequency\nrange, setting this bit to 1 gives the highest frequency range. The two frequency ranges are overlapping, in other\nwords a setting of OSCCAL = 0x7F gives a higher frequency than OSCCAL = 0x80.\nThe CAL[6:0] bits are used to tune the frequency within t he selected range. A setting of 0x00 gives the lowest fre-\nquency in that range, and a setting of 0x7F  gives the highest frequency in the range.B i t 76543210\n0x31 CAL7 CAL6 CAL5 CAL4 CAL3 CAL2 CAL1 CAL0 OSCCALRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value Device Specific Calibration Value\n32 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013To ensure stable operation of the MCU the calibration value should be changed in small. A variation in frequency of\nmore than 2% from one cycle to the next can lead to unpredicatble behavior. C hanges in OSCCAL should not\nexceed 0x20 for each calibration. It is required to ensure that the MCU is kept in Reset during such changes in the\nclock frequency\n6.5.2 CLKPR – Clock Prescale Register\n• Bit 7 – CLKPCE: Clock Prescaler Change Enable\nThe CLKPCE bit must be writ ten to logic one to enable change of the CLKPS bits . The CLKPCE bit is only updated\nwhen the other bits in CLKPR are simu ltaniosly written to zero. CLKPCE is cl eared by hardware four cycles after it\nis written or when the CLKPS bits are written. Rewriting the CLKPCE bit with in this time-out period does neither\nextend the time-out period, nor clear the CLKPCE bit.\n• Bits 6:4 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bits 3:0 – CLKPS[3:0]: Clock Prescaler Select Bits 3 - 0\nThese bits define the division factor between the selected clock source and the internal system clock. These bits\ncan be written run-time to vary the clock frequency to suit  the application requirements. As the divider divides the\nmaster clock input to the MCU, the speed of all synchro nous peripherals is reduced when a division factor is used.\nThe division factors are given in Table 6-15 .\nTo avoid unintentional changes of clock frequency, a special write proced ure must be followed to change the\nCLKPS bits:\n1. Write the Clock Prescaler Change Enable (CLKPCE) bi t to one and all other bits in CLKPR to zero.\n2. Within four cycles, write the desired value to CLKPS while  writing a zero  to CLKPCE. \nInterrupts must be disabled when changing prescaler setting to make sure the write procedure is not interrupted.\nThe CKDIV8 Fuse determines  the initial value of  the CLKPS bits. If CKDIV8 is unprogrammed, t he CLKPS bits will\nbe reset to “0000”. If CKDIV8 is programmed, CLKPS bits are reset to “0011”, giving a division factor of eight at\nstart up. This feature should be used if the selected cl ock source has a higher frequency than the maximum fre-\nquency of the device at the present operating conditions. Note  that any value can be written to the CLKPS bits\nregardless of the CKDIV8 Fuse setting. The Application soft ware must ensure that a sufficient division factor isTable 6-14. Internal RC Oscilla tor Frequency Range\nOSCCAL ValueTypical Lowest Frequency\nwith Respect to Nominal FrequencyTypical Highest Frequency\nwith Respect to Nominal Frequency\n0x00 50% 100%\n0x3F 75% 150%\n0x7F 100% 200%\nB i t 76543210\n0x26 CLKPCE – – – CLKPS3 CLKPS2 CLKPS1 CLKPS0 CLKPR\nRead/Write R/W R R R R/W R/W R/W R/WInitial Value 0 0 0 0 See Bit Description\n33 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013chosen if the selcted clock source has a higher frequency than the maximum frequency of  the device at the present\noperating conditions. The device is shipped with the CKDIV8 Fuse programmed.\nNote: The prescaler is disabled in ATtiny15 compatibility m ode and neither writing to CLKPR, nor programming the CKDIV8 \nfuse has any effect on the system clock (which will always be 1.6 MHz).Table 6-15. Clock Prescaler Select\nCLKPS3 CLKPS2 CLKPS1 CLKPS0 Clock Division Factor\n0000 1\n0001 2\n0010 4\n0011 8\n0100 1 60101 3 2\n0110 6 4\n0111 1 2 81000 2 5 6\n1001 R e s e r v e d\n1010 R e s e r v e d1011 R e s e r v e d\n1100 R e s e r v e d\n1101 R e s e r v e d1110 R e s e r v e d\n1111 R e s e r v e d\n34 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20137. Power Management and Sleep Modes\nThe high performance and industry leadi ng code efficiency makes the AVR microcontrollers an ideal choise for low\npower applications. In addition, sleep modes enable the application to shut down unused modules in the MCU,\nthereby saving power. The AVR provides various sleep modes  allowing the user to tailor the power consumption to\nthe application’s requirements.\n7.1 Sleep Modes\nFigure 6-1 on page 23  presents the different clock systems and their distribution in ATtiny25/45/85. The figure is\nhelpful in selecting an appropriate sleep mode. Table 7-1  shows the different sleep modes and their wake up\nsources.\nNote: 1. For INT0, only level interrupt.\nTo enter any of the three sleep modes, the SE bit in MC UCR must be writte n to logic one and a SLEEP instruction\nmust be executed. The SM[1:0] bits in the MCUCR Register select which sleep mode (Idle, ADC Noise Reduction\nor Power-down) will be activated by the SLEEP inst ruction. See Table 7-2  for a summary.\nIf an enabled interrupt occurs while the MCU is in a sl eep mode, the MCU wakes up. The MCU is then halted for\nfour cycles in addition to the start- up time, executes the interrupt routine,  and resumes execution from the instruc-\ntion following SLEEP. The contents of the Register File  and SRAM are unaltered when the device wakes up from\nsleep. If a reset occurs during sleep mode, the M CU wakes up and executes from the Reset Vector.\nNote that if a level triggere d interrupt is used for wake-up the changed level must be held for some time to wake up\nthe MCU (and for the MCU to enter the interrupt service routine). See “External Interrupts” on page 49  for details.\n7.1.1 Idle Mode\nWhen the SM[1:0] bits are written to 00, the SLEEP instruction makes the MCU enter Idle mode, stopping the CPU\nbut allowing Analog Comparator, ADC, USI, Timer/Counter, Watchdog, and the interrupt system to continue oper-\nating. This sleep mode basically halts clkCPU and clkFLASH , while allowing the other clocks to run.\nIdle mode enables the MCU to wake up  from external triggered interrupts as well as internal ones like the Timer\nOverflow. If wake-up from the Analog Comparator interr upt is not required, the Analog Comparator can be powered\ndown by setting the ACD bit in “ACSR – Analog Comparator Control and Status Register” on page 120 . This will\nreduce power consumption in Idle mode. If the ADC is enab led, a conversion starts automatically when this mode\nis entered. Table 7-1. Active Clock Domains and Wake-up Sour ces in the Different Sleep Modes\nActive Clock Domains Oscillators Wake-up Sources\nSleep Mode\nclkCPU\nclkFLASH\nclkIO\nclkADC\nclkPCK\nMain Clock \nSource Enabled\nINT0 and \nPin Change\nSPM/EEPROM\nReady\nUSI Start Condition\nADCOther I/O\nWatchdog \nInterrupt\nI d l e X X X X XXXXXX\nADC Noise\nReductionXX X(1)XXX X\nPower-down X(1)XX\n35 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20137.1.2 ADC Noise Reduction Mode\nWhen the SM[1:0] bits are written to  01, the SLEEP instruction makes the MCU enter ADC Nois e Reduction mode,\nstopping the CPU but allowing the ADC, the external interrupts, and the Watchdog to continue operating (if\nenabled). This sleep mode halts clkI/O, clkCPU, and clkFLASH , while allowing the other clocks to run.\nThis improves the noise environment for the ADC, enabling higher resolution measurements. If the ADC is\nenabled, a conversion starts automatical ly when this mode is entered. Apart form the ADC Conversion Complete\ninterrupt, only an External Reset, a Watchdog Reset, a Brown-out Reset, an SPM/EEPROM ready interrupt, an\nexternal level interrupt on INT0 or a pin change interr upt can wake up the MCU from ADC Noise Reduction mode.\n7.1.3 Power-down Mode\nWhen the SM[1:0] bits are written to 10, the SLEEP instruction makes the MCU enter Power-down mode. In this\nmode, the Oscillator is stopped, while the external interr upts, the USI start condition detection and the Watchdog\ncontinue operating (if enabled). Only an External Reset, a Watchdog Reset, a Brown-out Reset, USI start condition\ninterupt, an external level interrupt on INT0 or a pin c hange interrupt can wake up the MCU. This sleep mode halts\nall generated clocks, allowing operation of asynchronous modules only.\n7.2 Software BOD Disable\nWhen the Brown-out Detector (BOD) is enabled by BODLEVEL fuses (see Table 20-4 on page 148 ), the BOD is\nactively monitoring the supply voltage during a sleep period. In some devices it is possible to save power by dis-\nabling the BOD by software in Power-Down sleep mode. The sleep mode power consumption will then be at thesame level as when BOD is globally disabled by fuses.\nIf BOD is disabled by software, the BOD function is turned off immediately after entering the sleep mode. Upon\nwake-up from sleep, BOD is automatically enabled again. This ensures safe operation in case the V\nCC level has\ndropped during the sleep period.\nWhen the BOD has been disabled, the wake-up time from sleep mode will be the same as that for wakeing up from\nRESET. The user must manually  configure the wake up times such that the bandgap reference has time to start\nand the BOD is working correctly before the MCU continues  executing code. See SUT[1:0] and CKSEL[3:0] fuse\nbits in table “Fuse Low Byte” on page 149\nBOD disable is controlled by the BODS (BOD Sleep) bit of  MCU Control Register, see “MCUCR – MCU Control\nRegister” on page 37 . Writing this bit to one turns off BOD in Po wer-Down, while writing a zero keeps the BOD\nactive. The default setting is zero, i.e. BOD active.\nWriting to the BODS bit is controlled by  a timed sequence and an enable bit, see “MCUCR – MCU Control Regis-\nter” on page 37 .\n36 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20137.2.1 Limitations\nBOD disable functionality has been implemented in the following devices, only:\n• ATtiny25, revision E, and newer\n• ATtiny45, revision D, and newer\n• ATtiny85, revision C, and newer\nRevisions are marked on the device pack age and can be located as follows:\n• Bottom side of packages 8P3 and 8S2\n• Top side of package 20M1\n7.3 Power Reduction Register\nThe Power Reduction R egister (PRR), see “PRR – Power Reduction Register” on page 38 , provides a method to\nreduce power consumption by stopping the clock to individual peripherals. The cu rrent state of the peripheral is fro-\nzen and the I/O registers can not be re ad or written. Re sources used by th e peripheral when stopping the clock will\nremain occupied, hence the peripheral should in most cases be disabled before stopping the clock. Waking up a\nmodule, which is done by clearing the bit in PRR, puts the module in the same state as before shutdown.\nModule shutdown can be used in Idle mode and Active mode to significantly reduce the overall power consump-\ntion. In all other sleep modes, t he clock is already stopped. See “Supply Current of I/O modules” on page 177  for\nexamples.\n7.4 Minimizing Power Consumption\nThere are several issues to consider when trying to mini mize the power consumption in  an AVR controlled system.\nIn general, sleep modes should be used as  much as possible, and the sleep mode should be selected so that as\nfew as possible of the device’s functi ons are operating. All functions not need ed should be disabled. In particular,\nthe following modules may need  special consideration when trying to  achieve the lowest possible power\nconsumption.\n7.4.1 Analog to Digital Converter\nIf enabled, the ADC will be enab led in all sleep modes. To save power, the ADC should be di sabled before entering\nany sleep mode. When the ADC is turned  off and on again, the next conversi on will be an extended conversion.\nRefer to “Analog to Digital Converter” on page 122  for details on ADC operation.\n7.4.2 Analog Comparator\nWhen entering Idle mode, the Analog Comparator should  be disabled if not used. When entering ADC Noise\nReduction mode, the Analog Comparator should be disabled. In the other sleep modes, the Analog Comparator is\nautomatically disabled. However, if the Analog Comparator is set up to use the Internal Voltage Reference as\ninput, the Analog Comparator should be disabled in all sleep mo des. Otherwise, the Intern al Voltage Reference will\nbe enabled, independent of sleep mode. Refer to “Analog Comparator” on page 119  for details on how to configure\nthe Analog Comparator.\n7.4.3 Brown-out Detector\nIf the Brown-out Detector is not needed in the application, this module should be turned off. If the Brown-out Detec-\ntor is enabled by the BODLEVEL  Fuses, it will be enabled in all sleep modes, and hence, al ways consume power.\nIn the deeper sleep modes, this will contribute significantly to th e total current consumption. See “Brown-out Detec-\ntion” on page 41  and “Software BOD Disable” on page 35  for details on how to configure the Brown-out Detector.\n37 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20137.4.4 Internal Voltage Reference\nThe Internal Voltage Refere nce will be enabled when need ed by the Brown-out Detect ion, the Anal og Comparator\nor the ADC. If these modules are disabled as described in the sections above, the internal vo ltage reference will be\ndisabled and it will not be consuming power. When turned on again , the user must allow t he reference to start up\nbefore the output is used. If the reference is kept on in sleep mode, the output can be used immediately. Refer to\n“Internal Voltage Reference” on page 42  for details on the start-up time.\n7.4.5 Watchdog Timer\nIf the Watchdog Timer is not needed in the application, this module should be turned off. If the Watchdog Timer is\nenabled, it will be enabled in  all sleep modes, and hence, always cons ume power. In the dee per sleep modes, this\nwill contribute significantly to the total current consumption. Refer to “Watchdog Timer” on page 42  for details on\nhow to configure the Watchdog Timer.\n7.4.6 Port Pins\nWhen entering a sleep mode, all port pins should be conf igured to use minimum power. The most important thing\nis then to ensure that no pins drive resistive loads. In sleep modes where both the I/O clock (clkI/O) and the ADC\nclock (clkADC) are stopped, the in put buffers of the de vice will be disabled. This ensur es that no power is consumed\nby the input logic when not needed. In some cases, the input logic is needed for detecting wake-up conditions, and\nit will then be enabled. Refer to the section “Digital Input Enable and Sleep Modes” on page 57  for details on which\npins are enabled. If the input buffer is enabled and the input signal is left floating or has an analog signal level close\nto VCC/2, the input buffer will use excessive power. \nFor analog input pins, the digital input buffer should be di sabled at all times. An analog signal level close to VCC/2\non an input pin can cause significant current even in active  mode. Digital input buffers ca n be disabled by writing to\nthe Digital Input Disable Re gister (DIDR0). Refer to “DIDR0 – Digital Input Disable Register 0” on page 121  for\ndetails.\n7.5 Register Description\n7.5.1 MCUCR – MCU Control Register\nThe MCU Control Register contains control bits for power management.\n• Bit 7 – BODS: BOD Sleep\nBOD disable functionality is available in some devices, only. See “Limitations” on page 36 .\nIn order to disable BOD during sleep (see Table 7-1 on page 34 ) the BODS bit must be written to logic one. This is\ncontrolled by a timed sequence and the enable bit, BODSE in MCUCR. First, both BODS and BODSE must be set\nto one. Second, within four clock cycl es, BODS must be set to one and BOD SE must be set to zero. The BODS bit\nis active three clock cycles after it is set. A sleep instruction must be executed while BODS is active in order to turn\noff the BOD for the actual sleep mode. The BODS bit is automatically cleared after three clock cycles.\nIn devices where Sleeping BOD has not been implemented this bit is unused and will always read zero.\n• Bit 5 – SE: Sleep Enable\nThe SE bit must be written to logic one to make the MCU ente r the sleep mode when the SLEEP instruction is exe-\ncuted. To avoid the MCU entering the sleep mode unless it is the programmer’s purpose, it is recommended toB i t 76543210\n0x35 BODS PUD SE SM1 SM0 BODSE ISC01 ISC00 MCUCR\nRead/Write R R/W R/W R/W R/W R R/W R/WI n i t i a l  V a l u e00000000\n38 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013write the Sleep Enable ( SE) bit to one just before the execution of the SLEEP instructio n and to clear it immediately\nafter waking up.\n• Bits 4:3 – SM[1:0]: Sleep Mode Select Bits 1 and 0\nThese bits select between the three available sleep modes as shown in Table 7-2 .\n• Bit 2 – BODSE: BOD Sleep Enable\nBOD disable functionality is available in some devices, only. See “Limitations” on page 36 .\nThe BODSE bit enables setting of BODS  control bit, as explained on BODS bit description. BO D disable is con-\ntrolled by a timed sequence.\nThis bit is unused in devices where software BOD disabl e has not been implem ented and will read as zero in those\ndevices.\n7.5.2 PRR – Power Reduction Register\nThe Power Reduction Register  provides a method to reduce power cons umption by allowing peripheral clock sig-\nnals to be disabled.\n• Bits 7:4 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bit 3 – PRTIM1: Power Reduction Timer/Counter1\nWriting a logic one to this bit shuts down the Timer/Counter1 module. When the Timer/Counter1 is enabled, opera-\ntion will continue like before the shutdown.\n• Bit 2 – PRTIM0: Power Reduction Timer/Counter0\nWriting a logic one to this bit shuts down the Timer/Counter0 module. When the Timer/Counter0 is enabled, opera-\ntion will continue like before the shutdown.\n• Bit 1 – PRUSI: Power Reduction USI\nWriting a logic one to this bit shut s down the USI by stopping the clock to  the module. When waking up the USI\nagain, the USI should be re initialized to ensure proper operation.\n• Bit 0 – PRADC: Power Reduction ADC\nWriting a logic one to this bit shuts down the ADC. The A DC must be disabled before shut down. Note that the ADC\nclock is also used by some parts of the analog compar ator, which means that the analogue comparator can not be\nused when this bit is high.Table 7-2. Sleep Mode Select\nSM1 SM0 Sleep Mode\n00 I d l e\n0 1 ADC Noise Reduction1 0 Power-down\n11 R e s e r v e d\nB i t 76543 2 10\n0x20 – – – – PRTIM1 PRTIM0 PRUSI PRADC PRR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n39 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20138. System Control and Reset\n8.1 Resetting the AVR\nDuring reset, all I/O Registers are set to their initial values, and the program starts execution from the Reset Vec-\ntor. The instruction placed at the Reset Vector must be a RJMP – Relative Jump – inst ruction to the reset handling\nroutine. If the program never enables an interrupt source, the Interrupt Vectors are not used, and regular program\ncode can be placed at these locations. The circuit diagram in Figure 8-1  shows the reset logic. Electrical parame-\nters of the reset circuitry are given in “System and Reset Characteristics” on page 165 .\nFigure 8-1. Reset Logic\nThe I/O ports of the AVR are immediately reset to their initial state when a rese t source goes active. This does not\nrequire any clock source to be running.\nAfter all reset sources have gone inactive, a delay counter is  invoked, stretching the inte rnal reset. This allows the\npower to reach a stable level before normal operation starts . The time-out period of the delay counter is defined by\nthe user through the SUT and CKSEL Fuses. The different  selections for the delay period are presented in “Clock\nSources” on page 25 . \n8.2 Reset Sources\nThe ATtiny25/45/85 has four sources of reset:\n• Power-on Reset. The MCU is reset when the supply voltage is below the Power-on Reset threshold (VPOT).\n• External Reset. The MCU is reset when  a low level is pr esent on the RESET  pin for longer than the minimum \npulse length.\n• Watchdog Reset. The MCU is reset when the Watchdog Timer period expires and the Watchdog is enabled.\n• Brown-out Reset. The MCU is reset when the supply voltage VCC is below the Brown-out Reset threshold (VBOT) \nand the Brown-out Detector is enabled.MCU Status\nRegister (MCUSR)\nBrown-out\nReset Circuit BODLEVEL[2:0]\nDelay CountersReset Circuit RESETVCC\nWatchdog\nTimer\nINTERNAL  RESETCOUNTER  RESET\nCKSEL[3:0]CK\nTIMEOUTWDRFBORF\nEXTRFPORFDATA BUS\nRSQ\nClock\nGeneratorSPIKE\nFILTERPull-up Resistor\nWatchdog\nOscillator\nSUT[1:0]Power-on Reset\nCircuit\n40 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20138.2.1 Power-on Reset\nA Power-on Reset (POR) pulse is generated by an On-chi p detection circuit. The dete ction level is defined in “Sys-\ntem and Reset Characteristics” on page 165 . The POR is activated whenever VCC is below the dete ction level. The\nPOR circuit can be used to trigger the Start-up Reset, as well as to detect a failure in supply voltage.\nA Power-on Reset (POR) circuit ensures that the device is reset from Power-on. Reaching the Power-on Reset\nthreshold voltage invokes the delay co unter, which determines ho w long the device is kept in RESET after VCC rise.\nThe RESET signal is activated ag ain, without any delay, when VCC decreases below the detection level.\nFigure 8-2. MCU Start-up, RESET  Tied to VCC\nFigure 8-3. MCU Start-up, RESET  Extended Externally\n8.2.2 External Reset\nAn External Reset is generat ed by a low level on the RESET  pin if enabled. Reset pulses longer than the minimum\npulse width (see “System and Reset Characteristics” on page 165 ) will generate a reset, even if the clock is not\nrunning. Shorter pulses are not guaranteed to generate a reset. When the applied signal reaches the Reset\nThreshold Voltage – VRST – on its positive edge, the delay counter starts the MCU after the Time-out period – tTOUT\n– has expired.V\nRESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTCC\nRESET\nTIME-OUT\nINTERNAL\nRESETtTOUTVPOT\nVRSTVCC\n41 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 8-4. External Reset During Operation\n8.2.3 Brown-out Detection\nATtiny25/45/85 has an On-chi p Brown-out Detection (BOD) circuit for monitoring the VCC level during operation by\ncomparing it to a fixed trigger level. The trigger leve l for the BOD can be selected by the BODLEVEL Fuses. The\ntrigger level has a hysteresis to ensure spike free Br own-out Detection. The hysteresis on the detection level\nshould be interpreted as VBOT+ = VBOT + VHYST/2 and VBOT- = VBOT - VHYST/2.\nWhen the BOD is enabled, and VCC decreases to a value below the trigger level (VBOT- in Figure 8-5 ), the Brown-\nout Reset is immediately activated. When VCC increases above the trigger level (VBOT+ in Figure 8-5 ), the delay\ncounter starts the MCU after the Time-out period tTOUT has expired.\nThe BOD circuit will only detect a drop in VCC if the voltage stays below the trigger level for longer than tBOD given\nin “System and Reset Characteristics” on page 165 .\nFigure 8-5. Brown-out Reset During Operation\n8.2.4 Watchdog Reset\nWhen the Watchdog times out, it will gen erate a short reset pulse of one CK cycle duration. On the falling edge of\nthis pulse, the delay timer starts counting the Time-out period tTOUT. Refer to “Watchdog Timer” on page 42  for\ndetails on operation of the Watchdog Timer.CC\nVCC\nRESET\nTIME-OUT\nINTERNAL\nRESETVBOT -VBOT+\ntTOUT\n42 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 8-6. Watchdog Reset During Operation\n8.3 Internal Voltage Reference\nATtiny25/45/85 features an in ternal bandgap reference. This reference is used for Brown-out Detection, and it can\nbe used as an input to the Analog Comparator or the ADC.\n8.3.1 Voltage Reference Enable Signals and Start-up Time\nThe voltage reference has a start-up time that may influenc e the way it should be used. The start-up time is given\nin “System and Reset Characteristics” on page 165 . To save power, the reference is not always turned on. The ref-\nerence is on during the following situations:\n1. When the BOD is enabled (by prog ramming the BODLEVEL[2:0] Fuse Bits).\n2. When the bandgap reference is connected to the Anal og Comparator (by setting the ACBG bit in ACSR).\n3. When the ADC is enabled.\nThus, when the BOD is not enabled, after setting the ACBG bit or enabling the ADC, the user must always allow\nthe reference to start up before the output from the Analog Comparator or ADC is used. To reduce power con-\nsumption in Power-down mode, the user can avoid the three conditions above to ensure that the reference is\nturned off before entering Power-down mode.\n8.4 Watchdog Timer\nThe Watchdog Timer is clocked from an On-chip Oscillator  which runs at 128 kHz. By controlling the Watchdog\nTimer prescaler, the Watchdog Reset inte rval can be adjusted as shown in Table 8-3 on page 46 . The WDR –\nWatchdog Reset – instruction resets the Watchdog Timer. The Watchdog Timer is also reset when it is disabled\nand when a Chip Reset occurs. Ten different clock cycle pe riods can be selected to determine the reset period. If\nthe reset period expires without another Watchdog Reset, t he ATtiny25/45/85 resets and executes from the Reset\nVector. For timing details on the Watchdog Reset, refer to Table 8-3 on page 46 .\nThe Wathdog Timer can also be configured to generate an interrupt instead of a reset. This can be very helpful\nwhen using the Watchdog to wake-up from Power-down.CKCC\n43 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013To prevent unintentional disabling of the Watchdog or unin tentional change of time-out  period, two different safety\nlevels are selected by the fuse WDTON as shown in Table 8-1  Refer to “Timed Sequences for Changing the Con-\nfiguration of the Watchdog Timer” on page 43  for details.\nFigure 8-7. Watchdog Timer\n8.4.1 Timed Sequences for Changing the Configuration of the Watchdog Timer\nThe sequence for changing configuration differs slightly be tween the two safety levels. Separate procedures are\ndescribed for each level.\n8.4.1.1 Safety Level 1\nIn this mode, the Watchdog Timer is in itially disabled, but can be enabled by writing the WDE bit to one without any\nrestriction. A timed sequence is needed when disabling an enabled Watchdog Timer. To disable an enabledWatchdog Timer, the following procedure must be followed:\n1. In the same operation, write a logic one to WDCE and WDE. A logic one must be written to WDE regard-\nless of the previous value of the WDE bit.\n2. Within the next four clock cycles, in the same operat ion, write the WDE and WDP bits as desired, but with \nthe WDCE bit cleared.\n8.4.1.2 Safety Level 2\nIn this mode, the Watc hdog Timer is always enabled, and the WDE bi t will always read as one. A timed sequence\nis needed when changing the Watchdog Time-out period . To change the Watchdog Time -out, the following proce-\ndure must be followed:\n1. In the same operation, write a logical one to WDCE  and WDE. Even though the WDE always is set, the \nWDE must be written to one to start the timed sequence.\n2. Within the next four clock cycles, in the same op eration, write the WDP bits as desired, but with the \nWDCE bit cleared. The value written to the WDE bit is irrelevant.Table 8-1. WDT Configuration as a Function of  the Fuse Settings of WDTON\nWDTONSafety \nLevelWDT Initial \nStateHow to Disable the \nWDTHow to Change Time-\nout\nUnprogrammed 1 Disabled Timed sequence No limitations\nProgrammed 2 Enabled Always enabled Timed sequence\nOSC/2K\nOSC/4K\nOSC/8K\nOSC/16K\nOSC/32K\nOSC/64K\nOSC/128K\nOSC/256K\nOSC/512K\nOSC/1024K\nMCU RESETWATCHDOG\nPRESCALER128 kHz\nOSCILLATOR\nWATCHDOG\nRESET\nWDP0\nWDP1WDP2WDP3\nWDE\n44 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20138.4.2 Code Example\nThe following code example shows one assembly and one C function for turning off the WDT. The example\nassumes that interrupts are controlled (e.g., by disabling interrupts globally)  so that no interrupts will occur during\nexecution of these functions.\nNote: 1. See “Code Examples” on page 6 .\n8.5 Register Description\n8.5.1 MCUSR – MCU Status Register\nThe MCU Status Register prov ides information on which reset source caused an MCU Reset.\n• Bits 7:4 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bit 3 – WDRF: Watchdog Reset FlagAssembly Code Example(1)\nWDT_off:\nwdr\n; Clear WDRF in MCUSR\nldir16, (0<<WDRF)\noutMCUSR, r16\n; Write logical one to WDCE and WDE\n; Keep old prescaler setting to prevent unintentional Watchdog Resetin r16, WDTCR\nori r16, (1<<WDCE)|(1<<WDE)\nout WDTCR, r16\n; Turn off WDT\nldi r16, (0<<WDE)\nout WDTCR, r16\nret\nC Code Example(1)\nvoid WDT_off( void)\n{\n_WDR();\n/* Clear WDRF in MCUSR */\nMCUSR = 0x00/* Write logical one to WDCE and WDE */\nWDTCR |= (1<<WDCE) | (1<<WDE);\n/* Turn off WDT */WDTCR = 0x00;\n}\nB i t 76543210\n0x34 – – – – WDRF BORF EXTRF PORF MCUSR\nRead/Write R R R R R/W R/W R/W R/WInitial Value 0 0 0 0 See Bit Description\n45 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013This bit is set if a Watchdog Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the\nflag.\n• Bit 2 – BORF: Brown-out Reset Flag\nThis bit is set if a Brown-out Reset occurs. The bit is re set by a Power-on Reset, or by writing a logic zero to the\nflag.\n• Bit 1 – EXTRF: External Reset Flag\nThis bit is set if an External Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the flag.\n• Bit 0 – PORF: Power-on Reset Flag\nThis bit is set if a Power-on Reset occurs. The bit is reset only by writing a logic zero to the flag.\nTo make use of the Reset Flags to identify a reset condition, the user should read and then reset the MCUSR as\nearly as possible in the program. If the register is cleared  before another reset occurs, the source of the reset can\nbe found by examining the Reset Flags.\n8.5.2 WDTCR – Watchdog Timer Control Register\n• Bit 7 – WDIF: Watchdog Timeout Interrupt Flag\nThis bit is set when a time-out occurs in the Watc hdog Timer and the Watchdog Timer is configured for interrupt.\nWDIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, WDIF is\ncleared by writing a logic one to the flag. When the I-bit in SREG and WDIE are set, the Watchdog Time-out Inter-\nrupt is executed.\n• Bit 6 – WDIE: Watchdog Timeout Interrupt Enable\nWhen this bit is written to one, WDE is  cleared, and the I-bit in the Status Register is set, the Watchdog Time-out\nInterrupt is enabled. In this mode the corresponding interrupt is executed instead of a reset if a timeout in the\nWatchdog Timer occurs.\nIf WDE is set, WDIE is automatically cl eared by hardware when a time-out occurs. This is useful for keeping the\nWatchdog Reset security while using the interrupt. After the WDIE bit is  cleared, the next ti me-out will generate a\nreset. To avoid the Watchdog Reset, WDIE must be set after each interrupt.B i t 76543210\n0x21 WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 WDTCR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e0000X000\nTable 8-2. Watchdog Timer Configuration\nWDE WDIE Watchdog Timer State Action on Time-out\n0 0 Stopped None\n0 1 Running Interrupt\n1 0 Running Reset1 1 Running Interrupt\n46 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 4 – WDCE: Watchdog Change Enable\nThis bit must be set when the WDE bi t is written to logic zero. Otherwise,  the Watchdog will not be disabled. Once\nwritten to one, hardware will clear this  bit after four clock cycles. Refer to  the description of the WDE bit for a\nWatchdog disable procedure. This bit must also  be set when changing the prescaler bits. See “Timed Sequences\nfor Changing the Configuration of the Watchdog Timer” on page 43 .\n• Bit 3 – WDE: Watchdog Enable\nWhen the WDE is written to logic one, the Watchdog Timer is  enabled, and if the WDE is written to logic zero, the\nWatchdog Timer function is disabled. WDE can only be cleared if the WDCE bit has logic level one. To disable an\nenabled Watchdog Timer, the following procedure must be followed:\n1. In the same operation, write a logic one to WDCE and WDE. A logic one must be written to WDE even \nthough it is set to one before the disable operation starts.\n2. Within the next four clock cycles, write a logic 0 to WDE. This disables the Watchdog.\nIn safety level 2, it is not possible to disable the Watc hdog Timer, even with the algorithm described above. See\n“Timed Sequences for Changing the Config uration of the Watchdog Timer” on page 43 .\nIn safety level 1, WDE is ov erridden by WDRF in MCUSR. See “MCUSR – MCU Status Register” on page 44  for\ndescription of WDRF. This means that WDE is always set when WDRF is set. To clear WDE, WDRF must be\ncleared before disabling the Watchdog with the procedure described above. This feature ensures multiple resetsduring conditions causing failure, and a safe start-up after the failure.\nNote: If the watchdog timer is not going to be used in the applicat ion, it is important to go through a watchdog disable proce-\ndure in the initialization of the device. If the Watchdog is  accidentally enabled, for example by a runaway pointer or \nbrown-out condition, the device will be reset, which in turn wil l lead to a new watchdog reset. To avoid this situation, the \napplication software should always clear the WDRF flag and the WDE control bit in the initialization routine.\n• Bits 5, 2:0 – WDP[3:0]: Watchdog Timer Prescaler 3, 2, 1, and 0\nThe WDP[3:0] bits determine the Watc hdog Timer prescaling when the Watc hdog Timer is enabled. The different\nprescaling values and their corresponding Timeout Periods are shown in Table 8-3 .\nTable 8-3. Watchdog Timer Prescale Select\nWDP3 WDP2 WDP1 WDP0Number of WDT Oscillator \nCyclesTypical Time-out at \nVCC = 5.0V\n0 0 0 0 2K (2048) cycles 16 ms0 0 0 1 4K (4096) cycles 32 ms\n0 0 1 0 8K (8192) cycles 64 ms\n0 0 1 1 16K (16384) cycles 0.125 s0 1 0 0 32K (32764) cycles 0.25 s\n0 1 0 1 64K (65536) cycles 0.5 s\n0 1 1 0 128K (131072) cycles 1.0 s0 1 1 1 256K (262144) cycles 2.0 s\n1 0 0 0 512K (524288) cycles 4.0 s\n1 0 0 1 1024K (1048576) cycles 8.0 s\n47 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Note: 1. If selected, one of the valid settings below 0b1010 will be used.1010\nReserved(1)1011\n1100\n1101\n11101111Table 8-3. Watchdog Timer Prescale Select (Continued)\nWDP3 WDP2 WDP1 WDP0Number of WDT Oscillator \nCyclesTypical Time-out at \nVCC = 5.0V\n48 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20139. Interrupts\nThis section describes the specifics of the interrupt ha ndling as performed in ATtiny25/45/85. For a general expla-\nnation of the AVR interrupt handling, refer to “Reset and Interrupt Handling” on page 12 .\n9.1 Interrupt Vectors in ATtiny25/45/85\nThe interrupt vectors of ATtiny25/45/85 are described in Table 9-1 below.\nIf the program never enables an interrupt source, the Interrupt Vectors are not used, and regular program code can\nbe placed at these locations.Table 9-1. Reset and Interrupt Vectors\nVector No. Program Address Source Interrupt Definition\n1 0x0000 RESETExternal Pin, Power-on Reset,\nBrown-out Reset, Watchdog Reset\n2 0x0001 INT0 External Interrupt Request 0\n3 0x0002 PCINT0 Pin Change Interrupt Request 04 0x0003 TIMER1_COMPA Timer/Counter1 Compare Match A\n5 0x0004 TIMER1_OVF Timer/Counter1 Overflow\n6 0x0005 TIMER0_OVF Timer/Counter0 Overflow7 0x0006 EE_RDY EEPROM Ready\n8 0x0007 ANA_COMP Analog Comparator\n9 0x0008 ADC ADC Conversion Complete\n10 0x0009 TIMER1_COMPB Timer/Counter1 Compare Match B\n11 0x000A TIMER0_COMPA Timer/ Counter0 Compare Match A\n12 0x000B TIMER0_COMPB Timer/ Counter0 Compare Match B\n13 0x000C WDT Watchdog Time-out\n14 0x000D USI_START USI START\n15 0x000E USI_OVF USI Overflow\n49 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013A typical and general setup for interrupt vector addresse s in ATtiny25/45/85 is shown in the program example\nbelow.\nNote: See “Code Examples” on page 6 .\n9.2 External Interrupts\nThe External Interrupts are triggered by the INT0 pin or any of the PCINT[5:0] pins. Observe that, if enabled, the\ninterrupts will trigger even if the INT0 or  PCINT[5:0] pins are conf igured as outputs. This feature provides a way of\ngenerating a software interrupt. Pin change  interrupts PCI will trigger if any enabled PCINT[5:0] pin toggles. The\nPCMSK Register control which pins contribute to the pi n change interrupts. Pin change interrupts on PCINT[5:0]\nare detected asynchronously. This implies that these in terrupts can be used for waking the part also from sleep\nmodes other than Idle mode.\nThe INT0 interrupts can be triggered by a falling or rising edge or a low level.  This is set up as indicated in the\nspecification for the MCU Control Regi ster – MCUCR. When the INT0 interrupt  is enabled and is configured as\nlevel triggered, the in terrupt will trigger as long as the pin is held low. Note that reco gnition of falling or rising edge\ninterrupts on INT0 requires the presence of an I/O clock, described in “Clock Systems and their Distribution” on\npage 23 .\n9.2.1 Low Level Interrupt\nA low level interrupt on INT0 is detect ed asynchronously. This implies that this interrupt can be used for waking the\npart also from sleep modes other than Idle mode. The I/ O clock is halted in all sleep modes except Idle mode.\nNote that if a level triggered interrupt is used for wake-up from Power-down, the required level must be held long\nenough for the MCU to complete the wake-up to trigger the level interrupt. If the level disappears before the end ofAssembly Code Example\n.org 0x0000 ;Set address of next statement\nrjmp RESET ; Address 0x0000\nrjmp INT0_ISR ; Address 0x0001\nrjmp PCINT0_ISR ; Address 0x0002\nrjmp TIM1_COMPA_ISR ; Address 0x0003\nrjmp TIM1_OVF_ISR ; Address 0x0004rjmp TIM0_OVF_ISR ; Address 0x0005\nrjmp EE_RDY_ISR ; Address 0x0006\nrjmp ANA_COMP_ISR ; Address 0x0007rjmp ADC_ISR ; Address 0x0008\nrjmp TIM1_COMPB_ISR ; Address 0x0009\nrjmp TIM0_COMPA_ISR ; Address 0x000Arjmp TIM0_COMPB_ISR ; Address 0x000B\nrjmp WDT_ISR ; Address 0x000C\nrjmp USI_START_ISR ; Address 0x000Drjmp USI_OVF_ISR ; Address 0x000E\nRESET: ; Main program start\n<instr> ; Address 0x000F\n...\n50 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013the Start-up Time, the MCU will still wake up, but no interrupt will be generated. Th e start-up time is defined by the\nSUT and CKSEL Fuses as described in “System Clock and Clock Options” on page 23 .\nIf the low level on the interrupt pin is removed before the device has woken up then program execution will not be\ndiverted to the inte rrupt service routine but co ntinue from the instructio n following the SLEEP command.\n9.2.2 Pin Change Interrupt Timing\nAn example of timing of a pin change interrupt is shown in Figure 9-1 .\nFigure 9-1. Timing of pin change interrupts\nclk\nPCINT(0)\npin_lat\npin_sync\npcint_in_(0)\npcint_syn\npcint_setflag\nPCIFPCINT(0)\npin_syncpcint_synpin_lat\nD     Q\nLEpcint_setflag\nPCIF\nclk\nclkPCINT(0) in PCMSK(x)pcint_in_(0)0\nx\n51 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20139.3 Register Description\n9.3.1 MCUCR – MCU Control Register\nThe External Interrupt Control Register A cont ains control bits for interrupt sense control.\n• Bits 1:0 – ISC0[1:0]: Interrupt Sense Control 0 Bit 1 and Bit 0\nThe External Interrupt 0 is activated by the external pi n INT0 if the SREG I-flag and the corresponding interrupt\nmask are set. The level and edges on the external INT0 pin that activate the interrupt are defined in Table 9-2 . The\nvalue on the INT0 pin is sampled before detecting edges. If ed ge or toggle interrupt is se lected, pulses that last lon-\nger than one clock period will generate an interrupt. Shorter pulses are not guaranteed to ge nerate an in terrupt. If\nlow level interrupt is selected , the low level must be held until the completion of the currently executing instruction\nto generate an interrupt.\n9.3.2 GIMSK – General Interrupt Mask Register\n• Bits 7, 4:0 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bit 6 – INT0: External Interrupt Request 0 Enable\nWhen the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is\nenabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00) in the MCU Contro l Register (MCUCR) define\nwhether the external interrupt is activa ted on rising and/or falling edge of the INT0 pin or level sensed. Activity on\nthe pin will cause an interrupt request even  if INT0 is configured as  an output. The corresp onding interrupt of Exter-\nnal Interrupt Request 0 is executed  from the INT0 Interrupt Vector.\n• Bit 5 – PCIE: Pin Change Interrupt Enable\nWhen the PCIE bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt is\nenabled. Any change on any enabled PCINT[5:0] pin will cause an interrupt. The corresponding interrupt of Pin\nChange Interrupt Request is executed from the PCI Interr upt Vector. PCINT[5:0] pins are enabled individually by\nthe PCMSK0 Register.B i t 76543210\n0x35 BODS PUD SE SM1 SM0 BODSE ISC01 ISC00 MCUCR\nRead/Write R R/W R/W R/W R/W R R/W R/WI n i t i a l  V a l u e00000000\nTable 9-2. Interrupt 0 Sense Control\nISC01 ISC00 Description\n0 0 The low level of INT0 generates an interrupt request.0 1 Any logical change on INT0 generates an interrupt request.\n1 0 The falling edge of INT0 generates an interrupt request.\n1 1 The rising edge of INT0 gener ates an interrupt request.\nB i t 76543210\n0x3B – INT0 PCIE – – – – – GIMSK\nR e a d / W r i t e R R / W R / W RRRRRI n i t i a l  V a l u e00000000\n52 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20139.3.3 GIFR – General In terrupt Flag Register\n• Bits 7, 4:0 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bit 6 – INTF0: External Interrupt Flag 0\nWhen an edge or logic change on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in\nSREG and the INT0 bit in GIMSK are set (one), the MCU will jump  to the correspo nding Interrupt Vector. The flag\nis cleared when the interrupt routine is ex ecuted. Alternatively, the flag can be cleared by writing a logical one to it.\nThis flag is always cleared when INT0 is configured as a level interrupt.\n• Bit 5 – PCIF: Pin Change Interrupt Flag\nWhen a logic change on any PC INT[5:0] pin triggers an interrupt request,  PCIF becomes set (one). If the I-bit in\nSREG and the PCIE bit in GIMSK are set (one), the MCU will jump to the corr esponding Interrup t Vector. The flag\nis cleared when the interrupt routine is ex ecuted. Alternatively, the flag can be cleared by writing a logical one to it.\n9.3.4 PCMSK – Pin Change Mask Register\n• Bits 7:6 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bits 5:0 – PCINT[5:0]: Pin Change Enable Mask 5:0\nEach PCINT[5:0] bit selects whether pin change interrupt is enabled on the correspondin g I/O pin. If PCINT[5:0] is\nset and the PCIE bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT[5:0] is\ncleared, pin change interrupt on the corresponding I/O pin is disabled.B i t 76543210\n0x3A – I N T F 0 P C I F ––––– G I F R\nR e a d / W r i t e R R / W R / W RRRRRI n i t i a l  V a l u e00000000\nB i t 765432100x15 – – PCINT5 PCINT4 PCINT3 PCINT2 PCINT1 PCINT0 PCMSK\nRead/Write R R R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\n53 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201310. I/O Ports\n10.1 Introduction\nAll AVR ports have true Read-Modify-Write functionality wh en used as general digital I/O ports. This means that\nthe direction of one port pin can be changed without unin tentionally changing the direction of any other pin with the\nSBI and CBI instructions. The same applies when changing drive value (if configured as output) or enabling/dis-\nabling of pull-up resistors (if configured as input). Each  output buffer has symmetrical drive characteristics with\nboth high sink and source capability. The pin driver is strong enough to driv e LED displays directly. All port pins\nhave individually selectable pull-up resi stors with a supply-voltage invariant re sistance. All I/O pins have protection\ndiodes to both VCC and Ground as indicated in Figure 10-1 . Refer to “Electrical Characteristics” on page 161  for a\ncomplete list of parameters.\nFigure 10-1. I/O Pin Equivalent Schematic\nAll registers and bit references in this section are writt en in general form. A lower case “x” represents the number-\ning letter for the port, and a lower case “n” represents t he bit number. However, when using the register or bit\ndefines in a program, the precise form must be used. For example, PORTB3 for bit no. 3 in Port B, here docu-\nmented generally as PORTxn. The physical I/O Registers and bit locations are listed in “Register Description” on\npage 64 .\nThree I/O memory address locations are allocated for each port, one each for the Data Register – PORTx, Data\nDirection Register – DDRx, and the Port Input Pins – PINx. The Port Input Pins I/O location is read only, while the\nData Register and the Data Direction Register are read/wri te. However, writing a logic one to a bit in the PINx Reg-\nister, will result in a toggle  in the corresponding bit in the Data Register. In addition , the Pull-up Disable – PUD bit\nin MCUCR disables the pull-up function  for all pins in all ports when set.\nUsing the I/O port as General Digital I/O is described in “Ports as General Digital I/O” on page 53 . Most port pins\nare multiplexed with alternate functions for the peripheral features on the device. How each alternate function inter-\nferes with the port pin is described in “Alternate Port Functions” on page 57 . Refer to the individual module sections\nfor a full description of the alternate functions.\nNote that enabling the alternate function of some of the port pins does not affect the use of the other pins in the port\nas general digital I/O.\n10.2 Ports as General Digital I/O\nThe ports are bi-directional I/O ports with optional internal pull-ups. Figure 10-2  shows a functional description of\none I/O-port pin, here generically called Pxn.LogicRpu\nSee Figure\n"General Digital I/O" for\nDetailsPxn\n54 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 10-2. General Digital I/O(1)\nNote: 1. WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O, SLEEP, and PUD are \ncommon to all ports.\n10.2.1 Configuring the Pin\nEach port pin consists of three register bits: DDxn, PORTxn, and PINxn. As shown in “Register Description” on\npage 64 , the DDxn bits are accessed at the DDRx I/O address,  the PORTxn bits at the PORTx I/O address, and\nthe PINxn bits at the PINx I/O address.\nThe DDxn bit in the DDRx Register select s the direction of this pin. If DDxn is  written logic one, Pxn is configured\nas an output pin. If DDxn is  written logic zero, Pxn is configured as an input pin. \nIf PORTxn is written logic one when the pin is configured as  an input pin, the pull-up resistor is activated. To switch\nthe pull-up resistor off, PORTxn has to  be written logic zero or the pin has to be configured as an output pin. The\nport pins are tri-stated when reset condition becomes active, even if no clocks are running.\nIf PORTxn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If\nPORTxn is written logic zero when the pin is configured as  an output pin, the port pin is driven low (zero). \n10.2.2 Toggling the Pin\nWriting a logic one to PINxn toggles the value of PORTxn , independent on the value of  DDRxn. Note that the SBI\ninstruction can be used to toggle one single bit in a port.\n10.2.3 Switching Between Input and Output\nWhen switching between tri-state ({DDxn, PORTxn} = 0b00 ) and output high  ({DDxn, PORTxn} = 0b11), an inter-\nmediate state with either pull-up enabled {DDxn, PORTxn} = 0b01) or out put low ({DDxn, PORTxn} = 0b10) must\noccur. Normally, the pull-up enabled state is fully acceptable, as a high-impedant environment will not notice theclkRPxRRxRDxWDxPUD\nSYNCHRONIZER\nWDx: WRITE DDRx\nWRx: WRITE PORTx\nRRx: READ PORTx REGISTER\nRPx: READ PORTx PINPUD: PULLUP DISABLE\nclkI/O: I/O CLOCKRDx: READ DDRxD\nLQ\nQRESET\nRESET\nQQ DQQD\nCLRPORTxnQQD\nCLRDDxn\nPINxnDATA BUS\nSLEEP\nSLEEP: SLEEP CONTROLPxn\nI/OWPx01\nWRx\nWPx: WRITE PINx REGISTER\n55 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013difference between a strong high driver and a pull-up. If  this is not the case, the PUD bit in the MCUCR Register\ncan be set to disable a ll pull-ups in all ports. \nSwitching between input with pull-up and output low generate s the same problem. The user must use either the tri-\nstate ({DDxn, PORTxn} = 0b00) or the output high stat e ({DDxn, PORTxn} = 0b10) as an intermediate step.\nTable 10-1  summarizes the control signals for the pin value.\n10.2.4 Reading the Pin Value\nIndependent of the setting of Data Direction bit DDxn, t he port pin can be read through the PINxn Register bit. As\nshown in Figure 10-2 , the PINxn Register bit and the preceding latc h constitute a synchronizer. This is needed to\navoid metastability if the physical pin changes value near t he edge of the internal clock, but it also introduces a\ndelay. Figure 10-3  shows a timing diagram of the synchronization when reading an externally applied pin value.\nThe maximum and minimum propagation delays are denoted tpd,max  and tpd,min  respectively.\nFigure 10-3. Synchronization when Reading an Externally Applied Pin value\nConsider the clock period starting shortly after the first falling edge of the system clock. The latch is closed when\nthe clock is low, and goes transpar ent when the clock is high,  as indicated by the sh aded region of the “SYNC\nLATCH” signal. The signal value is latche d when the system clock goes low. It is clocked into the PINxn Register at\nthe succeeding positive clock edge. As indicated by the tw o arrows tpd,max and tpd,min,  a single signal transition\non the pin will be delayed between ½ and 1½ system cl ock period depend ing upon the time of assertion.\nWhen reading back a software assigned pin value, a nop instruction must be inserted as indicated in Figure 10-4 .\nThe out instruction sets the “SYNC LA TCH” signal at the positive edge of the clock. In this case, the delay tpd\nthrough the synchronizer is one system clock period.Table 10-1. Port Pin Configurations\nDDxn PORTxnPUD\n(in MCUCR) I/O Pull-up Comment\n0 0 X Input No Tri-state (Hi-Z)0 1 0 Input Yes Pxn will source current if ext. pulled low.\n0 1 1 Input No Tri-state (Hi-Z)\n1 0 X Output No Output Low (Sink)1 1 X Output No Output High (Source)\nXXX in r17, PINx\n0x00 0xFFINSTRUCTION S\nSYNC LATCH\nPINxn\nr17XXXSYSTEM CLK\ntpd, m ax\ntpd, min\n56 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 10-4. Synchronization when Reading a Software Assigned Pin Value\nThe following code example shows how to set port B pins 0 and 1 high, 2 and 3 low, and define the port pins from\n4 to 5 as input with a pull-up assigned to port pin 4. The resulting pin values are read back again, but as previously\ndiscussed, a nop instruction is included to be able  to read back the value recently assigned to some of the pins.\nNote: 1. For the assembly program, two temporary registers are us ed to minimize the time from pull-ups are set on pins 0, 1 \nand 4, until the direction bits are correctly set, defining bit 2 and 3 as low and redefining bits 0 and 1 as strong high \ndrivers.Assembly Code Example(1)\n...\n; Define pull-ups and set outputs high\n; Define directions for port pins\nldir16,(1<<PB4)|(1<<PB1)|(1<<PB0)\nldir17,(1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0)\noutPORTB,r16\noutDDRB,r17\n; Insert nop for synchronization\nnop\n; Read port pins\ninr16,PINB\n...\nC Code Example\nunsigned char i;\n...\n/* Define pull-ups and set outputs high */\n/* Define directions for port pins */\nPORTB = (1<<PB4)|(1<<PB1)|(1<<PB0);\nDDRB = (1<<DDB3)|(1<<DDB2)|(1<<DDB1)|(1<<DDB0);\n/* Insert nop for synchronization */\n_NOP();\n/* Read port pins */\ni = PINB;\n...out PORTx, r16 nop in r17, PINx0xFF\n0x00 0xFFSYSTEM CLK\nr16\nINSTRUCTIONS\nSYNC LATCH\nPINxn\nr17\ntpd\n57 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201310.2.5 Digital Input Enable and Sleep Modes\nAs shown in Figure 10-2 , the digital input signal can be clamped to gr ound at the input of the schmitt-trigger. The\nsignal denoted SLEEP in the figure, is set by the MCU Sleep Controller in Power- down mode to avoid high power\nconsumption if some input signals are left floati ng, or have an analog signal level close to VCC/2.\nSLEEP is overridden for port pins enabled as external inte rrupt pins. If the external in terrupt request is not enabled,\nSLEEP is active also for these pins. SL EEP is also overridden by various other alternate function s as described in\n“Alternate Port Functions” on page 57 .\nIf a logic high level (“one”) is present on an asynchronous external interrupt pin configured as “Interrupt on Rising\nEdge, Falling Edge, or Any Logic Change on Pin” while the external interrupt is not enabled, the corresponding\nExternal Interrupt Flag will be set when  resuming from the above mentioned Sl eep mode, as the cl amping in these\nsleep mode produces the requested logic change.\n10.2.6 Unconnected Pins\nIf some pins are unused, it is recommended to ensure that  these pins have a defined level. Even though most of\nthe digital inputs are disabled in the deep sleep modes as  described above, floating inputs should be avoided to\nreduce current consumption in all other modes where t he digital inputs are enabled (Reset, Active mode and Idle\nmode).\nThe simplest method to ensure a defined level of an unused pin, is to enable the internal pull-up. In this case, the\npull-up will be disabled during reset. If low power consumpt ion during reset is importan t, it is recommended to use\nan external pull-up or pulldown. C onnecting unused pins directly to VCC or GND is not recommended, since this\nmay cause excessive currents if the pin is  accidentally configured as an output.\n10.3 Alternate Port Functions\nMost port pins have alternate functions in addition to being general digital I/Os. Figure 10-5  shows how the port pin\ncontrol signals from the simplified Figure 10-2  can be overridden by alternate functions. The overriding signals may\nnot be present in all port pins, but the figure serves as a generic description applicable to all port pins in the AVR\nmicrocontroller family.\n58 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 10-5. Alternate Port Functions(1)\nNote: 1. WRx, WPx, WDx, RRx, RPx, and RDx are common to all pins within the same port. clkI/O, SLEEP, and PUD are \ncommon to all ports. All other signals are unique for each pin.clkRPxRRxWRxRDxWDxPUD\nSYNCHRONIZER\nWDx:     WRITE DDRx\nWRx:     WRITE PORTxRRx:     READ PORTx REGISTER\nRPx:     READ PORTx PINPUD:     PULLUP DISABLE\nclkI/O:     I/O CLOCKRDx:     READ DDRxD\nLQ\nQSET\nCLR01\n0101\nDIxn\nAIOxnDIEOExnPVOVxnPVOExnDDOVxnDDOExnPUOExn\nPUOVxn\nPUOExn: Pxn PULL-UP OVERRIDE ENABLE\nPUOVxn: Pxn PULL-UP OVERRIDE VALUE\nDDOExn: Pxn DATA DIRECTION OVERRIDE ENABLE\nDDOVxn: Pxn DATA DIRECTION OVERRIDE VALUE\nPVOExn: Pxn PORT VALUE OVERRIDE ENABLE\nPVOVxn: Pxn PORT VALUE OVERRIDE VALUE\nDIxn:     DIGITAL INPUT PIN n ON PORTx\nAIOxn:     ANALOG INPUT/OUTPUT PIN n ON PORTxRESETRESETQQ D\nCLR\nQQ D\nCLR\nQQD\nCLRPINxnPORTxnDDxn\nDATA BUS\n01DIEOVxn\nSLEEP\nDIEOExn: Pxn DIGITAL INPUT -ENABLE OVERRIDE ENABLE\nDIEOVxn: Pxn DIGITAL INPUT -ENABLE OVERRIDE VALUESLEEP: SLEEP CONTROLPxn\nI/O01\nPTOExn\nPTOExn: Pxn, PORT TOGGLE OVERRIDE ENABLEWPx: WRITE PINxWPx\n59 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Table 10-2  summarizes the function of the overriding signals. The pin and port indexes from Figure 10-5  are not\nshown in the succeeding tables. The overriding signals are generated internally in the modules having the alternate\nfunction.\nThe following subsections shortly describe the alternate functions for each port, and relate the overriding signals to\nthe alternate function. Refer to the alternat e function description for further details.Table 10-2. Generic Description of Overriding  Signals for Alternate Functions\nSignal Name Full Name Description\nPUOEPull-up Override \nEnableIf this signal is set, the pull-up enable is controlled by the PUOV \nsignal. If this signal is cleared, the pull-up is enabled when \n{DDxn, PORTxn, PUD} = 0b010. \nPUOVPull-up Override \nValueIf PUOE is set, the pull-up is enabled/disabled when PUOV is \nset/cleared, regardless of the setting of the DDxn, PORTxn, \nand PUD Register bits.\nDDOEData Direction \nOverride EnableIf this signal is set, the Output Dr iver Enable is controlled by the \nDDOV signal. If this signal is cleared, the Output driver is \nenabled by the DDxn Register bit. \nDDOVData Direction \nOverride ValueIf DDOE is set, the Output Driver is enabled/disabled when \nDDOV is set/cleared, regardle ss of the setting of the DDxn \nRegister bit.\nPVOEPort Value \nOverride EnableIf this signal is set and the Output Driver is enabled, the port \nvalue is controlled by the PVOV signal. If PVOE is cleared, and \nthe Output Driver is enabled, the port Value is controlled by the PORTxn Register bit.\nPVOVPort Value \nOverride ValueIf PVOE is set, the port value is  set to PVOV, regardless of the \nsetting of the PORTxn Register bit.\nPTOEPort Toggle \nOverride EnableIf PTOE is set, the PORTxn Register bit is inverted.\nDIEOEDigital Input \nEnable Override \nEnableIf this bit is set, the Digital I nput Enable is controlled by the \nDIEOV signal. If this signal is cleared, the Digital Input Enable \nis determined by MCU state (Normal mode, sleep mode).\nDIEOVDigital Input \nEnable Override \nValueIf DIEOE is set, the Digital Input is enabled/disabled when \nDIEOV is set/cleared, regardless of the MCU state (Normal \nmode, sleep mode).\nDI Digital InputThis is the Digital Input to altern ate functions. In the figure, the \nsignal is connected to the ou tput of the schmitt-trigger but \nbefore the synchronizer. Unless the Digital Input is used as a \nclock source, the module with the alternate function will use its \nown synchronizer.\nAIOAnalog \nInput/OutputThis is the Analog Input/Output to/from alternate functions. The \nsignal is connected directly to  the pad, and can be used bi-\ndirectionally.\n60 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201310.3.1 Alternate Functions of Port B\nThe Port B pins with alternate function are shown in Table 10-3 .\n• Port B, Bit 5 – RESET /dW/ADC0/PCINT5\n• RESET : External Reset input is active low and enabled by  unprogramming (“1”) the RSTDISBL Fuse. Pullup is \nactivated and output driver and digital input ar e deactivated when the pin is used as the RESET  pin.\n• dW: When the debugWIRE Enable (DWEN) Fuse is programmed and Lock bits are unprogrammed, the \ndebugWIRE system within the target device is activated. The RESET  port pin is configured as a wire-AND \n(open-drain) bi-directional I/O pin with pull-up e nabled and becomes the communication gateway between \ntarget and emulator.\n• ADC0: Analog to Digital  Converter, Channel 0 .\n• PCINT5: Pin Change Interrupt source 5.Table 10-3. Port B Pins Alternate Functions\nPort Pin Alternate Function\nPB5RESET :R e s e t  P i n\ndW: debugWIRE I/O\nADC0: ADC Input Channel 0\nPCINT5: Pin Change Interrupt, Source 5\nPB4XTAL2: Crystal Oscillator Output\nCLKO: System Clock OutputADC2: ADC Input Channel 2\nOC1B: Timer/Counter1 Compare Match B Output\nPCINT4: Pin Change Interrupt 0, Source 4\nPB3XTAL1: Crystal Oscillator Input\nCLKI:  External Clock Input\nADC3: ADC Input Channel 3OC1B\n: Complementary Timer/Counter 1 Compare Match B Output\nPCINT3: Pin Change Interrupt 0, Source 3\nPB2SCK: Serial Clock Input\nADC1: ADC Input Channel 1\nT0: Timer/Counter0 Clock Source\nUSCK: USI Clock (Three Wire Mode)SCL : USI Clock (Two Wire Mode)\nINT0: External Interrupt 0 Input\nPCINT2: Pin Change Interrupt 0, Source 2\nPB1MISO: SPI Master Data Input / Slave Data Output\nAIN1: Analog Comparator, Negative Input\nOC0B: Timer/Counter0 Compare Match B OutputOC1A: Timer/Counter1 Compare Match A Output\nDO: USI Data Output (Three Wire Mode)\nPCINT1:Pin Change Interrupt 0, Source 1\nPB0MOSI:: SPI Master Data Output / Slave Data Input\nAIN0: Analog Comparator, Positive Input\nOC0A: Timer/Counter0 Compare Match A outputOC1A\n: Complementary Timer/Counter1 Compare Match A Output\nDI: USI Data Input (Three Wire Mode)\nSDA: USI Data Input (Two Wire Mode)AREF: External Analog Reference\nPCINT0: Pin Change Interrupt 0, Source 0\n61 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Port B, Bit 4 – XTAL 2/CLKO/ADC2/OC1B/PCINT4\n• XTAL2: Chip Clock Oscillator pin 2. Used as clock pin fo r all chip clock sources exc ept internal calibrateble RC \nOscillator and external clock. When us ed as a clock pin, the pin can not be used as an I/O pin. When using \ninternal calibratable RC Oscillator or Ex ternal clock as a Chip clock sources,  PB4 serves as an ordinary I/O pin.\n• CLKO: The devided system clock can be output on the pin PB4. The divided system clock will be output if the \nCKOUT Fuse is programmed, regardless of the PORTB4 and DDB4 settings. It will also be out put during reset.\n• ADC2: Analog to Digital  Converter, Channel 2 .\n• OC1B: Output Compare Match output: The PB4 pin can serve as an external output for the Timer/Counter1 \nCompare Match B when configured as an output (DDB4 se t). The OC1B pin is also the output pin for the PWM \nmode timer function.\n• PCINT4: Pin Change Interrupt source 4.\n• Port B, Bit 3 – XTAL1/CLKI/ADC3/OC1B /PCINT3\n• XTAL1: Chip Clock Oscillator pin 1. Us ed for all chip clock sources except  internal calibrateble RC oscillator. \nWhen used as a clock pin, the pin can not be used as an I/O pin. \n• CLKI: Clock Input from an external clock source, see “External Clock” on page 26 .\n• ADC3: Analog to Digital  Converter, Channel 3 .\n•O C 1 B : Inverted Output Compare Match output: The PB3 pin can serve as an external output for the \nTimer/Counter1 Compare Match B when configured as an output (DDB3 set). The OC1B  pin is also the inverted \noutput pin for the PWM mode timer function.\n• PCINT3: Pin Change Interrupt source 3.\n• Port B, Bit 2 – SCK/ADC1/T0/USCK/SCL/INT0/PCINT2\n• SCK: Master Clock output, Slave Clock input pin for SPI ch annel. When the SPI is enabled as a Slave, this pin \nis configured as an input regardless of the setting of  DDB2. When the SPI is enabled as a Master, the data \ndirection of this pin is controlled by DDPB2. When the pin is forc ed by the SPI to be an in put, the pull-up can still \nbe controlled by the PORTB2 bit.\n• ADC1: Analog to Digital  Converter, Channel 1 .\n• T0: Timer/Counter0 counter source.\n• USCK: Three-wire mode Universal Serial Interface Clock.• SCL: Two-wire mode Serial Clock for USI Two-wire mode.\n• INT0: External Interrupt source 0.\n• PCINT2: Pin Change Interrupt source 2.\n• Port B, Bit 1 – MISO/AIN1/OC0B/OC1A/DO/PCINT1\n• MISO: Master Data input, Slave Data output pin for SPI channel. When the SPI is enabled as a Master, this pin \nis configured as an input regardless of the setting of DDB1. When the SPI is enabled as a Slave, the data \ndirection of this pin is controlled by DDB1. When the pin is forced by the SPI to be an input, the pull-up can still \nbe controlled by the PORTB1 bit.\n• AIN1: Analog Comparator Negative Inpu t. Configure the port pin as input with the internal pull-up switched off to \navoid the digital port function from interferin g with the function of the Analog Comparator.\n• OC0B: Output Compare Match output. The PB1 pin can serve as an external output for the Timer/Counter0 \nCompare Match B. The PB1 pin has to be configured as an  output (DDB1 set (one)) to  serve this function. The \nOC0B pin is also the output pin for the PWM mode timer function.\n62 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• OC1A: Output Compare Match output: The PB1 pin can serve as an external output for the Timer/Counter1 \nCompare Match B when configured as an output (DDB1 se t). The OC1A pin is also the output pin for the PWM \nmode timer function.\n• DO: Three-wire mode Universal Serial Interface Data output. Three-wire mode Data output overrides PORTB1 \nvalue and it is driven to the port when data direction bit DDB1 is set (o ne). PORTB1 still enabl es the pull-up, if \nthe direction is input and PORTB1 is set (one).\n• PCINT1: Pin Change Interrupt source 1.\n• Port B, Bit 0 – MOSI/AIN0/OC0A/OC1A /DI/SDA/AREF/PCINT0\n• MOSI: SPI Master Data output, Slave Data input for SPI channel. When the SPI is enabled as a Slave, this pin \nis configured as an input regardless of the setting of  DDB0. When the SPI is enabled as a Master, the data \ndirection of this pin is controlled by DDB0. When the pin is forced by the SPI to be an input, the pull-up can still \nbe controlled by the PORTB0 bit.\n• AIN0: Analog Comparator Positive Input. Configure the port pin as input with the internal pull-up switched off to \navoid the digital port function from interferin g with the function of the Analog Comparator.\n• OC0A: Output Compare Match output. The PB0 pin can serve as an external output for the Timer/Counter0 \nCompare Match A when configured as an output (DDB0 se t (one)). The OC0A pin is also the output pin for the \nPWM mode timer function.\n•O C 1 A : Inverted Output Compare Match output: The PB0 pin can serve as an external output for the \nTimer/Counter1 Compare Match B when configured as an output (DDB0 set). The OC1A  pin is also the inverted \noutput pin for the PWM mode timer function.\n• SDA: Two-wire mode Serial Interface Data.\n• AREF: External Analog Reference for ADC. Pullup and ou tput driver are disabled on PB0 when the pin is used \nas an external reference or Internal Voltage Reference with external capacitor at the AREF pin.\n• DI: Data Input in USI Three-wire mode. USI Three-wire mode does not override normal port functions, so pin \nmust be configure as an input for DI function.\n• PCINT0: Pin Change Interrupt source 0.\nTable 10-4  and Table 10-5  relate the alternate functions of Port  B to the overriding signals shown in Figure 10-5 on\npage 58 .\n63 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Note: 1. 1 when the Fuse is “0” (Programmed).Table 10-4. Overriding Signals for Alternate Functions in PB[5:3]\nSignal\nNamePB5/RESET /\nADC0/PCINT5PB4/ADC2/XTAL2/\nOC1B/PCINT4PB3/ADC3/XTAL1/\nOC1B /PCINT3\nPUOE RSTDISBL(1) • DWEN(1)00\nP U O V 100\nDDOE RSTDISBL(1) • DWEN(1)00\nDDOV debugWire Transmit 0 0PVOE 0 OC1B Enable OC1B\n Enable\nPVOV 0 OC1B OC1B\nP T O E 000\nDIEOERSTDISBL(1) + (PCINT5 • \nPCIE + ADC0D)PCINT4 • PCIE + ADC2D PCINT3 • PCIE + ADC3D\nDIEOV ADC0D ADC2D ADC3D\nDI PCINT5 Input PCINT4 Input PCINT3 Input\nAIO RESET Input, ADC0 I nput ADC2 Input ADC3 Input\nTable 10-5. Overriding Signals for Alternate Functions in PB[2:0]\nSignal\nNamePB2/SCK/ADC1/T0/\nUSCK/SCL/INT0/PCINT2PB1/MISO/DO/AIN1/\nOC1A/OC0B/PCINT1PB0/MOSI/DI/SDA/AIN0/AR\nEF/OC1A /OC0A/\nPCINT0\nPUOE USI_TWO_WIRE 0 USI_TWO_WIREP U O V 000\nDDOE USI_TWO_WIRE 0 USI_TWO_WIRE\nDDOV(USI_SCL_HOLD + \nPORTB2\n) • DDB20( S D A  + PORTB0 ) • DDB0\nPVOE USI_TWO_WIRE • DDB2OC0B Enable + OC1A \nEnable + USI_THREE_WIREOC0A Enable + OC1A\n \nEnable + (USI_TWO_WIRE • DDB0)\nPVOV 0 OC0B + OC1A + DO OC0A + OC1A\nPTOE USITC 0 0\nDIEOEPCINT2 • PCIE + ADC1D + \nUSISIEPCINT1 • PCIE + AIN1DPCINT0 • PCIE + AIN0D + \nUSISIE\nDIEOV ADC1D AIN1D AIN0D\nDIT0/USCK/SCL/INT0/\nPCINT2 InputPCINT1 Input DI/SDA/PCINT0 Input\nAIO ADC1 InputAnalog Comparator \nNegative InputAnalog Comparator Positive \nInput\n64 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201310.4 Register Description\n10.4.1 MCUCR – MCU Control Register\n• Bit 6 – PUD: Pull-up Disable\nWhen this bit is written to one, the pull-ups in the I/O ports are disabled even if the DDxn and PORTxn Registers\nare configured to enable the pull-ups ({DDxn, PORTxn} = 0b01). See “Configuring the Pin” on page 54  for more\ndetails about this feature.\n10.4.2 PORTB – Port B Data Register\n10.4.3 DDRB – Port B Da ta Direction Register\n10.4.4 PINB – Port B Input Pins AddressBit 7 6 5 4 3 2 1 0\n0x35 BODS PUD SE SM1 SM0 BODSE ISC01 ISC00 MCUCR\nRead/Write R R/W R/W R/W R/W R R/W R/WInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x18 – – PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 PORTB\nRead/Write R R R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 765432100x17 – – DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 DDRB\nRead/Write R R R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e 00000000\nB i t 765432100x16 – – PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 PINB\nRead/Write R R R/W R/W R/W R/W R/W R/WInitial Value 0 0 N/A N/A N/A N/A N/A N/A\n65 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201311. 8-bit Timer/Counter0 with PWM\n11.1 Features\n•Two Independent Output Compare Units\n•Double Buffered Output  Compare Registers\n•Clear Timer on Compare Match (Auto Reload)\n•Glitch Free, Phase Correct Pulse Width Modulator (PWM)\n•Variable PWM Period\n•Frequency Generator\n•Three Independent Interrupt Sources (TOV0, OCF0A, and OCF0B)\n11.2 Overview\nTimer/Counter0 is a general purpose 8-bit Timer/Counter  module, with two independent  Output Compare Units,\nand with PWM support. It allows accurate program exec ution timing (event management) and wave generation.\nA simplified block diagram of the 8-bit Timer/Counter is shown in Figure 11-1 . For the actual placement of I/O pins,\nrefer to “Pinout ATtiny25/45/85” on page 2 . CPU accessible I/O Registers, incl uding I/O bits and I/O pins, are\nshown in bold. The device-specific I/O Register and bit locations are listed in the “Register Description” on page 77 .\nFigure 11-1. 8-bit Timer/Counter Block Diagram \n11.2.1 Registers\nThe Timer/Counter (TCNT0) and Output Compare Registers (OCR0A and OCR0B) are 8-bit registers. Interrupt\nrequest (abbreviated to Int.Req. in the figure) signals are all visible in the Timer Interrupt Flag Register (TIFR). AllClock Select\nTimer/Counter\nDATA BUSOCRnA\nOCRnB=\n=TCNTn\nWaveform\nGeneration\nWaveform\nGenerationOCnA\nOCnB=\nFixed\nTOP\nValueControl Logic\n= 0TOP BOTTOMCount\nClear\nDirectionTOVn\n(Int.Req.)\nOCnA(Int.Req.)\nOCnB(Int.Req.)\nTCCRnA TCCRnBTnEdge\nDetector\n( From Prescaler )clkTn\n66 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013interrupts are individually masked with the Timer Interrup t Mask Register (TIMSK). TIFR and TIMSK are not shown\nin the figure.\nThe Timer/Counter can be clocked internally, via the prescale r, or by an external cloc k source on the T0 pin. The\nClock Select logic block controls which clock source and edge the Timer/Counter uses to increment (or decrement)\nits value. The Timer/Counter is inactive  when no clock source is selected. The output from the Clock Select logic is\nreferred to as the timer clock (clkT0).\nThe double buffered Output Compare Re gisters (OCR0A and OCR0B) is co mpared with the Timer/Counter value\nat all times. The result of the compare can be used by the Waveform Generator to generate a PWM or variable fre-\nquency output on the Output Compare pins (OC0A and OC0B). See “Output Compare Unit” on page 69.  for details.\nThe Compare Match event will also set the Compare Flag (OCF0A or OCF0B) which can be used to generate an\nOutput Compare interrupt request.\n11.2.2 Definitions\nMany register and bit references in this section are written in general form. A lo wer case “n” replaces the\nTimer/Counter number, in this case 0. A lower case “x” replaces the Output Compare Unit, in this case Compare\nUnit A or Compare Unit B. Ho wever, when using the register or bit defin es in a program, the precise form must be\nused, i.e., TCNT0 for accessing Timer/Counter0 counter value and so on.\nThe definitions in Table 11-1  are also used extensively throughout the document.\n11.3 Timer/Counter0 Pres caler and Clock Sources\nThe Timer/Counter can be clocked by an internal or an ex ternal clock source. The clock source is selected by the\nClock Select logic which is controlled by the Clock Select (c) bits located in the Timer/Counter0 Control Register\n(TCCR0B).\n11.3.1 Internal Clock Source with Prescaler\nTimer/Counter0 can be clocked directly by the system clock (by setting th e CS0[2:0] = 1). This provides the fastest\noperation, with a maximum time r/counter clock frequency equal to system clock frequency (fCLK_I/O ). Alternatively,\none of four taps from the prescaler can be used as a cl ock source. The prescaled clock has a frequency of either\nfCLK_I/O /8, fCLK_I/O /64, fCLK_I/O /256, or fCLK_I/O /1024.\n11.3.2 Prescaler Reset\nThe prescaler is free running, i.e. it operates independently of the Clock Sele ct logic of Timer/Counter0. Since the\nprescaler is not affe cted by the timer/counter’s clock select, the state of the prescale r will have implications for situ-\nations where a prescaled clock is used . One example of a prescaling artifact is when the timer/counter is enabled\nand clocked by the prescaler (6 > CS0[2:0] > 1). The nu mber of system clock cycles from when the timer is\nenabled to the first count occurs can be from 1 to N+1 s ystem clock cycles, where N equals the prescaler divisor\n(8, 64, 256, or 1024).\nIt is possible to use the Presca ler Reset for synchronizing the Timer/Counter to program execution.Table 11-1. Definitions\nConstant Description\nBOTTOM The counter reaches BO TTOM when it becomes 0x00\nMAX The counter reaches its MAXimum wh en it becomes 0xFF (decimal 255)\nTOPThe counter reaches the TOP when it becomes equal to the highest value in the count \nsequence. The TOP value can be assigned to be the fixed value 0xFF (MAX) or the \nvalue stored in the OCR0A Register. The assignment depends on the mode of operation\n67 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201311.3.3 External Clock Source\nAn external clock source applied to the T0 pin can be used as timer/counter clock (clkT0). The T0 pin is sampled\nonce every system clock cycle by th e pin synchronization logic. The sync hronized (sampled) signal is then passed\nthrough the edge detector. Figure 11-2  shows a functional equivalent block di agram of the T0 synchronization and\nedge detector logic. The registers are clocked at the positive edge of t he internal system clock ( clkI/O). The latch is\ntransparent in the high period of the internal system clock.\nThe edge detector generates one clkT0 pulse for each positive (CS0[2:0] = 7) or negative (CS0[2:0] = 6) edge it\ndetects.\nFigure 11-2. T0 Pin Sampling\nThe synchronization and edge detector logic introduces a dela y of 2.5 to 3.5 system clock cycles from an edge has\nbeen applied to the T0 pin to the counter is updated.\nEnabling and disabling of the clock input must be done when T0 has been stable for at least one system clock\ncycle, otherwise it is a risk that a fals e timer/counter clock pulse is generated.\nEach half period of the external clock applied must be  longer than one system clock cycle to ensure correct sam-\npling. The external clock must be guaranteed to  have less than half the system clock frequency (fExtClk < fclk_I/O /2)\ngiven a 50/50% duty cycle. Since the edge detector uses  sampling, the maximum frequency of an external clock it\ncan detect is half the sampling frequency (following the Nyquist sampling theorem). However, due to variation ofthe system clock frequency and duty cycle caused by os cillator source (cry stal, resonator, an d capacitors) toler-\nances, it is recommended that maximum frequency of an external clock so urce is less than f\nclk_I/O /2.5.\nAn external clock source  can not be prescaled.Tn_sync\n(To ClockSelect Logic)\nEdge Detector SynchronizationDQ DQ\nLEDQ Tn\nclkI/O\n68 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 11-3. Timer/Counter0 Prescaler\nThe synchronization logic on the input pins (T0) in Figure 11-3  is shown in Figure 11-2 on page 67 .\n11.4 Counter Unit\nThe main part of the 8-bit Timer/Counter is  the programmable bi-directional counter unit. Figure 11-4  shows a\nblock diagram of the coun ter and its surroundings.\nFigure 11-4. Counter Unit Block Diagram\nSignal description (internal signals):\ncount Increment or decrement TCNT0 by 1.\ndirection Select between increment and decrement.\nclear Clear TCNT0 (set all bits to zero).\nclkTn Timer/Counter clock, referred to as clkT0 in the following.\ntop Signalize that TCNT0 ha s reached maximum value.\nbottom Signalize that TCNT0 has re ached minimum value (zero).\nDepending of the mode of operation used, the counter is cl eared, incremented, or decr emented at each timer clock\n(clkT0). clkT0 can be generated from an external or internal cl ock source, selected by the Clock Select bits\n(CS0[2:0]). When no clock source is selected (CS0[2:0] = 0) the timer is stopped. However, the TCNT0 value canPSR10Clear\nclkT0T0clkI/O\nSynchronization\nDATA BUS\nTCNTn Control LogiccountTOVn\n(Int.Req.)\nClock Select\ntopTnEdge\nDetector\n( From Prescaler )clkTn\nbottomdirectionclear\n69 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013be accessed by the CPU, regardless of whether clkT0 is present or not. A CPU write overrides (has priority over) all\ncounter clear or count operations.\nThe counting sequence is determined by the setting of the WGM01 and WGM00 bits located in the Timer/Counter\nControl Register (TCCR0A) and the WG M02 bit located in the Timer/Counter Control Register B (TCCR0B). There\nare close connections between how t he counter behaves (counts) and how waveforms are generated on the Out-\nput Compare output OC0A. For more details about adv anced counting sequences and waveform generation, see\n“Modes of Operation” on page 71 .\nThe Timer/Counter Overflow Flag (TOV0) is set accord ing to the mode of operation selected by the WGM0[1:0]\nbits. TOV0 can be used for generating a CPU interrupt.\n11.5 Output Compare Unit\nThe 8-bit comparator continuously compares TCNT0 wi th the Output Compare Registers (OCR0A and OCR0B).\nWhenever TCNT0 equals OCR0A or OCR0B, the comparator signals a match. A match will set the Output Com-\npare Flag (OCF0A or OCF0B) at the next timer clock cycl e. If the corresponding interrupt is enabled, the Output\nCompare Flag generates an Output Compare interrupt. The Output Compare Flag is automatically cleared whenthe interrupt is executed. Alternatively, the flag can be cleared by software by wr iting a logical one to  its I/O bit loca-\ntion. The Waveform Generator uses the match signal to generate an output acco rding to operating mode set by the\nWGM0[2:0] bits and Compare Output mo de (COM0x[1:0]) bits. The max and bottom signals are used by the Wave-\nform Generator for handling the special cases of th e extreme values in some modes of operation ( See “Modes of\nOperation” on page 71. ).\nFigure 11-5  shows a block diagram of the Output Compare unit. \nFigure 11-5. Output Compare Unit, Block Diagram\nThe OCR0x Registers are double buffered when using an y of the Pulse Width Modulation (PWM) modes. For the\nnormal and Clear Timer on Compare (CTC) modes of operat ion, the double buffering is disabled. The double buff-\nering synchronizes the update of the OCR0x Compare Regi sters to either top or bottom of the counting sequence.\nThe synchronization prevents the occurrence of odd-length, non-symmetrical PWM pulses, thereby making theoutput glitch-free.OCFnx (Int.Req.)= (8-bit Comparator )OCRnx\nOCnxDATA BUS\nTCNTn\nWGMn[1:0]Waveform Generat ortop\nFOCn\nCOMnX[1:0]bottom\n70 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The OCR0x Register access may seem complex, but this is not case. When the double buffering is enabled, the\nCPU has access to the OCR0x Buffer Regi ster, and if double buffering is di sabled the CPU will access the OCR0x\ndirectly. \n11.5.1 Force Output Compare\nIn non-PWM waveform generation modes, the match output of the comparator can be forced by writing a one to\nthe Force Output Compare (FOC0x) bit. Forcing Compare Match will not set the OCF0x Flag or reload/clear the\ntimer, but the OC0x pin will be updated as if a real Compare Match had occurred (the COM0x[1:0] bits settings\ndefine whether the OC0x pin is set, cleared or toggled). \n11.5.2 Compare Match Blocking by TCNT0 Write\nAll CPU write operations to the TCNT0 Register will bloc k any Compare Match that occur in the next timer clock\ncycle, even when the timer is stopped. This feature allows  OCR0x to be initialized to the same value as TCNT0\nwithout triggering an interrupt when the Timer/Counter clock is enabled.\n11.5.3 Using the Output Compare Unit\nSince writing TCNT0 in any mode of operation will block all Compare Matches for one timer clock cycle, there are\nrisks involved when changing TCNT0 when using the Output Compare Unit, independently of whether the\nTimer/Counter is running or not. If the value written to TC NT0 equals the OCR0x value, the Compare Match will be\nmissed, resulting in incorr ect waveform generation. Similarly, do not write the TCNT0 value equal to BOTTOM\nwhen the counter is down-counting.\nThe setup of the OC0x should be performed before setting the Data Direction Register for the port pin to output.\nThe easiest way of setting the OC0x value is to use the Force Output Co mpare (FOC0x) strobe bits in Normal\nmode. The OC0x Registers keep their values even wh en changing between Waveform Generation modes.\nBe aware that the COM0x[1:0] bits are not double bu ffered together with the compare value. Changing the\nCOM0x[1:0] bits will ta ke effect immediately.\n11.6 Compare Match Output Unit\nThe Compare Output mode (COM0x[1:0]) bits have two functions. The Waveform Ge nerator uses the COM0x[1:0]\nbits for defining the Output Compare (OC0x) state at th e next Compare Match. Also, the COM0x[1:0] bits control\nthe OC0x pin output source. Figure 11-6  shows a simplified schematic of the l ogic affected by the COM0x[1:0] bit\nsetting. The I/O Registers, I/O bits, and I/O pins in the fi gure are shown in bold. Only the parts of the general I/O\nPort Control Registers (DDR and PORT) that are affected by the COM0x[1:0] bits  are shown. When referring to the\nOC0x state, the reference is for the internal OC0x Regi ster, not the OC0x pin. If a system reset occur, the OC0x\nRegister is reset to “0”.\n71 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 11-6. Compare Match Output Unit, Schematic\nThe general I/O port function is overridden by the Outp ut Compare (OC0x) from the Waveform Generator if either\nof the COM0x[1:0] bits are set. However, the OC0x pin direction (input or output) is still controlled by the Data\nDirection Register (DDR) for the port pin. The Data Direction Register bi t for the OC0x pin (DDR_OC0x) must be\nset as output before the OC0x value is visible on the pin. The port override function is independent of the Wave-\nform Generation mode.\nThe design of the Output Compare pin logic allows initia lization of the OC0x state before the output is enabled.\nNote that some COM0x[1:0] bit settings ar e reserved for certain modes of operation. See “Register Description” on\npage 77.\n11.6.1 Compare Output Mode and Waveform Generation\nThe Waveform Generator uses the COM0x[1:0] bits diff erently in Normal, CTC, and PWM modes. For all modes,\nsetting the COM0x[1:0] = 0 tells the Wa veform Generator that no action on the OC0x Register is to be performed\non the next Compare Match. For compare out put actions in the non-PWM modes refer to Table 11-2 on page 78 .\nFor fast PWM mode, refer to Table 11-3 on page 78 , and for phase correct PWM refer to Table 11-4 on page 78 .\nA change of the COM0x[1: 0] bits state will have effect at the first Comp are Match after the bits are written. For non-\nPWM modes, the action can be forced to have im mediate effect by usi ng the FOC0x strobe bits.\n11.7 Modes of Operation\nThe mode of operation, i.e., the behavior of the Timer/Counter and the Output Compare pins, is defined by the\ncombination of the Waveform Generation mode (WGM0[2:0]) and Compare Output mode (COM0x[1:0]) bits. TheCompare Output mode bits do not affect the counting sequence, while the Waveform Generation mode bits do.\nThe COM0x[1:0] bits control whethe r the PWM output generated should be inverted or not (inverted or non-\ninverted PWM). For non-PWM modes the COM0x[1:0] bits control whether the output should be set, cleared, or\ntoggled at a Compare Match ( See “Compare Match Output Unit” on page 70. ).PORT\nDDRDQDQOCn\nPin OCnxDQWaveform\nGener atorCOMnx1\nCOMnx0\n01\nDATA BUSFOCn\nclkI/O\n72 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013For detailed timing information refer to Figure 11-10 , Figure 11-11 , Figure 11-12  and Figure 11-13  in “Timer/Coun-\nter Timing Diagrams” on page 76 .\n11.7.1 Normal Mode\nThe simplest mode of operation is the Normal mode (WGM0[ 2:0] = 0). In this mode the counting direction is always\nup (incrementing), and no counter clear is performed. The counter simply overruns when it passes its maximum 8-\nbit value (TOP = 0xFF) and then restarts from the bott om (0x00). In normal operation the Timer/Counter Overflow\nFlag (TOV0) will be set in the same ti mer clock cycle as the TCNT0 become s zero. The TOV0 Flag in this case\nbehaves like a ninth bit, except that it  is only set, not cleared. However, comb ined with the timer overflow interrupt\nthat automatically clears the TOV0 Flag, the timer reso lution can be increased by software. There are no special\ncases to consider in the Normal mode, a new counter value can be written anytime.\nThe Output Compare Unit can be used to generate interru pts at some given time. Using the Output Compare to\ngenerate waveforms in Normal mode is not recommended, since this will occupy too much of the CPU time.\n11.7.2 Clear Timer on Compare Match (CTC) Mode\nIn Clear Timer on Compare or CTC mode (WGM0[2:0] = 2), the OCR0A Register is used to manipulate  the counter\nresolution. In CTC mode the counter is cleared to zero when the counter value (TCNT 0) matches the OCR0A. The\nOCR0A defines the top value for the counter, hence also its resolution. This mode allows greater control of the\nCompare Match output frequency. It also simplifie s the operation of counting external events.\nThe timing diagram for the CTC mode is shown in Figure 11-7 . The counter value (TCNT0)  increases until a Com-\npare Match occurs between TCNT0 and OCR0 A, and then counter (TCNT0) is cleared.\nFigure 11-7. CTC Mode, Timing Diagram\nAn interrupt can be generated each time the counter valu e reaches the TOP value by using the OCF0A Flag. If the\ninterrupt is enabled, the interrupt handler routine can be used for updating the TOP value. However, changing TOP\nto a value close to BOTTOM when the counter is runni ng with none or a low prescaler value must be done with\ncare since the CTC mode does not have the double buffering feature. If the new value written to OCR0A is lower\nthan the current value of TC NT0, the counter will miss the Compare Match. The counter will then have to count to\nits maximum value (0xFF) and wrap around starti ng at 0x00 before the Compare Match can occur. \nFor generating a waveform output in CTC mode, the OC0A output can be set to toggle its logical level on each\nCompare Match by setting the Compare Output mode bits to t oggle mode (COM0A[1:0] = 1). The OC0A value will\nnot be visible on the port pin unless the data direction for t he pin is set to output. The waveform generated will have\na maximum frequency of fOC0 = fclk_I/O /2 when OCR0A is set to zero (0x00). The waveform frequency is defined by\nthe following equation:TCNTn\nOCn\n(T oggle)OCnx Interrupt  Flag Set\n1 4 Per i o d 2 3(C OMnx[1:0] = 1)\nfOCnxfclk_I/O\n2 N 1 OCRnx +\uf028\uf029\uf0d7\uf0d7--------------------------------------------------=\n73 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nAs for the Normal mode of operation, the TOV0 Flag is set in the same ti mer clock cycle that the counter counts\nfrom MAX to 0x00.\n11.7.3 Fast PWM Mode\nThe fast Pulse Width Modulation or fast PWM mode (WGM 0[2:0] = 3 or 7) provides a high frequency PWM wave-\nform generation option. The fast PWM differs from the other PWM option by its single-slope operation. The counter\ncounts from BOTTOM to TOP then restarts from BOTT OM. TOP is defined as 0xFF when WGM0[2:0] = 3, and\nOCR0A when WGM0[2:0] = 7.\nIn non-inverting Compare Output mode, the Output Compare (OC0x) is cleared on the Compare Match between\nTCNT0 and OCR0x, and set at BOTTOM. In inverting Compare Output mode, the output is set on Compare Match\nand cleared at BOTTOM.\nDue to the single-slope operation, the operating frequen cy of the fast PWM mode can be twice as high as the\nphase correct PWM mode that use dual-slope operation. This high frequency makes the fast PWM mode well\nsuited for power regulation, rectification, and DAC applications. High fre quency allows physically small sized exter-\nnal components (coils, capacitors), and therefore reduces total system cost.\nIn fast PWM mode, the counte r is incremented until the counter value matches the TOP value. The counter is then\ncleared at the following timer clock cycle. The ti ming diagram for the fast PWM mode is shown in Figure 11-8 . The\nTCNT0 value is in the timing  diagram shown as a histogra m for illustrating the single-s lope operation.  The diagram\nincludes non-inverted and inverted PWM outputs. The sma ll horizontal line marks on the TCNT0 slopes represent\nCompare Matches between OCR0x and TCNT0.\nFigure 11-8. Fast PWM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV0) is set each time the counter reaches TOP. If the interrupt is enabled, the\ninterrupt handler routine can be used for updating the compare value.\nIn fast PWM mode, the compare unit allows generation of PWM waveforms on the OC0x pins. Setting the\nCOM0x[1:0] bits to two will produce a non-inverted PWM and an inverted PWM output can be g enerated by setting\nthe COM0x[1:0] to three: Setting the COM0A[1:0] bits to one allowes the AC0A pin to toggle on Compare Matches\nif the WGM02 bit is set. This option is not available for the OC0B pin (See Table 11-3 on page 78 ). The actual\nOC0x value will only be visible on the port pin if the data direction for the port pin is set as output. The PWM wave-TCNTnOCRnx Update and\nTOVn  Int er rup t  Fl ag  Set\n1 Per i o d 2 3OCn\nOCn(C OMnx[1:0] = 2)\n(C OMnx[1:0] = 3)OCRnx Interrupt  Flag Set\n4 5 6 7\n74 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013form is generated by setting (or clearing) the OC0x Re gister at the Compare Match between OCR0x and TCNT0,\nand clearing (or setting)  the OC0x Register at the timer clock cycle the counter is cleared (changes from TOP to\nBOTTOM).\nThe PWM frequency for the output can be calculated by the following equation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR0A Regi ster represents special cases when generating a PWM waveform output in\nthe fast PWM mode. If  the OCR0A is set equal to BOTTOM, the ou tput will be a narrow spike for each MAX+1\ntimer clock cycle. Setting the OCR0A equal to MAX will resu lt in a constantly high or  low output (depending on the\npolarity of the output se t by the COM0A[1:0] bits.)\nA frequency (with 50% duty cycle) waveform output in fast PWM mode can be achieved by setting OC0x to toggle\nits logical level on each Compare Match (COM0x[1:0] = 1). The waveform generate d will have a maximum fre-\nquency of fOC0 = fclk_I/O /2 when OCR0A is set to zero. This feature is similar to the OC0A toggle in CTC mode,\nexcept the double buffer feature of the Output Compare unit is enabled in the fast PWM mode.\n11.7.4 Phase Correct PWM Mode\nThe phase correct PWM mode (WGM0[2:0] = 1 or 5) provid es a high resolution phase correct PWM waveform gen-\neration option. The phase correct PWM mode is based on a dual-slope operation. Th e counter counts repeatedly\nfrom BOTTOM to TOP and then from TOP to BOTTOM . TOP is defined as 0xFF when WGM0[2:0] = 1, and\nOCR0A when WGM0[2:0] = 5. In non-in verting Compare Output mode, the Ou tput Compare (OC0x) is cleared on\nthe Compare Match between TCNT0 and OCR0x while upcounting, and set on the Compare Match while down-\ncounting. In inverting Output Compare mode, the operat ion is inverted. The dual-sl ope operation has lower maxi-\nmum operation frequency than single slope operation. Howe ver, due to the symmetric feature of the dual-slope\nPWM modes, these modes are preferred for motor control applications.\nIn phase correct PWM mode the counter is incremented unt il the counter value matches TOP. When the counter\nreaches TOP, it change s the count direction. The TCNT0 value will be eq ual to TOP for one ti mer clock cycle. The\ntiming diagram for the phase correct PWM mode is shown on Figure 11-9 . The TCNT0 value is in the timing dia-\ngram shown as a histogram for illu strating the dua l-slope operatio n. The diagram incl udes non-inverted and\ninverted PWM outputs. The small horizontal line ma rks on the TCNT0 slopes represent Compare Matches\nbetween OCR0x and TCNT0.fOCnxPWMfclk_I/O\nN 256\uf0d7------------------=\n75 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 11-9. Phase Correct PWM Mode, Timing Diagram\nThe Timer/Counter Overflow Flag (TOV0) is set each ti me the counter reaches BOTTOM. The Interrupt Flag can\nbe used to generate an interrupt each time the counter reaches the BOTTOM value.\nIn phase correct PWM mode, the compare unit allows generation of PWM waveforms on the OC0x pins. Setting\nthe COM0x[1:0] bits to two will produc e a non-inverted PWM. An inverted PW M output can be g enerated by setting\nthe COM0x[1:0] to three: Setting the COM0A0 bits to on e allows the OC0A pin to toggle on Compare Matches if\nthe WGM02 bit is set. This option is not available for the OC0B pin (See Table 11-4 on page 78 ). The actual OC0x\nvalue will only be visible on the port pin if the data direction for the port pin is set as output. The PWM waveform is\ngenerated by clearing (or setting) the OC0x Register at  the Compare Match between OCR0x and TCNT0 when the\ncounter increments, and setting (or clearing) the OC0x  Register at Compare Match between OCR0x and TCNT0\nwhen the counter decrements. The PWM frequency for t he output when using phase correct PWM can be calcu-\nlated by the following equation:\nThe N variable represents the prescale factor (1, 8, 64, 256, or 1024).\nThe extreme values for the OCR0A Register represent special cases when generating a PWM waveform output in\nthe phase correct PWM mode. If the O CR0A is set equal to BOTTOM, the outp ut will be continuously low and if set\nequal to MAX the output will be continuously high for non -inverted PWM mode. For inverted PWM the output will\nhave the opposite logic values.\nAt the very start of period 2 in Figure 11-9  OCn has a transition from high to low even though there is no Compare\nMatch. The point of this transition is to guaratee symme try around BOTTOM. There are two cases that give a tran-\nsition without Compare Match, as follows:\n• OCR0A changes its value from MAX, like in Figure 11-9 . When the OCR0A value is MAX the OCn pin value is \nthe same as the result of a down-counting Compare Match. To ensure symmetr y around BOTTOM the OCn \nvalue at MAX must correspond to the re sult of an up-counting Compare Match.TOVn Interrupt Flag SetOCnx Interrupt Flag Set\n1 2 3TCNTn\nPeriodOCn\nOCn(COMnx[1:0] = 2)\n(COMnx[1:0] = 3)OCRnx Update\nfOCnxPCPWMfclk_I/O\nN5 1 0\uf0d7------------------=\n76 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• The timer starts counting from a value higher than th e one in OCR0A, and for that reason misses the Compare \nMatch and hence the OCn change that would have happened on the way up.\n11.8 Timer/Counter Timing Diagrams\nThe Timer/Counter is a synchronous design and the timer clock (clkT0) is therefore shown as  a clock enable signal\nin the following figures. The figures include information on when In terrupt Flags are set. Figure 11-10  contains tim-\ning data for basic Timer/Counter operation. The figure shows the count sequence close to the MAX value in all\nmodes other than phase correct PWM mode.\nFigure 11-10. Timer/Counter Timing Diagram, no Prescaling\nFigure 11-11  shows the same timing data, but with the prescaler enabled.\nFigure 11-11. Timer/Counter Timing Dia gram, with Prescaler (fclk_I/O /8)\nFigure 11-12  shows the setting of OCF0B in all modes and OCF0A in all modes except CTC mode and PWM\nmode, where OCR0A is TOP.\nFigure 11-12. Timer/Counter Timing Diagram, Setting of OCF0x, with Prescaler (fclk_I/O /8)clkTn\n(clkI/O/1)\nTOVnclkI/O\nTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1\nTOVnTCNTn MAX - 1 MAX BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nOCFnxOCRnxTCNTn\nOCRnx V alueOCRnx - 1 OCRnx OCRnx + 1 OCRnx + 2clkI/O\nclkTn\n(clkI/O/8)\n77 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 11-13  shows the setting of OCF0A and the clearing of TCNT0 in CTC mode and fast PWM mode where\nOCR0A is TOP.\nFigure 11-13. Timer/Counter Timing Diagram, Clear Timer on Compare Match mode, with Prescaler (fclk_I/O /8)\n11.9 Register Description\n11.9.1 GTCCR – General Timer/Counter Control Register\n• Bit 7 – TSM: Timer/Counter Synchronization Mode\nWriting the TSM bit to one activates the Timer/Counter Synchron ization Mode. In this mode, the value written to\nPSR0 is kept, hence keeping the Prescale r Reset signal asserted. This ensures that the timer/counter is halted and\ncan be configured without the risk of advancing during conf iguration. When the TSM bit is written to zero, the PSR0\nbit is cleared by hardware, and the timer/counter start counting.\n• Bit 0 – PSR0: Prescaler Reset Timer/Counter0\nWhen this bit is one, the Timer/Count er0 prescaler will be Reset. This bit is  normally cleared im mediately by hard-\nware, except if the TSM bit is set.\n11.9.2 TCCR0A – Timer/Coun ter Control Register A\n• Bits 7:6 – COM0A[1:0]: Compare Match Output A Mode\n• Bits 5:4 – COM0B[1:0]: Compare Match Output B Mode\nThe COM0A[1:0] and COM0B[1:0] bits control the behavi our of Output Compare pins OC0A and OC0B, respec-\ntively. If any of the COM0A[1:0] bits are set, the OC0A outp ut overrides the normal port functionality of the I/O pin it\nis connected to. Similarly, if any of the COM0B[1:0] bits  are set, the OC0B output ov errides the normal port func-\ntionality of the I/O pin it is connect ed to. However, note that the Data Directi on Register (DDR) bit corresponding to\nthe OC0A and OC0B pins must be set in order to enable the output driver.OCFnxOCRnxTCNTn\n(CTC)\nTOPTOP - 1 TOP BOTTOM BOTTOM + 1clkI/O\nclkTn\n(clkI/O/8)\nBit 7 6 5 4 3 2 1 0\n0x2C TSM PWM1B COM1B1 COM1B0 FOC1B FOC1A PSR1 PSR0 GTCCR\nRead/Write R/W R R R R R R R/WInitial Value 0 0 0 0 0 0 0 0\nB i t 7 6 5 4 3 2100x2A COM0A 1 COM0A 0 COM0B 1 COM0B 0 –– WGM01 WGM00 TCCR0A\nRead/Write R/W R/W R/W R/W R R R/W R/WInitial Value 0 0 0 0 0 0 0 0\n78 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013When OC0A/OC0B is connected to t he I/O pin, the function of the CO M0A[1:0]/COM0B[1:0] bits depend on the\nWGM0[2:0] bit setting. Table 11-2  shows the COM0x[1:0] bi t functionality when the WGM0[2:0] bits are set to a\nnormal or CTC mode (non-PWM).\nTable 11-3  shows the COM0x[1:0] bit functionality when the WGM0[2:0] bits are set to fast PWM mode.\nNote: 1. A special case occurs when OCR0A or OCR0B equals TOP and COM0A1/COM0B1 is set. In this case, the com-\npare match is ignored, but the set or clear is done at BOTTOM. See “Fast PWM Mode” on page 73  for more details.\nTable 11-4  shows the COM0x[1:0] bit functionality when the WGM0[2:0] bits are set to phase correct PWM mode.\nNote: 1. A special case occurs when OCR0A or OCR0B equals TOP and COM0A1/COM0B1 is set. In this case, the Com-\npare Match is ignored, but the set or clear is done at TOP. See “Phase Correct PWM Mode” on page 74  for more \ndetails.\n• Bits 3:2 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.Table 11-2. Compare Output Mode, non-PWM Mode\nCOM0A1\nCOM0B1COM0A0\nCOM0B0 Description\n0 0 Normal port operation, OC0A/OC0B disconnected.\n0 1 Toggle OC0A/OC0B on Compare Match\n1 0 Clear OC0A/OC0B on Compare Match\n1 1 Set OC0A/OC0B on Compare Match\nTable 11-3. Compare Output Mode, Fast PWM Mode(1)\nCOM0A1\nCOM0B1COM0A0\nCOM0B0 Description\n0 0 Normal port operation, OC0A/OC0B disconnected.01 R e s e r v e d\n10Clear OC0A/OC0B on Compare Match, set OC0A/OC0B at BOTTOM\n(non-inverting mode)\n11Set OC0A/OC0B on Compare Match, clear OC0A/OC0B at BOTTOM\n(inverting mode)\nTable 11-4. Compare Output Mode, Phase Correct PWM Mode(1)\nCOM0A1\nCOM0B1COM0A0\nCOM0B0 Description\n0 0 Normal port operation, OC0A/OC0B disconnected.\n01 R e s e r v e d\n10Clear OC0A/OC0B on Compare Match when up-counting.\nSet OC0A/OC0B on Compare Match when down-counting.\n11Set OC0A/OC0B on Compare Match when up-counting.\nClear OC0A/OC0B on Compare Match when down-counting.\n79 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bits 1:0 – WGM0[1:0]: Waveform Generation Mode\nCombined with the WGM02 bit found in the TCCR0B Regist er, these bits control t he counting sequence of the\ncounter, the source for maximum (TOP) counter value,  and what type of waveform generation to be used, see\nTable 11-5 . Modes of operation supported by the Timer/Counter unit  are: Normal mode (counter), Clear Timer on\nCompare Match (CTC) mode, and two types of  Pulse Width Modulation (PWM) modes (see “Modes of Operation”\non page 71 ).\nNotes: 1. MAX        = 0xFF  \n2. BOTTOM = 0x00\n11.9.3 TCCR0B – Timer/Coun ter Control Register B\n• Bit 7 – FOC0A: Force Output Compare A\nThe FOC0A bit is only active when the WGM bits specify a non-PWM mode.\nHowever, for ensuring co mpatibility with future devices, this bit must be set to  zero when TCCR0B is written when\noperating in PWM mode. When  writing a logical one to the FOC0A bit,  an immediate Compare Match is forced on\nthe Waveform Generation unit. The OC0A  output is changed according to its CO M0A[1:0] bits se tting. Note that\nthe FOC0A bit is implemented as a strobe. Therefore it is the value present in the COM0 A[1:0] bits that determines\nthe effect of the forced compare. \nA FOC0A strobe will not generate any interrupt, nor will it clear the time r in CTC mode using OCR0A as TOP.\nThe FOC0A bit is always read as zero.\n• Bit 6 – FOC0B: Force Output Compare B\nThe FOC0B bit is only active when the WGM bits specify a non-PWM mode. \nHowever, for ensuring co mpatibility with future devices, this bit must be set to  zero when TCCR0B is written when\noperating in PWM mode. When  writing a logical one to the FOC0B bit,  an immediate Compare Match is forced on\nthe Waveform Generation unit. The OC0B  output is changed according to its CO M0B[1:0] bits se tting. Note that\nthe FOC0B bit is implemented as a strobe. Therefore it is the value present in the COM0 B[1:0] bits that determines\nthe effect of the forced compare.\nA FOC0B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0B as TOP. Table 11-5. Waveform Generation Mode Bit Description\nModeWGM\n02WGM\n01WGM\n00Timer/Counter Mode \nof Operation TOPUpdate of\nOCRx atTOV Flag\nSet on\n0 0 0 0 Normal 0xFF Immediate MAX(1)\n1 0 0 1 PWM, Phase Correct 0xFF TOP BOTTOM(2)\n2 0 1 0 CTC OCRA Immediate MAX(1)\n3 0 1 1 Fast PWM 0xFF BOTTOM(2)MAX(1)\n4 1 0 0 Reserved – – –5 1 0 1 PWM, Phase Correct OCRA TOP BOTTOM\n(2)\n6 1 1 0 Reserved – – –\n7 1 1 1 Fast PWM OCRA BOTTOM(2)TOP\nBit 7 6 5 4 3 2 1 0\n0x33 FOC0A FOC0B – – WGM02 CS02 CS01 CS00 TCCR0B\nRead/Write W W R R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n80 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The FOC0B bit is always read as zero.\n• Bits 5:4 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bit 3 – WGM02: Waveform Generation Mode\nSee the description in the “TCCR0A – Timer/Counter Cont rol Register A” on page 77 .\n• Bits 2:0 – CS0[2:0]: Clock Select\nThe three Clock Select bits select the clo ck source to be used by the Timer/Counter.\nIf external pin modes are used for the Timer/Counter0, transit ions on the T0 pin will clock the counter even if the\npin is configured as an output. This featur e allows software cont rol of the counting.\n11.9.4 TCNT0 – Time r/Counter Register\nThe Timer/Counter Register gives direct access, both for re ad and write operations, to the Timer/Counter unit 8-bit\ncounter. Writing to the TCNT0 Register blocks (removes) the Compare Match on the follo wing timer clock. Modify-\ning the counter (TCNT0) while the counter is running, introduces a risk of missing a Compare Match between\nTCNT0 and the OCR0x Registers.\n11.9.5 OCR0A – Output Compare Register A\nThe Output Compare Register A contains an 8-bit value that is continuously compared with the counter value\n(TCNT0). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on theOC0A pin.Table 11-6. Clock Select Bit Description \nCS02 CS01 CS00 Description\n0 0 0 No clock source (Timer/Counter stopped)001 c l k\nI/O/(No prescaling)\n010 c l kI/O/8 (From prescaler)\n011 c l kI/O/64 (From prescaler)\n100 c l kI/O/256 (From prescaler)\n101 c l kI/O/1024 (From prescaler)\n1 1 0 External clock source on T0 pin. Clock on falling edge.1 1 1 External clock source on T0 pin. Clock on rising edge.\nB i t 76543210\n0x32 TCNT0 [7:0] TCNT0\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\nB i t 765432100x29 OCR0A [7:0] OCR0A\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\n81 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201311.9.6 OCR0B – Output Compare Register B\nThe Output Compare Register B contains an 8-bit value that is continuously compared with the counter value\n(TCNT0). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on theOC0B pin.\n11.9.7 TIMSK – Timer/Counter  Interrupt Mask Register\n• Bits 7, 0 – Res: Reserved Bits\nThese bits are reserved bits and will always read as zero.\n• Bit 4 – OCIE0A: Timer/Counter0 Output Compare Match A Interrupt Enable\nWhen the OCIE0A bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Compare\nMatch A interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter0\noccurs, i.e., when the OCF0A bit is set in the Timer/Counter 0 Interrupt Flag Register – TIFR0.\n• Bit 3 – OCIE0B: Timer/Counter Output Compare Match B Interrupt Enable\nWhen the OCIE0B bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter Compare\nMatch B interrupt is enabled. The corresponding interrupt is executed if a Compare Matc h in Timer/Counter occurs,\ni.e., when the OCF0B bit is set in the Time r/Counter Interrupt Flag Register – TIFR0.\n• Bit 1 – TOIE0: Timer/Counter0 Overflow Interrupt Enable\nWhen the TOIE0 bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Overflow inter-\nrupt is enabled. The corresponding interr upt is executed if an overflow in Timer/Counter0 occurs, i.e., when the\nTOV0 bit is set in the Timer/Counter  0 Interrupt Flag Register – TIFR0.\n11.9.8 TIFR – Timer/Counter Interrupt Flag Register\n• Bits 7, 0 – Res: Reserved Bits\nThese bits are reserved bits and will always read as zero.\n• Bit 4 – OCF0A: Output Compare Flag 0 A\nThe OCF0A bit is set when a Compare Match occurs betwe en the Timer/Counter0 and the data in OCR0A – Out-\nput Compare Register0. OCF0A is cleared by hardwar e when executing the corr esponding interrupt handling\nvector. Alternatively, OCF0A is cleared by writing a lo gic one to the flag. When the I-bit in SREG, OCIE0A\n(Timer/Counter0 Compare Match Interrupt Enable), and OCF0A are set, the Timer/Counter0 Compare Match Inter-\nrupt is executed.B i t 76543210\n0x28 OCR0B [7:0] OCR0B\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\nB i t 765432100x39 –\nOCIE1A OCIE1B OCIE0A OCIE0B TOIE1 TOIE0 – TIMSK\nRead/Write R R/W R/W R/W R/W R/W R/W RInitial Value 0 0 0 0 0 0 0 0\nB i t 765432100x38 –\nOCF1A OCF1B OCF0A OCF0B TOV1 TOV0 –T I F R\nRead/Write R R/W R/W R/W R/W R/W R/W RI n i t i a l  V a l u e00000000\n82 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 3 – OCF0B: Output Compare Flag 0 B\nThe OCF0B bit is set when a Compare Match occurs between the Timer/Count er and the data in OCR0B – Output\nCompare Register0 B. OCF0B is cleared by hardware when  executing the corresponding  interrupt handling vector.\nAlternatively, OCF0B is clear ed by writing a logic one to the flag. When  the I-bit in SREG, OCIE0B (Timer/Counter\nCompare B Match Interrupt Enable), and OCF0B are set, th e Timer/Counter Compare Match Interrupt is executed.\n• Bit 1 – TOV0: Timer/Counter0 Overflow Flag\nThe bit TOV0 is set when an overflow occurs in Timer/Co unter0. TOV0 is cleared by hardware when executing the\ncorresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When theSREG I-bit, TOIE0 (Timer/Counter0 Ov erflow Interrupt Enable), and TOV0 are set, the Timer/Counter0 Overflow\ninterrupt is executed.\nThe setting of this flag is dependent of the WGM0[2:0] bit setting. Refer to Table 11-5 , “Waveform Generation\nMode Bit Description” on page 79 .\n83 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201312. 8-bit Timer/Counter1\nThe Timer/Counter1 is a general purpos e 8-bit Timer/Counter m odule that has a separate prescaling selection\nfrom the separate prescaler.\n12.1 Timer/Counter1 Prescaler\nFigure 12-1  shows the Timer/Counter1 prescale r that supports two clocking mo des, a synchronous clocking mode\nand an asynchronous clocking mode. The synchronous clocki ng mode uses the system clock (CK) as the clock\ntimebase and asynchronous mode uses the fast periphera l clock (PCK) as the clock time base. The PCKE bit from\nthe PLLCSR register enables the asyn chronous mode when it is set (‘1’).\nFigure 12-1. Timer/Counter1 Prescaler\nIn the asynchronous clocking mode the clock selections are from PCK to PCK/16384 and stop, and in the synchro-\nnous clocking mode the cl ock selections are from CK to CK/16384 and stop. The clock options are described in\nTable 12-5 on page 89  and the Timer/Counter1 Control Register, TCCR1. Setting the PSR1 bit in GTCCR register\nresets the prescaler. The PCKE bit in the PLLCSR regist er enables the asynchronous mode. The frequency of the\nfast peripheral clock is 64 MHz (or 32 MHz in Low Speed Mode).\n12.2 Counter and Compare Units\nThe Timer/Counter1 general operation is described in the asynchronous mode and the operation in the synchro-\nnous mode is mentioned only if there are differences between these two modes. Figure 12-2  shows Timer/Counter\n1 synchronization register block diagra m and synchronization delays in between registers. Note t hat all clock gat-\ning details are not shown in the figure. The Timer/Counter1 register values go through the internal synchronization\nregisters, which cause the input synchronization delay, before affecting the counter operation. The registers\nTCCR1, GTCCR, OCR1A, OCR1B, and OCR1C can be read back right after writing t he register. The read back\nvalues are delayed for the Timer/Counter1 (TCNT1) register and flags (OCF1A, OCF1B, and TOV1), because of\nthe input and output synchronization.\nThe Timer/Counter1 features a high resolution and a hi gh accuracy usage with the lower prescaling opportunities.\nIt can also support two accurate, high speed, 8-bit Puls e Width Modulators using clock speeds up to 64 MHz (or 32\nMHz in Low Speed Mode). In this mode, Timer/Counter1  and the output compare regi sters serve as dual stand-\nalone PWMs with non-overlapping non-inverted and inverted outputs. Refer to page 86  for a detailed description\non this function. Similarly, the high pr escaling opportunities make this unit us eful for lower speed functions or exact\ntiming functions with infrequent actions.TIMER/COUNTER1 COUNT ENABLEPSR1\nCS10\nCS11\nCS12PCK 64/32 MHz\n0\nCS1314-BIT\nT/C PRESCALER\nT1CK/2 T1CK T1CK/4 T1CK/8 T1CK/16 T1CK/32 T1CK/64 T1CK/128 T1CK/256 T1CK/512 T1CK/1024 T1CK/2048 T1CK/4096 T1CK/8192 T1CK/16384CKPCKE\nT1CK\n84 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 12-2. Timer/Counter 1 Synchronizat ion Register Block Diagram.\nTimer/Counter1 and the prescaler allow running the CPU fr om any clock source while the prescaler is operating on\nthe fast 64 MHz (or 32 MHz in Low Speed Mode) PCK clock in the asynchronous mode.\nNote that the system clock frequency  must be lower than one third of the PCK frequency. The synchronization\nmechanism of the asynchronous Timer/ Counter1 needs at least two edges of the PCK when the system clock is\nhigh. If the frequency of the system clock is too high, it is a risk that  data or control values are lost.\nThe following Figure 12-3  shows the block diagram for Timer/Counter1.8-BIT DATABUS\nOCR1A OCR1A_SI\nTCNT_SO OCR1B OCR1B_SI\nOCR1C OCR1C_SI\nTCCR1 TCCR1_SI\nGTCCR GTCCR_SI\nTCNT1 TCNT1_SI\nOCF1A OCF1A_SI\nOCF1B OCF1B_SI\nTOV1 TOV1_SI TOV1_SOOCF1B_SOOCF1A_SO\nTCNT1\nS\nA\nS\nAPCKE\nCK\nPCKIO-registers Input synchronization\nregistersTimer/Counter1 Output synchronization\nregisters\nSYNC\nMODE\nASYNC\nMODE1 CK Delay\n~1 CK Delay 1 PCK Delay No DelayTCNT1\nOCF1A\nOCF1B\nTOV1\n1/2 CK Delay 1 CK Delay 1/2 CK Delay\n1..2 PCK Delay\n85 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 12-3. Timer/Counter1 Block Diagram\nThree status flags (overflow and compar e matches) are found in the Timer/Counter Interrupt Flag Register - TIFR.\nControl signals are found in the Timer/Counter Contro l Registers TCCR1 and GTCCR.  The interrupt enable/dis-\nable settings are found in the Timer/Counter Interrupt Mask Register - TIMSK.\nThe Timer/Counter1 contains three Ou tput Compare Registers, OCR1A, OC R1B, and OCR1C as the data source\nto be compared with the Timer/Counter1 contents. In norm al mode the Output Compare functions are operational\nwith all three output compare register s. OCR1A determines action on the OC1A pin (PB1), and it can generate\nTimer1 OC1A interrupt in normal mode and in PWM mode . Likewise, OCR1B determines action on the OC1B pin\n(PB4) and it can generate Timer1 OC1B interrupt in normal mode and in PWM mode. OCR1C holds theTimer/Counter maximum value, i.e. the clear on compare match value. In the normal mode an overflow interrupt(TOV1) is generated when Timer/Counter1 counts from $ FF to $00, while in the PWM mode the overflow interrupt\nis generated when Timer/Counter1 count s either from $FF to $00 or from OCR1C to $00. The inverted PWM out-\nputs OC1A\n and OC1B  are not connected in normal mode.\nIn PWM mode, OCR1A and OCR1B provide the data values  against which the Timer Co unter value is compared.\nUpon compare match the PWM outputs (OC1A, OC1A , OC1B, OC1B ) are generated. In PWM mode, the Timer\nCounter counts up to the value specif ied in the output compare register O CR1C and starts again from $00. This\nfeature allows limiting the counter “full” value to a specified value, lower than $FF. Together with the many pres-\ncaler options, flexible PWM frequency selection is provided. Table 12-3 on page 88  lists clock selection and\nOCR1C values to obtain PWM frequencies from 20 kHz to 250 kHz in 10 kHz steps and from 250 kHz to 500 kHzin 50 kHz steps. Higher PWM frequencies can be obtained at the expense of resolution.8-BIT DATABUSTIMER INT. FLAG\nREGISTER (TIFR)\nTIMER/COUNTER1\n8-BIT COMPARATOR\nT/C1 OUTPUT\nCOMPARE REGISTERTIMER INT. MASK\nREGISTER (TIMSK)\nTIMER/COUNTER1\n(TCNT1)T/C CLEART/C1 CONTROL\nLOGICTOV1\nOCF1BOCF1BTOV1 TOIE0TOIE1OCIE1B OCIE1A OCF1A\nOCF1A\nCK\nPCKT/C1 OVER-\nFLOW IRQT/C1 COMPARE\nMATCH B IRQOC1A\n(PB1)T/C1 COMPARE\nMATCH A IRQ\nT/C CONTROL\nREGISTER 1 (TCCR1)\nCOM1B1 PWM1A PWM1BCOM1B0FOC1AFOC1B\n(OCR1A) (OCR1B) (OCR1C)8-BIT COMPARATOR\nT/C1 OUTPUT\nCOMPARE REGISTERTOV0\nCOM1A1COM1A0\n8-BIT COMPARATOR\nT/C1 OUTPUT\nCOMPARE REGISTERGLOBAL T/C CONTROL\nREGISTER (GTCCR)\nCS12 PSR1 CS11CS10 CS13 CTC1OC1A\n(PB0)OC1B\n(PB4)OC1B\n(PB3)\nDEAD TIME GENERATOR DEAD TIME GENERATOR\n86 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201312.2.1 Timer/Counter1 Initialization for Asynchronous Mode\nTo set Timer/Counter1  in asynchronous mode first e nable PLL and then wa it 100 µs for PLL to  stabilize. Next, poll\nthe PLOCK bit until it is se t and then set the PCKE bit.\n12.2.2 Timer/Counter1 in PWM Mode\nWhen the PWM mode is selected, Timer/Counter1 and the Output Compare Register C - OCR1C form a dual 8-bit,\nfree-running and glitch-free PWM generator with outputs on the PB1(OC1A) and PB4(OC1B) pins and inverted\noutputs on pins PB0(OC1A ) and PB3(OC1B ). As default non-overlapping times for complementary output pairs are\nzero, but they can be inserted using a Dead Time Generator (see description on page 100).\nFigure 12-4. The PWM Output Pair\nWhen the counter value match the contents of OCR1A or  OCR1B, the OC1A and OC1B outputs are set or cleared\naccording to the COM1A1/COM 1A0 or COM1B1/COM1B0 bits in the Time r/Counter1 Control Register A - TCCR1,\nas shown in Table 12-1 .\nTimer/Counter1 acts as an up-counter, counting from $00 up to the value specified in the output compare register\nOCR1C, and starting fr om $00 up again. A compare match with OC1C will set an overflow in terrupt flag (TOV1)\nafter a synchronization delay following the compare event.\nNote that in PWM mode, writing to the Output Compare Re gisters OCR1A or O CR1B, the data value is first trans-\nferred to a temporary location. The value is latche d into OCR1A or OCR1B when the Timer/Counter reaches\nOCR1C. This prevents the occurrence of odd-length PWM pulses (glitches) in the event of an unsynchronized\nOCR1A or OCR1B. See Figure 12-5  for an example.Table 12-1. Compare Mode Select in PWM Mode\nCOM1x1 COM1x0 Effect on Output Compare Pins\n00OC1x not connected.\nOC1x  not connected.\n01OC1x cleared on compare match. Set whenTCNT1 = $00.\nOC1x  set on compare match. Cleared when TCNT1 = $00.\n10OC1x cleared on compare match. Set when TCNT1 = $00. \nOC1x  not connected.\n11OC1x Set on compare match. Cleared when TCNT1= $00. \nOC1x  not connected.PWM1x\nPWM1x\nx = A or B tnon-overlap =0 tnon-overlap =0\n87 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 12-5. Effects of Unsynchronized OCR Latching\nDuring the time between the write and the latc h operation, a read from OCR1A or  OCR1B will read the contents of\nthe temporary location. This means that  the most recently written value alwa ys will read out of OCR1A or OCR1B.\nWhen OCR1A or OCR1B contain $00 or the top value, as specified in OCR1C register , the output PB1(OC1A) or\nPB4(OC1B) is held low or  high according to  the settings of COM1A1/COM1A0. This is shown in Table 12-2 .\nIn PWM mode, the Timer Overflow Flag - TOV1 is set when the TCNT1 counts to the OCR1C value and the\nTCNT1 is reset to $00. The Timer Overflow Interrupt1 is executed when TOV1 is set provided that Timer Overflow\nInterrupt and global interrupts are enabled. This also app lies to the Timer Output Compare flags and interrupts.\nThe frequency of the PW M will be Timer Clock 1 Frequency divided by (OCR1C value + 1). See the following\nequation:\nResolution shows how many bits are required to express the value in the OCR1C register and can be calculated\nusing the following equation:Table 12-2. PWM Outputs OCR1x = $00 or OCR1C, x = A or B\nCOM1x1 COM1x0 OCR1x Output OC1x Output OC1x\n0 1 $00 L H\n0 1 OCR1C H L\n1 0 $00 L Not connected.\n1 0 OCR1C H Not connected.1 1 $00 H Not connected.\n1 1 OCR1C L Not connected.PWM Output OC1x\nPWM Output OC1x\nUnsynchronized OC1x LatchSynchronized OC1x LatchCounter Value\nCompare Value\nCounter Value\nCompare ValueCompare Value changes\nGlitchCompare Value changes\nfPWMfTCK1\nOCR1C + 1\uf028\uf029----------------------------------- - =\nR 2O C R 1 C 1 + ()log=\n88 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Table 12-3. Timer/Counter1 Clock Prescale Se lect in the Asynchronous Mode\nPWM Frequency Clock Selection CS1[3:0] OCR1C RESOLUTION\n20 kHz PCK/16 0101 199 7.6\n30 kHz PCK/16 0101 132 7.1\n40 kHz PCK/8 0100 199 7.6\n50 kHz PCK/8 0100 159 7.360 kHz PCK/8 0100 132 7.1\n70 kHz PCK/4 0011 228 7.8\n80 kHz PCK/4 0011 199 7.690 kHz PCK/4 0011 177 7.5\n100 kHz PCK/4 0011 159 7.3\n110 kHz PCK/4 0011 144 7.2\n120 kHz PCK/4 0011 132 7.1\n130 kHz PCK/2 0010 245 7.9\n140 kHz PCK/2 0010 228 7.8150 kHz PCK/2 0010 212 7.7\n160 kHz PCK/2 0010 199 7.6\n170 kHz PCK/2 0010 187 7.6180 kHz PCK/2 0010 177 7.5\n190 kHz PCK/2 0010 167 7.4\n200 kHz PCK/2 0010 159 7.3250 kHz PCK 0001 255 8.0\n300 kHz PCK 0001 212 7.7\n350 kHz PCK 0001 182 7.5400 kHz PCK 0001 159 7.3\n450 kHz PCK 0001 141 7.1\n500 kHz PCK 0001 127 7.0\n89 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201312.3 Register Description\n12.3.1 TCCR1 – Timer/Counter1 Control Register\n• Bit 7 – CTC1 : Clear Timer/Counter on Compare Match\nWhen the CTC1 control bit is set (one), Timer/Counter1 is reset to $00 in the CPU clock cycle after a compare\nmatch with OCR1C register value. If the control bit is clea red, Timer/Counter1 continues counting and is unaffected\nby a compare match.\n• Bit 6 – PWM1A: Pulse Width Modulator A Enable\nWhen set (one) this bit enables PWM mode based on comparator OCR1A in Timer/Counter1 and the counter\nvalue is reset to $00 in the CPU clock cycle after a compare match with OCR1C register value.\n• Bits 5:4 – COM1A[1:0]: Comparator A Output Mode, Bits 1 and 0\nThe COM1A1 and COM1A0 control bits determine any output pin action following a compare match with compare\nregister A in Timer/Counter1. Since the output pin action is  an alternative function to an I/O port, the corresponding\ndirection control bit must be set (one) in order to control an output pin.\nIn Normal mode, the COM1A1 and COM1A0 control bits determine the output pin actions that affect pin PB1\n(OC1A) as described in Table 12-4 . Note that OC1A  is not connected in normal mode.\nIn PWM mode, these bits have different functions. Refer to Table 12-1 on page 86  for a detailed description.\n• Bits 3:0 - CS1[3:0]: Clock Se lect Bits 3, 2, 1, and 0\nThe Clock Select bits 3, 2, 1, and 0 defi ne the prescaling source of Timer/Counter1.Bit 7 6 5 4 3 2 1 0\n0x30 CTC1 PWM1A COM1A1 COM1A0 CS13 CS12 CS11 CS10 TCCR1\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nTable 12-4. Comparator A Mode Select in Normal Mode\nCOM1A1 COM1A0 Description\n0 0 Timer/Counter Comparator A disconnected from output pin OC1A.0 1 Toggle the OC1A output line.\n1 0 Clear the OC1A output line.\n1 1 Set the OC1A output line\nTable 12-5. Timer/Counter1 Pr escale Select \nCS13 CS12 CS11 CS10Asynchronous \nClocking Mode Synchronous\nClocking Mode \n0 0 0 0 T/C1 stopped T/C1 stopped000 1 P C K C K\n0 0 1 0 PCK/2 CK/2\n0 0 1 1 PCK/4 CK/4\n0 1 0 0 PCK/8 CK/8\n0 1 0 1 PCK/16 CK/160 1 1 0 PCK/32 CK/32\n90 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The Stop condition provides a Timer Enable/Disable function.\n12.3.2 GTCCR – General Timer/Counter1 Control Register\n• Bit 6 – PWM1B: Pulse Width Modulator B Enable\nWhen set (one) this bit enables PWM mode based on comparator OCR1B in Timer/Counter1 and the counter\nvalue is reset to $00 in the CPU clock cycle after a compare match with OCR1C register value.\n• Bits 5:4 – COM1B[1:0]: Comparator B Output Mode, Bits 1 and 0\nThe COM1B1 and COM1B0 control bits determine any output pin action following a compare match with compare\nregister B in Timer/Counter1. Since the output pin action is  an alternative function to an I/O port, the corresponding\ndirection control bit must be set (one) in order to control an output pin.\nIn Normal mode, the COM1B1 and COM1B0 control bits determine the output pin actions that affect pin PB4\n(OC1B) as described in Table 12-6 . Note that OC1B  is not connected in normal mode.\nIn PWM mode, these bits have different functions. Refer to Table 12-1 on page 86  for a detailed description.\n• Bit 3 – FOC1B: Force Output Compare Match 1B\nWriting a logical one to this bit forc es a change in the compare match output pin PB4 (OC1B) according to the val-\nues already set in COM1B1 and COM1B0. If COM1B1 and COM1B0 written in the same cycle as FOC1B, the new\nsettings will be used. The Force Output Compare bit can be  used to change the output pin value regardless of the\ntimer value. The automatic action programmed in COM1B1 and COM1B0 takes place as if a compare match had0 1 1 1 PCK/64 CK/64\n1 0 0 0 PCK/128 CK/1281 0 0 1 PCK/256 CK/256\n1 0 1 0 PCK/512 CK/512\n1 0 1 1 PCK/1024 CK/1024\n1 1 0 0 PCK/2048 CK/2048\n1 1 0 1 PCK/4096 CK/40961 1 1 0 PCK/8192 CK/8192\n1 1 1 1 PCK/16384 CK/16384Table 12-5. Timer/Counter1 Prescale  Select  (Continued)\nCS13 CS12 CS11 CS10Asynchronous \nClocking Mode Synchronous\nClocking Mode \nBit 7 6 5 4 3 2 1 0\n0x2C TSM PWM1B COM1B1 COM1B0 FOC1B FOC1A PSR1 PSR0 GTCCR\nRead/Write R/W R/W R/W R/W W W R/W R/WInitial value 0 0 0 0 0 0 0 0\nTable 12-6. Comparator B Mode Select in Normal Mode\nCOM1B1 COM1B0 Description\n0 0 Timer/Counter Comparator B disconnected from output pin OC1B.0 1 Toggle the OC1B output line.\n1 0 Clear the OC1B output line.\n1 1 Set the OC1B output line\n91 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013occurred, but no interrupt is generated. The FOC1B bit always reads as zero. FOC1B is not in use if PWM1B bit is\nset.\n• Bit 2 – FOC1A: Force Output Compare Match 1A\nWriting a logical one to this bit forc es a change in the compare match output pin PB1 (OC1A) according to the val-\nues already set in COM1A1 and COM1A0. If COM1A1 and COM1A0 written in the same cycle as FOC1A, the new\nsettings will be used. The Force Output Compare bit can be  used to change the output pin value regardless of the\ntimer value. The automatic action programmed in COM1A1 and COM1A0 takes place as if a compare match had\noccurred, but no interrupt is generated. The FOC1A bit always reads as zero. FOC1A is not in use if PWM1A bit is\nset.\n• Bit 1 – PSR1 : Prescaler Reset Timer/Counter1\nWhen this bit is set (one), the Time r/Counter prescaler (TCNT1  is unaffected) will be re set. The bit will be cleared\nby hardware after the operation is performed. Writing a zero to this bit will have no effect. This bit will always read\nas zero.\n12.3.3 TCNT1 – Timer/Counter1\nThis 8-bit register contains the value of Timer/Counter1.\nTimer/Counter1 is realized as an up counter with r ead and write access. Due to synchronization of the CPU,\nTimer/Counter1 data written into Timer/Counter1 is del ayed by one and half CPU clock cycles in synchronous\nmode and at most one CPU clock cycles for asynchronous mode.\n12.3.4 OCR1A –Timer/Counter1 Output Compare RegisterA\nThe output compare register A is an 8-bit read/write register.\nThe Timer/Counter Output Compare R egister A contains data to be conti nuously compared with Timer/Counter1.\nActions on compare matches are specified in TCCR1. A co mpare match does only occur if Timer/Counter1 counts\nto the OCR1A value. A software write that sets TCNT1 and OCR1A to the same value does not generate a com-\npare match.\nA compare match will set the compare interrupt fl ag OCF1A after a synchronizat ion delay followin g the compare\nevent.\n12.3.5 OCR1B – Timer/Counter1 Output Compare RegisterB\nThe output compare register B is an 8-bit read/write register.\nThe Timer/Counter Output Compare R egister B contains data to be conti nuously compared with Timer/Counter1.\nActions on compare matches are specified in TCCR1. A co mpare match does only occur if Timer/Counter1 countsB i t 76543210\n0x2F MSB LSB TCNT1\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nB i t 765432100x2E MSB LSB OCR1A\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nB i t 765432100x2B MSB LSB OCR1B\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\n92 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013to the OCR1B value. A software write that sets TCNT1 and OCR1B to the same value does not generate a com-\npare match.\nA compare match will set the compare interrupt fl ag OCF1B after a synchronizat ion delay followin g the compare\nevent.\n12.3.6 OCR1C – Timer/Counter1 Output Compare RegisterC\nThe output compare register C is an 8-bit read/write register.\nThe Timer/Counter Output Compare R egister C contains data to be conti nuously compared with Timer/Counter1.\nA compare match does only occur if Timer/ Counter1 counts to the OCR1C value.  A software write that sets TCNT1\nand OCR1C to the same value does not generate a compare match. If the CTC1 bit in TCCR1 is set, a compare\nmatch will clear TCNT1.\nThis register has the same function in normal mode and PWM mode. \n12.3.7 TIMSK – Timer/Counter Interrupt Mask Register\n• Bit 7 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.\n• Bit 6 – OCIE1A: Timer/Counter1 Output Compare Interrupt Enable\nWhen the OCIE1A bit is set (one) and the I-bit in the Stat us Register is set (one), the Timer/Counter1 Compare\nMatchA, interrupt is enabled. The corresponding interrupt at vector $003 is executed if a compare matchA occurs.\nThe Compare Flag in Timer/Counter1 is set (one) in the Timer/Counter Interrupt Flag Register.\n• Bit 5 – OCIE1B: Timer/Counter1 Output Compare Interrupt Enable\nWhen the OCIE1B bit is set (one) and the I-bit in the Stat us Register is set (one), the Timer/Counter1 Compare\nMatchB, interrupt is enabled. The corresponding interrupt at vector $009 is executed if a compare matchB occurs.\nThe Compare Flag in Timer/Counter1 is set (one) in the Timer/Counter Interrupt Flag Register.\n• Bit 2 – TOIE1: Timer/Counter1 Overflow Interrupt Enable\nWhen the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow inter-\nrupt is enabled. The corresponding interrupt (at vector $004 ) is executed if an overflow  in Timer/Counter1 occurs.\nThe Overflow Flag (Timer1) is set (one) in the Timer/Counter Interrupt Flag Register - TIFR.\n• Bit 0 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.B i t 76543210\n0x2D MSB LSB OCR1C\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 1 1 1 1 1 1 1 1\nBit 7 6 5 4 3 2 1 00x39 – OCIE1A OCIE1B\nOCIE0A OCIE0B TOIE1 TOIE0 – TIMSK\nRead/Write R R/W R/W R/W R/W R/W R/W RInitial value 0 0 0 0 0 0 0 0\n93 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201312.3.8 TIFR – Timer/Counter Interrupt Flag Register\n• Bit 7 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.\n• Bit 6 – OCF1A: Output Compare Flag 1A\nThe OCF1A bit is set (one) when compare match occurs between Timer/Counter1 and the data value in OCR1A -\nOutput Compare Register 1A. OCF1A is cleared by hardwa re when executing the corr esponding interrupt handling\nvector. Alternatively, OCF1A is cleared, after synchronizati on clock cycle, by writing a logic one to the flag. When\nthe I-bit in SREG, OCIE1A, and OCF1A are set (one), the Timer/Counter1 A compare match interrupt is executed.\n• Bit 5 – OCF1B: Output Compare Flag 1B\nThe OCF1B bit is set (one) when compare match occurs between Timer/Counter1 and the data value in OCR1B -\nOutput Compare Register 1A. OCF1B is cleared by hardwa re when executing the corr esponding interrupt handling\nvector. Alternatively, OCF1B is cleared, after synchronizati on clock cycle, by writing a logic one to the flag. When\nthe I-bit in SREG, OCIE1B, and OCF1B are set (one), the Timer/Counter1 B compare match interrupt is executed.\n• Bit 2 – TOV1: Timer/Counter1 Overflow Flag\nIn normal mode (PWM1A=0 and PWM1B=0) the bit TOV1 is set (one) when an overflow occurs in Timer/Counter1.\nThe bit TOV1 is cleared by hardware when executing t he corresponding interrupt handling vector. Alternatively,\nTOV1 is cleared, after synchronization clock cycle, by writing a logical one to the flag. \nIn PWM mode (either PWM1A=1 or PWM1B=1) the bit TO V1 is set (one) when compare match occurs between\nTimer/Counter1 and data value in OCR1C - Output Compare Register 1C.\nWhen the SREG I-bit, and TOIE1 (Timer/Counter1 Overflow Interrupt Enable), and TOV1 are set (one), the\nTimer/Counter1 Overflow interrupt is executed.\n• Bit 0 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.Bit 7 6 5 4 3 2 1 0\n0x38 –O C F 1 A O C F 1 B OCF0A OCF0B TOV1 TOV0 – TIFR\nRead/Write R R/W R/W R/W R/W R/W R/W RInitial value 0 0 0 0 0 0 0 0\n94 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201312.3.9 PLLCSR – PLL Control and Status Register\n• Bit 7 – LSM: Low Speed Mode\nThe high speed mode is enabled as def ault and the fast peripheral clock is 64 MHz, but the low speed mode can\nbe set by writing the LSM bit to one. Then the fast peripheral clock is scaled down to 32 MHz. The low speed mode\nmust be set, if the supply voltage is be low 2.7 volts, because the Timer/Counter1 is not running fast enough on low\nvoltage levels. It is highly recommen ded that Timer/Counter1 is stopped whenever the LSM bit is changed.\nNote, that LSM can not be set if PLLCLK is used as system clock.\n• Bit 6:3 – Res : Reserved Bits\nThese bits are reserved bits in the AT tiny25/45/85 and always read as zero.\n• Bit 2 – PCKE: PCK Enable\nThe PCKE bit change the Timer/Counter1 clock source. When it is set, the asynchronous clock mode is enabled\nand fast 64 MHz (or 32 MHz in Low Speed Mode) PCK cloc k is used as Timer/Counter1 clock source. If this bit is\ncleared, the synchronous clock mode is enabled, and sys tem clock CK is used as Timer/Counter1 clock source.\nThis bit can be set only if PLLE bit is se t. It is safe to set this bit only when the PLL is locked i.e the PLOCK bit is 1.\nThe bit PCKE can only be set, if the PLL has been enabled earlier.\n• Bit 1 – PLLE: PLL Enable\nWhen the PLLE is set, the PLL is starte d and if needed internal RC-oscillator is  started as a PLL reference clock. If\nPLL is selected as a system clock sour ce the value for th is bit is always 1.\n• Bit 0 – PLOCK: PLL Lock Detector\nWhen the PLOCK bit is set, the PLL is locked to the re ference clock. The PLOCK bit should be ignored during ini-\ntial PLL lock-in sequence when PLL frequency overshoots and undershoots, before reaching steady state. The\nsteady state is obtained within 100 µs. After PLL lock-in it is recommended to check the PLOCK bit before enabling\nPCK for Timer/Counter1.B i t 76543210\n0x27 LSM - - - - PCKE PLLE PLOCK PLLCSR\nRead/Write R/W R R R R R/W R/W RInitial value 0 0 0 0 0 0 0/1 0\n95 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201313. 8-bit Timer/Counter1 in ATtiny15 Mode\nThe ATtiny15 compatibility mode  is selected by writing th e code “0011” to the CKSEL fuses (if any other code is\nwritten, the Timer/Counter1 is work ing in normal mode).  When selected the ATtiny 15 compatibility mode provides\nan ATtiny15 backward compatible prescaler and Timer/Co unter. Furthermore, the clocking system has same clock\nfrequencies as in ATtiny15.\n13.1 Timer/Counter1 Prescaler\nFigure 13-1  shows an ATtiny15 compatible prescaler. It has two prescaler units, a 10-bi t prescaler for the system\nclock (CK) and a 3-bit prescaler for the fast peripheral clock (PCK). The clocking system of the Timer/Counter1 isalways synchronous in the ATtiny15 compatibility mode, bec ause the same RC Oscillator is used as a PLL clock\nsource (generates the input clock for the prescaler) and the AVR core.\nFigure 13-1. Timer/Counter1 Prescaler\nThe same clock selections as in ATtiny15 can be chosen for Timer/Counter1 from the output multiplexer, because\nthe frequency of the fast  peripheral clock is 25.6 MHz and the prescaler is similar in the ATtiny15 compatibility\nmode. The clock selections are PCK,  PCK/2, PCK/4, PCK/8, CK, CK/2, CK/4, CK/8, CK/16, CK/32, CK/64,\nCK/128, CK/256, CK/512, CK/1024 and stop.\n13.2 Counter and Compare Units\nFigure 13-2  shows Timer/Counter 1 synchronization register block diagram and synchronization delays in between\nregisters. Note that all clock gating details are not shown in the figure. The Timer/Counter1 register values go\nthrough the internal synchronization registers, which c ause the input synchronization delay, before affecting the\ncounter operation. The re gisters TCCR1, GTCCR, OCR1A and OCR1C ca n be read back right after writing the\nregister. The read back values are delayed for the Time r/Counter1 (TCNT1) register and flags (OCF1A and TOV1),\nbecause of the input and output synchronization.\nThe Timer/Counter1 features a high resolution and a hi gh accuracy usage with the lower prescaling opportunities.\nIt can also support an accurate, high speed, 8-bit Pulse Width Modulator (PWM) using clock speeds up to 25.6\nMHz. In this mode, Timer/Counter1 and the Output Compare Registers serve as a stand-alone PWM. Refer to\n“Timer/Counter1 in PWM Mode” on page 97  for a detailed description on this f unction. Similarly, the high prescal-\ning opportunities make this unit usef ul for lower speed functions or exact timing functions with infrequent actions.TIMER/COUNTER1 COUNT ENABLEPSR1\nCS10\nCS11\nCS12PCK  (25.6 MHz)\n0\nCS133-BIT T/C PRESCALER\nPCK/2 PCK PCK/4 PCK/8 CK/2 CK/4 CK/8 CK/16 CK/32 CK/64 CK/128 CK/256 CK/512 CK/102410-BIT T/C PRESCALERCK  (1.6 MHz)\nCKCLEAR CLEAR\n96 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 13-2. Timer/Counter 1 Synchronizat ion Register Block Diagram.\nTimer/Counter1 and the prescaler allow running the CPU fr om any clock source while the prescaler is operating on\nthe fast 25.6 MHz PCK clock in the asynchronous mode.\nThe following Figure 13-3  shows the block diagram for Timer/Counter1.8-BIT DATABUS\nOCR1A OCR1A_SI\nTCNT_SO OCR1C OCR1C_SI\nTCCR1 TCCR1_SI\nGTCCR GTCCR_SI\nTCNT1 TCNT1_SI\nOCF1A OCF1A_SI\nTOV1 TOV1_SI TOV1_SOOCF1A_SOTCNT1\nS\nA\nS\nAPCKE\nCK\nPCKIO-registers Input synchronization\nregistersTimer/Counter1 Output synchronization\nregisters\nSYNC\nMODE\nASYNC\nMODE1 PCK Delay No Delay ~1 CK Delay\n1PCK Delay No DelayTCNT1\nOCF1A\nTOV1\n1..2 PCK Delay\n~1 CK Delay 1..2 PCK Delay\n97 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 13-3. Timer/Counter1 Block Diagram\nTwo status flags (overflow and compare match) are found in the Timer/Counter Interrupt Flag Register - TIFR.\nControl signals are found in the Timer/Counter Contro l Registers TCCR1 and GTCCR.  The interrupt enable/dis-\nable settings are found in the Timer/Counter Interrupt Mask Register - TIMSK.\nThe Timer/Counter1 contains two Output Compare Regist ers, OCR1A and OCR1C as the data source to be com-\npared with the Timer/Counter1 contents. In normal mode the Output Compare functions are operational withOCR1A only. OCR1A determines action on the OC1A pin (PB1),  and it can generate Timer1 OC1A interrupt in nor-\nmal mode and in PWM mode. OCR1C holds the Timer/Counte r maximum value, i.e. the clear on compare match\nvalue. In the normal mode an overflow interrupt (TOV1) is generated when Timer/Counter1 counts from $FF to$00, while in the PWM mode the overfl ow interrupt is generated when the Ti mer/Counter1 counts either from $FF\nto $00 or from OCR1C to $00.\nIn PWM mode, OCR1A provides the data values against which the Timer Counter value is compared. Upon com-\npare match the PWM outputs (OC1A) is  generated. In PWM mode, the Timer Counter counts up to the value\nspecified in the output compare register OCR1C and starts again from $00. This feature allows limiting the counter\n“full” value to a specified value, lower than $FF. Together with the many  prescaler options, flexible PWM frequency\nselection is provided. Table 12-3 on page 88  lists clock selection and OCR1C values to obtain PWM frequencies\nfrom 20 kHz to 250 kHz in 10 kHz steps and from 250 kHz to 500 kHz in 50 kHz steps. Higher PWM frequencies\ncan be obtained at the expense of resolution.\n13.2.1 Timer/Counter1 in PWM Mode\nWhen the PWM mode is selected, Timer/Counter1 and the Output Compare Register A - OCR1A form an 8-bit,\nfree-running and glitch-free PWM gen erator with output on the PB1(OC1A). 8-BIT DATABUSTIMER INT. FLAG\nREGISTER (TIFR)\nTIMER/COUNTER1\n8-BIT COMPARATOR\nT/C1 OUTPUT\nCOMPARE REGISTERTIMER INT. MASK\nREGISTER (TIMSK)\nTIMER/COUNTER1\n(TCNT1)T/C CLEART/C1 CONTROL\nLOGICTOV1TOV1 TOIE0TOIE1 OCIE1A OCF1A\nOCF1A\nCK\nPCKT/C1 OVER-\nFLOW IRQOC1A\n(PB1)T/C1 COMPARE\nMATCH A IRQ\nGLOBAL T/C CONTROL\nREGISTER 2 (GTCCR)\nPWM1AFOC1A\n(OCR1A) (OCR1C)8-BIT COMPARATOR\nT/C1 OUTPUT\nCOMPARE REGISTERTOV0\nCOM1A1COM1A0T/C CONTROL\nREGISTER 1 (TCCR1)\nCS12 PSR1 CS11CS10 CS13 CTC1\n98 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013When the counter value match the content of OCR1A, t he OC1A and output is set or cleared according to the\nCOM1A1/COM1A0 bits in the Ti mer/Counter1 Control Register A - TCCR1, as shown in Table 13-1 .\nTimer/Counter1 acts as an up-counter, counting from $00 up to the value specified in the output compare register\nOCR1C, and starting from $00 up aga in. A compare match with OCR1C will se t an overflow interrupt flag (TOV1)\nafter a synchronization delay following the compare event.\nNote that in PWM mode, writing to the Output Compare Register OCR1A, the data value is first transferred to a\ntemporary location. The value is latc hed into OCR1A when the Timer/Counte r reaches OCR1C. This prevents the\noccurrence of odd-length PWM pulses (glitches) in the event of an unsynchronized OCR1A. See Figure 13-4  for an\ne xample.\nFigure 13-4. Effects of Unsynchronized OCR Latching\nDuring the time between the write and the latch operation, a read from OCR1 A will read the cont ents of the tempo-\nrary location. This means that  the most recently written va lue always will read out of OCR1A.\nWhen OCR1A contains $00 or the top value, as specifie d in OCR1C register, the outpu t PB1(OC1A) is held low or\nhigh according to the settings of COM1A1/COM1A0. This is shown in Table 13-2 .Table 13-1. Compare Mode Select in PWM Mode\nCOM1A1 COM1A0 Effect on  Output Compare Pin\n0 0 OC1A not connected.\n0 1 OC1A not connected.1 0 OC1A cleared on compare match. Set when TCNT1 = $00.\n1 1 OC1A set on compare match. Cleared when TCNT1 = $00.\nTable 13-2. PWM Outputs OCR1A = $00 or OCR1C\nCOM1A1 COM1A0 OCR1A Output OC1A\n01 $ 0 0 L\n0 1 OCR1C H\n10 $ 0 0 LPWM Output OC1A\nPWM Output OC1A\nUnsynchronized OC1A LatchSynchronized OC1A LatchCounter Value\nCompare Value\nCounter Value\nCompare ValueCompare Value changes\nGlitchCompare Value changes\n99 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013In PWM mode, the Timer Overflow Flag - TOV1 is set when the TCNT1 counts to the OCR1C value and the\nTCNT1 is reset to $00. The Timer Overflow Interrupt1 is executed when TOV1 is set provided that Timer Overflow\nInterrupt and global interrupts are enabled. This also app lies to the Timer Output Compare flags and interrupts.\nThe PWM frequency can be derived from the timer/coun ter clock frequency using the following equation:\nThe duty cycle of the PWM waveform can be calculated using the following equation:\n...where TPCK is the period of the fast peripheral clock (1/25.6 MHz = 39.1 ns).\nResolution indicates how many bits are required to expres s the value in the OCR1C regi ster. It can be calculated\nusing the following equation:1 0 OCR1C H\n11 $ 0 0 H\n1 1 OCR1C L\nTable 13-3. Timer/Counter1 Clock Prescale Se lect in the Asynchronous Mode\nPWM Frequency Clock Select ion CS1[3:0] OCR1C RESOLUTION\n20 kHz PCK/16 0101 199 7.6\n30 kHz PCK/16 0101 132 7.1\n40 kHz PCK/8 0100 199 7.650 kHz PCK/8 0100 159 7.3\n60 kHz PCK/8 0100 132 7.1\n70 kHz PCK/4 0011 228 7.880 kHz PCK/4 0011 199 7.6\n90 kHz PCK/4 0011 177 7.5\n100 kHz PCK/4 0011 159 7.3\n110 kHz PCK/4 0011 144 7.2\n120 kHz PCK/4 0011 132 7.1\n130 kHz PCK/2 0010 245 7.9140 kHz PCK/2 0010 228 7.8\n150 kHz PCK/2 0010 212 7.7Table 13-2. PWM Outputs OCR1A = $00 or OCR1C\nCOM1A1 COM1A0 OCR1A Output OC1A\nffTCK1\nOCR1C + 1\uf028\uf029----------------------------------- - =\nDOCR1A 1 + \uf028\uf029 TTCK1TPCK–\uf0b4\nOCR1C 1 + \uf028\uf029 TTCK1\uf0b4----------------------------------------------------------------------------=\nR 2O C R 1 C 1 + ()log=\n100 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201313.3 Register Description\n13.3.1 TCCR1 – Timer/Counter1 Control Register\n• Bit 7 – CTC1 : Clear Timer/Counter on Compare Match\nWhen the CTC1 control bit is set (one), Timer/Counter1 is reset to $00 in the CPU clock cycle after a compare\nmatch with OCR1A register. If the control bit is cleared, Timer/Counter1 cont inues counting and is unaffected by a\ncompare match.\n• Bit 6 – PWM1A: Pulse Width Modulator A Enable\nWhen set (one) this bit enables PWM mode based on comparator OCR1A in Timer/Counter1 and the counter\nvalue is reset to $00 in the CPU clock cycle after a compare match with OCR1C register value.\n• Bits 5:4 – COM1A[1:0]: Comparator A Output Mode, Bits 1 and 0\nThe COM1A1 and COM1A0 control bits determine any output pin action following a compare match with compare\nregister A in Timer/Counter1. Output pi n actions affect pin PB1 (OC1A). Since this is an alternative function to an\nI/O port, the corresponding direction control bit must be set (one) in order to control an output pin.\nIn PWM mode, these bits have different functions. Refer to Table 13-1 on page 98  for a detailed description.160 kHz PCK/2 0010 199 7.6\n170 kHz PCK/2 0010 187 7.6\n180 kHz PCK/2 0010 177 7.5\n190 kHz PCK/2 0010 167 7.4\n200 kHz PCK/2 0010 159 7.3\n250 kHz PCK 0001 255 8.0300 kHz PCK 0001 212 7.7\n350 kHz PCK 0001 182 7.5\n400 kHz PCK 0001 159 7.3450 kHz PCK 0001 141 7.1\n500 kHz PCK 0001 127 7.0Table 13-3. Timer/Counter1 Clock Prescale Select in the Asynchronous Mode (Continued)\nPWM Frequency Clock Select ion CS1[3:0] OCR1C RESOLUTION\nBit 7 6 5 4 3 2 1 0\n0x30 CTC1 PWM1A COM1A1 COM1A0 CS13 CS12 CS11 CS10 TCCR1A\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nTable 13-4. Comparator A Mode Select\nCOM1A1 COM1A0 Description\n0 0 Timer/Counter Comparator A disconnected from output pin OC1A.0 1 Toggle the OC1A output line.\n1 0 Clear the OC1A output line.\n1 1 Set the OC1A output line\n101 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bits 3:0 – CS1[3:0]: Clock Select Bits 3, 2, 1, and 0\nThe Clock Select bits 3, 2, 1, and 0 defi ne the prescaling source of Timer/Counter1.\nThe Stop condition provides a Timer Enable/Disable function.\n13.3.2 GTCCR – General Timer/Counter1 Control Register\n• Bit 2 – FOC1A: Force Output Compare Match 1A\nWriting a logical one to this bit forc es a change in the compare match output pin PB1 (OC1A) according to the val-\nues already set in COM1A1 and COM1A0. If COM1A1 and COM1A0 written in the same cycle as FOC1A, the new\nsettings will be used. The Force Output Compare bit can be  used to change the output pin value regardless of the\ntimer value. The automatic action programmed in COM1A1 and COM1A0 takes place as if a compare match had\noccurred, but no interrupt is generated. The FOC1A bit always reads as zero. FOC1A is not in use if PWM1A bit is\nset.\n• Bit 1 – PSR1 : Prescaler Reset Timer/Counter1\nWhen this bit is set (one), the Time r/Counter prescaler (TCNT1  is unaffected) will be re set. The bit will be cleared\nby hardware after the operation is performed. Writing a zero to this bit will have no effect. This bit will always read\nas zero.Table 13-5. Timer/Counter1 Pr escale Select \nCS13 CS12 CS11 CS10 T/C1 Clock\n0 0 0 0 T/C1 stopped00 0 1 P C K\n00 1 0 P C K / 2\n00 1 1 P C K / 4\n01 0 0 P C K / 8\n01 0 1 C K01 1 0 C K / 2\n01 1 1 C K / 4\n10 0 0 C K / 810 0 1 C K / 1 6\n10 1 0 C K / 3 2\n10 1 1 C K / 6 411 0 0 C K / 1 2 8\n11 0 1 C K / 2 5 6\n11 1 0 C K / 5 1 211 1 1 C K / 1 0 2 4\nBit 7 6 5 4 3 2 1 0\n0x2C TSM PWM1B COM1B1 COM1B0 FOC1B FOC1A PSR1 PSR0 GTCCR\nRead/Write R/W R/W R/W R/W W W R/W R/W\nInitial value 0 0 0 0 0 0 0 0\n102 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201313.3.3 TCNT1 – Timer/Counter1\nThis 8-bit register contains the value of Timer/Counter1.\nTimer/Counter1 is realized as an up counter with r ead and write access. Due to synchronization of the CPU,\nTimer/Counter1 data written into Timer/Counter1 is delayed by one CPU clock cycle in synchronous mode and at\nmost two CPU clock cycles  for asynchronous mode.\n13.3.4 OCR1A – Timer/Counter1 Output Compare RegisterA\nThe output compare register A is an 8-bit read/write register.\nThe Timer/Counter Output Compare R egister A contains data to be conti nuously compared with Timer/Counter1.\nActions on compare matches are specified in TCCR1. A co mpare match does only occur if Timer/Counter1 counts\nto the OCR1A value. A software write that sets TCNT1 and OCR1A to the same value does not generate a com-pare match.\nA compare match will set the compare interrupt fl ag OCF1A after a synchronizat ion delay followin g the compare\nevent.\n13.3.5 OCR1C – Timer/Counter1 Output Compare Register C\nThe Output Compare Register B - OCR1B from ATtiny15 is  replaced with the output compare register C - OCR1C\nthat is an 8-bit read/write register. This register has the same function as the Output Compare Register B inATtiny15.\nThe Timer/Counter Output Compare R egister C contains data to be conti nuously compared with Timer/Counter1.\nA compare match does only occur if Timer/ Counter1 counts to the OCR1C value.  A software write that sets TCNT1\nand OCR1C to the same value does not generate a compare match. If the CTC1 bit in TCCR1 is set, a comparematch will clear TCNT1.\n13.3.6 TIMSK – Timer/Counter Interrupt Mask Register\n• Bit 7 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.B i t 76543210\n0x2F MSB LSB TCNT1\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nB i t 765432100x2E MSB LSB OCR1A\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nB i t 765432100x2D MSB LSB OCR1C\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 1 1 1 1 1 1 1 1 \nBit 7 6 5 4 3 2 1 00x39 –O C I E 1 A\nOCIE1B OCIE0A OCIE0B TOIE1 TOIE0 – TIMSK\nRead/Write R R/W R/W R/W R/W R/W R/W RInitial value 0 0 0 0 0 0 0 0\n103 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 6 – OCIE1A: Timer/Counter1 Output Compare Interrupt Enable\nWhen the OCIE1A bit is set (one) and the I-bit in the Stat us Register is set (one), the Timer/Counter1 Compare\nMatchA, interrupt is enabled. The corresponding interrupt at vector $003 is executed if a compare matchA occurs.\nThe Compare Flag in Timer/Counter1 is set (one) in the Timer/Counter Interrupt Flag Register.\n• Bit 2 – TOIE1: Timer/Counter1 Overflow Interrupt Enable\nWhen the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow inter-\nrupt is enabled. The corresponding interrupt (at vector $004 ) is executed if an overflow  in Timer/Counter1 occurs.\nThe Overflow Flag (Timer1) is set (one) in the Timer/Counter Interrupt Flag Register - TIFR.\n• Bit 0 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.\n13.3.7 TIFR – Timer/Counter Interrupt Flag Register\n• Bit 7 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.\n• Bit 6 – OCF1A: Output Compare Flag 1A\nThe OCF1A bit is set (one) when compare match occurs between Timer/Counter1 and the data value in OCR1A -\nOutput Compare Register 1A. OCF1A is cleared by hardwa re when executing the corr esponding interrupt handling\nvector. Alternatively, OCF1A is cleared, after synchronizati on clock cycle, by writing a logic one to the flag. When\nthe I-bit in SREG, OCIE1A, and OCF1A are set (one), the Timer/Counter1 A compare match interrupt is executed.\n• Bit 2 – TOV1: Timer/Counter1 Overflow Flag\nThe bit TOV1 is set (one) when an overflow occurs in Ti mer/Counter1. TOV1 is cleared by hardware when execut-\ning the corresponding interrupt handling vector. Alternatively, TOV1 is cleared, after synchronization clock cycle,\nby writing a logical one to the flag. When the SREG I-bi t, and TOIE1 (Timer/Counter1 Overflow Interrupt Enable),\nand TOV1 are set (one), the Timer/Coun ter1 Overflow interrupt is executed.\n• Bit 0 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and always reads as zero.\n13.3.8 PLLCSR – PLL Control and Status Register\n• Bits 6:3 – Res : Reserved Bits\nThese bits are reserved bits in the AT tiny25/45/85 and always read as zero.\n• Bit 2 – PCKE: PCK Enable\nThe bit PCKE is always set in the ATtiny15 compatibility mode.\n• Bit 1 – PLLE: PLL Enable\nThe PLL is always en abled in the ATtiny15 compatibility mode.Bit 7 6 5 4 3 2 1 0\n0x38 –O C F 1 A OCF1B OCF0A OCF0B TOV1 TOV0 – TIFR\nRead/Write R R/W R/W R/W R/W R/W R/W RInitial value 0 0 0 0 0 0 0 0\nB i t 765432100x27\nLSM – – – – PCKE PLLE PLOCK PLLCSR\nRead/Write R/W R R R R R/W R/W RInitial value 0 0 0 0 0 0 0/1 0\n104 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 0 – PLOCK: PLL Lock Detector\nWhen the PLOCK bit is set, the PLL is locked to the re ference clock. The PLOCK bit should be ignored during ini-\ntial PLL lock-in sequence when PLL frequency overshoots and undershoots, before reaching steady state. Thesteady state is obtained within 100 µs. After PLL lock-in it is recommended to check the PLOCK bit before enabling\nPCK for Timer/Counter1.\n105 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201314. Dead Time Generator\nThe Dead Time Generator is provided for the Timer/Count er1 PWM output pairs to allow driving external power\ncontrol switches safely. The Dead Time  Generator is a separate block that  can be connected to Timer/Counter1\nand it is used to insert dead times (non-overlapping ti mes) for the Timer/Counter1 complementary output pairs\n(OC1A-OC1A  and OC1B-OC1B ). The sharing of tasks is as follows: the timer/counter gen erates the PWM output\nand the Dead Time Generator generates the non-overlapp ing PWM output pair from the timer/counter PWM signal.\nTwo Dead Time Generators are provided, one for each PW M output. The non-overlap time is adjustable and the\nPWM output and it’s complementary output are adjusted  separately, and independently for both PWM outputs.\nFigure 14-1. Timer/Counter1 & Dead Time Generators\nThe dead time generation is based on th e 4-bit down counters t hat count the dead time, as shown in Figure 46.\nThere is a dedicated prescaler in front of the Dead Time Generator that can divide the Timer/Counter1 clock (PCK\nor CK) by 1, 2, 4 or 8. This provides for large range of dead times that can be generated. The prescaler is con-\ntrolled by two control bits DTPS1[1:0] from the I/O regist er at address 0x23. The block has also a rising and falling\nedge detector that is used to start the dead time counting  period. Depending on the edge, one of the transitions on\nthe rising edges, OC1x or OC1x  is delayed until the counter has counted to zero. The comparator is used to com-\npare the counter with zero and stop the dead time insertion when zero has been reached. The counter is loaded\nwith a 4-bit DT1xH or DT1xL value from DT1x I/O register, depending on the edge of the PWM generator outputwhen the dead time insertion is started. \nFigure 14-2. Dead Time Generator\nThe length of the counting period is us er adjustable by selecting the dead time prescaler setting in 0x23 register,\nand selecting then the dead time value in I/O register DT1x . The DT1x register consists  of two 4-bit fields, DT1xH\nand DT1xL that control the dead time per iods of the PWM output and its’ co mplementary output separately. ThusTIMER/COUNTER1\nOC1A OC1A OC1B OC1BDEAD TIME GENERATORPWM GENERATORPCKE\nT15M\nPCKCK\nDT1AH DT1BH\nDEAD TIME GENERATORPWM1B PWM1A\nDT1AL DT1BL\nCLOCK CONTROLOC1x\nOC1xT/C1 CLOCK\nPWM1x4-BIT COUNTERCOMPARATOR\nDT1xLDT1xH\nDT1x\nI/O REGISTERDEAD TIMEPRESCALERDTPS1[1:0]\n106 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013the rising edge of OC1x and OC1x  can have different dead time periods. The dead time is adjusted as the number\nof prescaled dead time generator clock cycles. \nFigure 14-3. The Complementary Output Pair \n14.1 Register Description\n14.1.1 DTPS1 – Timer/Counter1 Dead Time Prescaler Register 1\nThe dead time prescaler register, DT PS1 is a 2-bit read/write register.\n• Bits 1:0 – DTPS1[1:0]: Dead Time Prescaler\nThe dedicated Dead Time prescaler in front of the Dead  Time Generator can divide the Timer/Counter1 clock (PCK\nor CK) by 1, 2, 4 or 8 providing a large range of dead times that can be generated. The Dead Time prescaler is\ncontrolled by two bits DTPS1[1:0] from the Dead Time Prescaler register. These bits define the division factor of\nthe Dead Time prescaler. The division factors are given in table 46.OC1x\nx = A or B\ntnon-overlap / rising edge tnon-overlap / falling edgeOC1xPWM1x\nB i t 76543210\n0x23 DTPS11 DTPS10 DTPS1\nRead/Write R R R R R R R/W R/WInitial value 0 0 0 0 0 0 0 0\nTable 14-1. Division factors of the Dead Time prescaler\nDTPS11 DTPS10 Prescaler divides the T/C1 clock by\n0 0 1x (no division)\n01 2 x\n10 4 x11 8 x\n107 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201314.1.2 DT1A – Timer/Counter1 Dead Time A\nThe dead time value register A is an 8-bit read/write register.\nThe dead time delay of is adjusted by the dead time va lue register, DT1A. The regist er consists of two fields,\nDT1AH[3:0] and DT1AL[3:0], one for each complementary output. Therefore a different dead time delay can beadjusted for the rising edge of OC1A and the rising edge of OC1A\n.\n• Bits 7:4 – DT1AH[3:0]: Dead Time Value for OC1A Output\nThe dead time value for the OC1A output. The dead time delay is set as a number of  the prescal ed timer/counter\nclocks. The minimum dead time is ze ro and the maximum dead time is th e prescaled time/counter clock period\nmultiplied by 15.\n• Bits 3:0 – DT1AL[3:0]: Dead Time Value for OC1A  Output\nThe dead time value for the OC1A  output. The dead time delay is set as  a number of the pr escaled timer/counter\nclocks. The minimum dead time is ze ro and the maximum dead time is th e prescaled time/counter clock period\nmultiplied by 15.\n14.1.3 DT1B – Timer/Counter1 Dead Time B\nThe dead time value register Bis an 8-bit read/write register.\nThe dead time delay of is adjusted by the dead time va lue register, DT1B. The regist er consists of two fields,\nDT1BH[3:0] and DT1BL[3:0], one for each complementary output. Therefore a different dead time delay can beadjusted for the rising edge of OC1A and the rising edge of OC1A\n.\n• Bits 7:4 – DT1BH[3:0]: Dead Time Value for OC1B Output\nThe dead time value for the OC1B output. The dead time delay is set as a number of  the prescal ed timer/counter\nclocks. The minimum dead time is ze ro and the maximum dead time is th e prescaled time/counter clock period\nmultiplied by 15.\n• Bits 3:0 – DT1BL[3:0]: Dead Time Value for OC1B  Output\nThe dead time value for the OC1B  output. The dead time delay is set as  a number of the pr escaled timer/counter\nclocks. The minimum dead time is ze ro and the maximum dead time is th e prescaled time/counter clock period\nmultiplied by 15.B i t 76543210\n0x25 DT1AH3 DT1AH2 DT1AH1 DT1AH0 DT1AL3 DT1AL2 DT1AL1 DT1AL0 DT1A\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\nB i t 765432100x24 DT1BH3 DT1BH2 DT1BH1 DT1BH0 DT1BL3 DT1BL2 DT1BL1 DT1BL0 DT1B\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial value 0 0 0 0 0 0 0 0\n108 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201315. USI – Universal Serial Interface\n15.1 Features\n•Two-wire Synchronous Data Transfer (Master or Slave)\n•Three-wire Synchronous Data Transfer (Master or Slave)\n•Data Received Interrupt\n•Wakeup from Idle Mode\n•Wake-up from All Sleep Modes In Two-wire Mode\n•Two-wire Start Condition Detect or with Interrupt Capability\n15.2 Overview\nThe Universal Serial Interface (USI), provides t he basic hardware resources needed for serial communication.\nCombined with a minimum of control softw are, the USI allows significantly higher transfer rates and uses less code\nspace than solutions based on software only. Interrupts are included to minimize the processor load. \nA simplified block diagram of the USI is shown in Figure 15-1  For actual placement of I/O pins refer to “Pinout\nATtiny25/45/85” on page 2 . Device-specific I/O Register and bit locations are listed in the “Register Descriptions”\non page 115 .\nFigure 15-1. Universal Serial Interface, Block Diagram\nThe 8-bit USI Data Register (USIDR) co ntains the incoming and outgoing data. It is directly accessible via the data\nbus but a copy of the contents is also placed in the USI Buffer Register (USIBR) where it can be retrieved later. If\nreading the USI Data Register directly, the register must be read as quickly as possible to ensure that no data is\nlost.\nThe most significant bit of the USI Data Register is connected to one of  two output pins (depending on the mode\nconfiguration, see “USICR – USI Control Register” on page 116 ). There is a transparent  latch between the output\nof the USI Data Register and the out put pin, which delays th e change of data output to the opposite clock edge of\nthe data input sampling. The serial input is always sa mpled from the Data Input (DI) pin independent of the\nconfiguration.\nDATA BUS\nUSIPF\nUSITCUSICLKUSICS0USICS1USIOIF USIOIE\nUSIDCUSISIF\nUSIWM0USIWM1USISIE Bit7Two-wire\n Clock\nControl UnitDO(Output only)\nDI/SDA(Input/Open Drain)\nUSCK/SCL(Input/Open Drain)\n4-bit CounterUSIDR\nUSISRDQ\nLE\nUSICRCLOCK\nHOLDTIM0 COMPBit0\n[1]3\n0123\n012\n0\n1\n2USIBR\n109 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The 4-bit counter can be both read and written via the data bu s, and it can generate an overflow interrupt. Both the\nUSI Data Register and the counter ar e clocked simultaneously by the same clock source. This allows the counter\nto count the number of bits received or transmitted and generate an interrupt when the transfer is complete. Note\nthat when an external clock source is selected the coun ter counts both clock edges. This means the counter regis-\nters the number of clock edges and not the number of data bits. The clock can be selected from three different\nsources: The USCK pin, Timer/Counter0 Compare Match or from software.\nThe two-wire clock control unit can be configured to generat e an interrupt when a start condition has been detected\non the two-wire bus. It can also be set to generate wait st ates by holding the clock pin low after a start condition is\ndetected, or after the counter overflows.\n15.3 Functional Descriptions\n15.3.1 Three-wire Mode\nThe USI three-wire mode is compliant to the Serial Peripheral Interface (SPI) mode 0 and 1, but does not have the\nslave select  (SS) pin functionality. However, this feature can be implemented in software, if required. Pin names\nused in this mode are DI, DO, and USCK.\nFigure 15-2. Three-wire Mode Operation, Simplified Diagram\nFigure 15-2  shows two USI units operating in three-wire mode, one as Master and one as  Slave. The two USI Data\nRegisters are interconnected in such way that after eight USCK clocks, the data in ea ch register has been inter-\nchanged. The same clock also increments the USI’s 4-bi t counter. The Counter Overflow (interrupt) Flag, or\nUSIOIF, can therefore be used to determine when a transfe r is completed. The clock is generated by the Master\ndevice software by toggling the USCK pin via the PORTB re gister or by writing a one to bit USITC bit in USICR.SLAVE\nMASTERBit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0DO\nDI\nUSCK\nBit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0DO\nDI\nUSCK\nPORTxn\n110 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 15-3. Three-Wire Mode, Timing Diagram\nThe three-wire mode timing is shown in Figure 15-3  At the top of the figure is a USCK cycle reference. One bit is\nshifted into the USI Data Register (USIDR) for each of these cycles. The USCK timi ng is shown for both external\nclock modes. In external clock mode 0 (USICS0 = 0), DI is sampled at positiv e edges, and DO is changed (USI\nData Register is shifted by one) at  negative edges. In external clock mo de 1 (USICS0 = 1) the opposite edges with\nrespect to mode 0 are used. In other words, data is samp led at negative and changes the output at positive edges.\nThe USI clock modes corresponds to the SPI data mode 0 and 1.\nReferring to the timing diagram ( Figure 15-3 ), a bus transfer involves the following steps:\n1. The slave and master devices set up their data outp uts and, depending on the protocol used, enable their \noutput drivers (mark A and B). The output is set up by writing the data to be transmitted to the USI Data \nRegister. The output is enabled by setting the correspo nding bit in the Data Direction Register of Port B. \nNote that there is not a preferred order of points A and B in the figure, but both must be at least one half USCK cycle before point C, where the data is sampled. This is in order to ensure that the data setup requirement is satisfied. The 4-bit counter is reset to zero.\n2. The master software generates a clock pulse by togg ling the USCK line twice (C and D). The bit values on \nthe data input (DI) pins are sampled by the USI on th e first edge (C), and the data output is changed on \nthe opposite edge (D). The 4- bit counter will co unt both edges.\n3. Step 2. is repeated eight times for a complete register (byte) transfer.\n4. After eight clock pulses (i.e., 16 clock edges) the co unter will overflow and indica te that the transfer has \nbeen completed. If USI Buffer Registers are not used the data bytes that have been transferred must now \nbe processed before a new transfer c an be initiated. The overflow interr upt will wake up the processor if it \nis set to Idle mode. Depending of the protocol us ed the slave device can now set its output to high \nimpedance.\n15.3.2 SPI Master Operation Example\nThe following code demonstrates how to use the USI as an SPI Master:\nSPITransfer:\nout USIDR,r16ldi r16,(1<<USIOIF)\nout USISR,r16\nldi r16,(1<<USIWM0)|(1<<USICS1)|(1<<USICLK)|(1<<USITC)\nSPITransfer_loop:\nout USICR,r16\nin r16, USISRsbrs r16, USIOIF\nrjmp SPITransfer_loop\nin r16,USIDR\nretMSB\nMSB654321 L S B1 2 3 4 5 6 7 8\n654321 L S BUSCK\nUSCK\nDO\nDI\nD C B A ECYCLE ( Reference )\n111 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013The code is size optimized using only ei ght instructions (plus return). The code example assumes that the DO and\nUSCK pins have been enabled as outputs in DDRB. The value stored in register r16 prior to the function is called is\ntransferred to the slave device, and when the transfer is completed the data received from the slave is stored back\ninto the register r16.\nThe second and third instructions clear the USI Counter Ov erflow Flag and the USI counter value. The fourth and\nfifth instructions set three-wire mode, positive edge clock, count at USITC strobe, and toggle USCK. The loop is\nrepeated 16 times.\nThe following code demonstrates how to use the USI as an SPI master with maximum speed (fSCK = fCK/2):\nSPITransfer_Fast:\nout USIDR,r16\nldi r16,(1<<USIWM0)|(0<<USICS0)|(1<<USITC)ldi r17,(1<<USIWM0)|(0<<USICS0)|(1<<USITC)|(1<<USICLK)\nout USICR,r16 ; MSB\nout USICR,r17\nout USICR,r16\nout USICR,r17out USICR,r16\nout USICR,r17\nout USICR,r16out USICR,r17\nout USICR,r16\nout USICR,r17out USICR,r16\nout USICR,r17\nout USICR,r16out USICR,r17\nout USICR,r16 ; LSB\nout USICR,r17\nin r16,USIDR\nret\n15.3.3 SPI Slave Operation Example \nThe following code demonstrates how to use the USI as an SPI slave:\ninit:\nldi r16,(1<<USIWM0)|(1<<USICS1)\nout USICR,r16\n...SlaveSPITransfer:\nout USIDR,r16\nldi r16,(1<<USIOIF)\nout USISR,r16\nSlaveSPITransfer_loop:\nin r16, USISR\n112 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013sbrs r16, USIOIF\nrjmp SlaveSPITransfer_loopin r16,USIDR\nret\nThe code is size optimized using only ei ght instructions (plus return). The code example assumes that the DO and\nUSCK pins have been enabled as outputs in DDRB. The value stored in register r16 prior to the function is called is\ntransferred to the master device, and when the transfer is completed the data received from the master is stored\nback into the register r16.\nNote that the first two instructions is for initialization, only, and need only be  executed once. Thes e instructions set\nthree-wire mode and positive edge clock. The loop is  repeated until the USI Co unter Overflow Flag is set.\n15.3.4 Two-wire Mode\nThe USI two-wire mode is comp liant to the Inter IC (TWI) bus protocol, but without slew  rate limiting on outputs and\nwithout input noise filtering. Pin names used in this mode are SCL and SDA.\nFigure 15-4. Two-wire Mode Operation, Simplified Diagram\nFigure 15-4  shows two USI units operating in two-wire mode, one as master and one as slave. It is only the physi-\ncal layer that is shown since the sy stem operation is highly dependent of  the communication scheme used. The\nmain differences between the master and slave operation at this level is the serial clock generation which is always\ndone by the master. Only the sl ave uses the clock control unit.\nClock generation must be implemented in software, but the shift operation is done automatically in both devices.\nNote that clocking only on negative edges for shifting data is of practical use in this mode. The slave can insert wait\nstates at start or end of transfer by forcing the SCL clock low. This means that  the master must always check if the\nSCL line was actually released after it has generated a positive edge.MASTERSLAVE\nBit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0SDA\nSCLBit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0\nTwo-wire Clock\nControl UnitHOLD\nSCL\nPORTxnSDA\nSCLVCC\n113 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Since the clock also increments the counter, a counter overflow can be used to indicate that the transfer is com-\npleted. The clock is generated by the master by toggling the USCK pin via the PORTB register.\nThe data direction is not given by the physical layer. A protocol, like the one used by the TWI-bus, must be imple-\nmented to control the data flow.\nFigure 15-5. Two-wire Mode, Typical Timing Diagram\nReferring to the timing diagram ( Figure 15-5 ), a bus transfer involves the following steps:\n1. The start condition is generated by the master by forcing the SDA low line while  keeping the SCL line high \n(A). SDA can be forced low either by writing a zero to bit 7 of the USI Data Regist er, or by setting the cor-\nresponding bit in the PORTB register to zero. Note that the Data Direction Register bit must be set to one for the output to be enabled. The start detector logic of the slave device (see Figure 15-6 on page 114 ) \ndetects the start condition and sets the USISIF Flag.  The flag can generate an interrupt if necessary. \n2. In addition, the start detector will hold the SCL line low after the master  has forced a negati ve edge on this \nline (B). This allows the slave to wake up from sleep or complete other tasks before setting up the USI \nData Register to receive the address. This is done by clearing the start condit ion flag and resetting the \ncounter.\n3. The master set the first bit to be transferred and releases the SCL line (C). The slave samples the data \nand shifts it into the USI Data Register  at the positive edge of the SCL clock.\n4. After eight bits containing slave address and data direction (read or write) have been transferred, the \nslave counter overflows and the SCL line is forced lo w (D). If the slave is not the one the master has \naddressed, it releases the SCL line and waits for a new start condition.\n5. When the slave is addressed, it holds the SDA lin e low during the acknowledgment cycle before holding \nthe SCL line low again (i.e., the US I Counter Register must be set to 14 before releasing SCL at (D)). \nDepending on the R/W bit the master or slave enables it s output. If the bit is set,  a master read operation \nis in progress (i.e., the slave drives the SDA line) The slave can hold the SCL line low after the acknowl-edge (E).\n6. Multiple bytes can now be transmitted, all in same di rection, until a stop condition is given by the master \n(F), or a new start condition is given.\nIf the slave is not able to receive mo re data it does not acknowledge the data byte it has last received. When the\nmaster does a read operation it must terminate the operati on by forcing the acknowledge bit low after the last byte\ntransmitted.\n15.3.5 Start Condition Detector\nThe start condition detector is shown in Figure 15-6 . The SDA line is delayed (in the range of 50 to 300 ns) to\nensure valid sampling of the SCL line. The start cond ition detector is only enabled in two-wire mode.P S ADDRESS1 - 7 8 9\nR/W ACK ACK1 - 8 9\nDATA ACK1 - 8 9\nDATASDA\nSCL\nAB D E C F\n114 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 15-6. Start Condition Detector, Logic Diagram\nThe start condition detector is working asynchronously a nd can therefore wake up the processor from power-down\nsleep mode. However, the protocol us ed might have restrictions on the SCL hold time. Therefore, when using this\nfeature the oscillator start-up ti me (set by CKSEL fuses, see “Clock Systems and thei r Distribution” on page 23 )\nmust also be taken into consideration. Re fer to the description of the USISIF bit on page 115  for further details.\n15.3.6 Clock speed considerations\nMaximum frequency for SCL and SCK is fCK / 2. This is also the maximum data transmit and receive rate in both\ntwo- and three-wire mode. In two-wire slave mode the Tw o-wire Clock Control Unit will hold the SCL low until the\nslave is ready to receive more data. This may reduce the actual data rate in two-wire mode.\n15.4 Alternative USI Usage\nThe flexible design of the USI allows it to be used for ot her tasks when serial communication is not needed. Below\nare some examples.\n15.4.1 Half-Duplex Asynchronous Data Transfer\nUsing the USI Data Register in three-wire mode it is possible to implement a more compact and higher perfor-\nmance UART than by software, only.\n15.4.2 4-Bit Counter\nThe 4-bit counter can be used as a stand-alone counter with ov erflow interrupt. Note that if the counter is clocked\nexternally, both clock edges will increment the counter value.\n15.4.3 12-Bit Timer/Counter\nCombining the 4-bit USI counter with one of the 8-bit timer/counters creates a 12-bit counter.\n15.4.4 Edge Triggered External Interrupt\nBy setting the counter to maximum value (F) it can func tion as an additional external interrupt. The Overflow Flag\nand Interrupt Enable bit are then used for the external in terrupt. This feature is selected by the USICS1 bit.\n15.4.5 Software Interrupt\nThe counter overflow interrupt can be used as a software interrupt triggered by a clock strobe.SDA\nSCL\nWrite( USISIF)CLOCK\nHOLDUSISIF\nDQ\nCLRDQ\nCLR\n115 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201315.5 Register Descriptions\n15.5.1 USIDR – USI Data Register\nThe USI Data Register can be accessed directly but a copy of the data can also be found in the USI Buffer\nRegister.\nDepending on the USICS[1:0] bits of t he USI Control Register a (left) shif t operation may be performed. The shift\noperation can be synchronised to an external clock edge, to  a Timer/Counter0 Compare Match, or directly to soft-\nware via the USICLK bit. If a serial clock occurs at the same  cycle the register is writte n, the register will contain the\nvalue written and no shift is performed.\nNote that even when no wire mode is selected (USIWM[1:0] = 0) both the external data input (DI/SDA) and the\nexternal clock input (USCK/SCL) can st ill be used by the USI Data Register.\nThe output pin (DO or SDA, depending on the wire mode) is connected via the output latc h to the most significant\nbit (bit 7) of the USI Data Register. The output latch ensures that data inpu t is sampled and data output is changed\non opposite clock edges. The latch is open (transparent) during the first half of a serial clock cycle when an exter-\nnal clock source is selected (USICS1 = 1) and constantly open when an internal clock source is used (USICS1 =\n0). The output will be ch anged immediately when a new MSB is written as lo ng as the latch is open.\nNote that the Data Direction Register bit corresponding to the output pin must be set to one in order to enable data\noutput from the USI Data Register.\n15.5.2 USIBR – USI Buffer Register\nInstead of reading data from the USI Data Register the USI Buffer Register can be used. This makes controlling\nthe USI less time critical and gives t he CPU more time to handle other prog ram tasks. USI flags as set similarly as\nwhen reading the USIDR register.\nThe content of the USI Data Register is loaded to the USI Buffer Register when the transfer has been completed.\n15.5.3 USISR – USI Status Register\nThe Status Register contains interrupt flag s, line status flags and the counter value.\n• Bit 7 – USISIF: Start Condition Interrupt Flag\nWhen two-wire mode is selected, the USISIF Flag is set (to one) when a start condition has been detected. When\nthree-wire mode or output  disable mode has been selected an y edge on the SCK pin will set the flag.Bit 7 6 5 4 3 2 1 0\n0x0F MSB LSB USIDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\nBit 7 6 5 4 3 2 1 00x10 MSB LSB USIBR\nRead/Write R R R R R R R RInitial Value 0 0 0 0 0 0 0 0\nBit 7 6 5 4 3 2 1 00x0E USISIF USIOIF USIPF USIDC USI CNT3 USICNT2 USICNT1 USICNT0 USISR\nRead/Write R/W R/W R/W R R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n116 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013If USISIE bit in USICR and the Global Interrupt Enable Flag are set, an interr upt will be generated when this flag is\nset. The flag will only be cleared by writing a logical one to  the USISIF bit. Clearing this  bit will release the start\ndetection hold of US CL in two-wire mode. \nA start condition interrupt will wakeup the processor from all sleep modes.\n• Bit 6 – USIOIF: Counter Overflow Interrupt Flag\nThis flag is set (one) when the 4-bit counter overflows (i.e ., at the transition from 15 to 0). If the USIOIE bit in\nUSICR and the Global Interrupt Enable Flag are set an interrupt will also be generated when  the flag is set. The\nflag will only be cleared if a one is written to the USIOIF bit. Clearing this  bit will release the c ounter overflow hold\nof SCL in two-wire mode.\nA counter overflow interrupt will wakeup the processor from  Idle sleep mode.\n• Bit 5 – USIPF: Stop Condition Flag\nWhen two-wire mode is selected, the USIPF Flag is set (one) when a stop condition has been detected. The flag is\ncleared by writing a one to this bit. Note that this is not an interrupt flag. This signal is useful when implementing\ntwo-wire bus master arbitration.\n• Bit 4 – USIDC: Data Output Collision\nThis bit is logical one when bit 7 in the USI Data Register  differs from the physical pin value. The flag is only valid\nwhen two-wire mode is used. This signal is useful  when implementing Two-wire bus master arbitration.\n• Bits 3:0 – USICNT[3:0]: Counter Value\nThese bits reflect the current 4-bit c ounter value. The 4-bit counter value c an directly be read or written by the\nCPU.\nThe 4-bit counter increments by one for each clock generat ed either by the external clock edge detector, by a\nTimer/Counter0 Compare Match, or by software using USICLK or USITC strobe bits. The clock source depends on\nthe setting of the USICS[1:0] bits.\nFor external clock operation a special feature is added that allo ws the clock to be gener ated by writing to the\nUSITC strobe bit. This feature is enab led by choosing an external clock so urce (USICS1 = 1) and writing a one to\nthe USICLK bit.\nNote that even when no wire mode is selected (USIWM[1 :0] = 0) the external clock input (USCK/SCL) can still be\nused by the counter.\n15.5.4 USICR – USI Control Register\nThe USI Control Register includes bits for interrupt e nable, setting the wire mode, selecting the clock and clock\nstrobe.\n• Bit 7 – USISIE: Start Condition Interrupt Enable\nSetting this bit to one enables the start condition detecto r interrupt. If there is a pending interrupt and USISIE and\nthe Global Interrupt Enable Flag are se t to one the interrupt w ill be executed immediately. Refer to the USISIF bit\ndescription on page 115  for further details.Bit 7 6 5 4 3 2 1 0\n0x0D USISIE USIOIE USIWM1 USIWM0 US ICS1 USICS0 USICLK USITC USICR\nRead/Write R/W R/W R/W R/W R/W R/W W WInitial Value 0 0 0 0 0 0 0 0\n117 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 6 – USIOIE: Counter Overflow Interrupt Enable\nSetting this bit to one enables the counter overflow inte rrupt. If there is a pending interrupt and USIOIE and the\nGlobal Interrupt Enable Flag are set to one the interrupt wi ll be executed immediately. Refer to the USIOIF bit\ndescription on page 116  for further details.\n• Bits 5:4 – USIWM[1:0]: Wire Mode\nThese bits set the type of wire mode to be used, as shown in Table 15-1  below.\nNote: 1. The DI and USCK pins are renamed to Serial Data  (SDA) and Serial Clock  (SCL) respectively to avoid confusion \nbetween the modes of operation.\nBasically only the function of the out puts are affected by these bits. Data and clock inputs are not affected by the\nmode selected and will always have the same function. The counter and USI Data Register can therefore be\nclocked externally and data input samp led, even when outputs are disabled.\n• Bits 3:2 – USICS[1:0]: Clock Source Select\nThese bits set the clock source for th e USI Data Register and counter. The da ta output latch ensures that the out-\nput is changed at the opposite edge of the sampling of the data input (DI/SDA)  when using external clock source\n(USCK/SCL). When software strobe or Timer/Counter0 Com pare Match clock option is se lected, the output latch is\ntransparent and therefore the ou tput is changed immediately.\nClearing the USICS[1:0] bits enables software strobe op tion. When using this option, writing a one to the USICLK\nbit clocks both the USI Data Register and the counter. For external clock source (USICS1 = 1), the USICLK bit is\nno longer used as a strobe, but select s between external clocking and softwa re clocking by the USITC strobe bit.Table 15-1. Relationship between USIWM[1:0] and USI Operation\nUSIWM1 USIWM0 Description\n00Outputs, clock hold, and start detector disabled.\nPort pins operates as normal.\n01Three-wire mode. Uses DO, DI, and USCK pins.\nThe Data Output  (DO) pin overrides the corresp onding bit in the PORTB register. \nHowever, the corresponding DDRB bit still contro ls the data direction. When the port pin is \nset as input the pin pull-up is  controlled by the PORTB bit.\nThe Data Input  (DI) and Serial Clock  (USCK) pins do not affect the normal port operation. \nWhen operating as master, clock pulses are software generated by toggling the PORTB \nregister, while the data direction is set to output. The USITC bit in the USICR Register can be used for this purpose.\n10Two-wire mode. Uses SDA (DI) and SCL (USCK) pins \n(1).\nThe Serial Data  (SDA) and the Serial Clock  (SCL) pins are bi-directional and use open-\ncollector output drives. The output drivers ar e enabled by setting the corresponding bit for \nSDA and SCL in the DDRB register.\nWhen the output driver is enabled for the SDA pin it will force the line SDA low if the \noutput of the USI Data Register or the corre sponding bit in the PORTB register is zero. \nOtherwise, the SDA line will not be driven (i.e ., it is released). When the SCL pin output \ndriver is enabled the SCL li ne will be forced low if the corresponding bit in the PORTB \nregister is zero, or by the start detector. Otherwise the SCL line will not be driven.\nThe SCL line is held low when a start detector detects a start condition and the output is \nenabled. Clearing the Start Condition Flag (USI SIF) releases the line. The SDA and SCL \npin inputs is not affected by enabling this mode. Pull-ups on the SDA and SCL port pin are \ndisabled in Two-wire mode.\n11Two-wire mode. Uses SDA and SCL pins.\nSame operation as in two-wire mode above, ex cept that the SCL line is also held low \nwhen a counter overflow occurs, and until t he Counter Overflow Flag (USIOIF) is cleared.\n118 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Table 15-2  shows the relationship between the USICS[1:0] and USICLK setting and clock source used for the USI\nData Register and the 4-bit counter.\n• Bit 1 – USICLK: Clock Strobe\nWriting a one to this bit location st robes the USI Data Register to shift one step and the counter to increment by\none, provided that the software clock strobe option has been selected by writ ing USICS[1:0] bits to zero. The out-\nput will change immediately when  the clock strobe is executed, i.e., duri ng the same instruction cycle. The value\nshifted into the USI Data Register is sampled the pr evious instruction cycle.\nWhen an external clock source is selected (USICS1 = 1), the USICLK function is changed from a clock strobe to a\nClock Select Register. Setting th e USICLK bit in this case will select the USITC strobe bit as clock source for the 4-\nbit counter (see Table 15-2 ).\nThe bit will be read as zero.\n• Bit 0 – USITC: Toggle Clock Port Pin\nWriting a one to this bit location toggles  the USCK/SCL value either from 0 to 1, or from 1 to 0. The toggling is inde-\npendent of the setting in the Data Direction Register, bu t if the PORT value is to be shown on the pin the\ncorresponding DDR pin must be set as output (to one). This  feature allows easy clock generation when implement-\ning master devices.\nWhen an external clock source is selected (USICS1 = 1) and the USICLK bit is set to one, writing to the USITC\nstrobe bit will directly clock the 4-bit counter. This allows an early dete ction of when the tran sfer is done when oper-\nating as a master device.\nThe bit will read as zero.Table 15-2. Relationship between the USIC S[1:0] and USICLK Setting\nUSICS1 USICS0 USICLK Clock Sour ce 4-bit Counter Clock Source\n0 0 0 No Clock No Clock\n0 0 1 Software clock strobe (USICLK) Software clock strobe (USICLK)\n0 1 X Timer/Counter0 Compare Matc h Timer/Counter0 Compare Match\n1 0 0 External, positive edge External, both edges\n1 1 0 External, negative edge External, both edges\n1 0 1 External, positive edge Software clock strobe (USITC)\n1 1 1 External, negative edge Software clock strobe (USITC)\n119 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201316. Analog Comparator\nThe Analog Comparator compares the input values on the positive pin AIN0 and negati ve pin AIN1. When the volt-\nage on the positive pin AIN0 is higher than the voltage on the negative pin AIN1, the Analog Comparator output,\nACO, is set. The comparator can trigger a separate interrupt, exclusive to the Analog Comparator. The user canselect Interrupt triggering on comparator  output rise, fall or toggle. A bloc k diagram of the comparator and its sur-\nrounding logic is shown in Figure 16-1 .\nFigure 16-1. Analog Comparator Block Diagram\nNotes: 1. See Table 16-1  below.\nSee Figure 1-1 on page 2  and Table 10-5 on page 63  for Analog Comparator pin placement.\n16.1 Analog Comparator Multiplexed Input\nWhen the Analog to Digital Converter (ADC) is configurated  as single ended input channel, it is possible to select\nany of the ADC[3:0] pins to replac e the negative input to the Analog Com parator. The ADC multiplexer is used to\nselect this input, and consequently, the ADC must be switched off to utilize this feature. If the Analog Comparator\nMultiplexer Enable bit (ACME in ADCSRB) is set and the ADC is switched off (A DEN in ADCSRA is zero),\nMUX[1:0] in ADMUX select the input pin to replace the negative input to the Analog Comparator, as shown in Table\n16-1. If ACME is cleared or ADEN is set, AIN1 is ap plied to the negative input to the Analog Comparator.ACD\n+\n_VCC\nACBG\nACI\nACOACIE\nACIS1 ACIS0I NTERRUPT\nSELECTANALOG\nCOMPARATORIR QAIN0\nAIN1INTER NAL 1.1V\nREFERENCE\nADC MULTIPLEXER\nOUTPUTACME\nADEN\n(1)\nTable 16-1. Analog Comparator Multiplexed Input\nACME ADEN MUX[1:0] Analog Comparator Negative Input\n0x x x A I N 1\n11 x x A I N 1\n10 0 0 A D C 010 0 1 A D C 1\n10 1 0 A D C 2\n10 1 1 A D C 3\n120 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201316.2 Register Description\n16.2.1 ADCSRB – ADC Control and Status Register B\n• Bit 6 – ACME: Analog Comparator Multiplexer Enable\nWhen this bit is written logic one and the ADC is switch ed off (ADEN in ADCSRA is zero), the ADC multiplexer\nselects the negative input to the Analog Comparator. When th is bit is written logic zero, AIN1 is applied to the neg-\native input of the Analog Comparator. For a detailed description of this bit, see “Analog Comparator Multiplexed\nInput” on page 119 . \n16.2.2 ACSR – Analog Comparator Control and Status Register\n• Bit 7 – ACD: Analog Comparator Disable\nWhen this bit is written logic one, th e power to the Analog Comparator is switched off. This bit can be set at any\ntime to turn off the Analog Comparator . This will reduce power consumption in  Active and Idle mode. When chang-\ning the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an\ninterrupt can occur when the bit is changed.\n• Bit 6 – ACBG: Analog Comparator Bandgap Select\nWhen this bit is set, a fixed bandgap reference voltage repl aces the positive input to the Analog Comparator. When\nthis bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. When the bandgap reference is\nused as input to the Analog Comparator, it will take a cert ain time for the voltage to stab ilize. If not stabilized, the\nfirst conversion may give a wrong value. See “Internal Voltage Reference” on page 42 .\n• Bit 5 – ACO: Analog Comparator Output\nThe output of the Analog Comparator  is synchronized and then directly connected to AC O. The synchronization\nintroduces a delay of 1 - 2 clock cycles. \n• Bit 4 – ACI: Analog Comparator Interrupt Flag\nThis bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and\nACIS0. The Analog Comparator interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI\nis cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by\nwriting a logic one to the flag.\n• Bit 3 – ACIE: Analog Comparator Interrupt Enable\nWhen the ACIE bit is written logic one and the I-bit in the Status Register is set, the Analog Comparator interrupt is\nactivated. When written logic ze ro, the interrupt is disabled.\n• Bit 2 – Res: Reserved Bit\nThis bit is a reserved bit in the ATti ny25/45/85 and will always read as zero.B i t 7 6543210\n0x03 BIN ACME IPR – – ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R/W R/W R/W R R R/W R/W R/WI n i t i a l  V a l u e 0 0000000\nB i t 765432100x08 ACD ACBG ACO ACI ACIE – ACIS1 ACIS0 ACSR\nRead/Write R/W R/W R R/W R/W R R/W R/WI n i t i a l  V a l u e00 N / A 00000\n121 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bits 1:0 – ACIS[1:0]: Analog Comparator Interrupt Mode Select\nThese bits determine which comparator events that trigger  the Analog Comparator interrupt. The different settings\nare shown in Table 16-2 .\nWhen changing the ACIS1/ACIS0 bits, th e Analog Comparator Interrupt must be disabled by clearing its Interrupt\nEnable bit in the ACSR Register. Otherwise an interrupt can occur when the bits are changed.\n16.2.3 DIDR0 – Digital I nput Disable Register 0\n• Bits 1:0 – AIN1D, AIN0D: AI N[1:0] Digital Input Disable\nWhen this bit is written logic one, the digital input buffer  on the AIN1/0 pin is disabl ed. The corresponding PIN Reg-\nister bit will always read as zero when this bit is set. Wh en an analog signal is applie d to the AIN1/0 pin and the\ndigital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the dig-\nital input buffer. Table 16-2. ACIS1/ACIS0 Settings\nACIS1 ACIS0 Interrupt Mode\n0 0 Comparator Interrupt on Output Toggle.\n01 R e s e r v e d\n1 0 Comparator Interrupt on Falling Output Edge.\n1 1 Comparator Interrupt on Rising Output Edge.\nB i t 76543210\n0x14 – – ADC0D ADC2D ADC3D ADC1D AIN1D AIN0D DIDR0\nRead/Write R R R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\n122 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201317. Analog to Digital Converter\n17.1 Features\n•10-bit Resolution\n•1 LSB Integral Non-linearity\n•± 2 LSB Absolute Accuracy\n•65 - 260 µs Conversion Time\n•Up to 15 kSPS at Maximum Resolution\n•Four Multiplexed Single Ended Input Channels\n•Two differential input channels with selectable gain\n•Temperature sensor input channel\n•Optional Left Adjustment  for ADC Result Readout\n•0 - VCC ADC Input Voltage Range\n•Selectable 1.1V / 2.56V ADC Voltage Reference\n•Free Running or Single Conversion Mode\n•ADC Start Conversion by Auto Triggering on Interrupt Sources\n•Interrupt on ADC Conversion Complete\n•Sleep Mode Noise Cancele\n•Unipolar / Bibilar Input Mode\n•Input Polarity Reversal Mode\n17.2 Overview\nThe ATtiny25/45/85 features a 10-bit successive approximation Analog to Digital Converter (ADC). The ADC is\nconnected to a 4-channel Analog Multip lexer which allows one differential volt age input and four single-ended volt-\nage inputs constructed from the pins of Port B. The di fferential input (PB3 , PB4 or PB2, PB5) is  equipped with a\nprogrammable gain stage, providing amp lification step of 26 dB (20x) on the differential input voltage before the\nA/D conversion. The single-ended voltage inputs refer to 0V (GND).\nThe ADC contains a Sample and Hold circuit which ensures that the input voltage to the ADC is held at a constant\nlevel during conversion. A block diagram of the ADC is shown in Figure 17-1 on page 123 .\nInternal reference voltages of nominally 1.1V / 2.56V are provided on-chip. Alternatively, VCC can be used as refer-\nence voltage for single ended channels. There is also an opt ion to use an external voltage reference and turn-off\nthe internal voltage reference.\n123 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 17-1. Analog to Digital Converter Block Schematic\n17.3 Operation\nThe ADC converts an analog input voltage to a 10-bit di gital value through successive approximation. The mini-\nmum value represents GND and the maximu m value represents the voltage on VCC, the voltage on the AREF pin\nor an internal 1.1V / 2.56V voltage reference.\nThe voltage reference for the ADC may be selected by writ ing to the REFS[2:0] bits in ADMUX. The VCC supply,\nthe AREF pin or an internal 1.1V / 2.56V voltage referenc e may be selected as the ADC voltage reference. Option-\nally the internal 2.56V voltage refere nce may be decoupled by an external capacitor at the AREF pin to improve\nnoise immunity.\nThe analog input channel and differential gain are selected by writing to the MUX[3:0] bits in ADMUX. Any of the\nfour ADC input pins ADC[3:0] can be selected as single  ended inputs to the ADC. ADC2 or ADC0 can be selected\nas positive input and ADC0, ADC1, ADC2 or ADC3 can be selected as negative input to the differential gainamplifier.\nIf differential channels are selected, the differential gain stage amplifies the voltage difference between the\nselected input pair by the selected gain factor, 1x or 20 x, according to the setting of the MUX[3:0] bits in ADMUX.\nThis amplified value then becomes the analog input to the ADC. If single ended channels are used, the gain ampli-\nfier is bypassed altogether.ADC CONVERSION\nCOMPLETE IRQ\n8-BIT DATA BUS\n15 0\nADC MULTIPLEXER\nSELECT (ADMUX)ADC CTRL. & STATUS A\nREGISTER (ADCSRA)ADC DATA REGISTER\n(ADCH/ADCL)ADIE\nADATE ADSC ADEN ADIFADIF\nMUX1 MUX0ADPS0 ADPS1 ADPS2\nCONVERSION LOGIC\n10-BIT DAC\n+-SAMPLE & HOLD\nCOMPARATORINTERNAL 1.1V/2.56V \nREFERENCEMUX DECODERMUX2\nAREF\nADC3\nADC2ADC1ADC0REFS[2:0]ADLARCHANNEL SELECTIONADC[9:0]\nADC MULTIPLEXER\nOUTPUTPRESCALER\nINPUT\nMUXTRIGGER\nSELECTADTS[2:0]INTERRUPT\nFLAGS\nSTART\n+\n-\nGAIN SELECTION\nGAIN\nAMPLIFIER\nNEG.\nINPUT\nMUXSINGLE ENDED / DIFFERENTIAL SELECTIONTEMPERATURE \nSENSOR\nADC4ADC CTRL. & STATUS B\nREGISTER (ADCSRB)\nBIN\nIPR\nVCC\n124 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013If ADC0 or ADC2 is selected as both the positive and negative input to the differential gain amplifier (ADC0-ADC0\nor ADC2-ADC2), the remaining offset in the gain stage and conversion circuitry can be measured directly as the\nresult of the conversion. This figure  can be subtracted from subsequent conversions with the same gain setting to\nreduce offset error to below 1 LSW.\nThe on-chip temperature sensor is selected by writing the code “1111” to the MUX[3: 0] bits in ADMUX register\nwhen the ADC4 channel is used as an ADC input.\nThe ADC is enabled by setting the ADC Enable bit, ADEN in ADCSRA. Voltage referenc e and input channel selec-\ntions will not go into effect until AD EN is set. The ADC does not consume pow er when ADEN is cleared, so it is\nrecommended to switch off the ADC before entering power saving sleep modes.\nThe ADC generates a 10-bit result which is presented in  the ADC Data Registers, ADCH and ADCL. By default,\nthe result is presented right adjust ed, but can optionally be presented left  adjusted by setting the ADLAR bit in\nADMUX.\nIf the result is left adjusted and no more than 8-bit precisio n is required, it is sufficie nt to read ADCH. Otherwise,\nADCL must be read first, then ADCH, to ensure that the content of the data registers belongs to the same conver-\nsion. Once ADCL is read, ADC access to data registers is blocked. This mean s that if ADCL has been read, and a\nconversion completes before ADCH is read, neither regist er is updated and the result from the conversion is lost.\nWhen ADCH is read, ADC access to the AD CH and ADCL Registers is re-enabled. \nThe ADC has its own interrupt which can be triggered when a conversion completes. When ADC access to the\ndata registers is prohibited between reading of ADCH and ADCL, the interrupt will tr igger even if the result is lost.\n17.4 Starting a Conversion\nA single conversion is started by writing a logical one to  the ADC Start Conversion bit, ADSC. This bit stays high as\nlong as the conversion is in progress and will be cleared by hardware when the conversion is completed. If a differ-\nent data channel is selected while a conv ersion is in progress, the ADC will finish the current conversion before\nperforming the channel change. \nAlternatively, a conversion can be triggered automatically by  various sources. Auto Triggering is enabled by setting\nthe ADC Auto Trigger Enable bit, ADATE in ADCSRA. The trigger source is selected by setting the ADC TriggerSelect bits, ADTS in ADCSRB  (see description of the ADTS bits for a list of the trigger sources). When a positive\nedge occurs on the selected trigger signal, the ADC prescale r is reset and a conversion is started. This provides a\nmethod of starting conversions at fixed intervals. If the trigger signal still is set w hen the conversion completes, a\nnew conversion will not be star ted. If another positive ed ge occurs on the trigger signa l during conversion, the edge\nwill be ignored. Note that an Interrupt Fl ag will be set even if the specific inte rrupt is disabled or the Global Interrupt\nEnable bit in SREG is cleared. A conversion can thus be triggered without causing an interrupt. However, the Inter-\nrupt Flag must be cleared in order to trigger a new conversion at the next interrupt event.\nUsing the ADC Interrupt Flag as a trigger source make s the ADC start a new conversion as soon as the ongoing\nconversion has finished. The ADC then operates in Free Running mode, co nstantly sampling and updating the\nADC Data Register. The first conversion must be started by writing a logical one to the ADSC bit in ADCSRA. Inthis mode the ADC will perform successi ve conversions independen tly of whether the ADC Interrupt Flag, ADIF is\ncleared or not.\n125 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 17-2. ADC Auto Trigger Logic\nIf Auto Triggering is enabled, single conversions can be started by writing ADSC in ADCSRA to one. ADSC can\nalso be used to determine if  a conversion is in progres s. The ADSC bit will be r ead as one duri ng a conversion,\nindependently of how the conversion was started.\n17.5 Prescaling and Conversion Timing\nFigure 17-3. ADC Prescaler\nBy default, the successive approximation circuitry requi res an input clock frequency between 50 kHz and 200 kHz\nto get maximum resolution. If a lower resolution than 10 bits is needed, the input cl ock frequency to the ADC can\nbe higher than 200 kHz to get a higher sample rate. It is not recommended to use a higher input clock frequency\nthan 1 MHz.\nThe ADC module contains a prescale r, which generates an ac ceptable ADC clock frequency from any CPU fre-\nquency above 100 kHz. The prescaling is  set by the ADPS bits in ADCSRA. Th e prescaler starts counting from the\nmoment the ADC is switched on by setting the ADEN bit in ADCSRA. The prescaler keeps running for as long as\nthe ADEN bit is set, and is continuously reset when ADEN is low.\nWhen initiating a single ended conversion  by setting the ADSC bit in ADCSRA, the conversion starts at the follow-\ning rising edge of the ADC clock cycle. ADSCADIF\nSOURCE 1\nSOURCE nADTS[2:0]\nCONVERSION\nLOGICPRESCALER\nSTART CLKADC\n..\n..\nEDGE\nDETECTORADATE\n7-BIT ADC PRESCALER\nADC CLOCK SOURCECK\nADPS0\nADPS1\nADPS2CK/128 CK/2CK/4CK/8CK/16CK/32CK/64ResetADEN\nSTART\n126 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013A normal conversion takes 13 ADC clo ck cycles. The first conversion after the ADC is switched on (ADEN in ADC-\nSRA is set) takes 25 ADC clock cycles in order to initialize the analog circuitry, as shown in Figure 17-4  below.\nFigure 17-4. ADC Timing Diagram, First Conver sion (Single Conversion Mode)\nThe actual sample-and-hold takes place 1.5 ADC clock cycl es after the start of a normal conversion and 13.5 ADC\nclock cycles after the start of an first conversion. When a c onversion is complete, the result is written to the ADC\nData Registers, and ADIF is set. In  Single Conversion mode, ADSC is cleared simultaneo usly. The software may\nthen set ADSC again, and a new conversion will be initia ted on the first rising ADC clock edge. \nFigure 17-5. ADC Timing Diagram, Single Conversion\nWhen Auto Triggering is used, the prescaler is reset when  the trigger event occurs. This assures a fixed delay from\nthe trigger event to the start of co nversion. In this mode, the sample-and-hold ta kes place two ADC clock cycles\nafter the rising edge on the trigger source signal. Three additional CPU clock cycles are used for synchronization\nlogic.Sign and MSB of Result\nLSB of ResultADC Clock\nADSC\nSample & HoldADIF\nADCHADCLCycle Number\nADEN1 21 2 13 14 15 16 17 18 19 20 21 22 23 24 25 1 2First ConversionNext\nConversion\n3\nMUX and REFS\nUpdateMUX and REFS\nUpdateConversion\nComplete\n1 2 3 4 5 6 7 8 9 10 11 12 13\nSign and MSB of Result\nLSB of ResultADC Clock\nADSCADIFADCHADCLCycle Number 12One Conversion Next Conversion\n3\nSample & Hold\nMUX and REFS\nUpdateConversion\nCompleteMUX and REFSUpdate\n127 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 17-6. ADC Timing Diagram, Auto Triggered Conversion\nIn Free Running mode, a new conver sion will be started immedi ately after the conversion completes, while ADSC\nremains high.\nFigure 17-7. ADC Timing Diagram, Free Running Conversion\nFor a summary of conversion times, see Table 17-1 .\nTable 17-1. ADC Conversion Time\nConditionSample & Hold \n(Cycles from Start of Conversion)Total Conversion Time\n(Cycles)\nFirst conversion 13.5 25\nNormal conversions 1.5 13\nAuto Triggered conversions 2 13.51 2 3 4 5 6 7 8 9 10 11 12 13\nSign and MSB of Result\nLSB of ResultADC Clock\nTrigger\nSource\nADIF\nADCHADCLCycle Number 12One Conversion Next Conversion\nConversion\nCompletePrescaler ResetADATE\nPrescalerReset Sample &\nHold\nMUX and REFS Update\n11 12 13\nSign and MSB of Result\nLSB of ResultADC Clock\nADSCADIFADCHADCLCycle Number12One Conversion Next Conversion\n34\nConversion\nCompleteSample & Hold\nMUX and REFS\nUpdate\n128 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201317.6 Changing Channel or Reference Selection\nThe MUX[3:0] and REFS[2:0] bits in the ADMUX Register ar e single buffered through a temporary register to which\nthe CPU has random access. This ensures that the channels and voltage reference selection only takes place at a\nsafe point during the conversion. The channel and voltage  reference selection is continuously updated until a con-\nversion is started. Once the conversion starts, the channe l and voltage reference selection is locked to ensure a\nsufficient sampling time for the ADC. Continuous updating resumes in the last ADC cl ock cycle before  the conver-\nsion completes (ADIF in ADCSRA is set) . Note that the conversion starts on the following rising ADC clock edge\nafter ADSC is written. The user is thus advised not to write new channel or voltage reference selection values to\nADMUX until one ADC clock cycle after ADSC is written.\nIf Auto Triggering is used, the exact time of the triggerin g event can be indeterministic. Special care must be taken\nwhen updating the ADMUX Register, in order to control which conversion w ill be affected by the new settings.\nIf both ADATE and ADEN is written to one, an interrupt event can occur at  any time. If the ADMUX Register is\nchanged in this period, the user cannot tell if the next co nversion is based on the old or the new settings. ADMUX\ncan be safely updated in the following ways:\na. When ADATE or ADEN is cleared.\nb. During conversion, minimum one ADC clock cycle after the trigger event.\nc. After a conversion, before the Interrupt Flag used as trigger source is cleared.\nWhen updating ADMUX in one of th ese conditions, the new settings will affect the next ADC conversion.\n17.6.1 ADC Input Channels\nWhen changing channel selections, the user should observe the following guid elines to ensure that the correct\nchannel is selected:\nIn Single Conversion mode, always sele ct the channel before starting the c onversion. The channel selection may\nbe changed one ADC clock cycle after writing one to ADSC. Ho wever, the simplest method is to wait for the con-\nversion to complete before changing the channel selection.\nIn Free Running mode, always select the channel before st arting the first conversion. The channel selection may\nbe changed one ADC clock cycle after writing one to ADSC. However, the simplest method is to wait for the first\nconversion to complete, and then change the channel se lection. Since the next conversion has already started\nautomatically, the next result will reflect the previous channel selection. Subsequent conversions will reflect the\nnew channel selection.\n17.6.2 ADC Voltage Reference\nThe voltage reference for the ADC (VREF) indicates the conversion range for the ADC. Single ended channels that\nexceed VREF will result in codes close to 0x3FF. VREF can be selected as either VCC, or internal 1.1V / 2.56V volt-\nage reference, or external AREF pin. The first ADC conversion result after switching voltage reference source may\nbe inaccurate, and the user is advised to discard this result.\n17.7 ADC Noise Canceler\nThe ADC features a noise canceler that enables conversion during sleep m ode to reduce noise induced from the\nCPU core and other I/O peripherals. The noise canceler  can be used with ADC Noise Reduction and Idle mode. To\nmake use of this feature, the following procedure should be used:\n• Make sure that the ADC is enabled and is not busy c onverting. Single Conversion mode must be selected and \nthe ADC conversion complete interrupt must be enabled.\n• Enter ADC Noise Reduction mode (or Idle mode). Th e ADC will start a conversion  once the CPU has been \nhalted.\n• If no other interrupts occu r before the ADC conversion completes, th e ADC interrupt will wake up the CPU and \nexecute the ADC Conversion Complete interrupt routine.  If another interrupt wakes up the CPU before the ADC \n129 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013conversion is complete, that interr upt will be executed, and an ADC Conver sion Complete inte rrupt request will \nbe generated when the ADC conversion completes. The CPU will remain  in active mode until a new sleep \ncommand is executed.\nNote that the ADC will not be automatically turned o ff when entering other sleep m odes than Idle mode and ADC\nNoise Reduction mode. The user is advised to write zero  to ADEN before entering such sleep modes to avoid\nexcessive power consumption. \n17.8 Analog Input Circuitry\nThe analog input circuitry for single end ed channels is illustrated in Figure 17- 8. An analog source applied to ADCn\nis subjected to the pin capacitance and input leakage of t hat pin, regardless of whether that channel is selected as\ninput for the ADC. When the channel is selected, the sour ce must drive the S/H capacitor through the series resis-\ntance (combined resistance in the input path).\nFigure 17-8. Analog Input Circuitry\nThe ADC is optimized for analo g signals with an output impedance of approximately 10 k \uf057 or less. If such a source\nis used, the sampling time will be negligible. If a source with higher impedance is used, the sampling time will\ndepend on how long time the source needs to charge the S/H capacitor, with can vary widely. The user is recom-\nmended to only use low impedant sources with slowly va rying signals, since this mi nimizes the required charge\ntransfer to the S/H capacitor.\nSignal components higher than the Nyquist frequency (fADC/2) should not be present to avoid distortion from unpre-\ndictable signal convolution. The user is advised to remove high frequency co mponents with a low-pass filter before\napplying the signals as inputs to the ADC.\n17.9 Noise Canceling Techniques\nDigital circuitry inside and outside the device generates EMI which might affect the accuracy of analog measure-\nments. If conversion accuracy is critical, the noise leve l can be reduced by applying the following techniques:\n• Keep analog signal paths as short as possible.\n• Make sure analog tracks run over the analog ground plane.\n• Keep analog tracks well away from high-speed switching digital tracks.• If any port pin is used as a digital output, it  mustn’t switch while a conversion is in progress.\n• Place bypass capacitors as close to V\nCC and GND pins as possible.\nWhere high ADC accuracy is required it is recommended to use ADC Noise Reduction Mode, as described in Sec-\ntion 17.7 on page 128 . This is especially the case when system cloc k frequency is above 1 MHz, or when the ADCADCnIIH\n1..100 k Ω\nCS/H= 14 pF\nVCC/2IIL\n130 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013is used for reading the internal te mperature sensor, as described in Section 17.12 on page 133 . A good system\ndesign with properly placed, exter nal bypass capacitors does  reduce the need for using ADC Noise Reduction\nMode\n17.10 ADC Accuracy Definitions\nAn n-bit single-ended ADC converts a voltage linearly between GND and VREF in 2n steps (LSBs). The lowest code\nis read as 0, and the highest code is read as 2n-1. \nSeveral parameters describe the deviation from the ideal behavior, as follows:\n• Offset: The deviation of the first transition (0x000 to 0x 001) compared to the ideal transition (at 0.5 LSB). Ideal \nvalue: 0 LSB.\nFigure 17-9. Offset Error\n• Gain Error: After adjusting for offset, the Gain Error is found as the deviation of the last transition (0x3FE to \n0x3FF) compared to the ideal transition (at 1.5 LSB below maximum). Ideal value: 0 LSBOutput Code\nVREF Input Volt ageIdeal ADC\nActual ADC\nOffset\nError\n131 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 17-10. Gain Error\n• Integral Non-linearity (INL): After adjusting for offset and gain error, the INL is the maximum deviation of an \nactual transition compared to an ideal transition for any code. Ideal value: 0 LSB.\nFigure 17-11. Integral Non- linearity (INL)\n• Differential Non-linearity (DNL): The maximum deviation of the actual code width (the interval between two \nadjacent transitions) from the ideal code width (1 LSB). Ideal value: 0 LSB.Output Code\nVREF Input Volt ageIdeal ADC\nActual ADCGain\nError\nOutput Code\nVREF Input Volt ageIdeal ADC\nActual ADCINL\n132 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 17-12. Differential Non-linearity (DNL)\n• Quantization Error: Due to the quantiz ation of the input voltage into a finite number of codes, a range of input \nvoltages (1 LSB wide) will code to the same value. Always ± 0.5 LSB.\n• Absolute Accuracy: The maximum deviatio n of an actual (unadjusted) transiti on compared to an ideal transition \nfor any code. This is the compound effect of offset, gain  error, differential error, non-linearity, and quantization \nerror. Ideal value: ± 0.5 LSB.\n17.11 ADC Conversion Result\nAfter the conversion is complete (ADIF is high), the co nversion result can be found in the ADC Result Registers\n(ADCL, ADCH). The form of the conversion  result depends on the type of the conversio as  there are three types of\nconversions: single ended conversion,  unipolar differential conversion and bipolar differential conversion.\n17.11.1 Single Ended Conversion\nFor single ended conversion, the result is\nwhere VIN is the voltage on the selected input pin and VREF the selected voltage reference (see Table 17-3 on page\n134 and Table 17-4 on page 135 ). 0x000 represents analog ground, a nd 0x3FF represents the selected voltage\nreference minus one LSB. The result is presented in one-sided form, from 0x3FF to 0x000.\n17.11.2 Unipolar Diff erential Conversion\nIf differential channels and an unipolar input mode are used, the result isOutput Code\n0x3FF\n0x000\n0 VREFInput Volt ageDNL1 LSB\nADCVIN1024\uf0d7\nVREF--------------------------=\n133 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013where V POS is the voltage on the positive input pin, V NEG the voltage on the negative input pin, and V REF the\nselected voltage reference (see Table 17-3 on page 134  and Table 17-4 on page 135 ). The voltage on the positive\npin must always be larger than the voltage on the negative pin or otherwise the voltage difference is saturated tozero. The result is presented in one-sided form, from 0x000 (0d) to 0x3FF (+1023d). The GAIN is either 1x or 20x. \n17.11.3 Bipolar Differential Conversion\nAs default the ADC converter operates in the unipolar input mode, but the bipolar input mode can be selected by\nwritting the BIN bit in the ADCSRB to one. In the bipo lar input mode two-sided voltage differences are allowed and\nthus the voltage on the negative input pin can also be larger  than the voltage on the posit ive input pin. If differential\nchannels and a bipolar input mode are used, the result is\nwhere V\nPOS is the voltage on the positive input pin, V NEG the voltage on the negative input pin, and V REF the\nselected voltage reference. The result is presented in two’s complement form, from 0x200 (-512d) through 0x000\n(+0d) to 0x1FF (+511d). The GAIN is either 1x or 20x. \nHowever, if the signal is not bipolar by nature (9 bits + sign as the 10t h bit), this scheme loses one bit of the con-\nverter dynamic range. Then, if the user wants to perform the conversion with the maximum dynamic range, the\nuser can perform a quick polarity check of the result and use the unipolar differential conversion with selectable dif-\nferential input pairs (see the Input Polari ty Reversal mode ie. the IPR bit in the “ADCSRB – ADC Control and\nStatus Register B” on page 137 ). When the polarity check is performed, it  is sufficient to read the MSB of the result\n(ADC9 in ADCH). If the bit is one, the result is negative, and if this bit is zero, the result is positive.\n17.12 Temperature Measurement\nThe temperature measurement is based on an on-chip temperature sensor that is coupled to a single ended ADC4\nchannel. Selecting the ADC4 channel by writing the MUX[3: 0] bits in ADMUX register to “1111” enables the tem-\nperature sensor. The internal 1.1V re ference must also be selected for the ADC reference source in the\ntemperature sensor measurement. When the temperature sensor is enabled, the ADC converter can be used in\nsingle conversion mode to measure the voltage over the temperature sensor.\nThe measured voltage has a linear relationship to the temperature as described in Table 17-2  The sensitivity is\napproximately 1 LSB / \uf0b0C and the accuracy depends on the method of user calibration. Typically, the measurement\naccuracy after a single temperature calibration is ± 10\uf0b0C, assuming calibration at room temperature. Better\naccuracies are achieved by using tw o temperature points for calibration.\nThe values described in Table 17-2  are typical values. However, due to pr ocess variation the temperature sensor\noutput voltage varies from one chip to  another. To be capable of achieving more accurate resu lts the temperature\nmeasurement can be calibrated in the application software . The sofware calibration can be done using the formula:\nT = k * [(ADCH << 8) | ADCL] + TOSADCVPOSVNEG–\uf028\uf029 1024\uf0d7\nVREF------------------------------------------------------- -GAIN\uf0d7 =\nADCVPOSVNEG–\uf028\uf029 512\uf0d7\nVREF---------------------------------------------------- -GAIN\uf0d7 =\nTable 17-2. Temperature vs. Sensor Output Voltage (Typical Case)\nTemperature -40 \uf0b0C+ 2 5 \uf0b0C+ 8 5 \uf0b0C\nADC 230 LSB 300 LSB 370 LSB\n134 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013where ADCH and ADCL are the ADC data register s, k is the fixed slope coefficient and TOS is the temperature sen-\nsor offset. Typically, k is very close to 1.0 and in singl e-point calibration the coeffici ent may be omitted. Where\nhigher accuracy is required the slope coefficient  should be evaluated based on measurements at two\ntemperatures.\n17.13 Register Description\n17.13.1 ADMUX – ADC Multiplexer Selection Register\n• Bits 7:6, 4 – REFS[2:0]: Voltage Reference Selection Bits\nThese bits select the voltage reference (VREF) for the ADC, as shown in Table 17-3 . If these bits are changed\nduring a conversion, the change  will not go in effect until this conversi on is complete (ADIF in ADCSR is set).\nWhenever these bits are changed, the next conversion will take 25 ADC cl ock cycles. When differential channels\nand gain are used, using VCC or an external AREF higher than (VCC - 1V) as a voltage reference is not\nrecommended as this will a ffect the ADC accuracy.\nNote: 1. The device requries a supply voltage of 3V in order to generate 2.56V reference voltage.\n• Bit 5 – ADLAR: ADC Left Adjust Result\nThe ADLAR bit affects the presentati on of the ADC conversion result in the ADC Data Register. Write one to\nADLAR to left adjust the resu lt. Otherwise, the result is right adjust ed. Changing the ADLAR bit will affect the ADC\nData Register immediately, regardless of any ongoing co nversions. For a complete de scription of this bit, see\n“ADCL and ADCH – The ADC Data Register” on page 137 .\n• Bits 3:0 – MUX[3:0]: Analog Channel and Gain Selection Bits\nThe value of these bits selects which co mbination of analog inputs are connected to the ADC. In case of differential\ninput (ADC0 - ADC1 or ADC2 - ADC3),  gain selection is also made with th ese bits. Selecting ADC2 or ADC0 as\nboth inputs to the differenti al gain stage enables offset  measurements. Selecting the single-ended channel ADC4B i t 76543210\n0x07 REFS1 REFS0 ADLAR REFS2 MUX3 MUX2 MUX1 MUX0 ADMUX\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\nTable 17-3. Voltage Reference Selections for ADC\nREFS2 REFS1 REFS0 Voltage Reference (VREF) Selection\nX00 VCC used as Voltage Reference, disconnected from PB0 (AREF).\nX01External Voltage Reference at PB0 (AREF) pin, Internal Voltage \nReference turned off.\n0 1 0 Internal 1.1V Voltage Reference.\n011 R e s e r v e d\n110Internal 2.56V Voltage Reference without external bypass \ncapacitor, disconnected from PB0 (AREF)(1).\n111Internal 2.56V Voltage Reference with external bypass capacitor at \nPB0 (AREF) pin(1).\n135 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013enables the temperature sensor. Refer to Table 17-4  for details. If these bits are changed during a conversion, the\nchange will not go into ef fect until this conversion is co mplete (ADIF in ADCSRA is set).\nNote: 1. For offset calibration, only. See “Operation” on page 123.\n2. After switching to internal voltage reference the ADC requ ires a settling time of 1ms before measurements are sta-\nble. Conversions starting before this may not be relia ble. The ADC must be enabled during the settling time.\n3. For temperature sensor.Table 17-4. Input Channel Selections\nMUX[3:0]Single Ended \nInputPositive \nDifferential InputNegative \nDifferential Input Gain\n0000 ADC0 (PB5)\nN/A0001 ADC1 (PB2)\n0010 ADC2 (PB4)\n0011 ADC3 (PB3)\n0100\nN/AADC2 (PB4) ADC2 (PB4) 1x\n0101 (1)ADC2 (PB4) ADC2 (PB4) 20x\n0110 ADC2 (PB4) ADC3 (PB3) 1x\n0111 ADC2 (PB4) ADC3 (PB3) 20x\n1000 ADC0 (PB5) ADC0 (PB5) 1x\n1001 ADC0 (PB5) ADC0 (PB5) 20x1010 ADC0 (PB5) ADC1 (PB2) 1x\n1011 ADC0 (PB5) ADC1 (PB2) 20x\n1100 \n(2)VBG\nN/A1101 GND\n1110 N/A\n1111 (3)ADC4\n136 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201317.13.2 ADCSRA – ADC Control and Status Register A\n• Bit 7 – ADEN: ADC Enable\nWriting this bit to one enables the ADC. By writing it to zero, th e ADC is turned off. Turning the ADC off while a con-\nversion is in progress, will  terminate this conversion.\n• Bit 6 – ADSC: ADC Start Conversion\nIn Single Conversion mode, write this bit to one to start each conversion. In Free Running mode, write this bit to\none to start the first conversion. The first conversion after ADSC has been written after the ADC has been enabled,\nor if ADSC is written at the same ti me as the ADC is enabled, will take 25  ADC clock cycles in stead of the normal\n13. This first conversion perf orms initializat ion of the ADC.\nADSC will read as one as long as a conv ersion is in progress. When the conver sion is complete, it returns to zero.\nWriting zero to this  bit has no effect.\n• Bit 5 – ADATE: ADC Auto Trigger Enable\nWhen this bit is written to one, Auto Triggering of the ADC is en abled. The ADC will start a conversion on a positive\nedge of the selected trigger signal. The trigger source is  selected by setting the ADC Trigger Select bits, ADTS in\nADCSRB.\n• Bit 4 – ADIF: ADC Interrupt Flag\nThis bit is set when an ADC conversion completes and t he data registers are updated. The ADC Conversion Com-\nplete Interrupt is executed if the ADIE bit and the I-bit in SREG are set. ADIF is cleared by hardware whenexecuting the corresponding interrupt handling vector. Alternat ively, ADIF is cleared by writing a logical one to the\nflag. Beware that if doing a Read-Modi fy-Write on ADCSRA, a pending interrupt can be disabled. This also applies\nif the SBI and CBI instructions are used.\n• Bit 3 – ADIE: ADC Interrupt Enable\nWhen this bit is written to one and t he I-bit in SREG is set, the ADC Conver sion Complete Interrupt is activated.\n• Bits 2:0 – ADPS[2:0]: ADC Prescaler Select Bits\nThese bits determine the division factor between the system clock frequency and the input clock to the ADC.B i t 76543210\n0x06 ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 ADCSRA\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\nTable 17-5. ADC Prescaler Selections\nADPS2 ADPS1 ADPS0 Division Factor\n000 2001 2\n010 4\n011 8100 1 6\n101 3 2\n110 6 4\n1 1 1 128\n137 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201317.13.3 ADCL and ADCH – The ADC Data Register\n17.13.3.1 ADLAR = 0\n17.13.3.2 ADLAR = 1\nWhen an ADC conversion is complete, the result is found in these two registers.\nWhen ADCL is read, the ADC Data Regi ster is not updated until ADCH is read . Consequently, if the result is left\nadjusted and no more than 8-bit precision is required, it is  sufficient to read ADCH. Otherwise, ADCL must be read\nfirst, then ADCH.\nThe ADLAR bit in ADMUX, and the MUXn bits in ADMUX affe ct the way the result is read from the registers. If\nADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right adjusted. \n• Bits 9:0 - ADC[9:0]: ADC Conversion Result\nThese bits represent the result from the conversion, as detailed in “ADC Conversion Result” on page 132 .\n17.13.4 ADCSRB – ADC Control and Status Register B\n• Bit 7 – BIN: Bipolar Input Mode\nThe gain stage is working in the unipolar mode as default,  but the bipolar mode can be selected by writing the BIN\nbit in the ADCSRB register. In the unipolar mode only on e-sided conversions are supported and the voltage on the\npositive input must always be larger than the voltage on th e negative input. Otherwise the result is saturated to the\nvoltage reference. In the bipolar mode two-sided conversi ons are supported and the result is represented in the\ntwo’s complement form. In the unipolar mode the resolution  is 10 bits and the bipolar mode the resolution is 9 bits\n+ 1 sign bit.\n• Bit 5 – IPR: Input Polarity Reversal\nThe Input Polarity mode allows software  selectable differential input pairs and full 10 bit ADC resolution, in the uni-\npolar input mode, assuming a pre-determined input polarity. If  the input polarity is not kn own it is actually possible\nto determine the polarity first by using the bipolar input mode (with 9 bit resolution + 1 sign bit ADC measurement).\nAnd once determined, set or clear the polarity reve rsal bit, as needed, for a succeeding 10 bit unipolar\nmeasurement.B i t 1 51 41 31 21 11 0 9 8\n0x05 –––––– ADC9 ADC8 ADCH\n0x04 ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADC1 ADC0 ADCL\n76543210\nR e a d / W r i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e00000000\n00000000\nB i t 1 51 41 31 21 11 0 9 80x05 ADC9 ADC8 ADC7 ADC6 ADC5 ADC4 ADC3 ADC2 ADCH\n0x04 ADC1 ADC0 –––––– ADCL\n76543210\nR e a d / W r i t e RRRRRRRR\nRRRRRRRR\nI n i t i a l  V a l u e00000000\n00000000\nB i t 76543210\n0x03 BIN ACME IPR – – ADTS2 ADTS1 ADTS0 ADCSRB\nRead/Write R/W R/W R/W R R R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n138 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bits 4:3 – Res: Reserved Bits\nThese bits are reserved bits in the ATti ny25/45/85 and will always read as zero.\n• Bits 2:0 – ADTS[2:0]: ADC Auto Trigger Source\nIf ADATE in ADCSRA is written to on e, the value of these bits selects wh ich source will trigger an ADC conversion.\nIf ADATE is cleared, the ADTS[2:0] se ttings will have no effect. A conversion will be triggered by the rising edge of\nthe selected Interrupt Flag. Note that sw itching from a trigger source that is cl eared to a trigger source that is set,\nwill generate a positive e dge on the trigger signal. If ADEN in ADCSRA  is set, this will start a conversion. Switching\nto Free Running mode (ADTS[2:0]=0) will not cause a trigger event, even if  the ADC Interrupt Flag is set .\n17.13.5 DIDR0 – Digital Input Disable Register 0\n• Bits 5:2 – ADC3D:ADC0D: ADC [3:0] Digital Input Disable\nWhen this bit is written logic one, the digital input bu ffer on the corresponding ADC pin is disabled. The corre-\nsponding PIN register bit will  always read as zero when this bit is set. When an analog signal is applied to the\nADC[3:0] pin and the digital input from  this pin is not needed, this bit s hould be written logic one to reduce power\nconsumption in the digital input buffer.Table 17-6. ADC Auto Trigger Source Selections\nADTS2 ADTS1 ADTS0 Trigger Source\n0 0 0 Free Running mode0 0 1 Analog Comparator\n0 1 0 External Interrupt Request 0\n0 1 1 Timer/Counter0 Compare Match A1 0 0 Timer/Counter0 Overflow\n1 0 1 Timer/Counter0 Compare Match B\n1 1 0 Pin Change Interrupt Request\nB i t 76543210\n0x14 – – ADC0D ADC2D ADC3D ADC1D AIN1D AIN0D DIDR0\nRead/Write R R R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\n139 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201318. debugWIRE On-ch ip Debug System\n18.1 Features\n•Complete Program Flow Control\n•Emulates All On-chi p Functions, Both Digital a nd Analog , except RESET Pin\n•Real-time Operation\n•Symbolic Debugging Support (Both at C and Assembler Source Level, or for Other HLLs)\n•Unlimited Number of Program Break Points (Using Software Break Points)\n•Non-intrusive Operation\n•Electrical Characteristics Identical to Real Device\n•Automatic Configuration System\n•High-Speed Operation\n•Programming of Non-volatile Memories\n18.2 Overview\nThe debugWIRE On-chip debug system uses a One-wire, bi-d irectional interface to control the program flow, exe-\ncute AVR instructions in the CPU and to program the different non-volatile memories. \n18.3 Physical Interface\nWhen the debugWIRE Enable (DWEN) Fuse is progra mmed and Lock bits are unprogrammed, the debugWIRE\nsystem within the target device  is activated. The RESET po rt pin is configured as a wire-AND (open-dra in) bi-direc-\ntional I/O pin with pull-up enabled and becomes the communication gateway between target and emulator.\nFigure 18-1  shows the schematic of a target MCU, with debugWIRE enabled, and the emulator connector. The\nsystem clock is not affected by de bugWIRE and will always be the clock so urce selected by  the CKSEL Fuses.\nFigure 18-1. The debugWIRE Setup\ndW\nGNDdW(RESET)VCC1.8 - 5.5 V\n140 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013When designing a system where debugWIRE will be used, the followin g must be observed:\n• Pull-Up resistor on the dW/(RESET) line must be in the range of 10k to 20 k \uf057. However, the pull- up resistor is \noptional.\n• Connecting the RESET pin directly to VCC will not work.\n• Capacitors inserted on the RESET pin must  be disconnected w hen using debugWire.\n• All external reset sources must be disconnected.\n18.4 Software Break Points\ndebugWIRE supports Program memory Break Points by the AVR Break instruction. Setting a Break Point in AVR\nStudio® will insert a BREAK instru ction in the Program  memory. The instru ction replaced by the BREAK instruction\nwill be stored. When program execution is continued, the stored inst ruction will be executed  before continuing from\nthe Program memory. A break can be in serted manually by putting the BREAK instruction in the program.\nThe Flash must be re-programmed each time a Break Point is changed. This is automa tically handled by AVR Stu-\ndio through the debugWIRE in terface. The use of Break Points will th erefore reduce the Flash Data retention.\nDevices used for debugging purposes should not be shipped to end customers.\n18.5 Limitations of debugWIRE\nThe debugWIRE communication pin (dW) is  physically located on the same pi n as External Reset (RESET). An\nExternal Reset source is therefore not supported when the debugWIRE is enabled.\nThe debugWIRE system accurately emulates all I/O functi ons when running at full speed, i.e., when the program in\nthe CPU is running. When the CPU is stopped, care must be taken while ac cessing some of the I/O Registers via\nthe debugger (AVR Studio). See the debugWIRE document ation for detailed descript ion of the limitations.\nThe debugWIRE interface is asynchronous, which means that the debugger needs to synchronize to the system\nclock. If the system clock is changed by software (e.g. by wr iting CLKPS bits) communic ation via debugWIRE may\nfail. Also, clock frequencies below 100kHz may cause communication problems.\nA programmed DWEN Fuse enables some parts of the clock system to be running in all sleep modes. This will\nincrease the power consumption while in sleep. Thus, th e DWEN Fuse should be disabled when debugWire is not\nused.\n18.6 Register Description\nThe following section describes the registers used with the debugWire.\n18.6.1 DWDR – debugWire Data Register\nThe DWDR Register provides a co mmunication channel from the running program in the MCU to the debugger.\nThis register is only accessible by the debugWIRE and ca n therefore not be used as a general purpose register in\nthe normal operations.B i t 76543210\n0x22 DWDR7 DWDR6 DWDR5 DWDR4 DWDR3 DWDR2 DWDR1 DWDR0 DWDR\nRead/Write R/W R/W R/W R/W R/W R/W R/W R/WI n i t i a l  V a l u e00000000\n141 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201319. Self-Programming the Flash\nThe device provides a Self-Programming mechanism fo r downloading and uploading program code by the MCU\nitself. The Self-Programming can use an y available data interface and associ ated protocol to read code and write\n(program) that code into the Program memory. The SPM instruction is disabled by default but it can be enabled byprogramming the SELFPRGEN fuse (to “0”).\nThe Program memory is updated in a page by page fashion. Before programming a page with the data stored in\nthe temporary page  buffer, the page must be erased. The temporary page buffer is filled o ne word at a time using\nSPM and the buffer can be filled either before the Page Erase command or between a Page Erase and a Page\nWrite operation:\nAlternative 1, fill the bu ffer before a Page Erase\n• Fill temporary page buffer\n• Perform a Page Erase\n• Perform a Page Write\nAlternative 2, fill the buffer after Page Erase\n• Perform a Page Erase\n• Fill temporary page buffer\n• Perform a Page Write\nIf only a part of the page needs to be changed, the rest of  the page must be stored (for example in the temporary\npage buffer) before the erase, and then be re-written. When  using alternative 1, the Boot Loader provides an effec-\ntive Read-Modify-Write feature which allows the user so ftware to first read the page,  do the necessary changes,\nand then write back the modified data. If alternative 2 is used, it is not pos sible to read the old data while loading\nsince the page is already erased. The temporary page buffer can be accessed in a random sequence. It is essen-\ntial that the page address used in both the Page Erase and Page Write operation is addressing the same page.\n19.1 Performing Page  Erase by SPM\nTo execute Page Erase, set up the address in the Z-pointer, write “00000011” to SPMCSR and execute SPM\nwithin four clock cycles after writing SPMCSR. The data in R1 and R0 is ignored. The page address must be writ-\nten to PCPAGE in the Z-register . Other bits in the Z-pointer will be ignored during this operation.\nNote: The CPU is halted during the Page Erase operation.\n19.2 Filling the Temporary Buffer (Page Loading)\nTo write an instructio n word, set up the address in the Z-pointer and data in R1:R0, write “00000001” to SPMCSR\nand execute SPM within four clock cycles after writing SP MCSR. The content of PCWORD in the Z-register is used\nto address the data in the temporary buffer. The temporar y buffer will auto-era se after a Page Write operation or by\nwriting the CTPB bit in SPMCSR. It is also  erased after a system reset. Note t hat it is not possible to write more\nthan one time to each address without erasing the temporary buffer.\nIf the EEPROM is written in the middle of an SPM Page  Load operation, all dat a loaded will be lost.\n142 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201319.3 Performing a Page Write\nTo execute Page Write, set up the address in the Z-poi nter, write “00000101” to SPMCSR and execute SPM within\nfour clock cycles after writing SPMCSR. The data in R1 an d R0 is ignored. The page address must be written to\nPCPAGE. Other bits in the Z-pointer must be  written to zero du ring this operation.\nNote: The CPU is halted during the Page Write operation.\n19.4 Addressing the Flash During Self-Programming\nThe Z-pointer is used to address the SPM commands.\nSince the Flash is organized in pages (see Table 20-8 on page 150 ), the Program Counter can be treated as hav-\ning two different sections. One section, consisting of t he least significant bits, is  addressing the words within a\npage, while the most significant bits are addressing the pages. This is shown in Figure 19-1 . Note that the Page\nErase and Page Write operations are addressed independently. Therefore it is of major importance that the soft-\nware addresses the same page in both the Page Erase and Page Write operation. \nThe LPM instruction uses the Z-pointer  to store the address. Since this in struction addresses the Flash byte-by-\nbyte, also the LSB (bit Z0) of the Z-pointer is used.\nFigure 19-1. Addressing the Flash During SPM(1)\nNote: 1. The different variables used in Figure 19-1  are listed in Table 20-8 on page 150 . \n19.5 EEPROM Write Prevents  Writing to SPMCSR\nNote that an EEPROM write operation will block all software programming to Flash. Reading the Fuses and Lock\nbits from software will also  be prevented during the E EPROM write operati on. It is recomm ended that the user\nchecks the status bit (EEPE) in the EECR Register and verifies th at the bit is cleared bef ore writing to the SPMCSR\nRegister.B i t 1 51 41 31 21 11 09 8\nZH (R31) Z15 Z14 Z13 Z12 Z11 Z10 Z9 Z8Z L  ( R 3 0 )Z 7Z 6Z 5Z 4Z 3Z 2Z 1Z 0\n76543210\nPROGRAM MEMORY01 15\nZ - REGISTERBIT\n0ZPAGEMSB\nWORD ADDRESS\nWITHIN A PAGEPAGE ADDRESS\nWITHIN THE FLASHZPCMSB\nINSTRUCTION WORDPAGEPCWORD[PAGEMSB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCMSB PAGEMSB\nPROGRAM\nCOUNTER\n143 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201319.6 Reading Lock, Fuse and Si gnature Data from Software\nIt is possible to read fuse and lock bits from firmware. In addition, firmware can also read data from the device sig-\nnature imprint table (see page 149 ).\nNote: Fuse and Lock bits that are programmed, will be read as ze ro. Fuse and Lock bits that are unprogrammed, will be read \nas one.\n19.6.1 Reading Lock Bits from Firmware\nIssuing an LPM instruction within th ree CPU cycles after RFLB and SELFPRG EN bits have been set in SPMCSR\nwill return lock bit values in the destination register. The RFLB and SE LFPRGEN bits autom atically clear upon\ncompletion of reading the lock bits, or if no LPM inst ruction is executed within three CPU cycles, or if no SPM\ninstruction is executed within four CPU cycles. When RFLB and SELFPRGEN are cleared LPM functions normally.\nTo read the lock bits, follow the below procedure:\n1. Load the Z-pointer with 0x0001.\n2. Set RFLB and SELFPRGEN bits in SPMCSR.3. Issue an LPM instruction within three clock cycles.4. Read the lock bits from the LPM destination register.\nIf successful, the contents of the destination register are as follows.\nSee section “Program And Data Memory Lock Bits” on page 147  for more information.\n19.6.2 Reading Fuse Bits from Firmware\nThe algorithm for reading fuse  bytes is similar to the one described above for reading lock bits, only the addresses\nare different. To read the Fuse Low Byte (FLB), follow the below procedure:\n1. Load the Z-pointer with 0x0000.\n2. Set RFLB and SELFPRGEN bits in SPMCSR.3. Issue an LPM instruction within three clock cycles.4. Read the FLB from the LPM destination register.\nIf successful, the contents of the destination register are as follows.\nRefer to Table 20-5 on page 149  for a detailed description and mapping of the Fuse Low Byte.\nTo read the Fuse High Byte (FHB), simply replace the address in the Z-pointer with 0x0003 and repeat the proce-\ndure above. If successful, the contents of  the destination register are as follows.\nRefer to Table 20-4 on page 148  for detailed description and mapping of the Fuse High Byte.B i t 76543210\nR d –––––– L B 2 L B 1\nB i t 76543210Rd FLB7 FLB6 FLB5 FLB4 FLB3 FLB2 FLB1 FLB0\nB i t 76543210\nRd FHB7 FHB6 FHB5 FHB4 FHB3 FHB2 FHB1 FHB0\n144 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013To read the Fuse Extended Byte (FEB), replace the addres s in the Z-pointer with 0x0002 and repeat the previous\nprocedure. If successful, the contents of the destination register are as follows.\nRefer to Table 20-3 on page 148  for detailed description and mapping of the Fuse Extended Byte.\n19.6.3 Reading Device Signature  Imprint Table from Firmware\nTo read the contents of the device signat ure imprint table, follow the below procedure:\n1. Load the Z-pointer with the table index.\n2. Set RSIG and SPMEN bits in SPMCSR.3. Issue an LPM instruction within three clock cycles.4. Read table data from the LPM destination register.\nSee program example below.\nNote: 1. See “Code Examples” on page 6 .\nIf successful, the contents of the destinat ion register are as described in section “Device Signature Imprint Table”\non page 149 .\n19.7 Preventing Flash Corruption\nDuring periods of low VCC, the Flash program can be corrupted because the supply voltage is too low for the CPU\nand the Flash to operate properly. These issues are the sa me as for board level systems using the Flash, and the\nsame design solutions should be applied. \nA Flash program corruption can be caused by two situations  when the voltage is too low. First, a regular write\nsequence to the Flash requires a minimum voltage to operate correctly. Secondly, the CPU itself can execute\ninstructions incorrectly, if the supply vo ltage for executing inst ructions is too low.\nFlash corruption can easily be avoided by following these design recommendations  (one is sufficient):\n1. Keep the AVR RESET active (low) during periods of in sufficient power supply vo ltage. This can be done \nby enabling the internal Brown-out Detector (BOD) if the operating voltage matches the detection level. If B i t 76543210\nRd FEB7 FEB6 FEB5 FEB4 FEB3 FEB2 FEB1 FEB0\nAssembly Code Example(1)\nDSIT_read:\n; Uses Z-pointer as table indexldiZH, 0\nldiZL, 1\n; Preload SPMCSR bits into R16, then write to SPMCSRldir16, (1<<RSIG)|(1<<SPMEN)\nout SPMCSR, r16\n; Issue LPM. Table data will be returned into r17lpm r17, Z\nret\n145 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013not, an external low VCC reset protection circuit can be used. If a reset occurs while a write operation is in \nprogress, the write operation will be completed provided that  the power supply voltage is sufficient.\n2. Keep the AVR core in Power-down sleep mode during periods of low VCC. This will prevent the CPU from \nattempting to decode and execute inst ructions, effectively protecting th e SPMCSR Register and thus the \nFlash from unintentional writes.\n19.8 Programming Time for Flash when Using SPM\nThe calibrated RC Oscillator is used to time Flash accesses. Table 19-1  shows the typical programming time for\nFlash accesses from the CPU.\nNote: 1. Minimum and maximum programming time is per individual operation.\n19.9 Register Description\n19.9.1 SPMCSR – Store Program Memory Control and Status Register\nThe Store Program Memory Control and Status Register contains the control bits needed to control the Program\nmemory operations.\n• Bits 7:6 – Res: Reserved Bits\nThese bits are reserved bits in the AT tiny25/45/85 and always read as zero.\n• Bit 5 – RSIG: Read Device Signature Imprint Table\nIssuing an LPM instruction within three cycles after RS IG and SPMEN bits have been se t in SPMCSR will return\nthe selected data (depending on Z-pointer value) from th e device signature imprint tabl e into the destination regis-\nter. See “Device Signature Imprint Table” on page 149  for details.\n• Bit 4 – CTPB: Clear Temporary Page Buffer\nIf the CTPB bit is written while fillin g the temporary page buffe r, the temporary page buffer will be cleared and the\ndata will be lost.\n• Bit 3 – RFLB: Read Fuse and Lock Bits\nAn LPM instruction within three cycles after RFLB and SPMEN are set in the SPMCSR Register, will read either\nthe Lock bits or the Fuse bits (depending on Z0 in the Z-pointer) into the destination register. See “EEPROM Write\nPrevents Writing to SPMCSR” on page 142  for details.\n• Bit 2 – PGWRT: Page Write\nIf this bit is written to one at the same time as SPMEN , the next SPM instruction within four clock cycles executes\nPage Write, with the data st ored in the temporary buffer. The page address is taken from the high part of the Z-\npointer. The data in R1 and R0 are ig nored. The PGWRT bit will auto -clear upon completion of a Page Write, or if\nno SPM instruction is executed within four clock cycles. The CPU is halted during the entire Page Write operation.Table 19-1. SPM Programming Time(1)\nSymbol Min Programming Time Max Programming Time\nFlash write (Page Erase, Page Write, and \nwrite Lock bits by SPM)3.7 ms 4.5 ms\nBit 7 6 5 4 3 2 1 0\n0x37 – – RSIG CTPB RFLB PGWRT PGERS SPMEN SPMCSR\nRead/Write R R R/W R/W R/W R/W R/W R/WInitial Value 0 0 0 0 0 0 0 0\n146 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• Bit 1 – PGERS: Page Erase\nIf this bit is written to one at the same time as SPMEN , the next SPM instruction within four clock cycles executes\nPage Erase. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. ThePGERS bit will auto-clear upon co mpletion of a Page Erase, or if no SPM in struction is executed within four clock\ncycles. The CPU is halted during the entire Page Write operation.\n• Bit 0 – SPMEN: Store Program Memory Enable\nThis bit enables the SPM instruction for the next four cl ock cycles. If set to one together with RSIG, CTPB, RFLB,\nPGWRT or PGERS, the following LPM/ SPM instruction will have a special meaning, as de scribed elsewhere.\nIf only SPMEN is written, t he following SPM instruction w ill store the value in R1:R0 in the temporary page buffer\naddressed by the Z-poin ter. The LSB of the Z-pointer is ignored. The SPMEN bit will au to-clear upon completion of\nan SPM instruction, or if no SPM instruction is executed within four clock cycles. During Page Erase and Page\nWrite, the SPMEN bit remains high until the operation is completed. \n147 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320. Memory Programming\nThis section describes the different methods for Programming the ATtiny25/45/85 memories.\n20.1 Program And Data Memory Lock Bits\nATtiny25/45/85 provides two Lock bits which can be le ft unprogrammed (“1”) or can be programmed (“0”) to obtain\nthe additional security listed in Table 20-2 . Lock bits can be erased to “1” with the Chip Erase command, only.\nProgram memory can be read out via the debugWIRE interf ace when the DWEN fuse is programmed, even if the\nLock Bits are set. Thus, when Lock Bit security is requir ed debugWIRE should always be disabled (by clearing the\nDWEN fuse). \nNote: 1. “1” means unprogrammed, “0” means programmed\nNotes: 1. Program the Fuse bits before programming the LB1 and LB2.\n2. “1” means unprogrammed, “0” means programmed\nLock bits can also be read by device firmware. See section “Reading Lock, Fuse and Signature Data from Soft-\nware” on page 143 .Table 20-1. Lock Bit Byte(1)\nLock Bit Bit No Description Default Value\n7 – 1 (unprogrammed)6 – 1 (unprogrammed)\n5 – 1 (unprogrammed)\n4 – 1 (unprogrammed)3 – 1 (unprogrammed)\n2 – 1 (unprogrammed)\nLB2 1 Lock bit 1 (unprogrammed)LB1 0 Lock bit 1 (unprogrammed)\nTable 20-2. Lock Bit Protection Modes(1)(2) \nMemory Lock Bits Protection Type\nLB Mode LB2 LB1\n1 1 1 No memory lock features enabled.\n21 0Further programming of the Flash and EEPROM is disabled in \nHigh-voltage and Serial Programming mode. The Fuse bits are locked in both Serial and High-voltage Programming mode.\n(1) \ndebugWire is disabled.\n30 0Further programming and verification of the Flash and EEPROM \nis disabled in High-voltage and Serial Programming mode. The \nFuse bits are locked in both Serial and High-voltage \nProgramming mode.(1) debugWire is disabled.\n148 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.2 Fuse Bytes\nATtiny25/45/85 has three fuse bytes, as described in Table 20-3 , Table 20-4 , and Table 20-5 . Note that fuses are\nread as logical zero, “0”, when programmed.\nNotes: 1. Enables SPM instruction. See “Self-Programming the Flash” on page 141 .\nNotes: 1. Controls use of RESET  pin. See “Alternate Functions of Port B” on page 60 .\n2. After this fuse has been programmed device can be programmed via high-voltage serial mode, only.\n3. Must be unprogrammed when lock bit security is required. See “Program And Data Memory Lock Bits” on page \n147.\n4. This fuse is not accessible in SPI programming mode.\n5. See “WDTCR – Watchdog Timer Control Register” on page 45  for details.\n6. See table “BODLEVEL Fuse Coding. TA = -40°C to +85°C” on page 166 .Table 20-3. Fuse Extended Byte\nFuse High Byte Bit No De scription Default Value\n7 - 1 (unprogrammed)\n6 - 1 (unprogrammed)\n5 - 1 (unprogrammed)4 - 1 (unprogrammed)\n3 - 1 (unprogrammed)\n2 - 1 (unprogrammed)1 - 1 (unprogrammed)\nSELFPRGEN \n(1)0 Self-programming enabled 1 (unprogrammed)\nTable 20-4. Fuse High Byte\nFuse High Byte Bit No De scription Default Value\nRSTDISBL (1) (2)7 External reset disabled 1 (unprogrammed)\nDWEN (1) (2) (3)6 DebugWIRE enabled 1 (unprogrammed)\nSPIEN (4)5Serial program and data download \nenabled0 (programmed)\n(SPI prog. enabled)\nWDTON (5)4 Watchdog timer always on 1 (unprogrammed)\nEESAVE 3 EEPROM preserves chip erase1 (unprogrammed)\n(EEPROM not preserved)\nBODLEVEL2 (6)2 Brown-out Detector trig ger level 1 (unprogrammed)\nBODLEVEL1 (6)1 Brown-out Detector trig ger level 1 (unprogrammed)\nBODLEVEL0 (6)0 Brown-out Detector trig ger level 1 (unprogrammed)\n149 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Notes: 1. See “System Clock Prescaler” on page 31  for details.\n2. Allows system clock to be output on pin. See “Clock Output Buffer” on page 31  for details.\n3. The default value gives maximum start-up time for the default clock source. See Table 6-7 on page 28  for details.\n4. The default setting selects internal, 8 MHz RC oscillator. See Table 6-6 on page 27  for details.\nNote that fuse bits are locked if Lock Bit 1 (LB1) is programmed. Fuse bits should be programmed before lock bits.\nThe status of fuse bits is not affected by chip erase.\nLock bits can also be read by device firmware. See section “Reading Lock, Fuse and Signature Data from Soft-\nware” on page 143 .\n20.2.1 Latching of Fuses\nFuse values are latched when the devi ce enters programming mode  and changes to fuse va lues will have no effect\nuntil the part leaves programming mode.  This does not apply to the EESAVE Fuse which takes effect once it is pro-\ngrammed. Fuses are also latched on power-up.\n20.3 Device Signature Imprint Table\nThe device signature imprint table is a dedicated memo ry area used for storing miscellaneous device information,\nsuch as the device signature and oscillat or calibration data. Most of this memory segment is reserved for internal\nuse, as outlined in Table 20-6 .\nNotes: 1. See section “Signature Bytes” for more information.\n2. See section “Calibration Bytes” for more information.Table 20-5. Fuse Low Byte\nFuse Low Byte Bit No De scription Default Value\nCKDIV8 (1)7 Clock divided by 8 0 (programmed)\nCKOUT (2)6 Clock output enabled 1 (unprogrammed)\nSUT1 (3)5 Start-up time setti ng 1 (unprogrammed)(3)\nSUT0 (3)4 Start-up time setting 0 (programmed)(3)\nCKSEL3 (4)3 Clock source setting 0 (programmed)(4)\nCKSEL2 (4)2 Clock source setting 0 (programmed)(4)\nCKSEL1 (4)1 Clock source setting 1 (unprogrammed)(4)\nCKSEL0 (4)0 Clock source setting 0 (programmed)(4)\nTable 20-6. Contents of Device Signature Imprint Table.\nAddress High Byte\n0x00 Signature byte 0 (1)\n0x01 Calibration data for internal oscillator at 8.0 MHz (2)\n0x02 Signature byte 1 (1)\n0x03 Calibration data for internal oscillator at 6.4 MHz (2)\n0x04 Signature byte 2 (1)\n0x05 ... 0x2A Reserved for internal use\n150 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.3.1 Signature Bytes\nAll Atmel microcontrollers have a three-byte signature c ode which identifies the device. This code can be read in\nboth serial and high-voltage programming mode, even when the device is locked.\nSignature bytes can also be read by the device firmware. See section “Reading Lock, Fuse and Signature Data\nfrom Software” on page 143 .\nThe three signature bytes reside in a separate address space called the device  signature imprint table. The signa-\nture data for ATtiny25/45/85 is given in Table 20-7 .\n20.3.2 Calibration Bytes\nThe device signature imprint table of ATtiny25/45/85 contains two bytes of calibration data for the internal RC\nOscillator, as shown in Table 20-6 on page 149 . In normal mode of operation the calibration data for 8 MHz opera-\ntion is automatically fetched and written to the OSCCAL register during reset. In ATtiny15 compatibility mode the\ncalibration data for 6.4 MHz operation is used instead. This  procedure guarantees the internal oscillator is always\ncalibrated to the correct frequency.\nCalibration bytes can also be read by the device firmware. See section “Reading Lock, Fuse and Signature Data\nfrom Software” on page 143 .\n20.4 Page SizeTable 20-7. Device Signature Bytes\nPart Signature Byte 0 Signature  Byte 1 Signature Byte 0\nATtiny25 0x1E 0x91 0x08\nATtiny45 0x1E 0x92 0x06ATtiny85 0x1E 0x93 0x0B\nTable 20-8. No. of Words in a Page and No. of Pages in the Flash\nDevice Flash Size Page Size PCWORD No. of Pages PCPAGE PCMSB\nATtiny251K words \n(2K bytes)16 words PC[3:0] 64 PC[9:4] 9\nATtiny452K words \n(4K bytes)32 words PC[4:0] 64 PC[10:5] 10\nATtiny854K words \n(8K bytes)32 words PC[4:0] 128 PC[11:5] 11\nTable 20-9. No. of Words in a Page and  No. of Pages in the EEPROM\nDeviceEEPROM \nSize Page Size PCWORD No. of Pages PCPAGE EEAMSB\nATtiny25 128 bytes 4 by tes EEA[1:0] 32 EEA[6:2] 6\nATtiny45 256 bytes 4 by tes EEA[1:0] 64 EEA[7:2] 7\nATtiny85 512 bytes 4 by tes EEA[1:0] 128 EEA[8:2] 8\n151 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.5 Serial Downloading\nBoth the Flash and EEPROM memory arrays can be programmed using the serial SPI bus while RESET  is pulled\nto GND. The serial interface consists of pins SCK, MOSI (input) and MISO (output). See below.\nFigure 20-1. Serial Programming and Verify(1)\nNotes: 1. If the device is clocked by the internal Oscillator, it is no need to connect a clock source to the CLKI pin.\nAfter RESET  is set low, the Programming Enab le instruction needs to be executed  first before program/erase oper-\nations can be executed.\nNote: In Table 20-10  above, the pin mapping for SPI programming is list ed. Not all parts use the SPI pins dedicated for the \ninternal SPI interface.\nWhen programming the EEPROM, an auto-erase cycle is bu ilt into the self-timed pr ogramming operation (in the\nSerial mode ONLY) and there is no need to first execut e the Chip Erase instruction. The Chip Erase operation\nturns the content of ever y memory location in both the Progra m and EEPROM arrays into 0xFF.\nDepending on CKSEL Fuses, a valid cloc k must be present. The minimum low a nd high periods for the serial clock\n(SCK) input are defined as follows:\nLow: > 2 CPU clock cycles for fck < 12 MHz, 3 CPU clock cycles for fck >= 12 MHz\nHigh: > 2 CPU clock cycles for fck < 12 MHz, 3 CPU clock cycles for fck >= 12 MHz\n20.5.1 Serial Programming Algorithm\nWhen writing serial data to the ATtiny25/45/85 , data is clocked on the rising edge of SCK.\nWhen reading data from the ATti ny25/45/85, data is clocked on the falling edge of SCK. See Figure 21-4  and Fig-\nure 21-5  for timing details.Table 20-10. Pin Mapping Serial Programming\nSymbol Pins I/O Description\nMOSI PB0 I Serial Data in\nMISO PB1 O Serial Data out\nSCK PB2 I Serial ClockVCC\nGNDSCKMISOMOSI\nRESET+1.8 - 5.5V\n152 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013To program and verify the ATtiny25/45/85 in the Serial Programming mode, the following sequence is recom-\nmended (see four byte instruction formats in Table 20-12 ):\n1. Power-up sequence: apply power between VCC and GND while RESET  and SCK are set to “0”\n– In some systems, the programmer can not guarantee that SCK is held low dur ing power-up . In this \ncase, RESET  must be given a positive pulse after SCK has been set to \'0\'. The duration of the pulse \nmust be at least tRST plus two CPU clock cycles. See Table 21-4 on page 165  for minimum pulse width \non RESET  pin, tRST\n2. Wait for at least 20 ms and enable serial programmi ng by sending the Programming Enable serial instruc-\ntion to pin MOSI.\n3. The serial programming instru ctions will not work if th e communication is out of synchronization. When in \nsync. the second byte (0x53), will echo back when issuing the third byte of  the Programming Enable \ninstruction. Whether the echo is correc t or not, all four bytes of the inst ruction must be transmitted. If the \n0x53 did not echo back, give RESET  a positive pulse and issue a new Programming Enable command. \n4. The Flash is programmed one page at a time. The memory  page is loaded one byte at a time by supplying \nthe 5 LSB of the address and data together with the Load Program memory Page instruction. To ensure \ncorrect loading of the page, the data low byte must be loaded before data high byte is applied for a given address. The Program memory Page is stored by loading the Write Program memory Page instruction \nwith the 6 MSB of the ad dress. If polling (RDY/BSY)\n is not used, the user must wait at least tWD_FLASH  \nbefore issuing the next page. (See Table 20-11 .) Accessing the serial programming interface before the \nFlash write operation completes can result in incorrect programming.\n5.A: The EEPROM array is prog rammed one byte at a time by supplyin g the address and data together with \nthe appropriate Write instruction. An EEPROM memory  location is first automatically erased before new \ndata is written. If polling (RDY/BSY)  is not used, the user must wait at least tWD_EEPROM before issuing the \nnext byte. (See Table 20-11 .) In a chip erased device, no 0xFFs in the data file(s) need to be pro-\ngrammed.B: The EEPROM array is programmed one page at a time. The Memory page is loaded one byte at a time \nby supplying the 2 LSB of  the address an d data together wit h the Load EEPROM Memo ry Page instruc-\ntion. The EEPROM Memory Page is stored by loading the Write EEPR OM Memory Page Instruction with \nthe 6 MSB of the address. When using EEPROM page access only byte locations loaded  with the Load \nEEPROM Memory Page instruction is altered. The remaining locations re main unchanged . If polling \n(RDY/BSY)\n is not used, the used must wait at least tWD_EEPROM  before issuing the next page (See Table \n20-9). In a chip erased device, no 0xFF in the data file(s) need to be programmed.\n6. Any memory location can be verified by using th e Read instruction which returns the content at the \nselected address at serial output MISO.\n7. At the end of the pr ogramming session, RESET  can be set high to commence normal operation.\n8. Power-off sequence (if needed):\nSet RESET  to “1”.\nTurn VCC power off.\n153 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.5.2 Serial Programming Instruction set\nTable 20-12 on page 153  and Figure 20-2 on page 154  describes the Instruction set.\nNotes: 1. Not all instructions are applicable for all parts.Table 20-11. Minimum Wait Delay Before Writing the Next Flash or EEPROM Location\nSymbol Minimum Wait Delay\ntWD_FLASH 4.5 ms\ntWD_EEPROM 4.0 ms\ntWD_ERASE 9.0 ms\ntWD_FUSE 4.5 ms\nTable 20-12. Serial Programming Instruction Set\nInstruction/OperationInstruction Format\nByte 1 Byte 2 Byte 3 Byte4\nProgramming Enable $AC $53 $00 $00\nChip Erase (Program Memory/EEPROM) $AC $80 $00 $00Poll RDY/BSY\n$F0 $00 $00 data byte out\nLoad Instructions\nLoad Extended Address byte(1)$4D $00 Extended adr $00\nLoad Program Memory Page, High byte $48 adr MSB adr LSB high data byte in\nLoad Program Memory Page, Low byte $40 adr MSB adr LSB low data byte in\nLoad EEPROM Memory Page (page access) $C1 $00 0000 000aa data byte inRead Instructions\nRead Program Memory, High byte $28 adr MSB adr LSB high data byte out\nRead Program Memory, Low byte $20 adr MSB adr LSB low data byte outRead EEPROM Memory $A0 $00 00aa aaaa data byte out\nRead Lock bits $58 $00 $00 data byte out\nRead Signature Byte $30 $00 0000 000aa data byte outRead Fuse bits $50 $00 $00 data byte out\nRead Fuse High bits $58 $08 $00 data byte out\nRead Extended Fuse Bits $50 $08 $00 data byte outRead Calibration Byte $38 $00 $00 data byte out\nWrite Instructions\n(6)\nWrite Program Memory Page $4C adr MSB adr LSB $00\nWrite EEPROM Memory $C0 $00 00aa aaaa data byte in\nWrite EEPROM Memory Page (page access) $C2 $00 00aa aa00 $00\nWrite Lock bits $AC $E0 $00 data byte in\nWrite Fuse bits $AC $A0 $00 data byte in\nWrite Fuse High bits $AC $A8 $00 data byte inWrite Extended Fuse Bits $AC $A4 $00 data byte in\n154 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20132. a = address\n3. Bits are programmed ‘0’, unprogrammed ‘1’.4. To ensure future compatibility, unused Fuses and Lock bits should be unprogrammed (‘1’) .\n5. Refer to the correspondig section for Fuse and Lock bits, Calibration and Signature bytes and Page size.\n6. Instructions accessing program memory use a word address. This address may be random within the page range.7. See htt://www.atmel.com/avr for Applicati on Notes regarding programming and programmers.\nIf the LSB in RDY/BSY data byte out is ‘1’,  a programming operation is  still pending. Wait un til this bit returns ‘0’\nbefore the next instruction is carried out.\nWithin the same page, the low data byte must be loaded prior to the high data byte.After data is loaded to the page buffer, program the EEPROM page, see Figure 20-2 on page 154 .\nFigure 20-2. Serial Programming Instruction example\nByte 1 Byte 2 Byte 3 Byte 4\nAdr MSB Adr LSB\nBit 15  B        0Serial Programming Instruction\nProgram Memory/\nEEPROM MemoryPage 0\nPage 1\nPage 2\nPage N-1Page BufferWrite Program Memory Page/\nWrite EEPROM Memory PageLoad Program Memory Page (High/Low Byte)/\nLoad EEPROM Memory Page (page access)\nByte 1 Byte 2 Byte 3 Byte 4\nBit 15  B        0Adr MSB Adr LSB\nPage Offset\nPage NumberAdrdr Mr MSSB A AAdrdr LS LSBSB\n155 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.6 High-voltage Serial Programming\nThis section describes how to program and verify Fl ash Program memory, EEPROM Data memory, Lock bits and\nFuse bits in the ATtiny25/45/85.\nFigure 20-3. High-voltage Serial Programming\nThe minimum period for the Serial Clock Input (SCI) during High-voltage Serial Programming is 220 ns.\n20.7 High-voltage Serial  Programming Algorithm\nTo program and verify the ATtiny25/45/85 in the High-vo ltage Serial Programming mode, the following sequence is\nrecommended (See instruction formats in Table 20-16 ):Table 20-13. Pin Name Mapping\nSignal Name in  High-voltage \nSerial Programming Mode Pin Name I/O Function\nSDI PB0 I Serial Data Input\nSII PB1 I Serial Instruction Input\nSDO PB2 O Serial Data OutputSCI PB3 I Serial Clock Input  (min. 220ns period)\nTable 20-14. Pin Values Used to Enter Programming Mode\nPin Symbol Value\nSDI Prog_enable[0] 0SII Prog_enable[1] 0\nSDO Prog_enable[2] 0VCC\nGNDSDO\nSIISDI(RESET)+4.5 - 5.5V\nPB0PB1PB2PB5+11.5 - 12.5V\nPB3 SCI\n156 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.7.1 Enter High-voltage Serial Programming Mode\nThe following algorithm puts the device in High-voltage Serial Programming mode:\n1. Set Prog_enable pins listed in Table 20-14  to “000”, RESET pin and VCC to 0V.\n2. Apply 4.5 - 5.5V between VCC and GND. Ensure that VCC reaches at least 1.8V within the next 20 µs.\n3. Wait 20 - 60 µs, and apply 11.5 - 12.5V to RESET.4. Keep the Prog_enable pins unchanged for at least 10 µs after the High-voltage has been applied to \nensure the Prog_enable Signature has been latched.\n5. Release the Prog_enable[2] pin to avoid driv e contention on the Prog_enable[2]/SDO pin.\n6. Wait at least 300 µs before giving any serial instructions on SDI/SII.\n7. Exit Programming mode by po wer the device down or by bringing RESET pin to 0V.\nIf the rise time of the V\nCC is unable to fulfill the requir ements listed above, the follo wing alternative algorithm can be\nused:\n1. Set Prog_enable pins listed in Table 20-14  to “000”, RESET pin and VCC to 0V.\n2. Apply 4.5 - 5.5V between VCC and GND.\n3. Monitor VCC, and as soon as VCC reaches 0.9 - 1.1V, appl y 11.5 - 12.5V to RESET.\n4. Keep the Prog_enable pins unchanged for at least 10 µs after the High-voltage has been applied to \nensure the Prog_enable Signature has been latched.\n5. Release the Prog_enable[2] pin to avoid driv e contention on the Prog_enable[2]/SDO pin.\n6. Wait until VCC actually reaches 4.5 - 5.5V before giving any serial instructions on SDI/SII.\n7. Exit Programming mode by po wer the device down or by bringing RESET pin to 0V.\n20.7.2 Considerations for Efficient Programming\nThe loaded command and address are retained in the devic e during programming. For efficient programming, the\nfollowing should be considered.\n• The command needs only be loaded once when writing or reading multiple memory locations.\n• Skip writing the data value 0xFF that is the cont ents of the entire EEPROM (unless the EESAVE Fuse is \nprogrammed) and Flash after a Chip Erase.\n• Address High byte needs only be loaded before progra mming or reading a new 256 word window in Flash or \n256 byte EEPROM. This consideration al so applies to Signature bytes reading.\n20.7.3 Chip Erase\nThe Chip Erase will erase the Flash and EEPROM(1) memories plus Lock bits. The Lo ck bits are not reset until the\nProgram memory has been completely erased. The Fuse bits are not changed. A Chip Erase must be performed\nbefore the Flash and/or EEPROM ar e re-programmed.\nNote: 1. The EEPROM memory is preserved during  Chip Erase if the EESAVE Fuse is programmed.Table 20-15. High-voltage Reset Characteristics\nSupply Voltage R ESET Pin High-vol tage ThresholdMinimum High-voltage Period for \nLatching Prog_enable\nVCC VHVRST tHVRST\n4.5V 11.5V 100 ns5.5V 11.5V 100 ns\n157 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20131. Load command “Chip Erase” (see Table 20-16 ).\n2. Wait after Instr. 3 until SDO goes high  for the “Chip Erase” cycle to finish.\n3. Load Command “No Operation”.\n20.7.4 Programming the Flash\nThe Flash is organized in pages, see Table 20-12 on page 153 . When programming the Flash, the program data is\nlatched into a page buffer. This allows one page of prog ram data to be programmed simultaneously. The following\nprocedure describes how to program the entire Flash memory:\n1. Load Command “Write Flash” (see Table 20-16 ).\n2. Load Flash Page Buffer.3. Load Flash High Address and Program Page.  Wait af ter Instr. 3 until SDO goes high for the “Page Pro-\ngramming” cycle to finish.\n4. Repeat 2 through 3 until the entire Flash is programmed or until all data has been programmed.5. End Page Programming by Loading Command “No Operation”.\nWhen writing or reading serial data to the ATtiny25/45/85, data is clocked on t he rising edge of the serial clock, see\nFigure 20-5 , Figure 21-6  and Table 21-12  for details.\nFigure 20-4. Addressing the Flash which is Organized in Pages\nFigure 20-5. High-voltage Serial Programming WaveformsPROGRAM MEMORYWORD ADDRESS\nWITHIN A PAGEPAGE ADDRESS\nWITHIN THE FLASH\nINSTRUCTION WORDPAGEPCWORD[PAGEMSB:0]:\n00\n01\n02\nPAGEENDPAGEPCWORD PCPAGEPCMSB PAGEMSB\nPROGRAM\nCOUNTER\nMSB\nMSB\nMSB LSBLSBLSB\n0123456789 1 0SDI\nPB0\nSII\nPB1\nSDO\nPB2\nSCI\nPB3\n158 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201320.7.5 Programming the EEPROM\nThe EEPROM is organi zed in pages, see Table 21-11 on page 170 . When programming the EEPROM, the data is\nlatched into a page buffer. This allows one page of da ta to be programmed simultaneously. The programming algo-\nrithm for the EEPROM Da ta memory is as follows (refer to Table 20-16 ):\n1. Load Command “Write EEPROM”.\n2. Load EEPROM Page Buffer.3. Program EEPROM Page. Wait after Instr. 2 until SDO goes high fo r the “Page Program ming” cycle to \nfinish.\n4. Repeat 2 through 3 until the entire EEPROM is  programmed or until a ll data has been programmed.\n5. End Page Programming by Loading Command “No Operation”.\n20.7.6 Reading the Flash\nThe algorithm for reading the Flash memory is as follows (refer to Table 20-16 ):\n1. Load Command "Read Flash".\n2. Read Flash Low and High Bytes. The contents at the selected address are avail able at serial output SDO.\n20.7.7 Reading the EEPROM\nThe algorithm for reading  the EEPROM memory is as follows (refer to Table 20-16 ):\n1. Load Command “Read EEPROM”.\n2. Read EEPROM Byte. The contents at the select ed address are available at serial output SDO.\n20.7.8 Programming and Reading the Fuse and Lock Bits\nThe algorithms for programming and reading the Fuse  Low/High bits and Lock bits are shown in Table 20-16 .\n20.7.9 Reading the Signature Bytes and Calibration Byte\nThe algorithms for reading the Signature bytes and Calibration byte are shown in Table 20-16 .\n20.7.10 Power-off sequence\nSet SCI to “0”. Set RE SET to “1”. Turn V\nCC power off.\nTable 20-16. High-voltage Serial Programming Instruction Set for ATtiny25/45/85\nInstructionInstruction Format\nOperation Remarks Instr.1/5 Instr.2/6 Instr.3 Instr.4\nChip EraseSDI\nSIISDO0_1000_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxWait after Instr.3 until SDO \ngoes high for the Chip Erase \ncycle to finish.\nLoad “Write \nFlash” CommandSDI\nSIISDO0_0001_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xxEnter Flash Programming \ncode.\nLoad Flash \nPage BufferSDI\nSIISDO0_bbbb _bbbb  _00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_eeee _eeee _00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_dddd _dddd _00\n0_0011_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1101_00\nx_xxxx_xxxx_xxRepeat after Instr. 1 - 5 until \nthe entire page buffer is filled \nor until all data within the page is filled.\n(2)\nSDI\nSIISDO0_0000_0000_00\n0_0111_1100_00\nx_xxxx_xxxx_xx Instr 5.\n159 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Load Flash \nHigh Address and Program \nPageSDI\nSIISDO0_0000_000 a_00\n0_0001_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxWait after Instr 3 until SDO \ngoes high. Repeat Instr. 2 - 3 for each loaded Flash Page \nuntil the entire Flash or all \ndata is programmed. Repeat Instr. 1 for a new 256 byte \npage.\n(2)\nLoad “Read \nFlash” CommandSDI\nSIISDO0_0000_0010_00\n0_0100_1100_00\nx_xxxx_xxxx_xxEnter Flash Read mode.\nRead Flash \nLow and High BytesSDI\nSIISDO0_bbbb _bbbb _00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_0000_000 a_00\n0_0001_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nq_qqqq _qqqx_xxRepeat Instr. 1, 3 - 6 for each \nnew address. Repeat Instr. 2 \nfor a new 256 byte page.\nSDI\nSIISDO0_0000_0000_00\n0_0111_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1100_00\np_pppp _pppx_xxInstr 5 - 6.\nLoad “Write \nEEPROM” CommandSDI\nSIISDO0_0001_0001_00\n0_0100_1100_00\nx_xxxx_xxxx_xxEnter EEPROM Programming \nmode.\nLoad \nEEPROM \nPage BufferSDI\nSIISDO0_00 bb_bbbb _00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_aaaa _aaaa _00\n0_0001_1100_00\nx_xxxx_xxxx_xx0_eeee _eeee _00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1101_00\nx_xxxx_xxxx_xxRepeat Instr. 1 - 5 until the \nentire page buffer is filled or \nuntil all data within the page is \nfilled.\n(3)\nSDI\nSIISDO0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxInstr. 5\nProgram \nEEPROM PageSDI\nSIISDO0_0000_0000_00\n0_0110_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxWait after Instr. 2 until SDO \ngoes high. Repeat Instr. 1 - 2 for each loaded EEPROM \npage until the entire \nEEPROM or all data is programmed.\nWrite \nEEPROM \nByteSDI\nSIISDO0_bbbb _bbbb _00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_aaaa _aaaa _00\n0_0001_1100_00\nx_xxxx_xxxx_xx0_eeee _eeee _00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1101_00\nx_xxxx_xxxx_xxRepeat Instr. 1 - 6 for each \nnew address. Wait after Instr. \n6 until SDO goes high.\n(4)\nSDI\nSIISDO0_0000_0000_00\n0_0110_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxInstr. 6\nLoad “Read \nEEPROM” \nCommandSDI\nSIISDO0_0000_0011_00\n0_0100_1100_00\nx_xxxx_xxxx_xxEnter EEPROM Read mode.\nRead \nEEPROM \nByteSDI\nSIISDO0_bbbb _bbbb _00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_aaaa _aaaa _00\n0_0001_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nq_qqqq _qqq0_00Repeat Instr. 1, 3 - 4 for each \nnew address. Repeat Instr. 2 \nfor a new 256 byte page.\nWrite Fuse \nLow BitsSDI\nSIISDO0_0100_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_A987 _6543 _00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxWait after Instr. 4 until SDO \ngoes high. Write A - 3  = “0” to \nprogram the Fuse bit.Table 20-16. High-voltage Serial Programming Instru ction Set for ATtiny25/45/85 (Continued)\nInstructionInstruction Format\nOperation Remarks Instr.1/5 Instr.2/6 Instr.3 Instr.4\n160 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Notes: 1. a = address high bits, b = address low bits, d = data in high bits, e = data in low bits, p = data out high bits, q = data out low \nbits, x = don’t care, 1 = Lock Bit1, 2 = Lock Bit2, 3 = CKSEL0 Fuse, 4 = CKSEL1 Fuse, 5 = CKSEL2 Fuse, 6 = CKSEL3 \nFuse, 7 = SUT0 Fuse, 8 = SUT1 Fuse, 9 = CKOUT Fuse, A = CKDIV8 Fuse, B = BODLEVEL0 Fuse, C = BODLEVEL1 \nFuse, D = BODLEVEL2 Fuse, E = EESAVE Fuse, F = WDTON Fuse, G = SPIEN Fuse, H = DWEN Fuse, I = RSTDISBL \nFuse, J = SELFPRGEN Fuse\n2. For page sizes less than 256 words, parts of th e address (bbbb_bbbb) will be parts of the page address.\n3. For page sizes less than 256 bytes, parts of t he address (bbbb_bbbb) will be parts of the page address.\n4. The EEPROM is written page-wise. But onl y the bytes that are loaded into the p age are actually written to the EEPROM. \nPage-wise EEPROM access is more efficient when multiple bytes are to be written to the same page. Note that auto-erase \nof EEPROM is not available in High-voltage Serial Programming, only in SPI Programming.Write Fuse \nHigh BitsSDI\nSIISDO0_0100_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_IHGF _EDCB _00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1100_00\nx_xxxx_xxxx_xxWait after Instr. 4 until SDO \ngoes high. Write I - B = “0” to \nprogram the Fuse bit.\nWrite Fuse \nExtended BitsSDI\nSIISDO0_0100_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_000 J_00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_0110_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1110_00\nx_xxxx_xxxx_xxWait after Instr. 4 until SDO \ngoes high. Write J = “0” to \nprogram the Fuse bit.\nWrite Lock \nBitsSDI\nSIISDO0_0010_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_00 21_00\n0_0010_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_0100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nx_xxxx_xxxx_xxWait after Instr. 4 until SDO \ngoes high. Write 2 - 1 = “0” to \nprogram the Lock bit.\nRead Fuse \nLow BitsSDI\nSIISDO0_0000_0100_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nA_9876 _543x_xxReading A - 3  = “0” means \nthe Fuse bit is programmed.\nRead Fuse \nHigh BitsSDI\nSIISDO0_0000_0100_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1010_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1110_00\nI_HGFE _DCB x_xxReading I - B = “0” means the \nFuse bit is programmed.\nRead Fuse \nExtended BitsSDI\nSIISDO0_0000_0100_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1010_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1110_00\nx_xxxx_xxJx_xxReading J = “0” means the \nFuse bit is programmed.\nRead Lock \nBitsSDI\nSIISDO0_0000_0100_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1100_00\nx_xxxx_x 21x_xxReading 2, 1 = “0” means the \nLock bit is programmed.\nRead \nSignature \nBytesSDI\nSIISDO0_0000_1000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_00 bb_00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0110_1100_00\nq_qqqq _qqqx_xxRepeats Instr 2 4 for each \nsignature byte address.\nRead \nCalibration ByteSDI\nSIISDO0_0000_1000_00\n0_0100_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0000_1100_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1000_00\nx_xxxx_xxxx_xx0_0000_0000_00\n0_0111_1100_00\np_pppp _pppx_xx\nLoad “No \nOperation” \nCommandSDI\nSII\nSDO0_0000_0000_00\n0_0100_1100_00\nx_xxxx_xxxx_xxTable 20-16. High-voltage Serial Programming Instru ction Set for ATtiny25/45/85 (Continued)\nInstructionInstruction Format\nOperation Remarks Instr.1/5 Instr.2/6 Instr.3 Instr.4\n161 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321. Electrical Characteristics\n21.1 Absolute Maximum Ratings*\n21.2 DC CharacteristicsOperating Temperature.................................. -55 \uf0b0C to +125 \uf0b0C *NOTICE: Stresses beyond those listed under “Absolute \nMaximum Ratings” may cause permanent dam-\nage to the device. This is a stress rating only and \nfunctional operation of the device at these or \nother conditions beyond those indicated in the \noperational sections of th is specification is not \nimplied. Exposure to absolute maximum rating \nconditions for extended periods may affect \ndevice reliability.Storage Temperature ..................................... -65°C to +150°C\nVoltage on any Pin except RESET\nwith respect to Ground ................................-0.5V to VCC+0.5V\nVoltage on RESET  with respect to Ground......-0.5V to +13.0V\nMaximum Operating Voltage ............................................ 6.0VDC Current per I/O Pin ............................................... 40.0 mA\nDC Current \nVCC and GND Pins................................ 200.0 mA\nTable 21-1.  DC Characteristics. TA = -40\uf0b0C to +85 \uf0b0C \nSymbol Parameter Condition Min. Typ.(1)Max. Units\nVILInput Low-voltage, except\nXTAL1 and RESET  pinVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V-0.5\n-0.50.2VCC(3)\n0.3VCC(3)V\nV\nVIHInput High-voltage, except\nXTAL1 and RESET  pinVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.7VCC(2)\n0.6VCC(2)VCC +0.5\nVCC +0.5V\nV\nVIL1Input Low-voltage, XTAL1 pin, \nExternal Clock SelectedVCC = 1.8V - 5.5V -0.5 0.1VCC(3)V\nVIH1Input High-voltage, XTAL1 pin, \nExternal Clock SelectedVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.8VCC(2)\n0.7VCC(2)VCC +0.5\nVCC +0.5V\nV\nVIL2Input Low-voltage,\nRESET  pinVCC = 1.8V - 5.5V -0.5 0.2VCC(3) V\nV\nVIH2Input High-voltage,\nRESET  pinVCC = 1.8V - 5.5V 0.9VCC(2)VCC +0.5 V\nVIL3Input Low-voltage,\nRESET  pin as I/OVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V-0.5\n-0.50.2VCC(3)\n0.3VCC(3)V\nV\nVIH3Input High-voltage,\nRESET  pin as I/OVCC = 1.8V - 2.4V\nVCC = 2.4V - 5.5V0.7VCC(2)\n0.6VCC(2)VCC +0.5\nVCC +0.5V\nV\nVOLOutput Low-voltage,(4)\nPort B (except RESET ) (6)IOL = 10 mA, VCC = 5V\nIOL = 5 mA, VCC = 3V0.6\n0.5V\nV\nVOHOutput High-voltage, (5)\nPort B (except RESET ) (6)IOH = -10 mA, VCC = 5V\nIOH = -5 mA, VCC = 3V4.3\n2.5V\nV\nIILInput Leakage\nCurrent I/O PinVCC = 5.5V, pin low\n(absolute value)< 0.05 1 µA\nIIHInput Leakage\nCurrent I/O PinVCC = 5.5V, pin high\n(absolute value)< 0.05 1 µA\nRRST Reset Pull-up Resistor VCC = 5.5V, input low 30 60 k \uf057\n162 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Notes: 1. Typical values at 25 \uf0b0C.\n2. “Min” means the lowest value where th e pin is guaranteed to be read as high.\n3. “Max” means the highest value where the pin is guaranteed to be read as low.4. Although each I/O port can sink more  than the test conditions (10 mA at V\nCC = 5V, 5 mA at VCC = 3V) under steady state \nconditions (non-transient), t he following must be observed:\n1] The sum of all IOL, for al l ports, should not exceed 60 mA.\nIf IOL exceeds the test conditio n, VOL may exceed the related sp ecification. Pins ar e not guaranteed to sink current greater \nthan the listed test condition.\n5. Although each I/O port can source more than the test conditions (10 mA at VCC = 5V, 5 mA at VCC = 3V) under steady state \nconditions (non-transient), t he following must be observed:\n1] The sum of all IOH, for all ports, should not exceed 60 mA.\nIf IOH exceeds the test condition, VOH may exceed the relat ed specification. Pins are not guaranteed to source current \ngreater than the listed test condition.\n6. The RESET  pin must tolerate high voltages when entering and op erating in programming modes and, as a consequence, \nhas a weak drive strength as compared to regular I/O pins. See Figure 22-23 , Figure 22-24 , Figure 22-25 , and Figure 22-26  \n(starting on page 184 ).\n7. Values are with external clo ck using methods described in “Minimizing Power Consumption” on page 36 . Power Reduction \nis enabled (PRR = 0xFF) and there is no I/O drive.\n8. Brown-Out Detection (BOD) disabled.Rpu I/O Pin Pull-up Resistor VCC = 5.5V, input low 20 50 k \uf057\nICCPower Supply Current (7)Active 1 MHz, VCC = 2V 0.3 0.55 mA\nActive 4 MHz, VCC = 3V 1.5 2.5 mA\nActive 8 MHz, VCC = 5V 5 8 mA\nIdle 1 MHz, VCC = 2V 0.1 0.2 mA\nIdle 4 MHz, VCC = 3V 0.35 0.6 mA\nIdle 8 MHz, VCC = 5V 1.2 2 mA\nPower-down mode (8)WDT enabled, VCC = 3V 10 µA\nWDT disabled, VCC = 3V 2 µATable 21-1.  DC Characteristics. TA = -40\uf0b0C to +85 \uf0b0C  (Continued)\nSymbol Parameter Condition Min. Typ.(1)Max. Units\n163 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321.3 Speed\nFigure 21-1. Maximum Frequency vs. VCC\nFigure 21-2. Maximum Frequency vs. VCC10 MHz\n4 MHz\n1.8V 2.7V 5.5VSafe Operating Area\n20 MHz\n10 MHz\n2.7V 4.5V 5.5VSafe Operating Area\n164 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321.4 Clock Characteristics\n21.4.1 Calibrated Internal RC Oscillator Accuracy\nIt is possible to manually ca librate the internal os cillator to be more a ccurate than default fa ctory calibration. Please\nnote that the oscillator frequency depend s on temperature and voltage. Volta ge and temperature characteristics\ncan be found in Figure 22-40 on page 193  and Figure 22-41 on page 193 .\nNotes: 1. Accuracy of oscillator frequency at calibrat ion point (fixed temperature and fixed voltage).\n2. ATtiny25/V, only: 6.4 MHz in ATtiny15 Compatibility Mode.\n3. Voltage range for ATtiny25V/45V/85V.\n4. Voltage range for ATtiny25/45/85.\n21.4.2 External Clock Drive\nFigure 21-3. External Clock Drive WaveformsTable 21-2. Calibration Accuracy of Internal RC Oscillator\nCalibration\nMethod Target Frequency VCC TemperatureAccuracy at given Voltage \n& Temperature (1)\nFactory\nCalibration8.0 MHz (2)3V 25 \uf0b0C± 1 0 %\nUser\nCalibrationFixed frequency within:\n6 – 8 MHzFixed voltage within:\n1.8V - 5.5V (3)\n2.7V - 5.5V (4)Fixed temperature \nwithin:\n-40\uf0b0C to +85 \uf0b0C±1%\nVIL1VIH1\nTable 21-3. External Clock Driv e Characteristics\nSymbol ParameterVCC = 1.8 - 5.5V VCC = 2.7 - 5.5V VCC = 4.5 - 5.5V\nUnits Min. Max. Min. Max. Min. Max.\n1/tCLCL Clock Frequency 0 4 0 10 0 20 MHz\ntCLCL Clock Period 250 100 50 ns\ntCHCX High Time 100 40 20 ns\ntCLCX Low Time 100 40 20 ns\ntCLCH Rise Time 2.0 1.6 0.5 µs\ntCHCL Fall Time 2.0 1.6 0.5 µs\n\uf044tCLCL Change in period fr om one clock cycle to the next 2 2 2 %\n165 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321.5 System and Reset Characteristics\nNote: 1. Values are guidelines only.\nTwo versions of power-on reset have been implemented, as follows.\n21.5.1 Standard Power-On Reset\nThis implementation of power-on reset existed in early versions of ATtiny 25/45/85. The table be low describes the\ncharacteristics of this power-on reset and it  is valid for the fo llowing devices, only:\n• ATtiny25, revision D, and older\n• ATtiny45, revision F, and older\n• ATtiny85, revision B, and newer\nNote: Revisions are marked on the package (pack ages 8P3 and 8S2: bottom, package 20M1: top)\nNote: 1. Values are guidelines, only\n2. Threshold where device is released from reset when voltage is rising3. The power-on reset will not work unless the supply voltage has been below V\nPOA\n21.5.2 Enhanced Power-On Reset\nThis implementation of power-on reset exists in newer versions of ATtiny 25/45/85. The table bel ow describes the\ncharacteristics of this power-on reset and it  is valid for the fo llowing devices, only:\n• ATtiny25, revision E, and newerTable 21-4. Reset, Brown-out and Internal Voltage Characteristics\nSymbol Parameter Condition Min(1)Typ(1)Max(1)Units\nVRST RESET  Pin Threshold Voltage VCC = 3V 0.2 VCC 0.9 VCC V\ntRSTMinimum pulse width on \nRESET  PinVCC = 3V 2.5 µs\nVHYST Brown-out Detector Hysteresis 50 mV\ntBODMin Pulse Width on \nBrown-out Reset2µ s\nVBGBandgap reference \nvoltageVCC = 5.5V\nTA= 25°C1.0 1.1 1.2 V\ntBGBandgap reference \nstart-up timeVCC = 2.7V\nTA= 25°C40 70 µs\nIBGBandgap reference \ncurrent consumptionVCC = 2.7V\nTA= 25°C15 µA\nTable 21-5. Characteristics of Standard Power-On Reset. TA = -40\uf0b0 to +85\uf0b0C\nSymbol Parameter Min(1)Typ(1)Max(1)Units\nVPOR Release threshold of power-on reset (2)0.7 1.0 1.4 V\nVPOA Activation threshold of power-on reset (3)0.05 0.9 1.3 V\nSRON Power-on slope rate 0.01 4.5 V/ms\n166 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013• ATtiny45, revision G, and newer\n• ATtiny85, revision C, and newer\nNote: 1. Values are guidelines, only\n2. Threshold where device is released from reset when voltage is rising\n3. The Power-on Reset will not work unless the supply voltage has been below VPOT (falling)\n21.6 Brown-Out Detection\nNote: 1. VBOT may be below nominal minimum operating voltage for some  devices. For devices where this is the case, the \ndevice is tested down to VCC = VBOT during the production test. This guarantees that a Brown-out Reset will occur \nbefore VCC drops to a voltage where correct operation of the microcontroller is no longer guaranteed. Table 21-6. Characteristics of Enhanced Power-On Reset. TA = -40\uf0b0C to +85 \uf0b0C\nSymbol Parameter Min(1)Typ(1)Max(1)Units\nVPOR Release threshold of power-on reset (2)1.1 1.4 1.6 V\nVPOA Activation threshold of power-on reset (3)0.6 1.3 1.6 V\nSRON Power-On Slope Rate 0.01 V/ms\nTable 21-7. BODLEVEL Fuse Coding. TA = -40\uf0b0C to +85 \uf0b0C\nBODLEVEL[2:0] Fuses Min(1)Typ(1)Max(1)Units\n111 BOD Disabled\n110 1.7 1.8 2.0\nV 101 2.5 2.7 2.9\n100 4.1 4.3 4.5\n0XX Reserved\n167 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321.7 ADC Characteristics\nNote: 1. Values are guidelines only.Table 21-8. ADC Characteristics, Single Ended Channels. TA = -40\uf0b0C to +85 \uf0b0C\nSymbol Parameter Condi tion Min Typ Max Units\nResolution 10 Bits\nAbsolute accuracy\n(Including INL, DNL, andQuantization, Gain and\nOffset errors)V\nREF = 4V, VCC = 4V,\nADC clock = 200 kHz2L S B\nVREF = 4V, VCC = 4V,\nADC clock = 1 MHz3L S B\nVREF = 4V, VCC = 4V,\nADC clock = 200 kHz\nNoise Reduction Mode1.5 LSB\nVREF = 4V, VCC = 4V,\nADC clock = 1 MHz\nNoise Reduction Mode2.5 LSB\nIntegral Non-linearity (INL)\n(Accuracy after offset and gain \ncalibration)VREF = 4V, VCC = 4V,\nADC clock = 200 kHz1L S B\nDifferential Non-linearity (DNL)VREF = 4V, VCC = 4V,\nADC clock = 200 kHz0.5 LSB\nGain ErrorVREF = 4V, VCC = 4V,\nADC clock = 200 kHz2.5 LSB\nOffset ErrorVREF = 4V, VCC = 4V,\nADC clock = 200 kHz1.5 LSB\nConversion Time Free Running Conversion 14 280 µs\nClock Frequency 50 1000 kHz\nVIN Input Voltage GND VREF V\nInput Bandwidth 38.4 kHz\nAREF External Reference Voltage 2.0 VCC V\nVINTInternal Voltage Reference 1.0 1.1 1.2 V\nInternal 2.56V Reference (1)VCC > 3.0V 2.3 2.56 2.8 V\nRREF 32 k \uf057\nRAIN Analog Input Resistance 100 M \uf057\nADC Output 0 1023 LSB\n168 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Note: 1. Values are guidelines only.Table 21-9. ADC Characteristics, Differential Channels (Unipolar Mode). TA = -40\uf0b0C to +85 \uf0b0C\nSymbol Parameter Condi tion Min Typ Max Units\nResolutionGain = 1x 10 Bits\nGain = 20x 10 Bits\nAbsolute accuracy\n(Including INL, DNL, and Quantization, Gain and Offset \nErrors)Gain = 1x\nV\nREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz10.0 LSB\nGain = 20x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz20.0 LSB\nIntegral Non-Linearity (INL)\n(Accuracy after Offset and \nGain Calibration)Gain = 1x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz4.0 LSB\nGain = 20x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz10.0 LSB\nGain ErrorGain = 1x 10.0 LSB\nGain = 20x 15.0 LSB\nOffset ErrorGain = 1x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz3.0 LSB\nGain = 20x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz4.0 LSB\nConversion Time Free Running Conversion 70 280 µs\nClock Frequency 50 200 kHz\nVIN Input Voltage GND VCC V\nVDIFF Input Differential Voltage VREF/Gain V\nInput Bandwidth 4 kHz\nAREF External Reference Voltage 2.0 VCC - 1.0 V\nVINTInternal Voltage Reference 1.0 1.1 1.2 V\nInternal 2.56V Reference (1)VCC > 3.0V 2.3 2.56 2.8 V\nRREF Reference Input Resistance 32 k \uf057\nRAIN Analog Input Resistance 100 M \uf057\nADC Conversion Output 0 1023 LSB\n169 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Note: 1. Values are guidelines only.Table 21-10. ADC Characteristics, Differential Channels (Bipolar Mode). TA = -40\uf0b0C to +85 \uf0b0C\nSymbol Parameter Condi tion Min Typ Max Units\nResolutionGain = 1x 10 Bits\nGain = 20x 10 Bits\nAbsolute accuracy\n(Including INL, DNL, and Quantization, Gain and Offset \nErrors)Gain = 1x\nV\nREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz8.0 LSB\nGain = 20x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz8.0 LSB\nIntegral Non-Linearity (INL)\n(Accuracy after Offset and \nGain Calibration)Gain = 1x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz4.0 LSB\nGain = 20x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz5.0 LSB\nGain ErrorGain = 1x 4.0 LSB\nGain = 20x 5.0 LSB\nOffset ErrorGain = 1x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz3.0 LSB\nGain = 20x\nVREF = 4V, VCC = 5V\nADC clock = 50 - 200 kHz4.0 LSB\nConversion Time Free Running Conversion 70 280 µs\nClock Frequency 50 200 kHz\nVIN Input Voltage GND VCC V\nVDIFF Input Differential Voltage VREF/Gain V\nInput Bandwidth 4 kHz\nAREF External Reference Voltage 2.0 VCC - 1.0 V\nVINTInternal Voltage Reference 1.0 1.1 1.2 V\nInternal 2.56V Reference (1)VCC > 3.0V 2.3 2.56 2.8 V\nRREF Reference Input Resistance 32 k \uf057\nRAIN Analog Input Resistance 100 M \uf057\nADC Conversion Output -512 511 LSB\n170 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321.8 Serial Programming Characteristics\nFigure 21-4. Serial Programming Waveforms\nFigure 21-5. Serial Programming Timing\nNote: 1. 2 tCLCL for fck < 12 MHz, 3 tCLCL for fck >= 12 MHzTable 21-11. Serial Programming Characteristics, TA = -40\uf0b0C to +85 \uf0b0C, VCC = 1.8 - 5.5V (Unless Otherwise \nNoted)\nSymbol Parameter Min Typ Max Units\n1/tCLCL Oscillator Frequency (VCC = 1.8 - 5.5V) 0 4 MHz\ntCLCL Oscillator Period (VCC = 1.8 - 5.5V) 250 ns\n1/tCLCL Oscillator Frequency (VCC = 2.7 - 5.5V) 0 10 MHz\ntCLCL Oscillator Period (VCC = 2.7 - 5.5V) 100 ns\n1/tCLCL Oscillator Frequency (VCC = 4.5V - 5.5V) 0 20 MHz\ntCLCL Oscillator Period (VCC = 4.5V - 5.5V) 50 ns\ntSHSL SCK Pulse Width High 2 tCLCL* ns\ntSLSH SCK Pulse Width Low 2 tCLCL* ns\ntOVSH MOSI Setup to SCK High tCLCL ns\ntSHOX MOSI Hold after SCK High 2 tCLCL ns\ntSLIV SCK Low to MISO Valid 100 nsMSB\nMSBLSB\nLSB\nSERIAL CLOCK INPUT\n(SCK)SERIAL DATA INPUT\n (MOSI)\n(MISO)\nSAMPLESERIAL DATA OUTPUT\nMOSI\nMISOSCKtOVSH\ntSHSLtSLSH tSHOX\ntSLIV\n171 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201321.9 High-voltage Serial Programming Characteristics\nFigure 21-6. High-voltage Serial Programming Timing\nTable 21-12. High-voltage Serial Programming Characteristics TA = 25\uf0b0C ± 10%, VCC = 5.0V ± 10% (Unless oth-\nerwise noted)\nSymbol Parameter Min Typ Max Units\ntSHSL SCI (PB3) Pulse Width High 125 ns\ntSLSH SCI (PB3) Pulse Width Low 125 ns\ntIVSH SDI (PB0), SII (PB1) Valid to SCI (PB3) High 50 ns\ntSHIX SDI (PB0), SII (PB1) Hold after SCI (PB3) High 50 ns\ntSHOV SCI (PB3) High to SDO (PB2) Valid 16 ns\ntWLWH_PFB Wait after Instr. 3 for Write Fuse Bits 2.5 msSDI (PB0), SII (PB1)\nSDO (PB2)SCI (PB3)tIVSH\ntSHSLtSLSH tSHIX\ntSHOV\n172 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322. Typical Characteristics\nThe data contained in this section is largely based on simulations and characterization of similar devices in the\nsame process and design methods. Thus , the data should be treated as in dications of how t he part will behave.\nThe following charts show typical behavior. These figure s are not tested during manufacturing. All current con-\nsumption measurements are performed with all I/O pins conf igured as inputs and with internal pull-ups enabled. A\nsine wave generator with rail-to-rail output is used as clock source.\nThe power consumption in Power-down mode  is independent of clock selection.\nThe current consumption is a function of several factors such as: operating voltage, operating frequency, loading of\nI/O pins, switching rate of I/O pins, code executed and ambient  temperature. The dominating factors are operating\nvoltage and frequency.\nThe current drawn from capacitive loaded pi ns may be estimated (for one pin) as CL*VCC*f where CL = load capac-\nitance, VCC = operating voltage and f = average switching frequency of I/O pin.\nThe parts are characterized at frequencies higher than test  limits. Parts are not guaranteed to function properly at\nfrequencies higher than the ordering code indicates.\nThe difference between current consumption in Power-down mode with Watchdog Timer enabled and Power-down\nmode with Watchdog Timer disabled represents the differential current drawn by the Watchdog Timer.\n22.1 Active Supply Current\nFigure 22-1. Active Supply Current vs. Low frequency (0.1 - 1.0 MHz)\nACTIVE SUPPLY CURRENT vs. LOW FREQUENCY\n0.1 -1.0 MHz\n5.5 V\n5.0 V\n4.5 V\n4.0 V\n3.3 V\n2.7 V\n1.8 V\n00,20,40,60,811,2\n0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 1\nFrequency (MHz)ICC (mA)\n173 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-2. Active Supply Current vs . Frequency (1 - 20 MHz)\nFigure 22-3. Active Supply Current vs. VCC (Internal RC o scillator, 8 MHz)ACTIVE SUPPLY CURRENT vs. FREQUENCY\n1 - 20 MHz\n5.5 V\n5.0 V\n4.5 V\n02468101214\n0 2 4 6 8 10 12 14 16 18 20Frequency (MHz)ICC (mA)\n1.8V2.7V3.3V4.0V\nACTIVE SUPPLY CURRENT vs. VCC\nINTERNAL RC OSCILLATOR, 8 MHz\n85 ˚C25 ˚C-40 ˚C\n01234567\n1,5 2 2,5 3 3,5 4 4,5 5 5,5VCC (V)ICC (mA)\n174 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-4. Active Supply Current vs. VCC (Internal RC O scillator, 1 MHz)\nFigure 22-5. Active Supply Current vs. VCC (Internal RC O scillator, 128 kHz)ACTIVE SUPPLY CURRENT vs. VCC\nINTERNAL RC OSCILLATOR, 1 MHz\n85 ˚C25 ˚C\n-40 ˚C\n00,20,40,60,811,21,41,6\n1,5 2 2,5 3 3,5 4 4,5 5 5,5VCC (V)ICC (mA)\nACTIVE SUPPLY CURRENT vs. VCC\nINTERNAL RC OSCILLATOR, 128 KHz\n85 ˚C25 ˚C-40 ˚C\n00,050,10,150,20,25\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)ICC (mA)\n175 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322.2 Idle Supply Current\nFigure 22-6. Idle Supply Current vs. lo w Frequency (0.1 - 1.0 MHz)\nFigure 22-7. Idle Supply Current vs. Frequency (1 - 20 MHz)IDLE SUPPLY CURRENT vs. LOW FREQUENCY\n0.1 - 1.0 MHz \n5.5 V\n5.0 V4.5 V4.0 V3.3 V2.7 V1.8 V\n00,050,10,150,20,25\n0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 1\nFrequency (MHz)ICC (mA)\nIDLE SUPPLY CURRENT vs. FREQUENCY\n1 - 20 MHz\n5.5 V\n5.0 V\n4.5 V\n00,511,522,533,54\n0 2 4 6 8 1 01 21 41 61 82 0\nFrequency (MHz)ICC (mA)\n1.8V2.7V3.3V4.0V\n176 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-8. Idle Supply Current vs. VCC (Internal RC O scillator, 8 MHz)I\nFigure 22-9. Idle Supply Current vs. VCC (Internal RC O scilllator, 1 MHz)IDLE SUPPLY CURRENT vs. VCC\nINTERNAL RC OSCILLATOR, 8 MHz\n85 ˚C\n25 ˚C\n-40 ˚C\n00,20,40,60,811,21,41,61,8\n1,5 2 2,5 3 3,5 4 4,5 5 5,5VCC (V)ICC (mA)\nIDLE SUPPLY CURRENT vs. V CC\nINTERNAL RC OSCILLATOR, 1 MHz\n85 ˚C\n25 ˚C\n-40 ˚C\n00,050,10,150,20,250,30,350,40,450,5\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)ICC (mA)\n177 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-10. Idle Supply Current vs. VCC (Internal RC O scillator, 128 kHz)\n22.3 Supply Current of I/O modules\nThe tables and formulas below can be used to calculate the additional current consumption for the different I/O\nmodules in Active and Idle mode. The enabling or disab ling of the I/O modules are controlled by the Power Reduc-\ntion Register. See “PRR – Power Reduction Register” on page 38  for details.\nIt is possible to calculate the typical cu rrent consumption based on the numbers from Table 22-2  for other VCC and\nfrequency settings that listed in Table 22-1 .IDLE SUPPLY CURRENT vs. V CC\nINTERNAL RC OSCILLATOR, 128 kHz\n85 ˚C25 ˚C-40 ˚C\n00,010,020,030,040,050,060,070,080,090,1\n1,5 2 2,5 3 3,5 4 4,5 5 5,5VCC (V)ICC (mA)\nTable 22-1. Additional Current Consumption for the different I/O modules (absolute values)\nPRR bit Typical numbers\nVCC = 2V, f = 1 MHz VCC = 3V, f = 4 MHz VCC = 5V, f = 8 MHz\nPRTIM1 45 uA 300 uA 1100 uA\nPRTIM0  5 uA 30 uA 110 uAPRUSI  5 uA 25 uA 100 uA\nPRADC 15 uA 85 uA 340 uA\nTable 22-2. Additional Current Consumption (percentage) in Active and Idle mode\nPRR bitAdditional Current consumption \ncompared to Active with external clock (see Figure 22-1  and Figure 22-2 )Additional Current consumption \ncompared to Idle with external clock (see Figure 22-6  and Figure 22-7 )\nPRTIM1 20 % 80 %\nPRTIM0 2 % 10 %PRUSI 2 % 10 %\nPRADC 5 % 25 %\n178 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322.3.1 Example\nCalculate the expected current consumption in idle mode with USI, TIMER0, and ADC enabled at VCC = 2.0V and f\n= 1 MHz. From Table 22-2 on page 177 , third column, we see that we need to add 10% for the USI, 25% for the\nADC, and 10% for the TIMER0 module. Reading from Figure 22-9 , we find that the idle current consumption is\n~0,18 mA at VCC = 2.0V and f = 1 MHz. The total current consumption in idle mode with USI, TIMER0, and ADC\nenabled, gives:\n22.4 Power-down Supply Current\nFigure 22-11. Power-down Supply Current vs. VCC (Watchdog Timer Disabled)ICC01 8mA , 10 1 ,02 5, 01, ++ +\uf028\uf029\uf0b4 02 6 1 mA ,\uf0bb =\nPOWER-DOWN SUPPLY CURRENT vs. VCC\nWATCHDOG TIMER DISABLED\n85 ˚C\n25 ˚C-40 ˚C\n00.20.40.60.811.21.4\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (uA)\n179 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-12. Power-down Supply Current vs. VCC (Watchdog Timer Enabled)\n22.5 Pin Pull-up\nFigure 22-13. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 1.8V)POWER-DOWN SUPPLY CURRENT vs. VCC\nWATCHDOG TIMER ENABLED\n85 ˚C25 ˚C-40 ˚C\n02468101214\n1.5 2 2.5 3 3.5 4 4.5 5 5.5VCC (V)ICC (uA)\nI/O PIN PULL-UP RESISTOR CURRENT vs. INPUT VOLTAGE\nVCC = 1.8V\n85 ˚C25 ˚C\n-40 ˚C0102030405060\n0 0,2 0,4 0,6 0,8 1 1,2 1,4 1,6 1,8 2VOP (V)IOP (uA)\n180 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-14. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 2.7V)\nFigure 22-15. I/O Pin Pull-up Resistor Current vs. Input Voltage (VCC = 5V)I/O PIN PULL-UP RESISTOR CURRENT vs. INPUT VOLTAGE\nVCC = 2.7V\n85 ˚C25 ˚C\n-40 ˚C\n01020304050607080\n0 0,5 1 1,5 2 2,5 3VOP (V)IOP (uA)\nI/O PIN PULL-UP RESISTOR CURRENT vs. INPUT VOLTAGE\nVCC = 5V\n85 ˚C25 ˚C\n-40 ˚C\n020406080100120140160\n0123456VOP (V)IOP (uA)\n181 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-16. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 1.8V)\nFigure 22-17. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 2.7V)RESET PULL-UP RESISTOR CURRENT vs. RESET PIN VOLTAGE\nVCC = 1.8V\n85 ˚C25 ˚C\n-40 ˚C\n0510152025303540\n0 0,2 0,4 0,6 0,8 1 1,2 1,4 1,6 1,8 2VRESET (V)IRESET (uA)\nRESET PULL-UP RESISTOR CURRENT vs. RESET PIN VOLTAGE\nVCC =2.7V\n85 ˚C25 ˚C\n-40 ˚C\n0102030405060\n0 0,5 1 1,5 2 2,5 3VRESET (V)IRESET  (uA)\n182 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-18. Reset Pull-up Resistor Curr ent vs. Reset Pin Voltage (VCC = 5V)\n22.6 Pin Driver Strength\nFigure 22-19. I/O Pin Output Voltage vs. Sink Current (VCC = 3V)RESET PULL-UP RESISTOR CURRENT vs. RESET PIN VOLTAGE\nVCC = 5V \n85 ˚C25 ˚C\n-40 ˚C\n020406080100120\n0123456VRESET (V)IRESET (uA)\nI/O PIN OUTPUT VOLTAGE vs. SINK CURRENT\nVCC = 3V\n85\n25\n-40\n00,20,40,60,811,2\n0 5 10 15 20 25\nIOL (mA)VOL (V)\n183 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-20. I/O Pin Output Voltage vs. Sink Current (VCC = 5V)\nFigure 22-21. I/O Pin Output Voltage vs. Source Current (VCC = 3V)I/O PIN OUTPUT VOLTAGE vs. SINK CURRENT\nVCC = 5V\n85\n25\n-40\n00,10,20,30,40,50,6\n0 5 10 15 20 25\nIOL (mA)VOL (V)\nI/O PIN OUTPUT VOLTAGE vs. SOURCE CURRENT\nVCC = 3V\n8525-40\n00,511,522,533,5\n0 5 10 15 20 25\nIOH (mA)VOH (V)\n184 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-22. I/O Pin Output Voltage vs. Source Current (VCC = 5V)\nFigure 22-23. Reset Pin Output Voltage vs. Sink Current (VCC = 3V)I/O PIN OUTPUT VOLTAGE vs. SOURCE CURRENT\nVCC = 5V\n8525-40\n4,44,54,64,74,84,955,1\n0 5 10 15 20 25\nIOH (mA)VOH (V)\nRESET AS I/O PIN OUTPUT VOLTAGE vs. SINK CURRENT\nVCC = 3V\n-45 °C0 °C85 °C\n00.511.5\n0 0.5 1 1.5 2 2.5 3\nIOL (mA)VOL (V)\n185 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-24. Reset Pin Output Voltage vs. Sink Current (VCC = 5V)\nFigure 22-25. Reset Pin Output Voltage vs. Source Current (VCC = 3V)RESET AS I/O PIN OUTPUT VOLTAGE vs. SINK CURRENT\nVCC = 5V\n-45 °C0 °C85 °C\n00.20.40.60.81\n0 0.5 1 1.5 2 2.5 3\nIOL (mA)VOL (V)\nRESET AS I/O PIN OUTPUT VOLTAGE vs. SOURCE CURRENT\nVCC = 3V\n-45 °C\n25 °C\n85 °C\n00.511.522.533.5\n00 . 511 . 52\nIOH (mA)VOH (V)\n186 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-26. Reset Pin Output Voltage vs. Source Current (VCC = 5V)\n22.7 Pin Threshold and Hysteresis\nFigure 22-27. I/O Pin Input Threshold Voltage vs. VCC (VIH, IO Pin Read as ‘1’)RESET AS I/O PIN OUTPUT VOLTAGE vs. SOURCE CURRENT\nVCC = 5V\n-45 °C\n25 °C\n85 °C 2.533.544.55\n0 0.5 1 1.5 2\nIOH (mA)VOH (V)\nI/O PIN INPUT THRESHOLD VOLTAGE vs. VCC\nVIH, IO PIN READ AS \'1\'\n85 ˚C\n25 ˚C-40 ˚C\n00,511,522,53\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)Threshold (V)\n187 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-28. I/O Pin Input Threshold Voltage vs. VCC (VIL, IO Pin Read as ‘0’)\nFigure 22-29. I/O Pin Input Hysteresis vs. VCCI/O PIN INPUT THRESHOLD VOLTAGE vs. VCC\nVIL, IO PIN READ AS \'0\'\n85 ˚C\n25 ˚C\n-40 ˚C\n00,511,522,53\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)Threshold (V)\n85 °C\n25 °C-40 °C\n00,10,20,30,40,50,6\n1,5 2 2,5 3 3,5 4 4,5 5 5,5Input Hysteresis (V)\nVCC (V)I/O PIN INPUT HYSTERESIS vs. VCC\n188 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-30. Reset Input Threshold Voltage vs. VCC (VIH, IO Pin Read as ‘1’)\nFigure 22-31. Reset Input Threshold Voltage vs. VCC (VIL, IO Pin Read as ‘0’)RESET INPUT THRESHOLD VOLTAGE vs. VCC\nVIH, IO PIN READ AS \'1\'\n85 °C\n25 °C\n-40 °C\n00,511,522,5\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)Threshold (V)\nRESET INPUT THRESHOLD VOLTAGE vs. VCC\nVIL, IO PIN READ AS \'0\'\n85 °C\n25 °C\n-40 °C\n00,511,522,5\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)Threshold (V)\n189 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-32. Reset Pin Input Hysteresis vs. VCC\n22.8 BOD Threshold\nFigure 22-33. BOD Threshold vs. Temperature (BOD Level is 4.3V)RESET PIN INPUT HYSTERESIS vs. VCC\n85 °C25 °C-40 °C\n00,050,10,150,20,250,30,350,40,450,5\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)Input Hysteresis (V)\nBOD THRESHOLDS vs. TEMPERATURE\nRising VCC\nFalling VCC\n4,264,284,34,324,344,364,384,4\n-50 -40 -30 -20 -10 0 10 20 30 40 50 60 70 80 90 100\nTemperature (C)Threshold (V)\n190 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-34. BOD Threshold vs. Temperature (BOD Level is 2.7V)\nFigure 22-35. BOD Threshold vs. Temperature (BOD Level is 1.8V)BOD THRESHOLDS vs. TEMPERATURE\nRising VCC\nFalling VCC\n2,682,72,722,742,762,782,8\n-50 -40 -30 -20 -10 0 10 20 30 40 50 60 70 80 90 100\nTemperature (C)Threshold (V)\nBOD THRESHOLDS vs. TEMPERATURE\nRising VCC\nFalling VCC\n1,7951,81,8051,811,8151,821,8251,831,8351,841,8451,85\n-50 -40 -30 -20 -10 0 10 20 30 40 50 60 70 80 90 100\nTemperature (C)Threshold (V)\n191 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-36. Bandgap Voltage vs. Supply Voltage\nFigure 22-37. Bandgap Voltage vs. TemperatureBANDGAP VOLTAGE vs. V CC\n85 °C\n25 °C\n-40 °C\n11,021,041,061,081,11,121,141,161,181,2\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVcc (V)Bandgap Voltage (V)\nBANDGAP VOLTAGE vs. Temperature\n5 V3 V1.8 V\n11,021,041,061,081,11,121,141,161,181,2\n-40 -20 0 20 40 60 80 100\nTemperatureBandgap Voltage (V)\n192 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322.9 Internal Oscillator Speed\nFigure 22-38. Watchdog Oscillator Frequency vs. VCC\nFigure 22-39. Watchdog Oscillator Freq uency vs. TemperatureWATCHDOG OSCILLATOR FREQUENCY vs. VCC\n85 ˚C25 ˚C-40 ˚C\n0,1120,1140,1160,1180,120,1220,1240,1260,128\n2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)FRC (MHz)\nWATCHDOG OSCILLATOR FREQUENCY vs. TEMPERATURE\n5.5 V4.0 V3.3 V2.7 V1.8 V\n0,1080,110,1120,1140,1160,1180,12\n- 4 0 - 3 0 - 2 0 - 1 00 1 02 03 04 05 06 07 08 09 0 1 0 0\nTemperatureFRC (MHz)\n193 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-40. Calibrated 8 MHz RC Oscillator Frequency vs. VCC\nFigure 22-41. Calibrated 8 MHz RC Oscillato r Frequency vs.  TemperatureCALIBRATED 8 MHz RC OSCILLATOR FREQUENCY vs. V CC\n85 ˚C\n25 ˚C\n-40 ˚C\n7,57,67,77,87,988,18,2\n1,5 2 2,5 3 3,5 4 4,5 5 5,5VCC (V)FRC (MHz)\nCALIBRATED 8 MHz RC OSCILLATOR FREQUENCY vs. TEMPERATURE\n5.0 V3.0 V\n7,77,757,87,857,97,9588,058,18,15\n-60 -40 -20 0 20 40 60 80 100\nTemperatureFRC (MHz)\n194 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-42. Calibrated 8 MHz RC Oscillator Frequency vs. OSCCAL Value\nFigure 22-43. Calibrated 1.6 MHz RC Os cillator Frequency vs. VCCCALIBRATED 8 MHz RC OSCILLATOR FREQUENCY vs. OSCCAL VALUE\n85 ˚C\n25 ˚C\n-40 ˚C\n024681012141618\n0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240OSCCAL (X1)FRC (MHz)\nCALIBRATED 1.6 MHz RC OSCILLATOR FREQUENCY vs. VCC\n85 ˚C\n25 ˚C\n-40 ˚C\n1,41,451,51,551,61,65\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)FRC (MHz)\n195 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-44. Calibrated 1.6 MHz RC Oscillato r Frequency vs. Temperature\nFigure 22-45. Calibrated 1.6 MHz RC Oscillato r Frequency vs. OSCCAL ValueCALIBRATED 1.6MHz RC OSCILLATOR FREQUENCY vs. TEMPERATURE\n5.0 V3.0 V\n1,51,521,541,561,581,61,621,64\n-60 -40 -20 0 20 40 60 80 100TemperatureFRC (MHz)\nCALIBRATED 1.6 MHz RC OSCILLATOR FREQUENCY vs. OSCCAL VALUE\n85 ˚C\n25 ˚C\n-40 ˚C\n00,511,522,533,544,5\n0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240\nOSCCAL (X1)FRC (MHz)\n196 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322.10 Current Consumpti on of Peripheral Units\nFigure 22-46. Brownout Detector Current vs. VCC\nFigure 22-47. ADC Current vs. VCC (AREF = AVCC)BROWNOUT DETECTOR CURRENT vs. VCC\n85 °C\n25 °C\n-40 °C\n051015202530\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)ICC (uA)\nADC CURRENT vs. VCC\nAREF = AVCC\n85 °C\n25 °C\n-40 °C\n050100150200250\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)ICC (uA)\n197 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-48. Analog Comparator Current vs. VCC\nFigure 22-49. Programming Current vs. VCCANALOG COMPARATOR CURRENT vs. VCC\n85 °C\n25 °C\n-40 °C\n05101520253035404550\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)ICC (uA)\nPROGRAMMING CURRENT vs. Vcc\nExt Clk\n85 °C25 °C-40 °C\n024681012\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)ICC (mA)\n198 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322.11 Current Consumption in Reset and Reset Pulsewidth\nFigure 22-50. Reset Supply Current vs. VCC (0.1 - 1.0 MHz, Excluding Current Through The Reset Pull-up)\nFigure 22-51. Reset Supply Current vs. VCC (1 - 20 MHz, Excluding Current Through The Reset Pull-up)RESET SUPPLY CURRENT vs. VCC\n0.1 - 1.0 MHz, EXCLUDING CURRENT THROUGH THE RESET PULLUP\n5.5 V\n5.0 V\n4.5 V\n4.0 V\n3.3 V\n2.7 V\n1.8 V\n00,020,040,060,080,10,120,140,16\n0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 1Frequency (MHz)ICC (mA)\nRESET SUPPLY CURRENT vs. VCC\n1 - 20 MHz, EXCLUDING CURRENT THROUGH THE RESET PULLUP\n5.5 V\n5.0 V\n4.5 V\n00,511,522,5\n0 2 4 6 8 1 01 21 41 61 82 0\nFrequency (MHz)ICC (mA)\n1.8V2.7V3.3V4.0V\n199 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Figure 22-52. Minimum Reset Pulse Width vs. VCC\nMINIMUM RESET PULSE WIDTH vs. VCC\n85 ˚C\n25 ˚C\n-40 ˚C\n05001000150020002500\n1,5 2 2,5 3 3,5 4 4,5 5 5,5\nVCC (V)Pulsewidth (ns)\n200 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201323. Register Summary\nNote: 1. For compatibility with future devices, reserved bits shou ld be written to zero if accesse d. Reserved I/O memory addresse s Address Name Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Page\n0x3F SREG I T H S V N Z C page 8\n0x3E SPH – – – – – – SP9 SP8 page 11\n0x3D SPL SP7 SP6 SP5 SP4 SP3 SP2 SP1 SP0 page 11\n0x3C Reserved –\n0x3B GIMSK – INT0 PCIE – – – – – page 51\n0x3A GIFR – INTF0 PCIF – – – – – page 52\n0x39 TIMSK – OCIE1A OCIE1B OCIE0A OCIE0B TOIE1 TOIE0 – pages 81, 102\n0x38 TIFR – OCF1A OCF1B OCF0A OCF0B TOV1 TOV0 – page 81\n0x37 SPMCSR – – RSIG CTPB RFLB PGWRT PGERS SPMEN page 145\n0x36 Reserved –\n0x35 MCUCR BODS PUD SE SM1 SM0 BODSE ISC01 ISC00 pages 37, 51, 64\n0x34 MCUSR – – – – WDRF BORF EXTRF PORF page 44 ,\n0x33 TCCR0B FOC0A FOC0B – – WGM02 CS02 CS01 CS00 page 79\n0x32 TCNT0  Timer/Counter0 page 80\n0x31 OSCCAL Oscillator  Calibration Register page 31\n0x30 TCCR1 CTC1 PWM1A COM1A1 COM1A0 CS13 CS12 CS11 CS10 pages 89, 100\n0x2F TCNT1 Timer/Counter1 pages 91, 102\n0x2E OCR1A Timer/Counter1 Output Compare Register A pages 91, 102\n0x2D OCR1C Timer/Counter1 Output Compare Register C pages 91, 102\n0x2C GTCCR TSM PWM1B COM1B1 COM1B0 FOC1B FOC1A PSR1 PSR0 pages 77, 90, 101\n0x2B OCR1B Timer/Counter1 Output Compare Register B page 92\n0x2A TCCR0A COM0A1 COM0A0 COM0B1 COM0B0 – WGM01 WGM00 page 77\n0x29 OCR0A Timer/Counter0 – Output Compare Register A page 80\n0x28 OCR0B Timer/Counter0 – Output Compare Register B page 81\n0x27 PLLCSR LSM – – – – PCKE PLLE PLOCK pages 94, 103\n0x26 CLKPR CLKPCE – – – CLKPS3 CLKPS2 CLKPS1 CLKPS0 page 32\n0x25 DT1A DT1AH3 DT1AH2 DT1AH1 DT 1AH0 DT1AL3 DT1AL2 DT1AL1 DT1AL0 page 107\n0x24 DT1B DT1BH3 DT1BH2 DT1BH1 DT 1BH0 DT1BL3 DT1BL2 DT1BL1 DT1BL0 page 107\n0x23 DTPS1 - - - - - - DTPS11 DTPS10 page 106\n0x22 DWDR DWDR[7:0] page 140\n0x21 WDTCR WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 page 45\n0x20 PRR – PRTIM1 PRTIM0 PRUSI PRADC page 36\n0x1F EEARH EEAR8 page 20\n0x1E EEARL EEAR7 EEAR6 EEAR5 EEAR4 EEAR3 EEAR2 EEAR1 EEAR0 page 21\n0x1D EEDR EEPROM Data Register page 21\n0x1C EECR – – EEPM1 EEPM0 EERIE EEMPE EEPE EERE page 21\n0x1B Reserved –\n0x1A Reserved –\n0x19 Reserved –\n0x18 PORTB – – PORTB5 PORTB4 PORTB3 PORTB2 PORTB1 PORTB0 page 64\n0x17 DDRB – – DDB5 DDB4 DDB3 DDB2 DDB1 DDB0 page 64\n0x16 PINB – – PINB5 PINB4 PINB3 PINB2 PINB1 PINB0 page 64\n0x15 PCMSK – – PCINT5 PCINT4 PCINT3 PCINT2 PCINT1 PCINT0 page 52\n0x14 DIDR0 – – ADC0D ADC2D ADC3D ADC1D AIN1D AIN0D pages 121, 138\n0x13 GPIOR2 General Purpose I/O Register 2 page 10\n0x12 GPIOR1 General Purpose I/O Register 1 page 10\n0x11 GPIOR0 General Purpose I/O Register 0 page 10\n0x10 USIBR USI Buffer Register page 115\n0x0F USIDR USI Data Register page 115\n0x0E USISR USISIF USIOIF USIPF USIDC USICNT3 USICNT2 USICNT1 USICNT0 page 115\n0x0D USICR USISIE USIOIE USIWM1 USIWM0 USICS1 USICS0 USICLK USITC page 116\n0x0C Reserved –\n0x0B Reserved –\n0x0A Reserved –\n0x09 Reserved –\n0x08 ACSR ACD ACBG ACO ACI ACIE – ACIS1 ACIS0 page 120\n0x07 ADMUX REFS1 REFS0 ADLAR REFS2 MUX3 MUX2 MUX1 MUX0 page 134\n0x06 ADCSRA ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0 page 136\n0x05 ADCH ADC Data Register High Byte page 137\n0x04 ADCL ADC Data Register Low Byte page 137\n0x03 ADCSRB BIN ACME IPR – – ADTS2 ADTS1 ADTS0 pages 120, 137\n0x02 Reserved –\n0x01 Reserved –\n0x00 Reserved –\n201 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013should never be written.\n2. I/O Registers within the address range 0x00 - 0x1F are directly  bit-accessible using the SBI and CBI instructions. In these \nregisters, the value of single bits can be ch ecked by using the SBIS and SBIC instructions.\n3. Some of the Status Flags are cleared by writing a logical one  to them. Note that, unlike most other AVRs, the CBI and SBI \ninstructions will only operation the specif ied bit, and can therefore be used on r egisters containing such Status Flags. The \nCBI and SBI instructions work wit h registers 0x00 to 0x1F only.\n202 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201324. Instruction Set Summary\nMnemonics Operands Description Operation Flags #Clocks\nARITHMETIC AND LOGIC INSTRUCTIONS\nADD Rd, Rr Add two Registers Rd \uf0ac Rd + Rr Z,C,N,V,H 1\nADC Rd, Rr Add with Carry two Registers Rd \uf0ac Rd + Rr + C Z,C,N,V,H 1\nADIW Rdl,K Add Immediate to Word Rdh:Rdl \uf0ac Rdh:Rdl + K Z,C,N,V,S 2\nSUB Rd, Rr Subtract two Registers Rd \uf0ac Rd - Rr Z,C,N,V,H 1\nSUBI Rd, K Subtract Constant from Register Rd \uf0ac Rd - K Z,C,N,V,H 1\nSBC Rd, Rr Subtract with Carry two Registers Rd \uf0ac Rd - Rr - C Z,C,N,V,H 1\nSBCI Rd, K Subtract with Carry Constant from Reg. Rd \uf0ac Rd - K - C Z,C,N,V,H 1\nSBIW Rdl,K Subtract Immediate from Word Rdh:Rdl \uf0ac Rdh:Rdl - K Z,C,N,V,S 2\nAND Rd, Rr Logical AND Registers Rd \uf0ac\uf020Rd \uf0b7 Rr Z,N,V 1\nANDI Rd, K Logical AND Register and Constant Rd \uf0ac Rd \uf0b7\uf020K Z,N,V 1\nOR Rd, Rr Logical OR Registers Rd \uf0ac Rd v Rr Z,N,V 1\nORI Rd, K Logical OR Register and Constant Rd \uf0ac\uf020Rd v K Z,N,V 1\nEOR Rd, Rr Exclusive OR Registers Rd \uf0ac Rd \uf0c5 Rr Z,N,V 1\nCOM Rd One’s Complement Rd \uf0ac 0xFF \uf02d Rd Z,C,N,V 1\nNEG Rd Two’s Complement Rd \uf0ac 0x00 \uf02d Rd Z,C,N,V,H 1\nSBR Rd,K Set Bit(s) in Register Rd \uf0ac Rd v K Z,N,V 1\nCBR Rd,K Clear Bit(s) in Register Rd \uf0ac Rd \uf0b7 (0xFF - K) Z,N,V 1\nINC Rd Increment Rd \uf0ac Rd + 1 Z,N,V 1\nDEC Rd Decrement Rd \uf0ac Rd \uf02d 1 Z,N,V 1\nTST Rd Test for Zero or Minus Rd \uf0ac Rd \uf0b7 Rd Z,N,V 1\nCLR Rd Clear Register Rd  \uf0ac Rd \uf0c5 Rd Z,N,V 1\nSER Rd Set Register Rd \uf0ac 0xFF None 1\nBRANCH INSTRUCTIONSRJMP k Relative Jump PC \uf020\uf0ac PC + k  + 1 None 2\nIJMP Indirect Jump to (Z) PC \uf0ac Z None 2\nRCALL k Relative Subroutine Call PC \uf0ac PC + k + 1 None 3\nICALL Indirect Call to (Z) PC \uf0ac ZN o n e 3\nRET Subroutine Return PC \uf0ac STACK None 4\nRETI Interrupt Return PC \n\uf0ac STACK I 4\nCPSE Rd,Rr Compare, Skip if Equal if (Rd = Rr) PC \uf020\uf0ac PC + 2 or 3 None 1/2/3\nCP Rd,Rr Compare Rd \uf02d Rr Z, N,V,C,H 1 \nCPC Rd,Rr Compare with Carry Rd \uf02d Rr \uf02d C Z, N,V,C,H 1\nCPI Rd,K Compare Register with Immediate Rd \uf02d K Z, N,V,C,H 1\nSBRC Rr, b Skip if Bit in Register Cleared if (Rr(b)=0) PC \uf0ac PC + 2 or 3 None 1/2/3\nSBRS Rr, b Skip if Bit in Register is Set if (Rr(b)=1) PC \uf0ac PC + 2 or 3 None 1/2/3\nSBIC P, b Skip if Bit in I/O Register Cleared if (P(b)=0) PC \uf0ac PC + 2 or 3 None 1/2/3\nSBIS P, b Skip if Bit in I/O Register is Set if (P(b)=1) PC \uf0ac PC + 2 or 3 None 1/2/3\nBRBS s, k Branch if Status Flag Set if (SREG(s) = 1) then PC \uf0acPC+k + 1 None 1/2\nBRBC s, k Branch if Status Flag Cleared if (SREG(s) = 0) then PC \uf0acPC+k + 1 None 1/2\nBREQ  k Branch if Equal if (Z = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRNE  k Branch if Not Equal if (Z = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRCS  k Branch if Carry Set if (C = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRCC  k Branch if Carry Cleared if (C = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRSH  k Branch if Same or Higher if (C = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRLO  k Branch if Lower if (C = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRMI  k Branch if Minus if (N = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRPL  k Branch if Plus if (N = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRGE  k Branch if Greater or Equal, Signed if (N \uf0c5 V= 0) then PC \uf0ac PC + k + 1 None 1/2\nBRLT  k Branch if Less Than Zero, Signed if (N \uf0c5 V= 1) then PC \uf0ac PC + k + 1 None 1/2\nBRHS  k Branch if Half Carry Flag Set if (H = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRHC  k Branch if Half Carry Flag Cleared if (H = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRTS  k Branch if T Flag Set if (T = 1) then PC \uf0ac PC + k  + 1 None 1/2\nBRTC  k Branch if T Flag Cleared if (T = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRVS  k Branch if Overflow Flag is Set if (V = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRVC  k Branch if Overflow Flag is Cleared if (V = 0) then PC \uf0ac PC + k + 1 None 1/2\nBRIE  k Branch if Interrupt Enabled if ( I = 1) then PC \uf0ac PC + k + 1 None 1/2\nBRID  k Branch if Interrupt Disabled if ( I = 0) then PC \uf0ac PC + k + 1 None 1/2\nBIT AND BIT-TEST INSTRUCTIONSSBI P,b Set Bit in I/O Register I/O(P,b) \uf0ac 1N o n e 2\nCBI P,b Clear Bit in I/O Register I/O(P,b) \uf0ac 0N o n e 2\nLSL Rd Logical Shift Left Rd(n+1) \uf0ac Rd(n), Rd(0) \n\uf0ac 0 Z,C,N,V 1\nLSR Rd Logical Shift Right Rd(n) \uf0ac Rd(n+1), Rd(7) \uf0ac 0 Z,C,N,V 1\nROL Rd Rotate Left Through Carry Rd(0) \uf0acC,Rd(n+1) \uf0ac Rd(n),C \uf0acRd(7) Z,C,N,V 1\nROR Rd Rotate Right Through Carry Rd(7) \uf0acC,Rd(n)\uf0ac Rd(n+1),C \uf0acRd(0) Z,C,N,V 1\nASR Rd Arithmetic Shift Right Rd(n) \uf0ac Rd(n+1), n=0..6 Z,C,N,V 1\n203 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013SWAP Rd Swap Nibbles Rd(3..0) \uf0acRd(7..4),Rd(7..4) \uf0acRd(3..0) None 1\nBSET s Flag Set SREG(s) \uf0ac 1 SREG(s) 1\nBCLR s Flag Clear SREG(s) \uf0ac 0 SREG(s) 1\nBST Rr, b Bit Store from Register to T T \uf0ac Rr(b) T 1\nBLD Rd, b Bit load from T to Register Rd(b) \uf0ac TN o n e 1\nSEC Set Carry C \uf0ac 1C 1\nCLC Clear Carry C \uf0ac 0 C 1\nSEN Set Negative Flag N \uf0ac 1N 1\nCLN Clear Negative Flag N \uf0ac 0 N 1\nSEZ Set Zero Flag Z \uf0ac 1Z 1\nCLZ Clear Zero Flag Z \uf0ac 0 Z 1\nSEI Global Interrupt Enable I \uf0ac 1I 1\nCLI Global Interrupt Disable I \uf020\uf0ac 0 I 1\nSES Set Signed Test Flag S \uf0ac 1S 1\nCLS Clear Signed Test Flag S \uf0ac 0 S 1\nSEV Set Twos Complement Overflow. V \uf0ac 1V 1\nCLV Clear Twos Complement Overflow V \uf0ac 0 V 1\nSET Set T in SREG T \uf0ac 1T 1\nCLT Clear T in SREG T \uf0ac 0 T 1\nSEH Set Half Carry Flag in SREG H \uf0ac 1H 1\nCLH Clear Half Carry Flag in SREG H \uf0ac 0 H 1\nDATA TRANSFER INSTRUCTIONSMOV Rd, Rr Move Between Registers Rd \uf0ac Rr None 1\nMOVW Rd, Rr Copy Register Word Rd+1:Rd \uf0ac Rr+1:Rr None 1\nLDI Rd, K Load Immediate Rd  \uf0ac KN o n e 1\nLD Rd, X Load Indirect Rd \uf0ac (X) None 2\nLD Rd, X+ Load Indirect and Post-Inc. Rd \uf0ac (X), X \uf0ac X + 1 None 2\nLD Rd, - X Load Indirect and Pre-Dec. X \uf0ac X - 1, Rd \uf0ac (X) None 2\nLD Rd, Y Load Indirect Rd \uf0ac (Y) None 2\nLD Rd, Y+ Load Indirect and Post-Inc. Rd \uf0ac (Y), Y \uf0ac Y + 1 None 2\nLD Rd, - Y Load Indirect and Pre-Dec. Y \uf0ac Y - 1, Rd \n\uf0ac (Y) None 2\nLDD Rd,Y+q Load Indirect with Displacement Rd \uf0ac (Y + q) None 2\nLD Rd, Z Load Indirect Rd \uf0ac (Z) None 2\nLD Rd, Z+ Load Indirect and Post-Inc. Rd \uf0ac (Z), Z \uf0ac Z+1 None 2\nLD Rd, -Z Load Indirect and Pre-Dec. Z \uf0ac Z - 1, Rd \uf0ac (Z) None 2\nLDD Rd, Z+q Load Indirect with Displacement Rd \uf0ac (Z + q) None 2\nLDS Rd, k Load Direct from SRAM Rd  \uf0ac (k) None 2\nST X, Rr Store Indirect (X) \uf020\uf0ac Rr None 2\nST X+, Rr Store Indirect and Post-Inc. (X) \uf020\uf0ac Rr, X \uf0ac X + 1 None 2\nST - X, Rr Store Indirect and Pre-Dec. X \uf0ac X - 1, (X) \uf0ac Rr None 2\nST Y, Rr Store Indirect (Y) \uf0ac Rr None 2\nST Y+, Rr Store Indirect and Post-Inc. (Y) \uf0ac Rr, Y \uf0ac Y + 1 None 2\nST - Y, Rr Store Indirect and Pre-Dec. Y \uf0ac Y - 1, (Y) \uf0ac Rr None 2\nSTD Y+q,Rr Store Indirect with Displacement (Y + q) \uf0ac Rr None 2\nST Z, Rr Store Indirect (Z) \uf0ac Rr None 2\nST Z+, Rr Store Indirect and Post-Inc. (Z) \uf0ac Rr, Z \uf0ac Z + 1 None 2\nST -Z, Rr Store Indirect and Pre-Dec. Z \uf0ac Z - 1, (Z) \uf0ac Rr None 2\nSTD Z+q,Rr Store Indirect with Displacement (Z + q) \uf0ac Rr None 2\nSTS k, Rr Store Direct to SRAM (k) \uf0ac Rr None 2\nLPM Load Program Memory R0 \uf0ac (Z) None 3\nLPM Rd, Z Load Program Memory Rd \uf0ac (Z) None 3\nLPM Rd, Z+ Load Program Memory and Post-Inc Rd \uf0ac (Z), Z \uf0ac Z+1 None 3\nSPM Store Program Memory (z) \uf0ac R1:R0 None\nIN Rd, P In Port Rd \uf0ac PN o n e 1\nOUT P, Rr Out Port P \uf0ac Rr None 1\nPUSH Rr Push Register on Stack STACK \uf0ac Rr None 2\nPOP Rd Pop Register from Stack Rd \uf0ac STACK None 2\nMCU CONTROL INSTRUCTIONS\nNOP No Operation None 1\nSLEEP Sleep (see specific descr. for Sleep function) None 1\nWDR Watchdog Reset (see specific descr. for WDR/Timer) None 1\nBREAK Break For On-chip Debug Only None N/AMnemonics Operands Description Operation Flags #Clocks\n204 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201325. Ordering Information\nNotes: 1. For speed vs. supply voltage, see section  21.3 “Speed” on page 163 .\n2. All Pb-free, halide-free, fully green, an d comply with European directive for Restri ction of Hazardous Substances (RoHS).\n3. Code indicators: H = NiPdAu lead finish, U/N = matte tin, R = tape & reel.\n4. Can also be supplied in wafer form. Contact your local Atmel sales office for ordering information and minimum quantities.\n5. For characteristics, see “Appendix A – Specification at 105 \uf0b0C”.\n6. For characteristics, see “Appendix B – Specification at 125 \uf0b0C”.25.1 ATtiny25\nSpeed (MHz) (1) Supply Voltage (V) Temperature Range Package (2)Ordering Code (3)\n10 1.8 – 5.5Industrial\n(-40\uf0b0C to +85 \uf0b0C) (4)8P3 ATtiny25V-10PU\n8S2ATtiny25V-10SU\nATtiny25V-10SUR\nATtiny25V-10SH\nATtiny25V-10SHR\nS8S1ATtiny25V-10SSU\nATtiny25V-10SSUR\nATtiny25V-10SSH\nATtiny25V-10SSHR\n20M1ATtiny25V-10MU\nATtiny25V-10MUR\nIndustrial\n(-40\uf0b0C to +105 \uf0b0C) (5)8S2ATtiny25V-10SN\nATtiny25V-10SNR\nS8S1ATtiny25V-10SSN\nATtiny25V-10SSNR\nIndustrial (-40 \uf0b0C to +125 \uf0b0C) (6)20M1ATtiny25V-10MF\nATtiny25V-10MFR\n20 2.7 – 5.5Industrial\n(-40\uf0b0C to +85 \uf0b0C) (4)8P3 ATtiny25-20PU\n8S2ATtiny25-20SU\nATtiny25-20SUR\nATtiny25-20SH\nATtiny25-20SHR\nS8S1ATtiny25-20SSU\nATtiny25-20SSUR\nATtiny25-20SSH\nATtiny25-20SSHR\n20M1ATtiny25-20MU\nATtiny25-20MUR\nIndustrial\n(-40\uf0b0C to +105 \uf0b0C) (5)8S2ATtiny25-20SN\nATtiny25-20SNR\nS8S1ATtiny25-20SSN\nATtiny25-20SSNR\nIndustrial (-40 \uf0b0C to +125 \uf0b0C) (6)20M1ATtiny25-20MF\nATtiny25-20MFR\nPackage Types\n8P3 8-lead, 0.300" Wide, Plastic Dual Inline Package (PDIP)\n8S2 8-lead, 0.208" Wide, Plastic Gull -Wing Small Outline (EIAJ SOIC)\nS8S1 8-lead, 0.150" Wide, Plastic Gull -Wing Small Outline (JEDEC SOIC)\n20M1 20-pad, 4 x 4 x 0.8 mm Body, Quad Flat  No-Lead/Micro Lead Frame Package (QFN/MLF)\n205 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Notes: 1. For speed vs. supply voltage, see section  21.3 “Speed” on page 163 .\n2. All packages are Pb-free, halide-free and fully green and they co mply with the European directive for Restriction of Hazard-\nous Substances (RoHS).\n3. Code indicators:\n– H: NiPdAu lead finish\n– U: matte tin\n– R: tape & reel\n4. These devices can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering informa-\ntion and minimum quantities.25.2 ATtiny45\nSpeed (MHz) (1) Supply Voltage (V) Temperature Range Package (2)Ordering Code (3)\n10 1.8 – 5.5Industrial\n(-40\uf0b0C to +85 \uf0b0C) (4)8P3 ATtiny45V-10PU\n8S2ATtiny45V-10SU\nATtiny45V-10SUR\nATtiny45V-10SH\nATtiny45V-10SHR\n8XATtiny45V-10XU\nATtiny45V-10XUR\n20M1ATtiny45V-10MU\nATtiny45V-10MUR\n20 2.7 – 5.5Industrial\n(-40\uf0b0C to +85 \uf0b0C) (4)8P3 ATtiny45-20PU\n8S2ATtiny45-20SU\nATtiny45-20SUR\nATtiny45-20SH\nATtiny45-20SHR\n8XATtiny45-20XU\nATtiny45-20XUR\n20M1ATtiny45-20MU\nATtiny45-20MUR\nPackage Types\n8P3 8-lead, 0.300" Wide, Plastic Dual Inline Package (PDIP)8S2 8-lead, 0.208" Wide, Plastic Gull -Wing Small Outline (EIAJ SOIC)\n8X 8-lead, 4.4 mm Wide, Plastic Thin Shrink Small Outline Package (TSSOP)\n20M1 20-pad, 4 x 4 x 0.8 mm Body, Quad Flat No-Lead/Micro Lead Frame Package (QFN/MLF)\n206 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Notes: 1. For speed vs. supply voltage, see section  21.3 “Speed” on page 163 .\n2. All packages are Pb-free, halide-free and fully green and they co mply with the European directive for Restriction of Hazard-\nous Substances (RoHS).\n3. Code indicators:\n– H: NiPdAu lead finish\n– U: matte tin\n– R: tape & reel\n4. These devices can also be supplied in wafer form. Please contact your local Atmel sales office for detailed ordering informa-\ntion and minimum quantities.25.3 ATtiny85\nSpeed (MHz) (1)Supply Voltage (V) Temperature Range Package (2)Ordering Code (3)\n10 1.8 – 5.5Industrial\n(-40\uf0b0C to +85 \uf0b0C) (4)8P3 ATtiny85V-10PU\n8S2ATtiny85V-10SU\nATtiny85V-10SUR\nATtiny85V-10SH\nATtiny85V-10SHR\n20M1ATtiny85V-10MU\nATtiny85V-10MUR\n20 2.7 – 5.5Industrial\n(-40\uf0b0C to +85 \uf0b0C) (4)8P3 ATtiny85-20PU\n8S2ATtiny85-20SU\nATtiny85-20SUR\nATtiny85-20SH\nATtiny85-20SHR\n20M1ATtiny85-20MU\nATtiny85-20MUR\nPackage Types\n8P3 8-lead, 0.300" Wide, Plastic Dual Inline Package (PDIP)\n8S2 8-lead, 0.208" Wide, Plastic Gull -Wing Small Outline (EIAJ SOIC)\n20M1 20-pad, 4 x 4 x 0.8 mm Body, Quad Flat No-Lead/Micro Lead Frame Package (QFN/MLF)\n207 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201326. Packaging Information\n26.1 8P3\n2325 Orchard Parkway\nSan Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n8P3, 8-lead, 0.300" Wide Body, Plastic Dual \nIn-line Package (PDIP)01/09/02\n8P3 BD\nD1E\nE1\ne\nL b2\nbA2A1\nN\neAc\nb3\n4 PLCSTop View\nSide ViewEnd View\nCOMMON DIMENSIONS\n(Unit of Measure = inches)\nSYMBOL MIN NOM MAX NOTE\nNotes: 1. This drawing is for general information only; refer to JEDEC Drawing MS-001, Variation BA for additional information.\n2. Dimensions A and L are measured with the package seated in JEDEC seating plane Gauge GS-3.3. D, D1 and E1 dimensions do not include mold Flash or protrusions.  Mold Flash or protrusions shall not exceed 0.010 inch.4. E and eA measured with the leads constrained to be perpendicular to datum.5. Pointed or rounded lead tips are preferred to ease insertion.6. b2 and b3 maximum dimensions do not include Dambar protrusions.  Dambar protrusions shall not exceed 0.010 (0.25 mm).A 0.210 2\nA2 0.115 0.130 0.195b 0.014 0.018 0.022 5b2 0.045 0.060 0.070 6b3 0.030 0.039 0.045 6c 0.008 0.010 0.014D 0.355 0.365 0.400 3D1 0.005 3E 0.300 0.310 0.325 4E1 0.240 0.250 0.280 3e 0.100 BSCeA 0.300 BSC 4L 0.115 0.130 0.150 2\n208 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201326.2 8S2\nTITLE DRAWING NO.     GPC REV.\n   Packa ge Drawin g Contact:\n packagedrawings@atmel.com 8S2 STN F8S2, 8-lead, 0.208” Body, Plastic Small\nOutline Package (EIAJ)4/15/08COMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes: 1. This drawing is for general information only; refer to EIAJ Drawing EDR-7320 for additional information.\n 2. Mismatch of the upper and lower dies and resin burrs aren\'t included.\n 3. Determines the true geometric position. 4. Values b,C apply to plated terminal.  The standard thickness of the plating layer shall measure between 0.007 to .021 mm.A 1.70  2.16 \nA1 0.05  0.25 b 0.35  0.48  4C 0.15  0.35  4D 5.13  5.35 E1 5.18  5.40  2E 7.70  8.26 L 0.51  0.85 θ   0°   8°\ne            1.27 BSC   3θθ11\nNNEE\nTOP VIEWTOP VIEWCC\nE1E1\nEND VIEWEND VIEW\nAAbbLL\nA1A1ee\nDD\nSIDE VIEWSIDE VIEW\n209 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201326.3 S8S1\n2325 Orchard Parkway\nSan Jose, CA  95131TITLE DRAWING NO.\nRREV.  \nS8S1 , 8-lead, 0.150" Wide Body, Plastic Gull Wing Small \nOutline (JEDEC SOIC)7/28/03\nS8S1 ACOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes: 1. This drawing is for general information only; refer to JEDEC Drawing MS-012 for proper dimensions, tolerances, datums,e tc.E 5.79 6.20\nE1 3.81 3.99A 1.35 1.75A1 0.1 0.25\nD 4.80 4.98\nC 0.17 0.25\nb 0.31 0.51L 0.4 1.27\ne            1.27 BSC\n0\no           8oTop View\nSide View\nEnd View1\nN\nCA\nA1b\nLe\nDE1 E\n210 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201326.4 8X\nTITLE DRAWING NO.\nRREV.  Note:  These drawings are for general information only. Refer to JEDEC Drawing MO-153AC.\n  2325 Orchard Parkway\n  San Jose, CA  951314/14/05\n8X, 8-lead, 4.4 mm Body Width, Plastic Thin Shrink\nSmall Outline Package (TSSOP) 8X ACOMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTE\n   \n A 1.05 1.10 1.20 \n A1 0.05 0.10 0.15    b 0.25 – 0.30\n C – 0.127 –  \n D 2.90 3.05 3.10   E1 4.30 4.40 4.50    E 6.20 6.40 6.60  e  0.65 TYP   L 0.50 0.60 0.70 \nØ 0o – 8o \n       CC\nAAbbLL\nA1A1\nD\nSide ViewTop ViewEnd View\nEE11\nE1E1\neØØ\n211 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201326.5 20M1\n  2325 Orchard Parkway\n  San Jose, CA  95131TITLE DRAWING NO.\nRREV.  \n20M1 , 20-pad, 4 x 4 x 0.8 mm Body, Lead Pitch 0.50 mm,\nB 20M110/27/04\n 2.6 mm Exposed Pad, Micro Lead Frame Package (MLF) A 0.70 0.75 0.80\nA1 – 0.01 0.05\nA2  0.20 REF\nb 0.18 0.23 0.30D  4.00 BSC \nD2 2.45 2.60 2.75E  4.00 BSC\nE2 2.45 2.60 2.75\ne 0.50 BSC\nL 0.35 0.40 0.55   SIDE VIEWPin 1 ID\nPin #1\nNotch\n(0.20 R)\nBOTTOM VIEWTOP VIEW\nNote:   Reference JEDEC Standard MO-220, Fig . 1 (SAW Singulation) WGGD-5.COMMON DIMENSIONS\n(Unit of Measure = mm)\nSYMBOL MIN NOM MAX NOTED\nE\neA2\nA1\n AD2\nE20.08 C\nL1\n2\n3\nb1\n2\n3\n212 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201327. Errata\n27.1 Errata ATtiny25\nThe revision letter in this  section refers to  the revision of the ATtiny25 device.\n27.1.1 Rev D – F\nNo known errata.\n27.1.2 Rev B – C\n•EEPROM read may fail at  low supply voltage / low clock frequency\n1. EEPROM read may fail at low supp ly voltage / low clock frequency\nTrying to read EEPROM at low clock frequencies a nd/or low supply voltage may result in invalid data.\nProblem Fix/Workaround\nDo not use the EEPROM when clock frequency is below 1M Hz and supply vo ltage is below 2V . If operating fre-\nquency can not be raised above 1MHz then supply voltage  should be more than 2V. Similarly, if supply voltage\ncan not be raised above 2V then operating frequency should be more than 1MHz.\nThis feature is known to be temperature dependent but it has not been characterised. Guidelines are given for\nroom temperature, only.\n27.1.3 Rev A\nNot sampled.\n27.2 Errata ATtiny45\nThe revision letter in this  section refers to  the revision of the ATtiny45 device.\n27.2.1 Rev F – G\nNo known errata\n27.2.2 Rev D – E\n•EEPROM read may fail at  low supply voltage / low clock frequency\n1. EEPROM read may fail at low supp ly voltage / low clock frequency\nTrying to read EEPROM at low clock frequencies a nd/or low supply voltage may result in invalid data.\nProblem Fix/Workaround\nDo not use the EEPROM when clock frequency is below 1M Hz and supply vo ltage is below 2V . If operating fre-\nquency can not be raised above 1MHz then supply voltage  should be more than 2V. Similarly, if supply voltage\ncan not be raised above 2V then operating frequency should be more than 1MHz.\nThis feature is known to be temperature dependent but it has not been characterised. Guidelines are given for\nroom temperature, only.\n213 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201327.2.3 Rev B – C\n•PLL not locking\n•EEPROM read from ap plication code does not wo rk in Lock Bit Mode 3\n•EEPROM read may fail at  low supply voltage / low clock frequency\n•Timer Counter 1 PWM output generation on OC1B- XOC1B does not work correctly\n1. PLL not locking\nWhen at frequencies below 6.0 MHz, the PLL will not lock \nProblem fix / Workaround\nWhen using the PLL, run at 6.0 MHz or higher.\n2. EEPROM read from applic ation code does not work in Lock Bit Mode 3\nWhen the Memory Lock Bits LB2 and LB1 are programmed to mode 3, EEPROM read does not work from the\napplication code.\nProblem Fix/Work around\nDo not set Lock Bit Protection Mode 3 when th e application code needs to read from EEPROM.\n3. EEPROM read may fail at low supp ly voltage / low clock frequency\nTrying to read EEPROM at low clock frequencies a nd/or low supply voltage may result in invalid data.\nProblem Fix/Workaround\nDo not use the EEPROM when clock frequency is below 1M Hz and supply vo ltage is below 2V . If operating fre-\nquency can not be raised above 1MHz then supply voltage  should be more than 2V. Similarly, if supply voltage\ncan not be raised above 2V then operating frequency should be more than 1MHz.\nThis feature is known to be temperature dependent but it has not been characterised. Guidelines are given for\nroom temperature, only.\n4. Timer Counter 1 PWM output generation on OC1B – XOC1B does not work correctly\nTimer Counter1 PWM output OC1B-XOC1B does not work correctly. Only in  the case when the control bits,\nCOM1B1 and COM1B0 are in the same mode as COM1 A1 and COM1A0, respectively, the OC1B-XOC1B out-\nput works correctly.\nProblem Fix/Work around\nThe only workaround is to use same control setting on CO M1A[1:0] and COM1B[1:0] co ntrol bits, see table 14-\n4 in the data sheet. The problem has been fixed for Tiny45 rev D.\n27.2.4 Rev A\n•Too high power down power consumption\n•DebugWIRE looses communication when single stepping into interrupts\n•PLL not locking\n•EEPROM read from ap plication code does not wo rk in Lock Bit Mode 3\n•EEPROM read may fail at  low supply voltage / low clock frequency\n1. Too high power down power consumption\nThree situations will lead to a too high power down power consumption. These are:\n– An external clock is selected by fuses, but the I/O PORT is still en abled as an output.\n– The EEPROM is read before entering power down.\n– VCC is 4.5 volts or higher.\nProblem fix / Workaround\n214 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013– When using external clock, avoid setting the clock pin as Output.\n– Do not read the EEPROM if power down power cons umption is important.\n– Use VCC lower than 4.5 Volts.\n2. DebugWIRE looses communication when single stepping into interrupts\nWhen receiving an interr upt during single stepp ing, debugwire will loose\ncommunication.Problem fix / Workaround\n– When singlestepping, disable interrupts.\n– When debugging interrupts, use breakpoints within the interrupt routine, and run into the interrupt.\n3. PLL not locking\nWhen at frequencies below 6.0 MHz, the PLL will not lock \nProblem fix / Workaround\nWhen using the PLL, run at 6.0 MHz or higher.\n4. EEPROM read from applic ation code does not work in Lock Bit Mode 3\nWhen the Memory Lock Bits LB2 and LB1 are programmed to mode 3, EEPROM read does not work from the\napplication code.\nProblem Fix/Work around\nDo not set Lock Bit Protection Mode 3 when th e application code needs to read from EEPROM.\n5. EEPROM read may fail at low supp ly voltage / low clock frequency\nTrying to read EEPROM at low clock frequencies a nd/or low supply voltage may result in invalid data.\nProblem Fix/Workaround\nDo not use the EEPROM when clock frequency is below 1M Hz and supply vo ltage is below 2V . If operating fre-\nquency can not be raised above 1MHz then supply voltage  should be more than 2V. Similarly, if supply voltage\ncan not be raised above 2V then operating frequency should be more than 1MHz.\nThis feature is known to be temperature dependent but it has not been characterized. Guidelines are given for\nroom temperature, only.\n215 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201327.3 Errata ATtiny85 \nThe revision letter in this  section refers to  the revision of the ATtiny85 device.\n27.3.1 Rev B – C\nNo known errata.\n27.3.2 Rev A\n•EEPROM read may fail at  low supply voltage / low clock frequency\n1. EEPROM read may fail at low supp ly voltage / low clock frequency\nTrying to read EEPROM at low clock frequencies a nd/or low supply voltage may result in invalid data.\nProblem Fix/Workaround\nDo not use the EEPROM when clock frequency is below 1M Hz and supply vo ltage is below 2V . If operating fre-\nquency can not be raised above 1MHz then supply voltage  should be more than 2V. Similarly, if supply voltage\ncan not be raised above 2V then operating frequency should be more than 1MHz.\nThis feature is known to be temperature dependent but it has not been characterised. Guidelines are given for\nroom temperature, only.\n216 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201328. Datasheet Revision History\n28.1 Rev. 2586Q-08/13\n28.2 Rev. 2586P-06/13\n28.3 Rev. 2586O-02/13\nUpdated ordering codes on page 204 , page 205 , and page 206 .\n28.4 Rev. 2586N-04/11\n1. Added:\n– Section “Capacitive Touch Sensing” on page 6 .\n2. Updated:\n– Document template.\n– Removed “Preliminary” on front page. All devices now final and in production.\n– Section “Limitations” on page 36 .\n– Program example on page 49 .\n– Section “Overview” on page 122 .\n–Table 17-4 on page 135 .\n– Section “Limitations of debugWIRE” on page 140 .\n– Section “Serial Programming Algorithm” on page 151 .\n–Table 21-7 on page 166 .\n– EEPROM errata on pages 212, 212, 213, 214, and 215\n– Ordering information on pages 204, 205, and 206.\n28.5 Rev. 2586M-07/10\n1. Clarified Section 6.4 “Clock Output Buffer” on page 31 .\n2. Added Ordering Codes -SN and -SNR for ATtiny25 extended temperature.\n28.6 Rev. 2586L-06/10\n1. Added:\n– TSSOP for ATtiny45 in “Features” on page 1 , Pinout Figure 1-1 on page 2 , Ordering Information in \nSection 25.2 “ATtiny45” on page 205 , and Packaging Information in Section 26.4 “8X” on page 210\n–Table 6-11, “Capacitance of Low-Freq uency Crystal Oscillator,” on page 29\n–Figure 22-36 on page 191  and Figure 22-37 on page 191 , Typical Characteristics plots for Bandgap \nVoltage vs. VCC and Temperature\n– Extended temperature in Section 25.1 “ATtiny25” on page 204 , Ordering Information\n– Tape & reel part numbers in Ordering Information, in Section 25.1 “ATtiny25” on page 204  and Section \n25.2 “ATtiny45” on page 2051.“Bit 3 – FOC1B: Force Output Compare Match 1B”  description in “GTCCR – General Timer/Counter1 Control \nRegister” on page 90  updated: PB3 in “compare match output pin PB3 (OC1B)” corrected to PB4.\n1.Updated description of “EEARH – EEPROM Address Register” and “EEARL – EEPROM Address Register” on page \n20.\n217 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20132. Updated:\n–“Features” on page 1 , removed Preliminary from ATtiny25\n–Section 8.4.2 “Code Example” on page 44\n–“PCMSK – Pin Change Mask Register” on page 52 , Bit Descriptions\n–“TCCR1 – Timer/Counter1 Control Register” on page 89  and “GTCCR – General Timer/Counter1 \nControl Register” on page 90 , COM bit descriptions clarified\n–Section 20.3.2 “Calibration Bytes” on page 150 , frequencies (8 MHz, 6.4 MHz)\n–Table 20-11, “Minimum Wait  Delay Before Writing the Next Flash or EEPROM  Location,” on page 153 , \nvalue for tWD_ERASE\n–Table 20-16, “High-voltage Serial Programming In struction Set for ATtiny25/45/85,” on page 158\n–Table 21-1, “DC Characteristics. TA  = -40°C to +85°C,” on page 161 , notes adjusted\n–Table 21-11, “Serial Programming Characteristics, TA = -40°C to +85°C, VCC = 1.8 - 5.5V (Unless \nOtherwise Noted),” on page 170 , added tSLIV\n– Bit syntax throughout the datasheet, e.g. from CS02:0 to CS0[2:0].\n28.7 Rev. 2586K-01/08\n1. Updated Document Template.\n2. Added Sections:\n–“Data Retention” on page 6\n–“Low Level Interrupt” on page 49\n–“Device Signature Imprint Table” on page 149\n3. Updated Sections:\n–“Internal PLL for Fast Peripheral Clock Generation - clkPCK” on page 24\n–“System Clock and Clock Options” on page 23\n–“Internal PLL in ATtiny15 Compatibility Mode” on page 24\n–“Sleep Modes” on page 34\n–“Software BOD Disable” on page 35\n–“External Interrupts” on page 49\n–“Timer/Counter1 in PWM Mode” on page 97\n–“USI – Universal Serial Interface” on page 108\n–“Temperature Measurement” on page 133\n–“Reading Lock, Fuse and Signature Data from Software” on page 143\n–“Program And Data Memory Lock Bits” on page 147\n–“Fuse Bytes” on page 148\n–“Signature Bytes” on page 150\n–“Calibration Bytes” on page 150\n–“System and Reset Characteristics” on page 165\n4. Added Figures:\n–“Reset Pin Output Voltage vs. Sink Current (VCC = 3V)” on page 184\n–“Reset Pin Output Voltage vs. Sink Current (VCC = 5V)” on page 185\n–“Reset Pin Output Voltage vs. Source Current (VCC = 3V)” on page 185\n–“Reset Pin Output Voltage vs. Source Current (VCC = 5V)” on page 186\n218 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20135. Updated Figure:\n–“Reset Logic” on page 39\n6. Updated Tables:\n–“Start-up Times for Internal Calibra ted RC Oscillator Clock” on page 28\n–“Start-up Times for Internal Calibrated RC Os cillator Clock (in ATtiny15 Mode)” on page 28\n–“Start-up Times for the 128 kHz Internal Oscillator” on page 28\n–“Compare Mode Select in PWM Mode” on page 86\n–“Compare Mode Select in PWM Mode” on page 98\n–“DC Characteristics. TA = -40°C to +85°C” on page 161\n–“Calibration Accuracy of Intern al RC Oscillator” on page 164\n–“ADC Characteristics” on page 167\n7. Updated Code Example in Section:\n–“Write” on page 17\n8. Updated Bit Descriptions in:\n–“MCUCR – MCU Control Register” on page 37\n–“Bits 7:6 – COM0A[1:0]: Compare Match Output A Mode” on page 77\n–“Bits 5:4 – COM0B[1:0]: Compare Match Output B Mode” on page 77\n–“Bits 2:0 – ADTS[2:0]: ADC Auto Trigger Source” on page 138\n–“SPMCSR – Store Program Memory Control and Status Register” on page 145 .\n9. Updated description of feature “EEPROM read may fa il at low supply voltage / low clock frequency” in \nSections:\n–“Errata ATtiny25” on page 212\n–“Errata ATtiny45” on page 212\n–“Errata ATtiny85” on page 215\n10. Updated Package Description in Sections:\n–“ATtiny25” on page 204\n–“ATtiny45” on page 205\n–“ATtiny85” on page 206\n11. Updated Package Drawing:\n–“S8S1” on page 209\n12. Updated Order Codes for:\n–“ATtiny25” on page 204\n28.8 Rev. 2586J-12/06\n1. Updated “Low Power Consumption” on page 1 .\n2. Updated description of instruction length in “Architectural Overview” .\n3. Updated Flash size in “In-System Re-programmable Flash Program Memory” on\npage 15 .\n4. Updated cross-references in sections “Atomic Byte Programming” , “Erase”  and\n“Write” , starting on page 17 .\n5. Updated “Atomic Byte Programming” on page 17 .\n6. Updated “Internal PLL for Fast Peripheral Clo ck Generation - clkPCK” on page 24 .\n7. Replaced single clocking  system figure with two: Figure 6-2  and Figure 6-3 .\n219 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20138. Updated Table 6-1 on page 25 , Table 6-13 on page 30  and Table 6-6 on page 27 .\n9. Updated “Calibrated Internal Oscillator” on page 27 .\n10. Updated Table 6-5 on page 26 .\n11. Updated “OSCCAL – Oscillator Calibration Register” on page 31 .\n12. Updated “CLKPR – Clock Prescale Register” on page 32 .\n13. Updated “Power-down Mode” on page 35 .\n14. Updated “Bit 0” in “PRR – Power Reduction Register” on page 38 .\n15. Added footnote to Table 8-3 on page 46 .\n16. Updated Table 10-5 on page 63 .\n17. Deleted “Bits 7, 2” in “MCUCR – MCU Control Register” on page 64 .\n18. Updated and moved section “Timer/Counter 0 Prescaler and Clock Sources”, now\nlocated on page 66 .\n19. Updated “Timer/Counter1 Initialization for Asynchronous Mode” on page 86 .\n20. Updated bit description in “PLLCSR – PLL Control and Status Register” on page 94\nand “PLLCSR – PLL Control and St atus Register” on page 103 .\n21. Added recommended maximum frequency in “Prescaling and Conversion Timing” on\npage 125 .\n22. Updated Figure 17-8 on page 129  .\n23. Updated “Temperature Measurement” on page 133 .\n24. Updated Table 17-3 on page 134 .\n25. Updated bit R/W descriptions in:\n“TIMSK – Timer/Counter Interrupt Mask Register” on page 81 , \n“TIFR – Timer/Counter Interrupt Flag Register” on page 81 ,\n“TIMSK – Timer/Counter Interrupt Mask Register” on page 92 ,\n“TIFR – Timer/Counter Interrupt Flag Register” on page 93 ,\n“PLLCSR – PLL Control and Status Register” on page 94 ,\n“TIMSK – Timer/Counter Interrupt Mask Register” on page 102 ,\n“TIFR – Timer/Counter Interrupt Flag Register” on page 103 ,\n“PLLCSR – PLL Control and Status Register” on page 103  and\n“DIDR0 – Digital Input Disable  Register 0” on page 138 .\n26. Added limitation to “Limitations of debugWIRE” on page 140 .\n27. Updated “DC Characteristics” on page 161 .\n28. Updated Table 21-7 on page 166 .\n29. Updated Figure 21-6 on page 171 .\n30. Updated Table 21-12 on page 171 .\n31. Updated Table 22-1 on page 177 .\n32. Updated Table 22-2 on page 177 .\n33. Updated Table 22-30 , Table 22-31  and Table 22-32 , starting on page 188 .\n34. Updated Table 22-33 , Table 22-34  and Table 22-35 , starting on page 189 .\n35. Updated Table 22-39 on page 192 .\n36. Updated Table 22-46 , Table 22-47 , Table 22-48  and Table 22-49 .\n220 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201328.9 Rev. 2586I-09/06\n28.10 Rev. 2586H-06/06\n28.11 Rev. 2586G-05/06\n28.12 Rev. 2586F-04/061. All Characterization data moved to “Electrical Characteristics” on page 161 .\n2. All Register Descriptions are gathered up in seperate sections in the end of each\nchapter.\n3. Updated Table 11-3 on page 78 , Table 11-5 on page 79 , Table 11-6 on page 80  and\nTable 20-4 on page 148 .\n4. Updated “Calibrated Internal Oscillator” on page 27 .\n5. Updated Note in Table 7-1 on page 34 .\n6. Updated “System Control and Reset” on page 39 .\n7. Updated Register Description in “I/O Ports” on page 53 .\n8. Updated Features in “USI – Universal Serial Interface” on page 108 .\n9. Updated Code Example in “SPI Master Operation Example” on page 110  and “SPI\nSlave Operation Example” on page 111 .\n10. Updated “Analog Comparator Multiplexed Input” on page 119 .\n11. Updated Figure 17-1 on page 123 .\n12. Updated “Signature Bytes” on page 150 .\n13. Updated “Electrical Characteristics” on page 161 .\n1. Updated “Calibrated Internal Oscillator” on page 27 .\n2. Updated Table 6.5.1 on page 31 .\n3. Added Table 21-2 on page 164 .\n1. Updated “Internal PLL for Fast Peripheral Clo ck Generation - clkPCK” on page 24 .\n2. Updated “Default Clock Source” on page 30 .\n3. Updated “Low-Frequency Crystal Oscillator” on page 29 .\n4. Updated “Calibrated Internal Oscillator” on page 27 .\n5. Updated “Clock Output Buffer” on page 31 .\n6. Updated “Power Management and Sleep Modes” on page 34 .\n7. Added “Software BOD Disable” on page 35 .\n8. Updated Figure 16-1 on page 119 .\n9. Updated “Bit 6 – ACBG: Analog Comparator Bandgap Select” on page 120 .\n10. Added note for Table 17-2 on page 125 .\n11. Updated “Register Summary” on page 200 .\n1. Updated “Digital Input Enable and Sleep Modes” on page 57 .\n2. Updated Table 20-16 on page 158 .\n3. Updated “Ordering Information” on page 204 .\n221 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201328.13 Rev. 2586E-03/06\n28.14 Rev. 2586D-02/06\n28.15 Rev. 2586C-06/05\n28.16 Rev. 2586B-05/05\n28.17 Rev. 2586A-02/05\nInitial revision.1. Updated Features in “Analog to Digital Converter” on page 122 .\n2. Updated Operation in “Analog to Digital Converter” on page 122 .\n3. Updated Table 17-2 on page 133 .\n4. Updated Table 17-3 on page 134 .\n5. Updated “Errata” on page 212 .\n1. Updated Table 6-13 on page 30 , Table 6-10 on page 29 , Table 6-3 on page 26 ,\nTable 6-9 on page 28 , Table 6-5 on page 26 , Table 9-1 on page 48 ,Table 17-4 on\npage 135 , Table 20-16 on page 158 , Table 21-8 on page 167 .\n2. Updated “Timer/Counter1 in PWM Mode” on page 86 .\n3. Updated text “Bit 2 – TOV1: Timer/Counter1 Overflow Flag” on page 93 .\n4. Updated values in “DC Characteristics” on page 161 .\n5. Updated “Register Summary” on page 200 .\n6. Updated “Ordering Information” on page 204 .\n7. Updated Rev B and C in “Errata ATtiny45” on page 212 .\n8. All references to power-save mode are removed.9. Updated Register Adresses.\n1. Updated “Features” on page 1 .\n2. Updated Figure 1-1 on page 2 . \n3. Updated Code Examples on page 18  and page 19 .\n4. Moved “Temperature Measurement” to Section 17.12  page 133 .\n5. Updated “Register Summary” on page 200 .\n6. Updated “Ordering Information” on page 204 .\n1. CLKI added, instances of EEMWE /EEWE renamed EEMPE/EEPE, removed some\nTBD.\nRemoved “Preliminary Description” from “Temperature Measurement” on page 133 .\n2. Updated “Features” on page 1 .\n3. Updated Figure 1-1 on page 2  and Figure 8-1 on page 39 .\n4. Updated Table 7-2 on page 38 , Table 10-4 on page 63 , Table 10-5 on page 63\n5. Updated “Serial Programming Instruction set” on page 153 .\n6. Updated SPH register in “Instruction Set Summary” on page 202 .\n7. Updated “DC Characteristics” on page 161 .\n8. Updated “Ordering Information” on page 204 .\n9. Updated “Errata” on page 212 .\n222 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013\n223 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013\n224 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013\n225 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013\n226 ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013\ni ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013Table of Contents\nFeatures .............. ................. ................ .............. .............. .............. ............1\n1 Pin Configurations .......... ................. ................ .............. .............. ............2\n1.1 Pin Descriptions ........... ......................................................................................2\n2 Overview ................. .............. .............. .............. .............. .............. ............4\n2.1 Block Diagram ...................................................................................................4\n3 About .............. ................ ................ ................. ................ .............. ............6\n3.1 Resources .........................................................................................................6\n3.2 Code Examples .................................................................................................63.3 Capacitive Touch Sensing .................................................................................63.4 Data Retention ...................................................................................................6\n4 AVR CPU Core  ................. ................. ................ .............. .............. ............7\n4.1 Introduction ........................................................................................................7\n4.2 Architectural Overview .......................................................................................74.3 ALU – Arithmetic Logic Unit ...............................................................................84.4 Status Register ..................................................................................................84.5 General Purpose Register  File ........................................................................10\n4.6 Stack Pointer ...................................................................................................114.7 Instruction Execution Timing ...........................................................................114.8 Reset and Interrupt Handling ...........................................................................12\n5 AVR Memories ........ ................ ................. ................ ................. ..............15\n5.1 In-System Re-programmable Flash Prog ram Memory ....................................15\n5.2 SRAM Data Memory ........................................................................................15\n5.3 EEPROM Data Memory . ................ ................. ............. ............ ............. ..........16\n5.4 I/O Memory ......................................................................................................195.5 Register Description ........................................................................................20\n6 System Clock and Clock Opti ons ................. .............. .............. ............23\n6.1 Clock Systems and their Distribution .. .............................................................23\n6.2 Clock Sources .................................................................................................256.3 System Clock Prescaler ..................................................................................316.4 Clock Output Buffer .........................................................................................316.5 Register Description ........................................................................................31\n7 Power Management and Sleep Modes .... ................ ................. ............34\n7.1 Sleep Modes ....................................................................................................34\nii ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/20137.2 Software BOD Disable .....................................................................................35\n7.3 Power Reduction Register ...............................................................................367.4 Minimizing Power Consumption ......................................................................367.5 Register Description ........................................................................................37\n8 System Control and R eset ................... .............. .............. ............ ..........39\n8.1 Resetting the AVR ...........................................................................................39\n8.2 Reset Sources .................................................................................................398.3 Internal Voltage Reference ..............................................................................428.4 Watchdog Timer ..............................................................................................428.5 Register Description ........................................................................................44\n9 Interrupts ............... .............. .............. .............. .............. .............. ............48\n9.1 Interrupt Vectors in ATtiny25/45/85 .................................................................48\n9.2 External Interrupts ...........................................................................................499.3 Register Description ........................................................................................51\n10 I/O Ports ......... ................ ................ ................. .............. .............. ............53\n10.1 Introduction ......................................................................................................53\n10.2 Ports as General Digital I/O .............................................................................5310.3 Alternate Port Functions ..................................................................................5710.4 Register Description ........................................................................................64\n11 8-bit Timer/Counter0 with PW M .................... .............. .............. ............65\n11.1 Features ..........................................................................................................65\n11.2 Overview ..........................................................................................................6511.3 Timer/Counter0 Prescaler and Clock Sources ................................................66\n11.4 Counter Unit ....................................................................................................6811.5 Output Compare Unit .......................................................................................6911.6 Compare Match Output Unit ............................................................................7011.7 Modes of Operation .........................................................................................7111.8 Timer/Counter Timing Dia grams ......................................................................76\n11.9 Register Description ........................................................................................77\n12 8-bit Timer/Counter1 .......... .............. .............. .............. .............. ............83\n12.1 Timer/Counter1 Prescale r ...............................................................................83\n12.2 Counter and Compare Units ............................................................................8312.3 Register Description ........................................................................................89\n13 8-bit Timer/Counter1 in ATtiny15 Mode ................ ................. ..............95\n13.1 Timer/Counter1 Prescale r ...............................................................................95\niii ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201313.2 Counter and Compare Units ............................................................................95\n13.3 Register Description ......................................................................................100\n14 Dead Time Generator ......... .............. .............. .............. .............. ..........105\n14.1 Register Description ......................................................................................106\n15 USI – Universal Serial Inte rface ................. ................. .............. ..........108\n15.1 Features ........................................................................................................108\n15.2 Overview ........................................................................................................10815.3 Functional Descriptions .................................................................................10915.4 Alternative USI Usage ...................................................................................11415.5 Register Descriptions ....................................................................................115\n16 Analog Comparator ............ .............. .............. .............. .............. ..........119\n16.1 Analog Comparator Multiplexed Input ...........................................................119\n16.2 Register Description ......................................................................................120\n17 Analog to Digital Converter ................. .............. .............. ............ ........122\n17.1 Features ........................................................................................................122\n17.2 Overview ........................................................................................................12217.3 Operation .......................................................................................................12317.4 Starting a Conversion ....................................................................................12417.5 Prescaling and Conversion Timing ................................................................12517.6 Changing Channel or Reference Selection ...................................................12817.7 ADC Noise Canceler .....................................................................................12817.8 Analog Input Circuitry ....................................................................................12917.9 Noise Canceling Techniques .........................................................................12917.10 ADC Accuracy Definitions .............................................................................13017.11 ADC Conversion Result .................................................................................13217.12 Temperature Measurement ...........................................................................13317.13 Register Description ......................................................................................134\n18 debugWIRE On-chip Debug S ystem ............. .............. .............. ..........139\n18.1 Features ........................................................................................................139\n18.2 Overview ........................................................................................................13918.3 Physical Interface ..........................................................................................13918.4 Software Break Points ...................................................................................14018.5 Limitations of debugWIRE .............................................................................14018.6 Register Description ......................................................................................140\n19 Self-Programming the Flash ............. .............. .............. .............. ........141\niv ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201319.1 Performing Page Erase by  SPM ....................................................................141\n19.2 Filling the Temporary Buffer (Page Loading) .................................................14119.3 Performing a Page Write .................... ...........................................................142\n19.4 Addressing the Flash During Self-Pro gramming ...........................................142\n19.5 EEPROM Write Prevents Writing to SPMCSR ............. ............ ............. ........142\n19.6 Reading Lock, Fuse and Signature Data  from Software ...............................143\n19.7 Preventing Flash Corruption ..........................................................................14419.8 Programming Time for Flash when Us ing SPM .............................................145\n19.9 Register Description ......................................................................................145\n20 Memory Programming ........... ................. ................ ................. ............147\n20.1 Program And Data Memory  Lock Bits ...........................................................147\n20.2 Fuse Bytes .....................................................................................................14820.3 Device Signature Imprint Table .....................................................................14920.4 Page Size ......................................................................................................15020.5 Serial Downloading ........................................................................................15120.6 High-voltage Serial Prog ramming ..................................................................155\n20.7 High-voltage Serial Prog ramming Algorithm ..................................................155\n21 Electrical Characteristics .. .............. .............. .............. .............. ..........161\n21.1 Absolute Maximum Ratings* .........................................................................161\n21.2 DC Characteristics .........................................................................................16121.3 Speed ............................................................................................................16321.4 Clock Characteristics .....................................................................................16421.5 System and Reset Characteristics ................................................................16521.6 Brown-Out Detection .....................................................................................16621.7 ADC Characteristics ......................................................................................16721.8 Serial Programming Characteristics ... ...........................................................170\n21.9 High-voltage Serial Prog ramming Characteristics .........................................171\n22 Typical Characteristics ...... .............. .............. .............. .............. ..........172\n22.1 Active Supply Current ....................................................................................172\n22.2 Idle Supply Current ........................................................................................17522.3 Supply Current of I/O modules ......................................................................17722.4 Power-down Supply Curr ent ..........................................................................178\n22.5 Pin Pull-up .....................................................................................................17922.6 Pin Driver Strength ........................................................................................18222.7 Pin Threshold and Hysteresis ........................................................................18622.8 BOD Threshold ..............................................................................................189\nv ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201322.9 Internal Oscillator Speed ...............................................................................192\n22.10 Current Consumption of Peripheral Units ......................................................19622.11 Current Consumption in Reset and Re set Pulsewidth ...................................198\n23 Register Summary .............. .............. .............. .............. .............. ..........200\n24 Instruction Set Summary ..... .............. .............. .............. .............. ........202\n25 Ordering Information ........... .............. .............. .............. .............. ........204\n25.1 ATtiny25 ........................................................................................................204\n25.2 ATtiny45 ........................................................................................................20525.3 ATtiny85 ........................................................................................................206\n26 Packaging Information ....... .............. .............. .............. .............. ..........207\n26.1 8P3 ................................................................................................................207\n26.2 8S2 ................................................................................................................20826.3 S8S1 ..............................................................................................................20926.4 8X ..................................................................................................................21026.5 20M1 ..............................................................................................................211\n27 Errata ........... ................. ................ ................ ................. .............. ..........212\n27.1 Errata ATtiny25 ..............................................................................................212\n27.2 Errata ATtiny45 ..............................................................................................21227.3 Errata ATtiny85 ..............................................................................................215\n28 Datasheet Revision History .. ............. .............. .............. .............. ........216\n28.1 Rev. 2586Q-08/13 .........................................................................................216\n28.2 Rev. 2586P-06/13 ..........................................................................................21628.3 Rev. 2586O-02/13 .........................................................................................21628.4 Rev. 2586N-04/11 .........................................................................................21628.5 Rev. 2586M-07/10 .........................................................................................21628.6 Rev. 2586L-06/10 ..........................................................................................21628.7 Rev. 2586K-01/08 ..........................................................................................21728.8 Rev. 2586J-12/06 ..........................................................................................21828.9 Rev. 2586I-09/06 ...........................................................................................22028.10 Rev. 2586H-06/06 .........................................................................................22028.11 Rev. 2586G-05/06 .........................................................................................22028.12 Rev. 2586F-04/06 ..........................................................................................22028.13 Rev. 2586E-03/06 ..........................................................................................22128.14 Rev. 2586D-02/06 .........................................................................................22128.15 Rev. 2586C-06/05 .........................................................................................221\nvi ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/201328.16 Rev. 2586B-05/05 ..........................................................................................221\n28.17 Rev. 2586A-02/05 ..........................................................................................221\nTable of Contents...... ................. ................ ................ ................. ...............i\nvii ATtiny25/45/85 [DATASHEET]\n2586Q–AVR–08/2013\nAtmel Corporation\n1600 Technology Drive\nSan Jose, CA 95110USATel:  (+1) (408) 441-0311\nFax: (+1) (408) 487-2600\nwww.atmel.comAtmel Asia Limited\nUnit 01-5 & 16, 19F\nBEA Tower, Millennium City 5418 Kwun Tong RoaKwun Tong, KowloonHONG KONGTel: (+852) 2245-6100\nFax: (+852) 2722-1369Atmel Munich GmbH\nBusiness Campus\nParkring 4D-85748 Garching b. MunichGERMANYTel: (+49) 89-31970-0\nFax: (+49) 89-3194621Atmel Japan G.K.\n16F Shin-Osaki Kangyo Bldg\n1-6-4 Osaki, Shinagawa-kuTokyo 141-0032JAPANTel: (+81) (3) 6417-0300\nFax: (+81) (3) 6417-0370\n© 2013 Atmel Corporation. All rights reserved.  /  Rev.: 2586Q–AVR–08/2013\nDisclaimer: The information in this document is provided in co nnection with Atmel products. No lic ense, express or implied, by estoppel or otherwise, to any intellectual property right is granted by this \ndocument or in connection with the sale of Atmel products. EXC EPT AS SET FORTH IN THE ATMEL TERMS AND CONDITIONS OF SALES LOCAT ED ON THE ATMEL WEBSITE, ATMEL ASSUMES \nNO LIABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTORY WARRANTY RELATING TO ITS PRODUCTS INCLUDING, BUT NOT LI MITED TO, THE IMPLIED \nWARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY D IRECT, INDIRECT, \nCONSEQUENTIAL, PUNITIVE, SPECIAL OR INCIDE NTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS AND PROFITS, BUSINESS I NTERRUPTION, OR LOSS OF \nINFORMATION) ARISING OUT OF THE US E OR INABILITY TO USE THIS DOCUMENT, EVEN IF AT MEL HAS BEEN ADVISED OF THE POSSIBILITY OF SUC H DAMAGES. Atmel makes no \nrepresentations or warranties with respect to the accuracy or completeness of the contents of this document and reserves the ri ght to make changes to specifications and products descriptions at any time \nwithout notice. Atmel does not make any commitment to update th e information contained herein. Un less specifically provided oth erwise, Atmel products are not suitable for, and shall not be used in, \nautomotive applications. Atmel products are not intended, authorized, or warranted for use as components in applications intend ed to support or sustain life.Atmel®, Atmel logo and combinations thereof, Enabling Unlimited Possibilities®, AVR®, tinyAVR® and others are registered trademarks or trademarks of Atmel \nCorporation or its subsidiaries. Other terms and product names may be trademarks of others.\nMouser Electronics\n  \nAuthorized Distributor\n \n  \nClick to View Pricing, Inventory, Delivery & Lifecycle Information:\n \n \n \n Microchip:   \n\xa0 ATTINY45-20XU\xa0 ATTINY45V-10XU\xa0 ATTINY25V-10SSU\xa0 ATTINY25-20SSU\xa0 ATTINY25-20SH\xa0 ATTINY25-20SSH\xa0\nATTINY25V-10SH\xa0 ATTINY25V-10SSH\xa0 ATTINY45-20SH\xa0 ATTINY45V-10SH\xa0 ATTINY85-20SH\xa0 ATTINY85V-10SH\xa0\nATTINY25-20MUR\xa0 ATTINY25-20SSN\xa0 ATTINY25-20SSUR\xa0 ATTINY25-20SUR\xa0 ATTINY25V-10MUR\xa0 ATTINY25V-\n10SSUR\xa0 ATTINY25V-10SUR\xa0 ATTINY45-20MUR\xa0 ATTINY45-20SUR\xa0 ATTINY45-20XUR\xa0 ATTINY45V-10MUR\xa0\nATTINY45V-10SUR\xa0 ATTINY45V-10XUR\xa0 ATTINY85-20MUR\xa0 ATTINY85-20SUR\xa0 ATTINY85V-10MUR\xa0 ATTINY85V-\n10SUR\xa0 ATTINY25-20SSNR\xa0 ATTINY25V-10PU\xa0 ATTINY25V-10SU\xa0 ATTINY25V-10MU\xa0 ATTINY25-20PU\xa0 ATTINY25-\n20SU\xa0 ATTINY25-20MU\xa0 ATTINY45V-10PU\xa0 ATTINY45V-10SU\xa0 ATTINY45V-10MU\xa0 ATTINY45-20PU\xa0 ATTINY45-20SU\n\xa0 ATTINY45-20MU\xa0 ATTINY85V-10PU\xa0 ATTINY85V-10SU\xa0 ATTINY85V-10MU\xa0 ATTINY85-20PU\xa0 ATTINY85-20SU\xa0\nATTINY85-20MU\xa0 ATTINY85V-15MT\xa0 ATTINY85V-15ST\xa0 ATTINY85-W\xa0 ATTINY45-D\xa0 ATTINY25V-10SSNR\xa0\nATTINY25V-10SSN\xa0 ATTINY25-20SN\xa0 ATTINY25-20SNR\xa0 ATTINY25V-10SN\xa0 ATTINY25V-10SNR\xa0 ATTINY25-20MF\xa0\nATTINY25-20MFR\xa0 ATTINY25V-10MF\xa0 ATTINY25V-10MFR\xa0 ATTINY85V-10SHR\xa0 ATTINY25V-10SHR\xa0 ATTINY85-\n20SHR\xa0 ATTINY25-20SHR\xa0 ATTINY45-20SHR\xa0 ATTINY45V-10SHR\xa0 ATTINY25-20SSHR\xa0 ATTINY25V-10SSHR\xa0\nATTINY85-20SF\xa0 ATTINY85-20SFR\n'}]
!==============================================================================!
### Component Summary: ATTINY45V-10SUR

#### Key Characteristics and Specifications:
- **Voltage Ratings**: 
  - Operating Voltage: 1.8V to 5.5V
  - Speed Grade: 0 - 4 MHz @ 1.8 - 5.5V, 0 - 10 MHz @ 2.7 - 5.5V
- **Current Ratings**: 
  - Active Mode: 300 µA @ 1 MHz, 1.8V
  - Power-down Mode: 0.1 µA @ 1.8V
- **Power Consumption**: 
  - Low power consumption with various modes to optimize energy usage.
- **Operating Temperature Range**: 
  - Industrial: -40°C to +85°C
- **Package Type**: 
  - 8-pin PDIP, 8-pin SOIC, 20-pad QFN/MLF, and 8-pin TSSOP
- **Special Features**: 
  - 8-bit AVR® RISC architecture with 120 powerful instructions.
  - 2/4/8K bytes of in-system programmable Flash memory.
  - 128/256/512 bytes of EEPROM and SRAM.
  - 10-bit ADC with 4 single-ended channels and 2 differential pairs.
  - Programmable watchdog timer and on-chip debugWIRE system.
  - Low power modes including Idle, ADC Noise Reduction, and Power-down.
- **Moisture Sensitive Level (MSL)**: 
  - MSL Level 1 per JEDEC J-STD-020E.

#### Description:
The **ATTINY45V-10SUR** is a high-performance, low-power 8-bit microcontroller from Microchip Technology, based on the AVR architecture. It features a compact design with a variety of integrated peripherals, including a 10-bit ADC, timers, and EEPROM, making it suitable for a wide range of applications. The microcontroller is designed for efficiency, allowing for low power consumption in various operational modes.

#### Typical Applications:
- **Embedded Systems**: Ideal for small, low-power applications such as sensors, actuators, and control systems.
- **Consumer Electronics**: Used in devices requiring efficient processing with minimal power usage.
- **Automotive**: Suitable for automotive applications where reliability and low power consumption are critical.
- **Industrial Automation**: Can be utilized in automation systems for monitoring and control tasks.
- **IoT Devices**: Perfect for Internet of Things applications due to its low power modes and integrated peripherals.

This microcontroller is particularly advantageous in applications where space and power efficiency are paramount, making it a versatile choice for developers in various fields.