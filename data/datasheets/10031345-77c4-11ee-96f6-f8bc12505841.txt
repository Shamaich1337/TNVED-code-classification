[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of AT45DB011D-SH-T production of ATMEL from the text:Features\n•Single 2.7V to 3.6V Supply\n\x7fRapidS® Serial Interface: 66 MHz Maximum Clock Frequency\n– SPI Compatible Modes 0 and 3\n\x7fUser Configurable Page Size\n– 256 Bytes per Page\n– 264 Bytes per Page\n– Page Size Can Be Factory Pre-configured for 256 Bytes\n\x7fPage Program Operation\n– Intelligent Programming Operation\n– 512 Pages (256/264 Bytes/Page) Main Memory\n\x7fFlexible Erase Options\n– Page Erase (256 Bytes)\n– Block Erase (2 Kbytes)– Sector Erase (32 Kbytes)\n– Chip Erase (1 Mbits)\n\x7fOne SRAM Data Buffer (256/264 Bytes)\n\x7fContinuous Read Capability through Entire Array\n– Ideal for Code Shadowing Applications\n\x7fLow-power Dissipation\n– 7 mA Active Read Current Typical\n– 25 µA Standby Current Typical\n– 5 µA Deep Power-down Typical\n\x7fHardware and Software Data Protection Features\n– Individual Sector\n\x7fSector Lockdown for Secure Code and Data Storage\n– Individual Sector\n\x7fSecurity: 128-byte Security Register\n– 64-byte User Programmable Space\n– Unique 64-byte Device Identifier\n\x7fJEDEC Standard Manufacturer and Device ID Read\n\x7f100,000 Program/Erase Cycles Per Page Minimum\n\x7fData Retention – 20 Years\n\x7fIndustrial Temperature Range\n\x7fGreen (Pb/Halide-free/RoHS Compliant) Packaging Options\n1. Description\nThe AT45DB011D is a 2.7V, serial-interface Flash memory ideally suited for a wide\nvariety of digital voice-, image-, program code- and data-storage applications. The\nAT45DB011D supports RapidS serial interf ace for applications requiring very high\nspeed operations. RapidS serial interface is SPI compatible for frequencies up to 66\nMHz. Its 1,081,344 bits of memory are organized as 512 pages of 256 bytes or 264\nbytes each. In addition to the main memory, the AT45DB011D also contains oneSRAM buffer of 256/264 bytes. EEPROM emulat ion (bit or byte alterability) is easily\nhandled with a self-contained three step read-modify-write operation. Unlike conven-\ntional Flash memories that are accessed randomly with multiple address lines and aparallel interface, the DataFlash\n® uses a RapidS serial interface to sequentially\naccess its data. The simple sequential access dramatically reduces active pin count,\nfacilitates hardware layout, increases syst em reliability, minimizes switching noise,\nand reduces package size.1-megabit \n2.7-volt Minimum\nDataFlash\nAT45DB011D\n 3639E–DFLASH–5/08\n2\n3639E–DFLASH–5/08AT45DB011DThe device is optimized for use in many commerci al and industrial applications where high-den-\nsity, low-pin count, low-voltage and low-power are essential.\nTo allow for simple in-system reprogrammabi lity, the AT45DB011D does  not require high input\nvoltages for programming. The device operates from a single power supply, 2.7V to 3.6V, forboth the program and read operations. The AT45DB011D is enabled through the chip select pin\n(CS\n) and accessed via a three-wire interface consisting of the Serial Input (SI), Serial Output\n(SO), and the Serial Clock (SCK).\nAll programming and erase cycles are self-timed.\n2. Pin Configurations and Pinouts\nTable 2-1. Pin Configurations\nSymbol Name and FunctionAsserted \nState Type\nCSChip Select:  Asserting the CS  pin selects the device. When the CS  pin is deasserted, the device will be deselected \nand normally be placed in the standby mode (not Deep Powe r-Down mode), and the output pin (SO) will be in a \nhigh-impedance state. When the device is deselected, data will not be accepted on the input pin (SI).\nA high-to-low transition on the CS  pin is required to start an operation, and  a low-to-high transition is required to \nend an operation. When ending an internally self-timed operat ion such as a program or erase cycle, the device \nwill not enter the standby mode until the completion of the operation.Low Input\nSCKSerial Clock:  This pin is used to provide a clock to the device and is used to control the flow of data to and from \nthe device. Command, address, and input data present on t he SI pin is always latched on the rising edge of SCK, \nwhile output data on the SO pin is always clocked out on the falling edge of SCK.– Input\nSISerial Input:  The SI pin is used to shift data into the device . The SI pin is used for all data input including \ncommand and address sequences. Data on the SI pin is always latched on the rising edge of SCK.– Input\nSOSerial Output:  The SO pin is used to shift data out from the de vice. Data on the SO pin is always clocked out on \nthe falling edge of SCK.– Output\nWPWrite Protect:  When the WP  pin is asserted, all sectors s pecified for protection by the Se ctor Protection Register will \nbe protected against program and erase operations regardless of whether the Enable Sector Protection command \nhas been issued or not. The WP  pin functions independently of the softwar e controlled protection method. After the \nWP pin goes low, the content of the Sect or Protection Register cannot be modified.\nIf a program or erase command is issued to the device while the WP  pin is asserted, the device will simply ignore \nthe command and perform no operation. The device will return to the idle state once the CS  pin has been \ndeasserted. The Enable Sector Protection command and Sector Lockdown command, however, will be \nrecognized by the device when the WP  pin is asserted.\nThe WP  pin is internally pulled-high and may be left floating if hardware controlled protection will not be used. \nHowever, it is recommended that the WP  pin also be externally connected to VCC whenever possible.Low Input\nRESETReset:  A low state on the reset pin (RESET ) will terminate the operation in progress and reset the internal state \nmachine to an idle state. The device will remain in the reset condition as long as a low level is present on the RESET  \npin. Normal operation can resume once the RESET  pin is brought back to a high level.\nThe device incorporates an internal power-on rese t circuit, so there are no restrictions on the RESET  pin during \npower-on sequences. If this pin and feature are not utilized it is recommended that the RESET  pin be driven high \nexternally.Low Input\nVCCDevice Power Supply:  The VCC pin is used to supply the source voltage to the device.\nOperations at invalid VCC voltages may produce spurious results and should not be attempted.–P o w e r\nGND Ground:  The ground reference for the power supply. GND should be connected to the system ground. – Ground\n3\n3639E–DFLASH–5/08AT45DB011D\nNote: 1. The metal pad on the bottom of the UDFN package is float ing. This pad can be a “No Connect” or connected to GND.\n3. Block DiagramFigure 2-1. SOIC Top View Figure 2-2. UDFN Top View(1)\n1\n2348\n765SI\nSCK\nRESET\nCSSO\nGNDVCCWP\nSI\nSCK\nRESET\nCSSO\nGNDVCCWP8\n7651\n234\nFLASH MEMORY ARRAY\nPAGE (256/264 BYTES)\nBUFFER (256/264 BYTES)\nI/O INTERFACESCK\nCS\nRESET\nVCC\nGNDWP\nSO SI\n4\n3639E–DFLASH–5/08AT45DB011D4. Memory Array\nTo provide optimal flexibility, t he memory array of the AT45DB011D is divided into three levels of\ngranularity comprising of sectors, blocks, and pages. The “Memory Architecture Diagram” illus-\ntrates the breakdown of each level and details t he number of pages per sector and block. All\nprogram operations to the DataFlash occur on a page-by-page basis. The erase operations can\nbe performed at the chip, sector, block or page level.\nFigure 4-1. Memory Architecture Diagram\n5. Device Operation\nThe device operation is controlled by instructions from the host processor. The list of instructions\nand their associated opcodes are contained in Tables 15-1 through  15-7. A valid instruction\nstarts with the falling edge of CS  followed by the appropriate 8-bit opcode and the desired buffer\nor main memory address location. While the CS  pin is low, toggling the SCK pin controls the\nloading of the opcode and the desired buffer or main memory address location through the SI\n(serial input) pin. All instructions, addresses, and data are transferred with the most significant\nbit (MSB) first.\nBuffer addressing for the DataFlash standard page size (264 bytes) is referenced in the\ndatasheet using the terminology BFA8 - BFA0 to denote the 9 address bits required to designate\na byte address within a buffer. Main memory  addressing is referenced using the terminology\nPA8 - PA0 and BA8 - BA0, where PA8 - PA0 denotes the 9 address bits required to designate a\npage address and BA8 - BA0 denotes the 9 address bits required to designate a byte address\nwithin the page.\nFor the “Power of 2” binary page size (256 bytes), the Buffer addressing is referenced in the\ndatasheet using the conventional terminology BFA7 - BFA0 to denote the 8 address bits\nrequired to designate a byte address within a buffer. Main memory addressing is referencedusing the terminology A16 - A0, where A16 - A8 denotes the 9 address bits required to desig-\nnate a page address and A7 - A0 denotes the 8 address bits required to designate a byte\naddress within a page.SECTOR 0a = 8 Pages \n2,048/2,112 bytes \nSECTOR 0b = 120 Pages \n31,744/32,726 bytes \nBlock = 2,048/2,112 bytes 8 Pages SECTOR 0a \nSECTOR 0b \nPage = 256/264 bytes PAGE 0 \nPAGE 1 \nPAGE 6 \nPAGE 7 PAGE 8 PAGE 9 \nPAGE 510 \nPAGE 511 BLOCK 0 \nPAGE 14 PAGE 15 \nPAGE 16 PAGE 17 PAGE 18 \n BLOCK 1 SECTOR ARCHITECTURE BLOCK ARCHITECTURE PAGE ARCHITECTURE \nBLOCK 0 \nBLOCK 1 \nBLOCK 14\nBLOCK 15BLOCK 16BLOCK 17\nBLOCK 62 \nBLOCK 63 BLOCK 30BLOCK 31\nBLOCK 32BLOCK 33SECTOR 1 \nSECTOR 3 = 128 Pages \n32,768/33,792 bytes BLOCK 2 \nSECTOR 1 = 128 Pages \n32,768/33,792 bytes \n SECTOR 2 = 128 Pages \n32,768/33,792 bytes \n5\n3639E–DFLASH–5/08AT45DB011D\n6. Read Commands\nBy specifying the appropriate opcode, data can be read from the main memory or from the\nSRAM data buffer. The DataFlash supports RapidS protocols for Mode 0 and Mode 3. Please\nrefer to the “Detailed Bit-level Read Timing” diagrams in this datasheet for details on the clock\ncycle sequences for each mode.\n6.1 Continuous Array Read (Legac y Command – E8H): Up to 66 MHz\nBy supplying an initial starting address for the main memory array, the Continuous Array Read\ncommand can be utilized to sequentially read a continuous stream of data from the device by\nsimply providing a clock signal; no additional addressing information or control signals need tobe provided. The DataFlash incorporates an internal address counter that will automatically\nincrement on every clock cycle, allowing one continuous read operation without the need of\nadditional address sequences. To perform a cont inuous read from the DataFlash standard page\nsize (264 bytes), an opcode of E8H must be clocked into the device followed by three address\nbytes (which comprise the 24-bit page and byte address sequence) and 4 don’t care bytes. The\nfirst 9 bits (PA8 - PA0) of the 18-bit address sequence specify which page of the main memory\narray to read, and the last 9 bits (BA8 - BA0) of the 18-bit address sequence specify the starting\nbyte address within the page. To perform a continuous read from the binary page size (256\nbytes), the opcode (E8H) must be clocked into the device followed by three address bytes and 4\ndon’t care bytes. The first 9 bits (A16 - A8) of the 17-bits sequence specify which page of the\nmain memory array to read, and the last 8 bits (A7 - A0) of the 18-bits address sequence specify\nthe starting byte address within the page. The don’t care bytes that follow the address bytes areneeded to initialize the read operation. Following the don’t care bytes, additional clock pulses on\nthe SCK pin will result in data being output on the SO (s erial output) pin.\nThe CS\n pin must remain low during the loading of the opcode, the address bytes, the don’t care\nbytes, and the reading of data. When the end of a page in main memory is reached during a\nContinuous Array Read, the device will conti nue reading at the beginning of the next page with\nno delays incurred during the page boundary crossover (the crossover from the end of one pageto the beginning of the next page). When the last bit in the main memory array has been read,the device will continue reading ba ck at the beginning of the firs t page of memory. As with cross-\ning over page boundaries, no delays will be incu rred when wrappi ng around from the end of the\narray to the beginning of the array.\nA low-to-high transition on the CS\n pin will terminate t he read operati on and tri-st ate the output\npin (SO). The maximum SCK frequency allowable for the Continuous Array Read is defined by\nthe fCAR1 specification. The Continuous Array Read bypasses the data buffer and leaves the\ncontents of the buffer unchanged.\n6.2 Continuous Array Read (High Freq uency Mode – 0BH): Up to 66 MHz\nThis command can be used with the serial interface to read the main memory array sequentially\nin high speed mode for any clock frequency up to the maximum specified by fCAR1. To perform a\ncontinuous read array with the page size set to 264 bytes, the CS  must first be asserted then an\nopcode 0BH must be clocked into the device followed by three address bytes and a dummy\nbyte. The first 9 bits (PA8 - PA0) of the 18-bit address sequence specify which page of the mainmemory array to read, and the last 9 bits (BA8 - BA0) of the 18-bit address sequence specify the\nstarting byte address within the page. To perform a continuous read with the page size set to\n256 bytes, the opcode, 0BH, must be clocked in to the device followed by three address bytes\n(A16 - A0) and a dummy byte. Following the du mmy byte, additional clock pulses on the SCK\npin will result in data being out put on the SO (serial output) pin.\n6\n3639E–DFLASH–5/08AT45DB011DThe CS pin must remain low during the loading of the opcode, the address bytes, and the read-\ning of data. When the end of a page in the main  memory is reached during a Continuous Array\nRead, the device will continue reading at the be ginning of the next page with no delays incurred\nduring the page boundary crossover (the crossover from the end of one page to the beginning of\nthe next page). When the last bit in the main memory array has been read, the device will con-\ntinue reading back at the beginning of the fi rst page of memory. As with crossing over page\nboundaries, no delays will be incurred when wrapping around from the end of the array to thebeginning of the array. A low-to -high transition on the CS pin will term inate the r ead operation\nand tri-state the output pin (SO). The maxi mum SCK frequency allowable for the Continuous\nArray Read is defined by the f\nCAR1 specification. The Continuous Array Read bypasses the data\nbuffer and leaves the contents of the buffer unchanged.\n6.3 Continuous Array Read (Low Fr equency Mode: 03H): Up to 33 MHz\nThis command can be used with the serial interface to read the main memory array sequentially\nwithout a dummy byte up to maximum frequencies specified by fCAR2. To perform a continuous\nread array with the page size set to 264 bytes, the CS  must first be asserted then an opcode,\n03H, must be clocked into the device followed by  three address bytes (which comprise the 24-bit\npage and byte address sequence). The first 9 bits (PA8 - PA0) of the 18-bit address sequence\nspecify which page of the main memory array to read, and the last 9 bits (BA8 - BA0) of the\n18-bit address sequence specify the starting byte address within the page. To perform a contin-\nuous read with the page size set to 256 bytes, the opcode, 03H, must be clocked into the device\nfollowed by three address bytes (A16 - A0). Followi ng the address bytes, additional clock pulses\non the SCK pin will result in data bei ng output on the SO (serial output) pin.\nThe CS pin must remain low during the loading of the opcode, the address bytes, and the read-\ning of data. When the end of a page in the main  memory is reached during a Continuous Array\nRead, the device will continue reading at the be ginning of the next page with no delays incurred\nduring the page boundary crossover (the crossover from the end of one page to the beginning ofthe next page). When the last bit in the main memory array has been read, the device will con-\ntinue reading back at the beginning of the fi rst page of memory. As with crossing over page\nboundaries, no delays will be incurred when wrapping around from the end of the array to thebeginning of the array. A low-to -high transition on the CS pin will term inate the r ead operation\nand tri-state the output pin (SO). The Continuous Array Read bypasses the data buffer and\nleaves the contents of the buffer unchanged.\n6.4 Main Memory Page Read\nA main memory page read allows the user to read data directly from any one of the 2,048 pages\nin the main memory, bypassing the data buffer and leaving the contents of the buffer\nunchanged. To start a page read from the DataFlash standard page size (264 bytes), an opcodeof D2H must be clocked into the device followed by three address bytes (which comprise the\n24-bit page and byte address sequence) and 4 don’t care bytes. The first 9 bits (PA8 - PA0) of\nthe 18-bit address sequence specify the page in main memory to be read, and the last 9 bits(BA8 - BA0) of the 18-bit address sequence specify the starting byte address within that page.\nTo start a page read from the binary page size (256 bytes), the opcode D2H must be\nclocked into the device followed by three address bytes and 4 don’t care bytes. The first 9 bits(A16 - A8) of the 17-bit sequence specify which page of the main memory array to read, and thelast 8 bits (A7 - A0) of the 17-bit address sequenc e specify the starting byte address within the\npage. The don’t care bytes that follow the address bytes are sent to initialize the read operation.\nFollowing the don’t care bytes, additional pulses on SCK result in data being output on the SO(serial output) pin. The CS\n pin must remain low during the loading of the opcode, the address\nbytes, the don’t care bytes, and the reading of data. When the end of a page in main memory is\n7\n3639E–DFLASH–5/08AT45DB011D\nreached, the device will continue reading back at the beginni ng of the same pag e. A low-to-high\ntransition on the CS  pin will terminate the read operation and tri-state the output pin (SO). The\nmaximum SCK frequency allowable for the Main Memory Page Read is defined by the fSCK\nspecification. The Main Memory Page Read bypa sses the data buffer and leaves the contents of\nthe buffer unchanged.\n6.5 Buffer Read\nThe SRAM data buffer can be accessed independently from the main memory array, and utiliz-ing the Buffer Read Command allows data to be sequentially read directly from the buffer. Twoopcodes, D4H or D1H, can be used for the Buffer Read Command. The use of each opcode\ndepends on the maximum SCK frequency that will be used to read data from the buffer. The\nD4H opcode can be used at any SCK frequency up to the maximum specified by f\nCAR1. The D1H\nopcode can be used for lower frequency read operations up to the maximum specified by fCAR2.\nTo perform a buffer read from the DataFlash standard buffer (264 bytes), the opcode must be\nclocked into the device followed by three address bytes comprised of 15 don’t care bits and\n9 buffer address bits (BFA8 - BFA0). To perform a buffer read from the binary buffer (256 bytes),\nthe opcode must be clocked into the device followed by three address bytes comprised of16 don’t care bits and 8 buffer address bits (BFA7 - BFA0). Following the address bytes, one\ndon’t care byte must be clocked in to initialize the read operation. The CS\n pin must remain low\nduring the loading of the opcode, the address by tes, the don’t care bytes, and the reading of\ndata. When the end of a bu ffer is reached, the de vice will continue readi ng back at the beginning\nof the buffer. A low-to-high transition on the CS  pin will terminate the read  operation and tri-state\nthe output pin (SO).\n7. Program and Erase Commands\n7.1 Buffer Write\nData can be clocked in from the input pin (SI) into the buffer. To load data into the DataFlashstandard buffer (264 bytes), a 1-byte opcode, 84H, must be clocked into the device followed bythree address bytes comprised of 15 don’t care bits and 9 buffer address bits (BFA8 - BFA0).\nThe 9 buffer address bits specify the first byte in the buffer to be written. To load data into the\nbinary buffers (256 bytes each), a 1-byte opcode, 84H, must be clocked into the device followedby three address bytes comprised of 16 don’t care  bits and 8 buffer address bits (BFA7 - BFA0).\nThe 8 buffer address bits specify the first byte in the buffer to be written. After the last address\nbyte has been clocked into the device, data can then be clocked in on subsequent clock cycles.\nIf the end of the data buffer is  reached, the device w ill wrap around back to the beginning of the\nbuffer. Data will continue to be l oaded into the buffer until a low-to-high tran sition is detected on\nthe CS\n pin.\n7.2 Buffer to Main Memory Page Program with Built-in Erase\nData written into the buffer can be programmed into the main memory. A 1-byte opcode, 83H,\nmust be clocked into the device. For the DataFl ash standard page size (264 bytes), the opcode\nmust be followed by three address bytes consist of 5 don’t care bits, 9 page address bits\n(PA8 - PA0) that specify the page in the main memory to be written and 9 don’t care bits. To per-form a buffer to main memory page program with built-in erase for the binary page size (256\nbytes), the opcode 83H must be clocked into th e device followed by three address bytes consist-\ning of 7 don’t care bits, 9 page address bits (A16 - A8) that specify the page in the main memoryto be written and 8 don’t care bits. When a low-to-high transition occurs on the CS\n pin, the part\n8\n3639E–DFLASH–5/08AT45DB011Dwill first erase the selected page in main memory (the erased state is a logic 1) and then pro-\ngram the data stored in the buffer into the specified page in main memory. Both the erase and\nthe programming of the page are internally self-timed and should take place in a maximum time\nof tEP. During this time, the status regist er will indicate that the part is busy.\n7.3 Buffer to Main Memory Page Program without Built-in Erase\nA previously-erased page within main memory can be programmed with the contents of the\nbuffer. A 1-byte opcode, 88H, must be clocked into the device. For the DataFlash standard page\nsize (264 bytes), the opcode must be followed by three address bytes consist of 6 don’t care\nbits, 9 page address bits (PA8 - PA0) that specify the page in the main memory to be written and\n9 don’t care bits. To perform a buffer to main memory page program without built-in erase for the\nbinary page size (256 bytes), the opcode 88H mu st be clocked into the device followed by three\naddress bytes consisting of 7 don’t care bits, 9 page address bits (A16 - A8) that specify the\npage in the main memory to be written and 8 don’t care bits. When a low-to-high transition\noccurs on the CS  pin, the part will program the data stored in the buffer  into the specified page in\nthe main memory. It is necessary that the page in main memory that is being programmed has\nbeen previously erased using one of the er ase commands (Page Erase or Block Erase). The\nprogramming of the page is internally self-timed and should take place in a maximum time of tP.\nDuring this time, the status register will indicate that the part is busy.\n7.4 Page Erase\nThe Page Erase command can be used to individually erase any page in the main memory array\nallowing the Buffer to Main Memory Page Program to be utilized at a later time. To perform apage erase in the DataFlash standard page size (264 bytes), an opcode of 81H must be loaded\ninto the device, followed by three address bytes comprised of 6 don’t care bits, 9 page address\nbits (PA8 - PA0) that specify the page in the main memory to be erased and 9 don’t care bits. Toperform a page erase in the binary page size (256 bytes), the opcode 81H must be loaded into\nthe device, followed by three address bytes consist of 7 don’t care bits, 9 page address bits\n(A16 - A8) that specify the page in the main memory to be erased and 8 don’t care bits. When alow-to-high transition occurs on the CS\n pin, the part will erase the selected page (the erased\nstate is a logical 1). The erase operation is internally self-timed and should take place in a maxi-\nmum time of tPE. During this time, the status register will indicate that the part is busy.\n7.5 Block Erase\nA block of eight pages can be erased at one time. This command is useful when large amounts\nof data has to be written into  the device. This will avoid us ing multiple Page Erase Commands.\nTo perform a block erase for the DataFlash standard page size (264 bytes), an opcode of 50Hmust be loaded into the device, followed by thre e address bytes comprised of 6 don’t care bits,\n6 page address bits (PA8 -PA3) and 12 don’t care bits. The 6 page address bits are used to\nspecify which block of eight pages is to be eras ed. To perform a block erase for the binary page\nsize (256 bytes), the opcode 50H must be loaded into the device, followed by three address\nbytes consisting of 7 don’t care bits, 6 page addre ss bits (A16 - A11) and 11 don’t care bits. The\n6 page address bits are used to specify which bl ock of eight pages is to be erased. When a low-\nto-high transition occurs on the CS\n pin, the part will erase the se lected block of eight pages. The\nerase operation is internally self-timed and should take place in a maximum time of tBE. During\nthis time, the status register will indicate that the part is busy.\n9\n3639E–DFLASH–5/08AT45DB011D\n7.6 Sector Erase\nThe Sector Erase command can be used to individually erase any sector in the main memory.\nThere are 4 sectors and only one sector can be erased at one time. To perform sector 0a or sec-\ntor 0b erase for the DataFlash standard page size (264 bytes), an opcode of 7CH must be\nloaded into the device, followed by three address bytes comprised of 5 don’t care bits, 7 pageaddress bits (PA9 - PA3) and 12 don’t care bits. To perform a sector 1-3 erase, the opcode 7CH\nmust be loaded into the device, followed by three address bytes comprised of 6 don’t care bits, 2\npage address bits (PA8 - PA7) and 16 don’t care bits. To perform sector 0a or sector 0b erasefor the binary page size (256 bytes), an opcode of 7CH must be loaded into the device, followed\nby three address bytes comprised of 6 don’t care bits and 7 page address bits (A17 - A11) and\n11 don’t care bits. To perform a sector 1-3 erase, the opcode 7CH must be loaded into thedevice, followed by three address bytes comprised of 7 don’t care bit and 2 page address bits\n(A16 - A15) and 16 don’t care bits. The page address bits are used to specify any valid address\nlocation within the sector which is to be erased. When a low-to-high transition occurs on the CS\npin, the part will erase the sele cted sector. The erase operation is internally self-timed and\nshould take place in a maximum time of tSE. During this time, the status  register will indicate that\nthe part is busy.Table 7-1. Block Erase Addressing\nPA8/\nA16PA7/\nA15PA6/\nA14PA5/\nA13PA4/\nA12PA3/\nA11PA2/\nA10PA1/\nA9PA0/\nA8 Block\n000000XXX 0\n000001XXX 1000010XXX 2000011XXX 3\n\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\x7f\n\x7f\x7f\n111100XXX 6 0111101XXX 6 1111110XXX 6 2111111XXX 6 3\n10\n3639E–DFLASH–5/08AT45DB011D7.7 Chip Erase\nThe entire main memory can be erased at one time by using the Chip Erase command.\nTo execute the Chip Erase command, a 4-byte command sequence C7H, 94H, 80H and 9AH\nmust be clocked into the device. Since the entir e memory array is to be erased, no address\nbytes need to be clocked into the device, and any data clocked in after the opcode will be\nignored. After the last bit of the opcode sequence has been clocked in, the CS  pin can be deas-\nserted to start the erase process. The erase operation is internally self-timed and should take\nplace in a time of tCE. During this time, the Status Register will indicate that the device is busy.\nThe Chip Erase command w ill not affect sectors that are prot ected or locked down; the contents\nof those sectors will re main unchanged. Only those sectors that are not prot ected or locked\ndown will be erased.\nThe WP  pin can be asserted while the de vice is erasing, but protecti on will not be activated until\nthe internal erase cycle completes.\nFigure 7-1. Chip EraseTable 7-2. Sector Erase Addressing\nPA8/\nA16PA7/\nA15PA6/\nA14PA5/\nA13PA4/\nA12PA3/\nA11PA2/\nA10PA1/\nA9PA0/\nA8 Sector\n000000XXX 0 a000001XXX 0 b\n010000000 1\n10XXXXXXX 2\n11XXXXXXX 3\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nChip Erase C7H 94H 80H 9AH\nOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4CS\nEach transition\nrepre sents 8 bitsSI\n11\n3639E–DFLASH–5/08AT45DB011D\n7.8 Main Memory Page Program Through Buffer\nThis operation is a combination of the Buffer Write and Buffer to Main Memory Page Program\nwith Built-in Erase operations. Data is first clock ed into the buffer from the input pin (SI) and then\nprogrammed into a specified page in the main memory. To perform a main memory page pro-gram through buffer for the DataFlash standard page size (264 bytes), a 1-byte opcode, 82H,\nmust first be clocked into the device, followed by three address bytes. The address bytes are\ncomprised of 6 don’t care bits, 9 page address bits, (PA8 - PA0) that select the page in the mainmemory where data is to be written, and 9 buffer address bits (BFA8 - BFA0) that select the first\nbyte in the buffer to be written. To perform a main memory page program through buffer for the\nbinary page size (256 bytes), the opcode 82H mu st be clocked into the device followed by three\naddress bytes consisting of 7 don’t care bits, 9 page address bits (A16 - A8) that specify the\npage in the main memory to be written, and 8 buffer address bits (BFA7 - BFA0) that selects the\nfirst byte in the buffer to be wr itten. After all address  bytes are clocked in, the part will take data\nfrom the input pins and store it in the specified data buffer. If the end of the buffer is reached, the\ndevice will wrap around back to the beginning of the buffer. When there is a low-to-high transi-\ntion on the CS\n pin, the part will first erase the select ed page in main memory to all 1s and then\nprogram the data stored in the buffer into that memory page. Both the erase and the program-\nming of the page are internally self-timed and s hould take place in a maximum time of tEP.\nDuring this time, the status register will indicate that the part is busy.\n8. Sector Protection\nTwo protection methods, hardware and software co ntrolled, are provided for protection against\ninadvertent or erroneous program and erase cycles. The software controlled method relies on\nthe use of software commands to enable and disable sector protection while the hardware con-trolled method employs the use of the Write Protect (WP\n) pin. The selection of which sectors\nthat are to be protected or unprotected against program and erase operations is specified in the\nnonvolatile Sector Protection Register. The status  of whether or not sector protection has been\nenabled or disabled by either the software or the hardware controlled methods can be deter-\nmined by checking the Status Register.\n12\n3639E–DFLASH–5/08AT45DB011D8.1 Software Sector Protection\n8.1.1 Enable Sector Protection Command\nSectors specified for protection in the Sector Protection Register can be protected from program\nand erase operations by issuing the Enable Sector Protection command. To enable the sector\nprotection using the software controlled method, the CS  pin must first be asserted as it would be\nwith any other command. Once the CS  pin has been asserted, the appropriate 4-byte command\nsequence must be clocked in via the input pin (S I). After the last bit of the command sequence\nhas been clocked in, the CS  pin must be deasserted after which the sector protection will be\nenabled.\nFigure 8-1. Enable Sector Protection\n8.1.2 Disable Sector Protection Command\nTo disable the sector protection using the software controlled method, the CS  pin must first be\nasserted as it would be with any other command. Once the CS  pin has been asserted, the\nappropriate 4-byte sequence for the Disable Sector Protection command must be clocked in via\nthe input pin (SI). After the last bit of the command sequence has been clocked in, the CS  pin\nmust be deasserted after wh ich the sector protection  will be disabled. The WP  pin must be in the\ndeasserted state; otherwise,  the Disable Sector Protecti on command will be ignored.\nFigure 8-2. Disable Sector Protection\n8.1.3 Various Aspects About Software Controlled Protection\nSoftware controlled protection is useful in applications in which the WP  pin is not or cannot be\ncontrolled by a host processor. In such instances, the WP  pin may be left floating (the WP  pin is\ninternally pulled high) and sector protection can be controlled using the Enable Sector Protection\nand Disable Sector Protection commands.\nIf the device is power cycled, then the software controlled protection will be disabled. Once the\ndevice is powered up, the Enable Sector Protecti on command should be reissued if sector pro-\ntection is desired and if the WP  pin is not used.Command Byte 1 Byte 2 Byte 3 Byte 4\nEnable Sector Protection 3DH 2AH 7FH A9H\nOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4CS\nEach transitionrepresents 8 bitsSI\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nDisable Sector Protection 3DH 2AH 7FH 9AH\nOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4CS\nEach transitionrepresents 8 bitsSI\n13\n3639E–DFLASH–5/08AT45DB011D\n9. Hardware Controlled Protection\nSectors specified for protection in the Sector Protection Register and the Sector Protection Reg-\nister itself can be protected from program and erase operations by asserting the WP  pin and\nkeeping the pin in its asserted state. The Sector Protection Register and any sector specified forprotection cannot be erased or reprogrammed as long as the WP\n pin is asserted. In order to\nmodify the Sector Protection Register, the WP  pin must be deasserted. If the WP  pin is perma-\nnently connected to GND, then the content of the Sector Protection Register cannot be changed.If the WP\n pin is deasserted, or permanently connected to VCC, then the content of the Sector\nProtection Register can be modified.\nThe WP  pin will override the software controlled protection method but only for protecting the\nsectors. For example, if the sectors were not previously protected by the Enable Sector Protec-\ntion command, then simply asserting the WP  pin would enable the sector protection within the\nmaximum specified tWPE time. When the WP  pin is deasserted; however, the sector protection\nwould no longer be enabled (after the maximum specified tWPD time) as long as the Enable Sec-\ntor Protection command was not issued while the WP  pin was asserted. If the Enable Sector\nProtection command was issued before or while the WP  pin was asserted, then simply deassert-\ning the WP  pin would not disable the sector protec tion. In this case, the Disable Sector\nProtection command would need to be issued while the WP  pin is deasserted to disable the sec-\ntor protection. The Disable Sector Protecti on command is also ignored whenever the WP  pin is\nasserted.\nA noise filter is incorporated to help protect against spurious noise that may inadvertently assert\nor deassert the WP  pin.\nThe table below details the sector protection status for various scenarios of the WP  pin, the\nEnable Sector Protection command, and the Disable Sector Protection command. \nFigure 9-1. WP Pin and Protection Status\nWP12 3\nTable 9-1. WP Pin and Protection Status\nTime \nPeriod WP  PinEnable Sector Protection \nCommandDisable Sector \nProtection CommandSector Protection \nStatusSector \nProtection \nRegister\n1H i g hCommand Not Issued Previously\n–\nIssue CommandX\nIssue Command\n–Disabled\nDisabled\nEnabledRead/Write\nRead/Write\nRead/Write\n2 Low X X Enabled Read Only\n3H i g hCommand Issued During Period 1 \nor 2\n–\nIssue CommandNot Issued Y et\nIssue Command\n–Enabled\nDisabled\nEnabledRead/Write\nRead/WriteRead/Write\n14\n3639E–DFLASH–5/08AT45DB011D9.1 Sector Protection Register\nThe nonvolatile Sector Protection Register specifies which sectors are to be protected or unpro-\ntected with either the software or hardware controlled protection methods. The Sector Protection\nRegister contains 4 bytes of data, of which byte locations 0 through 3 contain values that specifywhether sectors 0 through 3 will be protected or unprote cted. The Sector Prot ection Register is\nuser modifiable and must first be erased before it can be reprogrammed. Table 9-3  illustrates the\nformat of the Sector Protection Register.\nNote: 1. The default value for bytes 0 through 3 when shipped from Atmel® is 00H.\nx = don’t care.Table 9-2. Sector Protection Register\nSector Number 0 (0a, 0b) 1 to 3\nProtected\nSee Table 9-3FFH\nUnprotected 00H\nTable 9-3. Sector 0 (0a, 0b)\n0a 0b\nBit 3, 2Data \nValue(Page 0-7)  (Page 8-127)\nBit 7, 6 Bit 5, 4 Bit 1, 0\nSectors 0a, 0b Unprotected 00 00 xx xx 0xH\nProtect Sector 0a 11 00 xx xx CxHProtect Sector 0b (Page 8-127) 00 11 xx xx 3xH\nProtect Sectors 0a (Page 0-7), 0b \n(Page 8-127)\n(1) 11 11 xx xx FxH\n15\n3639E–DFLASH–5/08AT45DB011D\n9.1.1 Erase Sector Protection Register Command\nIn order to modify and change the values of t he Sector Protection Register, it must first be\nerased using the Erase Sector Protection Register command. \nTo erase the Sector Protection Register, the CS  pin must first be asserted as it would be with\nany other command. Once the CS  pin has been asserted, the appropriate 4-byte opcode\nsequence must be clocked into the device via the SI pin. The 4-byte opcode sequence muststart with 3DH and be followed by 2AH, 7FH, and CFH. After the last bit of the opcode sequence\nhas been clocked in, the CS\n pin must be deasserted to initiate the internally self-timed erase\ncycle. The erasing of the Sector Protection Re gister should take place in a time of tPE, during\nwhich time the Status Register will indicate that the device is busy. If the device is powered-\ndown before the completion of the erase cycle, then the contents of the Sector Protection Regis-\nter cannot be guaranteed.\nThe Sector Protection Register can be erased with the sector protection enabled or disabled.\nSince the erased state (FFH) of each byte in the Sector Protection Register is used to indicate\nthat a sector is specified for protection, leaving the sector protection enabled during the erasingof the register allows the protection scheme to be more effective in the prevention of accidental\nprogramming or erasing of the device. If for some reason an erroneous program or erase com-\nmand is sent to the device imm ediately after erasing the Sector Protection Register and before\nthe register can be reprogrammed, then the erroneous program or erase command will not be\nprocessed because all sectors would be protected.\nFigure 9-2. Erase Sector Protection RegisterCommand Byte 1 Byte 2 Byte 3 Byte 4\nErase Sector Protection Register 3DH 2AH 7FH CFH\nOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4CS\nEach transitionrepresents 8 bitsSI\n16\n3639E–DFLASH–5/08AT45DB011D9.1.2 Program Sector Protection Register Command\nOnce the Sector Protection Register has been erased, it can be reprogrammed using the\nProgram Sector Protection Register command. \nTo program the Sector Protection Register, the CS  pin must first be asserted and the appropri-\nate 4-byte opcode sequence must be clocked into the device via the SI pin. The 4-byte opcode\nsequence must start with 3DH and be followed by 2AH, 7FH, and FCH. After the last bit of theopcode sequence has been clocked into the device, the data for the contents of the Sector Pro-\ntection Register must be clocked in. As described in Section 9.1 , the Sector Protection Register\ncontains 4 bytes of data, so 4 bytes must be clo cked into the device. The first byte of data corre-\nsponds to sector 0, the second byte corresponds to sector 1, the third byte corresponds to sector\n2, and the last byte of data corresponding to sector 3.\nAfter the last data byte has been clocked in, the CS\n pin must be deasserted to initiate the inter-\nnally self-timed program cycle. The programming of  the Sector Protection Register should take\nplace in a time of tP, during which time the Status  Register will indicate that the device is busy. If\nthe device is powered-down during the program cycle, then the contents of the Sector ProtectionRegister cannot be guaranteed.\nIf the proper number of data bytes is not clocked in before the CS\n pin is deasserted, then the\nprotection status of the sectors corresponding to the bytes not clocked in can not be guaranteed.For example, if only the first two bytes are clocked in instead of the complete 4 bytes, then the\nprotection status of the last 2 sectors cannot be guaranteed. Furthermore, if more than 4 bytes\nof data is clocked into the device, then the data will wrap back around to the beginning of theregister. For instance, if 5 byte s of data are clocked in, then the 5th byte will be stored at byte\nlocation 0 of the Sector Protection Register.\nIf a value other than 00H or FFH is clocked into a byte location of the Sector Protection Register,\nthen the protection status of the sector corresponding to that byte location cannot be guaran-\nteed. For example, if a value of 17H is clocked into byte location 2 of the Sector Protection\nRegister, then the protection status of sector 2 cannot be guaranteed.\nThe Sector Protection Register can be reprogrammed while the sector protection enabled or dis-\nabled. Being able to reprogram the Sector Protection Register with the sector protection enabled\nallows the user to temporarily disable the sector protection to an individual sector rather thandisabling sector protection completely.\nThe Program Sector Protection Register command utilizes the internal SRAM buffer for\nprocessing. Therefore, the contents of the buffer will be altere d from its previous  state when this\ncommand is issued.\nFigure 9-3. Program Sector Protection RegisterCommand Byte 1 Byte 2 Byte 3 Byte 4\nProgram Sector Protection Register 3DH 2AH 7FH FCH\nData Byte\nnOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4Data Byte\nn + 1Data Byte\nn + 3CS\nEach transitionrepresents 8 bitsSI\n17\n3639E–DFLASH–5/08AT45DB011D\n9.1.3 Read Sector Protection Register Command\nTo read the Sector Protection Register, the CS  pin must first be asserted. Once the CS  pin has\nbeen asserted, an opcode of 32H and 3 dummy bytes must be clocked in via the SI pin. After thelast bit of the opcode and dummy bytes have been clocked in, any additional clock pulses on the\nSCK pins will result in data for the content of the Sect or Protection Register  being output on the\nSO pin. The first byte corresponds to sector 0 (0a, 0b), the second byte corresponds to sector 1,the third byte corresponds to sector 2, and the last byte (byte 4) corresponds to sector 3. Once\nthe last byte of the Sector Protection Register  has been clocked out, any additional clock pulses\nwill result in undefined data being output on the SO pin. The CS \nmust be deasserted to termi-\nnate the Read Sector Protection Register operation and put the output into a high-impedance\nstate.\nNote: xx = Dummy Byte\nFigure 9-4. Read Sector Protection Register\n9.1.4 Various Aspects About the Sector Protection Register\nThe Sector Protection Register is subject to a limit of 10,000 erase/program cycles. Users are\nencouraged to carefully evaluate the number of ti mes the Sector Protection Register will be\nmodified during the course of the applications’ life cycle. If the application requires that the Sec-\ntor Protection Register be modified more than the specified limit of 10,000 cycles because the\napplication needs to temporarily unprotect indivi dual sectors (sector protection remains enabled\nwhile the Sector Protection Regist er is reprogrammed), th en the application w ill need to limit this\npractice. Instead, a combination of temporarily unprotecting individual sectors along with dis-\nabling sector protection completely will need to be implement ed by the applicatio n to ensure that\nthe limit of 10,000 cycles is not exceeded.Command Byte 1 Byte 2 Byte 3 Byte 4\nRead Sector Protection Register 32H xxH xxH xxH\nOpcode X X X\nData Byte\nnData Byte\nn + 1CS\nData Byte\nn + 3SI\nSO\nEach transition\nrepresents 8 bits\n18\n3639E–DFLASH–5/08AT45DB011D10. Security Features\n10.1 Sector Lockdown\nThe device incorporates a Sector Lockdown mechanism that allows each individual sector to be\npermanently locked so that it becomes read only. This is useful for applications that require theability to permanently prot ect a number of sectors against malic ious attempts at altering program\ncode or security information. Once a sector is locked down, it can never be erased or pro-\ngrammed, and it can never be unlocked.\nTo issue the Sector Lockdown command, the CS\n pin must first be asserted as it would be for\nany other command. Once the CS  pin has been asserted, the appropriate 4-byte opcode\nsequence must be clocked into the device in  the correct order. The 4-byte opcode sequence\nmust start with 3DH and be followed by 2AH, 7FH, and 30H. After the last byte of the command\nsequence has been clocked in, then three address bytes specifying any address within the sec-\ntor to be locked down must be clocked into the device. After the last address bit has beenclocked in, the CS\n pin must then be deasserted to initiate the internally self-timed lockdown\nsequence.\nThe lockdown sequence should take place in a maximum time of tP, during which time the Status\nRegister will indicate that the device is busy.  If the device is powered-down before the comple-\ntion of the lockdown sequence, then the lockdown status of the sector cannot be guaranteed. In\nthis case, it is recommended that the user read the Sector Lockdown Register to determine thestatus of the appropriate sector lockdown bits or bytes and reissue the Sector Lockdown com-\nmand if necessary.\nFigure 10-1. Sector LockdownCommand Byte 1 Byte 2 Byte 3 Byte 4\nSector Lockdown 3DH 2AH 7FH 30H\nOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4CS\nAddress\nBytesAddress\nBytesAddress\nBytes\nEach transition\nrepresents 8 bitsSI\n19\n3639E–DFLASH–5/08AT45DB011D\n10.1.1 Sector Lockdown Register\nSector Lockdown Register is a nonvolatile register that contains 4 bytes of data, as shown\nbelow:\n10.1.2 Reading the Sector Lockdown Register\nThe Sector Lockdown Register can be read to determine which sectors in the memory array are\npermanently locked down. To read the Sector Lockdown Register, the CS  pin must first be\nasserted. Once the CS  pin has been asserted, an opcode of 35H and 3 dummy bytes must be\nclocked into the device via the SI pin. After the last bit of the opcode and dummy bytes have\nbeen clocked in, the data for the contents of the Sector Lockdown Register will be clocked out\non the SO pin. The first byte corresponds to sector 0 (0a, 0b) the second byte corresponds tosector 1 and the last byte (byte 4) corresponds to sector 3. After the last byte of the Sector Lock-\ndown Register has been read, additional pulses on the SCK pin will simp ly result in undefined\ndata being output on the SO pin.\nDeasserting the CS\n pin will terminate the Read Sector Lo ckdown Register operation and put the\nSO pin into a high-impedance state.\nTable 10-2  details the values read from the Sector Lockdown Register.\nFigure 10-2. Read Sector Lockdown RegisterSector Number 0 (0a, 0b) 1 to 3\nLocked\nSee BelowFFH\nUnlocked 00H\nTable 10-1. Sector 0 (0a, 0b)\n0a 0b\nBit 3, 2Data \nValue(Page 0-7)  (Page 8-127)\nBit 7, 6 Bit 5, 4 Bit 1, 0\nSectors 0a, 0b Unlocked 00 00 00 00 00H\nSector 0a Locked (Page 0-7) 11 00 00 00 C0H\nSector 0b Locked (Page 8-127) 00 11 00 00 30HSectors 0a, 0b Locked (Page 0-127) 11 11 00 00 F0H\nTable 10-2. Sector Lockdown Register\nCommand Byte 1 Byte 2 Byte 3 Byte 4\nRead Sector Lockdown Register 35H xxH xxH xxH\nNote: xx = Dummy Byte\nOpcode X X X\nData Byte\nnData Byte\nn + 1CS\nData Byte\nn + 3SI\nSO\nEach transition\nrepresents 8 bits\n20\n3639E–DFLASH–5/08AT45DB011D10.2 Security Register\nThe device contains a specialized Security R egister that can be used for purposes such as\nunique device serialization or locked key storage.  The register is comprised of a total of\n128 bytes that is divided into two portions. The first 64 bytes (byte locations 0 through 63) of theSecurity Register are allocated as a one-time user programmable space. Once these 64 bytes\nhave been programmed, they cannot be reprogrammed. The remaining 64 bytes of the register\n(byte locations 64 through 127) are factory programmed by Atmel and will contain a uniquevalue for each device. The factory programmed data is fixed and cannot be changed.\n10.2.1 Programming the Security Register\nThe user programmable portion of the Security Register does not need to be erased before it is\nprogrammed. \nTo program the Security Register, the CS\n pin must first be asserted and the appropriate 4-byte\nopcode sequence must be clocked into the device in the correct order. The 4-byte opcode\nsequence must start with 9BH and be followed by 00H, 00H, and 00H. After the last bit of the\nopcode sequence has been clocked into the device, the data for the contents of the 64-byte user\nprogrammable portion of the Security Register must be clocked in.\nAfter the last data byte has been clocked in, the CS  pin must be deasserted to initiate the inter-\nnally self-timed program cycle. The programming of the Security Register should take place in a\ntime of tP, during which time the Status Register will in dicate that the device is busy. If the device\nis powered-down during the program cycle, then the contents of the 64-byte user programmable\nportion of the Security Register cannot be guaranteed.\nIf the full 64 bytes of data is not clocked in before the CS  pin is deasserted, then the values of\nthe byte locations not clocked in cannot be guaranteed. For example, if only the first two bytesare clocked in instead of the complete 64 bytes, then the remaining 62 bytes of the user pro-\ngrammable portion of the Security Register cannot be guaranteed. Furthermore, if more than\n64 bytes of data is clocked into the device, th en the data will wrap back around to the beginning\nof the register. For instance, if 65  bytes of data are clocked in, t hen the 65th byte will be stored at\nbyte location 0 of the Security Register.\nThe user programmable portion of the Security Register can only be programmed one\ntime. Therefore, it is not possible to only program the first two bytes of the register and then pro-\ngram the remaining 62 bytes at a later time.\nThe Program Security Register command utilizes  the internal SRAM buffer for processing.\nTherefore, the contents of the buffer will be altered from its previous state when this command is\nissued.\nFigure 10-3. Program Security RegisterTable 10-3. Security Register\nSecurity Register Byte Number\n01 • • • 62 63 64 65 • • • 126 127\nData Type One-time User Programmable Factory Programmed By Atmel\nData Byte\nnOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4Data Byte\nn + 1Data Byte\nn + xCS\nEach transitionrepresents 8 bitsSI\n21\n3639E–DFLASH–5/08AT45DB011D\n10.2.2 Reading the Security Register\nThe Security Register can be read by first asserting the CS  pin and then clocking in an opcode\nof 77H followed by three dummy bytes. After the la st don’t care bit has been clocked in, the con-\ntent of the Security Register can be clocked out on the SO pins. After the last byte of the\nSecurity Register has been read , additional pulses on the SCK pin will simply result in undefined\ndata being output on the SO pins.\nDeasserting the CS  pin will terminate the Read Security Register operation and put the SO pins\ninto a high-impedance state.\nFigure 10-4. Read Security Register\n11. Additional Commands\n11.1 Main Memory Page to Buffer Transfer\nA page of data can be transferred from the main memory to the buffer. To start the operation for\nthe DataFlash standard page size (264 bytes), a 1- byte opcode, 53H, must be clocked into the\ndevice, followed by three address bytes comp rised of 6 don’t care bits, 9 page address bits\n(PA8 - PA0), which specify the page in main memory that is to be transferred, and 9 don’t carebits. To perform a main memory page to buffer transfer for the binary page size (256 bytes), the\nopcode 53H must be clocked into the device foll owed by three address bytes consisting of 7\ndon’t care bits, 9 page address bits (A16 - A8) which specify the page in the main memory that isto be transferred, and 8 don’t care bits. The CS\n pin must be low while toggling the SCK pin to\nload the opcode and the address bytes from the input pin (SI). The transfer of the page of data\nfrom the main memory to the buffer will begin when the CS  pin transitions from a low to a high\nstate. During the transfer of a page of data (tXFR), the status register can be read to determine\nwhether the transfer has been completed.\n11.2 Main Memory Page to Buffer Compare\nA page of data in main memory can be compared to the data in the buffer. To initiate the opera-tion for the DataFlash standard page size, a 1-byte opcode, 60H, must be clocked into thedevice, followed by three address bytes consisting of 6 don’t care bits, 9 page address bits\n(PA8 - PA0) that specify the page in the main memory that is to be compared to the buffer, and\n9 don’t care bits. To start a main memory page to buffer compare for a binary page size, theopcode 60H must be clocked into the device foll owed by three address bytes consisting of 6\ndon’t care bits, 9 page address bits (A16 - A8) that specify the page in the main memory that is\nto be compared to the buffer, and 8 don’t care bits. The CS\n pin must be low while toggling the\nSCK pin to load the opcode and the address bytes from the input pin (SI). On the low-to-high\ntransition of the CS  pin, the data bytes in the selected main memory page will be compared withOpcode X X X\nData Byte\nnData Byte\nn + 1CS\nData Byte\nn + x\nEach transition\nrepresents 8 bitsSI\nSO\n22\n3639E–DFLASH–5/08AT45DB011Dthe data bytes in the buffer. During this time (tCOMP ), the status register w ill indicate that the part\nis busy. On completion of the compare operation, bit 6 of the status register is updated with the\nresult of the compare.\n11.3 Auto Page Rewrite\nThis mode is only needed if multiple bytes within a page or multiple pages of data are modified in\na random fashion within a sector. This mode is a combination of two operations: Main Memory\nPage to Buffer Transfer and Buffer to Main Memory Page Program with Built-in Erase. A page of\ndata is first transferred from the main memory to the buffer and then the same data (from thebuffer) is programmed back into its original page of main memory. To start the rewrite operation\nfor the DataFlash standard page size (264 bytes), a 1-byte opcode, 58H, must be clocked into\nthe device, followed by three address bytes comprised of 6 don’t care bits, 9 page address bits(PA8 - PA0) that specify the page in main memory to be rewritten and 9 don’t care bits. To ini-\ntiate an auto page rewrite for a binary page size (256 bytes), the opcode 58H must be clocked\ninto the device followed by three address bytes consisting of 7 don’t care bits, 9 page addressbits (A16 - A8) that specify the page in the main memory that is to be written and 8 don’t care\nbits. When a low-to-high transition occurs on the CS\n pin, the part will first transfer data  from the\npage in main memory to a buffer and then program the data from the buffer back into same pageof main memory. The operation is internally self-timed and should take place in a maximum time\nof t\nEP. During this time, the status regist er will indicate that the part is busy.\nIf a sector is programmed or reprogrammed sequentially page by page, then the programming\nalgorithm shown in Figure 25-1  (page 45 ) is recommended. Otherwise,  if multiple bytes in a\npage or several pages are programmed randomly in a sector, then the programming algorithm\nshown in Figure 25-2  (page 46 ) is recommended. Each page within a sector must be\nupdated/rewritten at least once within every 10,000 cumulative page erase/program operations\nin that sector.\n11.4 Status Register Read\nThe status register can be used to determine th e device’s ready/busy status, page size, a Main\nMemory Page to Buffer Compare operation result, the Sector Protection status or the device\ndensity. The Status Register can be read at any  time, including during an internally self-timed\nprogram or erase operation. To read the status register, the CS  pin must be asserted and the\nopcode of D7H must be loaded into the device. Af ter the opcode is clocked in, the 1-byte status\nregister will be clocked out on th e output pin (SO), starting with the next clock cycle. The data in\nthe status register, starting with  the MSB (bit 7), will be clock ed out on the SO pi n during the next\neight clock cycles. After the one byte of the st atus register has been clocked out, the sequence\nwill repeat itself (as long as CS  remains low and SCK is being toggled). The data in the status\nregister is constantly updated, so each repeating sequence will output new data.\nReady/busy status is indicated using bit 7 of the st atus register. If bit 7 is a 1, then the device is\nnot busy and is ready to accept the next command. If bit 7 is a 0, then the device is in a busy\nstate. Since the data in the status register is constantly updated, the user must toggle SCK pin to\ncheck the ready/busy status. There are several operations that can cause the device to be in abusy state: Main Memory Page to Buffer Transfer, Main Memory Page to Buffer Compare,\nBuffer to Main Memory Page Program, Main Memory Page Program through Buffer, Page\nErase, Block Erase, Sector Erase, Chip Erase and Auto Page Rewrite.\nThe result of the most recent Main Memory Page to Buffer Compare operation is indicated using\nbit 6 of the status register. If bit 6 is a 0, then the data in the main memory page matches the\n23\n3639E–DFLASH–5/08AT45DB011D\ndata in the buffer. If bit 6 is a 1, then at least one bit of the data in the main memory page does\nnot match the data in the buffer.\nBit 1 in the Status Register is used to provide information to the user whether or not the sector\nprotection has been enabled or disabled, either by software-controlled method or hardware-con-trolled method. A logic 1 indicates that sector protection has been enabled and logic 0 indicates\nthat sector protection has been disabled.\nBit 0 in the Status Register indicates whether the page size of the main memory array is config-\nured for “power of 2” binary page size (256 bytes) or the DataFlash standard page size\n(264 bytes). If bit 0 is a 1, then the page size is set to 256 bytes. If bit 0 is a 0, then the page size\nis set to 264 bytes.\nThe device density is indicated using bits 5, 4, 3, and 2 of the status register. For the\nAT45DB011D, the four bits are 0011 The decimal va lue of these four binary bits does not equate\nto the device density; the four bits represent a combinational code relating to differing densities\nof DataFlash devices. The device density is not the same as the density code indicated in the\nJEDEC device ID information. The device densit y is provided only for backward compatibility.  \nTable 11-1. Status Register Format\nBit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0\nRDY/BUSY COMP 0 0 1 1 PROTECT PAGE SIZE\n24\n3639E–DFLASH–5/08AT45DB011D12. Deep Power-down\nAfter initial power-up, the device will default in standby mode. The Deep Po wer-down command\nallows the device to enter into the lowest power consumption mode. To enter the Deep Power-\ndown mode, the CS  pin must first be asserted. Once the CS  pin has been asserted, an opcode\nof B9H command must be clocked in via input pi n (SI). After the last bit of the command has\nbeen clocked in, the CS  pin must be de-asserted to initiate the Deep Power-down operation.\nAfter the CS  pin is de-asserted, the will device ente r the Deep Power-down mode within the\nmaximum tEDPD time. Once the device has entered the Deep Power-down mode, all instructions\nare ignored except for the Resume from Deep Power-down command.\nFigure 12-1. Deep Power-down\n12.1 Resume from Deep Power-down\nThe Resume from Deep Power-down command takes the device out of the Deep Power-down\nmode and returns it to the normal standby mode. To Resume from Deep Power-down mode, the\nCS pin must first be asserted and an opcode of ABH command must be clocked in via input pin\n(SI). After the last bit of the command has been clocked in, the CS  pin must be de-asserted to\nterminate the Deep Power-down mode. After the CS  pin is de-asserted, the device will return to\nthe normal standby mode within the maximum tRDPD time. The CS  pin must remain high during\nthe tRDPD time before the device can receive any commands. After resuming form Deep Power-\ndown, the device w ill return to the normal standby mode.\nFigure 12-2. Resume from Deep Power-DownCommand Opcode\nDeep Power-down B9H\nOpcodeCS\nEach transition\nrepresents 8 bitsSI\nCommand Opcode\nResume from Deep Power-down ABH\nOpcodeCS\nEach transition\nrepresents 8 bitsSI\n25\n3639E–DFLASH–5/08AT45DB011D\n13. “Power of 2” Binary Page Size Option\n“Power of 2” binary page size Configuration Regi ster is a user-programmable nonvolatile regis-\nter that allows the page size of the main memory to be configured for binary page size(256 bytes) or the DataFlash standard page size (264 bytes). The “power of 2” page size is a\nOne-time Programmable (OTP)  register and once the device is configured for “power of\n2” page size, it cannot be reconfigured again.  The devices are initially shipped with the page\nsize set to 264 bytes. The user has the optio n of ordering binary page size (256 bytes) devices\nfrom the factory. For details, please refer to Section 26. ”Ordering Information” on page 47 .\nFor  the binary “power of 2” page size to become effective, the following steps must be followed:\n1. Program the one-time programmable configuration resister using opcode sequence \n3DH, 2AH, 80H and A6H (please see Section 13.1 ).\n2. Power cycle the device (i.e. power down and power up again).3. The page for the binary page size can now be programmed.\nIf the above steps are not followed to set the page size prior to page programming, incorrect\ndata during a read operation may be encountered.\n13.1 Programming the Configuration Register\nTo program the Configuration Register for “power of 2” binary page size, the CS  pin must first be\nasserted as it would be with any other command. Once the CS  pin has been asserted, the\nappropriate 4-byte opcode sequence must be clocked into the device in the correct order. The\n4-byte opcode sequence must start with 3DH and be followed by 2AH, 80H, and A6H. After the\nlast bit of the opcode sequence has been clocked in, the CS  pin must be deasserted to initiate\nthe internally self-timed prog ram cycle. The pr ogramming of the Config uration Register should\ntake place in a time of tP, during which time the Status Regist er will indicate that the device is\nbusy. The device must be powe r-cycled after the comp letion of the program cycle to set the\n“power of 2” page size. If the device is powered-down before the completion of the program\ncycle, then setting the Configuration Register cannot be guaranteed. However, the user should\ncheck bit 0 of the status register to see w hether the page size was configured for binary page\nsize. If not, the command can be re-issued again.\nFigure 13-1. Erase Sector Protection Register\n14. Manufacturer an d Device ID Read\nIdentification information can be read from the dev ice to enable systems to electronically query\nand identify the device while it is in system. The identification method and the command opcode\ncomply with the JEDEC standard for “Manufacturer and Device ID Read Methodology for SPI\nCompatible Serial Interface Memory Devices”. The type of information that can be read from thedevice includes the JEDEC defined Manufacturer ID, the vendor specific Device ID, and the ven-\ndor specific Extended Device Information.Command Byte 1 Byte 2 Byte 3 Byte 4\nPower of Two Page Size 3DH 2AH 80H A6H\nOpcode\nByte 1Opcode\nByte 2Opcode\nByte 3Opcode\nByte 4CS\nEach transitionrepresents 8 bitsSI\n26\n3639E–DFLASH–5/08AT45DB011DTo read the identification information, the CS  pin must first be asserted and the opcode of 9FH\nmust be clocked into the device. After the opc ode has been clocked in, the device will begin out-\nputting the identification data on the SO pin during the subsequent cloc k cycles. The first byte\nthat will be output will be the Manufacturer ID followed by two bytes of Device ID information.The fourth byte ou tput will be the Extended Device Inform ation String Length, which will be 00H\nindicating that no Extended Device  Information follows. As indi cated in the JEDEC standard,\nreading the Extended Device Information String Length and any subsequent data is optional.\nDeasserting the CS\n pin will terminate the Manufacturer and Device ID Read operation and put\nthe SO pin into a high-impedance state. The CS  pin can be deasserted at any time and does not\nrequire that a full byte of data be read.\n14.1 Manufacturer and Device ID Information    \nNote: Based on JEDEC publication 106 (JEP106), Manufacturer ID data ca n be comprised of any number of bytes. Some manufacturers may have\nManufacturer ID codes that are two, three or even four byte s long with the first byte(s) in the sequence being 7FH. A system sh ould detect code\n7FH as a “Continuation Code” and continue to read Manufacturer ID bytes. The first non-7FH byte would signify the last byte of Manufacturer ID\ndata. For Atmel (and some other manufacturers), the Manufacturer ID data is comprised of only one byte.14.1.1 Byte 1 – Manufacturer ID\nHex \nValueJEDEC Assigned Code\nBit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0\n1FH 0 0 0 1 1 1 1 1 Manufacturer ID 1FH = Atmel\n14.1.2 Byte 2 – Device ID (Part 1)\nHex \nValueFamily Code Density Code\nBit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Family Code 001 = DataFlash\n24H 0 0 1 0 0 0 1 0 Density Code 00010 = 1-Mbit\n14.1.3 Byte 3 – Device ID (Part 2)\nHex \nValueMLC Code Product Version Code\nBit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 MLC Code 000 = 1-bit/Cell Technology\n00H 0 0 0 0 0 0 0 0 Product Version 00000 = Initial Version\n14.1.4 Byte 4 – Extended Device Information String Length\nHex \nValueByte Count\nBit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0\n00H 0 0 0 0 0 0 0 0 Byte Count 00H = 0 Bytes of Information\n9FH\nManufacturer ID\nByte nDevice ID\nByte 1Device ID\nByte 2\nThis information would only be output \nif the Extended Device Information String Length \nvalue was something other than 00H.Extended\nDevice \nInformation\nString LengthExtended\nDevice \nInformation\nByte xExtended\nDevice \nInformation\nByte x + 1CS\n1FH 22H 00H 00H Data DataSI\nSOOpcode\nEach transition\nrepresents 8 bits\n27\n3639E–DFLASH–5/08AT45DB011D\n14.2 Operation M ode Summary\nThe commands described previously can be grouped into four different categories to better\ndescribe which commands can be executed at what times.\nGroup A commands consist of:\n1. Main Memory Page Read\n2. Continuous Array Read3. Read Sector Protection Register4. Read Sector Lockdown Register5. Read Security Register\nGroup B commands consist of:\n1. Page Erase\n2. Block Erase3. Sector Erase4. Chip Erase5. Main Memory Page to Buffer Transfer6. Main Memory Page to Buffer Compare7. Buffer to Main Memory Page Program with Built-in Erase8. Buffer to Main Memory Page Program without Built-in Erase9. Main Memory Page Program through Buffer10. Auto Page Rewrite\nGroup C commands consist of:\n1. Buffer Read\n2. Buffer Write3. Status Register Read4. Manufacturer and Device ID Read\nGroup D commands consist of:\n1. Erase Sector Protection Register\n2. Program Sector Protection Register3. Sector Lockdown4. Program Security Register\nIf a Group A command is in progress (not fully completed), then another command in Group A,\nB, C, or D should not be started. However, during the internally self-timed portion of Group B\ncommands 1 through 4, any command in Group C can be executed. During the internally self-timed portion of Group B commands 5 through 10, only Group C commands 3 and 4 can be exe-\ncuted. Finally, during the internally self-timed portion of a Group D command, only the Status\nRegister Read command should be executed.\n28\n3639E–DFLASH–5/08AT45DB011D15. Command Tables\n Table 15-1. Read Commands\nCommand Opcode\nMain Memory Page Read D2H\nContinuous Array Read (Legacy Command) E8HContinuous Array Read (Low Frequency) 03HContinuous Array Read (High Frequency) 0BHBuffer Read (Low Frequency) D1HBuffer Read D4H\nTable 15-2. Program and Erase Commands\nCommand Opcode\nBuffer Write 84H\nBuffer to Main Memory Page Program with Built-in Erase 83HBuffer to Main Memory Page Program without Built-in Erase 88HPage Erase 81H\nBlock Erase 50H\nSector Erase 7CH\nChip Erase 7CH, 94H, 80H, 9AHMain Memory Page Program through Buffer 82H\n29\n3639E–DFLASH–5/08AT45DB011D\nNote: 1. These legacy commands are not recommended for new designs.Table 15-3. Protection and Security Commands\nCommand Opcode\nEnable Sector Protection 3DH + 2AH + 7FH + A9H\nDisable Sector Protection 3DH + 2AH + 7FH + 9AH\nErase Sector Protection Register 3DH + 2AH + 7FH + CFH\nProgram Sector Protection Register 3DH + 2AH + 7FH + FCHRead Sector Protection Register 32HSector Lockdown 3DH + 2AH + 7FH + 30H\nRead Sector Lockdown Register 35H\nProgram Security Register 9BH + 00H + 00H + 00HRead Security Register 77H\nTable 15-4. Additional Commands\nCommand Opcode\nMain Memory Page to Buffer Transfer 53H\nMain Memory Page to Buffer Compare 60HAuto Page Rewrite through Buffer 58HDeep Power-down B9HResume from Deep Power-down ABHStatus Register Read D7HManufacturer and Device ID Read 9FH\nTable 15-5. Legacy Commands(1)\nCommand Opcode\nBuffer Read 54H\nMain Memory Page Read 52HContinuous Array Read 68HStatus Register Read 57H\n30\n3639E–DFLASH–5/08AT45DB011DNote: x = Don’t CareTable 15-6. Detailed Bit-level Addressing Sequence for Binary Page Size (256 Bytes)\nPage Size = 256 bytes Address Byte Address Byte Address Byte\nAdditional \nDon’t Care \nBytes Opcode Opcode\nReserved\nReservedReserved\nReserved\nReservedReservedReserved\nA16\nA15\nA14\nA13\nA12A11A10\nA9\nA8\nA7\nA6\nA5\nA4A3A2\nA1\nA0 0 3 h 00000011 xxx xxxxAA A AAAAA AAAAAAAA A N/A\n0 B h 00001011 xxx xxxxAA A AAAAA AAAAAAAA A 1\n5 0 h 01010000 xxx xxxxAA A A Axxx xxxxxxxx x N/A\n5 3 h 01010011 xxx xxxxAA A AAAAA A x x xxxxx x N/A\n5 8 h 01011000 xxx xxxxAA A AAAAA A x x xxxxx x N/A\n6 0 h 01100000 xxx xxxxAA A AAAAA A x x xxxxx x N/A\n7 7 h 01110111 xxx xxxxxxxxxxxx xxxxxxxx x N/A\n7 C h 01111100 xxx xxxxxxxxxxxx xxxxxxxx x N/A\n8 1 h 10000001 xxx xxxxAA A AAAAA A x x xxxxx x N/A\n8 2 h 10000010 xxx xxxxAA A AAAAA AAAAAAAA A N/A\n8 3 h 10000011 xxx xxxxAA A AAAAA A x x xxxxx x N/A\n8 4 h 10000100 xxx xxxxxxxxxxxx xA AAAAAA A N/A\n8 8 h 10001000 xxx xxxxAA A AAAAA A x x xxxxx x N/A\n9 F h 10011111 N / A N / A N / A N/A\nB 9 h 10111001 N / A N / A N / A N/A\nA B h 10101011 N / A N / A N / A N/A\nD 1 h 11010001 xxx xxxxxxxxxxxx xA AAAAAA A N/A\nD 2 h 11010010 xxx xxxxAA A AAAAA AAAAAAAA A 4 \nD 4 h 11010100 xxx xxxxxxxxxxxx xA AAAAAA A 1\nD 7 h 11010111 N / A N / A N / A N/A\nE 8 h 11101000 xxx xxxxAA A AAAAA AAAAAAAA A 4\n31\n3639E–DFLASH–5/08AT45DB011D\nNote: P = Page Address Bit\nB = Byte/Buffer Address Bitx = Don’t CareTable 15-7. Detailed Bit-level Addressing Sequence for Standard DataFlash Page Size (264 Bytes)\nPage Size = 264 bytes Address Byte Address Byte Address Byte\nAdditional \nDon’t Care \nBytes Opcode Opcode\nReserved\nReserved\nReserved\nReservedReserved\nReserved\nPA8\nPA7\nPA6\nPA5\nPA4\nPA3\nPA2\nPA1\nBA0\nBA8\nBA7\nBA6\nBA5BA4\nBA3\nBA2\nBA1\nBA0\n0 3 h 00000011 xxxxxxPPPP PPP PPBBB BB BB BB N/A\n0 B h 0000101 1 x x x x x xPPPPPPPPPBBBBBBBB B 1\n5 0 h 01010000xxxxxxPPP P Pxxxxxxxxxxxx x N/A\n5 3 h 01010011xxxxxxPPP P P P P P Pxxxxxxxx x N/A\n5 8 h 01011000xxxxxxPPP P P P P P Pxxxxxxxx x N/A\n6 0 h 01100000xxxxxxPPP P P P P P Pxxxxxxxx x N/A\n7 7 h 01110111xxxxxxxxxxxxxxxxxxxxxxx x N/A\n7 C h 01111100xxxxxxxxxxxxxxxxxxxxxxx x N/A\n8 1 h 10000001xxxxxxPPP P P P P P Pxxxxxxxx x N/A\n8 2 h 10000010 xxxxxxPPPP PPP PPBBB BB BB BB N/A\n8 3 h 10000011xxxxxxPPP P P P P P Pxxxxxxxx x N/A\n8 4 h 10000100xxxxxxxxxxxxxxxBB B B B B B BB N/A\n8 8 h 10001000xxxxxxPPP P P P P P Pxxxxxxxx x N/A\n9 F h 10011111 N / A N / A N / A N/A\nB 9 h 10111001 N / A N / A N / A N/A\nA B h 10101011 N / A N / A N / A N/A\nD 1 h 11010001xxxxxxxxxxxxxxxBB B B B B B BB N/A\nD 2 h 1101001 0 x x x x x xPPPPPPPPPBBBBBBBB B 4\nD 4 h 11010100xxxxxxxxxxxxxxxBB B B B B B BB 1\nD 7 h 11010111 N / A N / A N / A N/A\nE 8 h 1110100 0 x x x x x xPPPPPPPPPBBBBBBBB B 4\n32\n3639E–DFLASH–5/08AT45DB011D16. Power-on/Reset State\nWhen power is first applied to the device, or when recovering from a reset condition, the device\nwill default to Mode 3. In addition, the output pin (SO) will be in a high impedance state, and a\nhigh-to-low transition on the CS  pin will be required to start a va lid instruction. The mode (Mode\n3 or Mode 0) will be automatically  selected on every falling edge of CS  by sampling the inactive\nclock state. \n16.1 Initial Power-up/Reset Timing Restrictions\nAt power up, the device must not be selected until the supply voltage reaches the VCC (min.) and\nfurther delay of tVCSL. During power-up, the internal Power-on Reset circuitry keeps the device in\nreset mode until the VCC rises above the Power-on Reset threshold value (VPOR). At this time, all\noperations are disabled and the device does not respond to any commands. After power up isapplied and the V\nCC is at the minimum operating voltage VCC (min.), the tVCSL delay is required\nbefore the device can be selected in order to perform a read operation. \nSimilarly, the tPUW delay is required after the VCC rises above the Power-on Reset threshold\nvalue (VPOR) before the device can perform a write (Program or Erase) operation. After initial\npower-up, the device will default in Standby mode.\n17. System Considerations\nThe RapidS serial interface is controlled by the clock SCK, serial input SI and chip select CS\npins. These signals must rise and fall monotonica lly and be free from noise. Excessive noise or\nringing on these pins can be mi sinterpreted as multiple edges and cause improper operation of\nthe device. The PC board traces must be kept  to a minimum distance or appropriately termi-\nnated to ensure proper operation. If necessary, decoupling capacitors can be added on thesepins to provide filtering against noise glitches. \nAs system complexity continues to increase, voltage regulation is becoming more important. A\nkey element of any voltage regulation scheme is its current sourcing capability. Like all Flash\nmemories, the peak current for DataFlash occur during the programming and erase operation.The regulator needs to supply this peak current requirement. An under specified regulator can\ncause current starvation. Besides increasing sy stem noise, current starvation during program-\nming or erase can lead to improper operation and possible data corruption.Symbol Parameter Min Typ Max Units\ntVCSL VCC (min.) to Chip Select low 1 ms\ntPUW Power-Up Device Delay before Write Allowed 20 ms\nVPOR Power-On Reset Voltage 1.5 2.5 V\n33\n3639E–DFLASH–5/08AT45DB011D\n18. Electrical Specifications\nNotes: 1. ICC1 during a buffer read is 20 mA maximum @ 20 MHz.\n2. All inputs are 5 volts tolerant.Table 18-1. Absolute Maximum Ratings*\nTemperature under Bias .... ........... ............ .... -55 °C to +125 °C *NOTICE: Stresses beyond those listed under “Absolute \nMaximum Ratings” may cause permanent dam-\nage to the device. This is a stress rating only and functional operation of the device at these or any \nother conditions beyond those indicated in the \noperational sections of t his specification is not \nimplied. Exposure to absolute maximum rating \nconditions for extended periods may affect device reliability.Storage Temperature .................................... -65 °C to +150 °C\nAll Input Voltages (including NC Pins)\nwith Respect to Ground .............. .....................-0.6V to +6.25V\nAll Output Voltages\nwith Respect to Ground .............................-0.6V to V\nCC + 0.6V\nTable 18-2. DC and AC Operating Range\nAT45DB011D\nOperating Temperature (Case) Ind. -40 °C to 85 °C\nVCC Power Supply 2.7V to 3.6V\nTable 18-3. DC Characteristics\nSymbol Parameter Condition Min Typ Max Units\nIDP Deep Power-down Current CS, RESET , WP  = VIH, all \ninputs at CMOS levels51 5 µ A\nISB Standby CurrentCS, RESET , WP  = VIH, all \ninputs at CMOS levels25 50 µA\nICC1(1)Active Current, Read Operationf = 20 MHz; IOUT = 0 mA; \nVCC = 3.6V71 0 m A\nf = 33 MHz; IOUT = 0 mA; \nVCC = 3.6V81 2 m A\nf = 50 MHz; IOUT = 0 mA; \nVCC = 3.6V10 14 mA\nf = 66 MHz; IOUT = 0 mA; \nVCC = 3.6V15 25 mA\nICC2Active Current, Program/Erase \nOperationVCC = 3.6V 12 20 mA\nILI Input Load Current VIN = CMOS levels 1 µA\nILO Output Leakage Current VI/O = CMOS levels 1 µA\nVIL Input Low Voltage VCC x 0.3 V\nVIH Input High Voltage VCC x 0.7 V\nVOL Output Low Voltage IOL = 1.6 mA; VCC = 2.7V 0.4 V\nVOH Output High Voltage IOH = -100 µA VCC - 0.2V V\n34\n3639E–DFLASH–5/08AT45DB011DTable 18-4. AC Characteristics – RapidS/Serial Interface\nSymbol Parameter Min Typ Max Units\nfSCK SCK Frequency 66 MHz\nfCAR1 SCK Frequency for Continuous Array Read 66 MHz\nfCAR2 SCK Frequency for Continuous Array Read (Low Frequency) 33 MHz\ntWH SCK High Time 6.8 ns\ntWL SCK Low Time 6.8 ns\ntSCKR(1)SCK Rise Time, Peak-to-Peak (Slew Rate) 0.1 V/ns\ntSCKF(1)SCK Fall Time, Peak-to-Peak (Slew Rate) 0.1 V/ns\ntCS Minimum CS  High Time 50 ns\ntCSS CS Setup Time 5 ns\ntCSH CS Hold Time 5 ns\ntSU Data In Setup Time 2 ns\ntH Data In Hold Time 3 ns\ntHO Output Hold Time 0 ns\ntDIS Output Disable Time 6n s\ntV Output Valid 6n s\ntWPE WP Low to Protection Enabled 1 µs\ntWPD WP High to Protection Disabled 1 µs\ntEDPD CS High to Deep Power-down Mode 3 µs\ntRDPD CS High to Standby Mode 35 µs\ntXFR Page to Buffer Transfer Time 200 µs\ntcomp Page to Buffer Compare Time 200 µs\ntEP Page Erase and Programming Time (256/264 bytes) 14 35 ms\ntP Page Programming Time (256/264 bytes) 2 4 ms\ntPE Page Erase Time (256/264 bytes) 13 32 ms\ntBE Block Erase Time (2,048/2,112 bytes) 18 35 ms\ntSE Sector Erase Time (32,768/33,792 bytes) 0.8 2.5 s\ntCE Chip Erase Time 1.8 3 s\ntRST RESET  Pulse Width 10 µs\ntREC RESET  Recovery Time 1µ s\n35\n3639E–DFLASH–5/08AT45DB011D\n19. Input Test Waveforms and Measurement Levels\ntR, tF < 2 ns (10% to 90%)\n20. Output Test Load\n21. AC Waveforms\nSix different timing waveforms are shown on page 36 . Waveform 1 shows the SCK signal being\nlow when CS  makes a high-to-low transition, and waveform 2 shows the SCK signal being high\nwhen CS  makes a high-to-low transition. In both cases, output SO becomes valid while the\nSCK signal is still low (SCK lo w time is specified as tWL). Timing waveforms 1 and 2 conform to\nRapidS serial interface but for frequencies up to 66 MHz. Waveforms 1 and 2 are compatible\nwith SPI Mode 0 and SPI Mode 3, respectively.\nWaveform 3 and waveform 4 illustra te general timing diagram for R apidS serial interface. These\nare similar to waveform 1 and waveform 2, except that output SO is not restricted to become\nvalid during the tWL period. These timing waveforms are valid over the full frequency range (max-\nimum frequency = 66 MHz) of the RapidS serial case. AC\nDRIVING\nLEVELSAC\nMEASUREME NT\nLEVEL0.45V1.5V2.4V\nDEVICE\nUNDER\nTEST\n30 pF\n36\n3639E–DFLASH–5/08AT45DB011D21.1 Waveform 1 – SPI Mode 0 Compatib le (for Frequencies up to 66 MHz)\n21.2 Waveform 2 – SPI Mode 3 Compatib le (for Frequencies up to 66 MHz)\n21.3 Waveform 3 – RapidS Mode 0 (FMAX = 66 MHz)\n21.4 Waveform 4 – RapidS Mode 3 (FMAX = 66 MHz)CS\nSCK\nSISOtCSS\nVALID INtH tSUtWH tWL tCSHtCS\ntV\nHIGH IMPEDANCEVALID OUTtHO tDIS\nHIGH IMPEDANCE\nCS\nSCK\nSOtCSS\nVALID INtH tSUtWL tWH tCSHtCS\ntV\nHIGH ZVALID OUTtHO tDIS\nHIGH IMPEDANCE\nSI\nCS\nSCK\nSISOtCSS\nVALID INtH tSUtWH tWL tCSHtCS\ntV\nHIGH IMPEDANCE\nVALID OUTtHO tDIS\nHIGH IMPEDANCE\nCS\nSCK\nSOtCSS\nVALID INtH tSUtWL tWH tCSHtCS\ntV\nHIGH ZVALID OUTtHO tDIS\nHIGH IMPEDANCE\nSI\n37\n3639E–DFLASH–5/08AT45DB011D\n21.5 Utilizing the RapidS Function\nTo take advantage of the RapidS function\'s abili ty to operate at higher clock frequencies, a full\nclock cycle must be used to transmit data back and forth across the serial bus. The DataFlash is\ndesigned to always clock its data  out on the falling edge of the SCK signal and clock data in on\nthe rising edge of SCK.\nFor full clock cycle operation to  be achieved, when the DataFlas h is clocking data out on the\nfalling edge of SCK, the host contro ller should wait until the next falling edge of SCK to latch the\ndata in. Similarly, the host controller should cl ock its data out on the rising edge of SCK in\norder to give the DataFlash a full clock cycle to latch the incoming data in on the next rising edge\nof SCK.\nFigure 21-1. RapidS Mode\nSCK\nMOSIMISO1\n23456781\n2345678\nMOSI = Master Out, Slave In\nMISO = Master In, Slave OutThe Master is the host controller and the Slave is the DataFlash\nThe Master always clocks data out on the rising edge of SCK and always clocks data in on the falling edge of SCK.\nThe Slave always clocks data out on the falling edge of SCK and always clocks data in on the rising edge of SCK.\nA. Master clocks out first bit of BYTE-MOSI on the rising edge of SCK.\nB. Slave clocks in first bit of BYTE-MOSI on the next rising edge of SCK.C. Master clocks out second bit of BYTE-MOSI on the same rising edge of SCK.D. Last bit of BYTE-MOSI is clocked out from the Master.E. Last bit of BYTE-MOSI is clocked into the slave.F . Slave clocks out first bit of BYTE-SO.G. Master clocks in first bit of BYTE-SO.H. Slave clocks out second bit of BYTE-SO.I. Master clocks in last bit of BYTE-SO.AB\nCDE\nFG1\nH BYTE-MOSIMSB LSB\nBYTE-SOMSB LSBSlave  CS\nI\n38\n3639E–DFLASH–5/08AT45DB011D21.6 Reset Timing\nNote: The CS  signal should be in the high state before the RESET  signal is deasserted.\n21.7 Command Sequence for Read/Write Operations  for Page Size 256 Bytes (Except Status \nRegister Read, Manufactur er and Device ID Read)\n21.8 Command Sequence for Read/Write Operations  for Page Size 264 Bytes (Except Status \nRegister Read, Manufactur er and Device ID Read)CS\nSCK\nRESET\nSO (OUTPUT)HIGH IMPEDANCE HIGH IMPEDANCE\nSI (INPUT)tRSTtREC tCSS\nSI (INPUT) CMD 8 bits 8 bits 8 bits\nPage Address\n(A16 - A8)X X X X X X X   X  X X X X X X X X LSB X X X X X X X X\nByte/Buffer Address\n(A7 - A0/BFA7 - BFA0)MSB\n7 Don’t Care \nBits\nPage Address\n(PA8 - PA0)Byte/Buffer Address\n(BA8 - BA0/BFA8 - BFA0)SI (INPUT) CMD 8 bits 8 bits 8 bits\nX X X X X X X X X X X   X LSB X X X X X X X X MSB\n6 Don’t Care \nBitsX X X X\n39\n3639E–DFLASH–5/08AT45DB011D\n22. Write Operations\nThe following block diagram a nd waveforms illustrate  the various write sequences available.\n22.1 Buffer Write\n22.2 Buffer to Main Memory Page Program (Dat a from Buffer Programm ed into Flash Page)FLASH MEMORY ARRAY\nPAGE (256/264 BYTES)\nBUFFER (256/264 BYTES)\nI/O INTERFACE\nSIBUFFER TO\nMAIN MEMORY\nPAGE PROGRAM\nBUFFER\nWRITE\nSI (INPUT)CMDCompletes writing into the buffer\nCS\nX X···X, BFA8 BFA7-0 n n+1 Last ByteBINARY PAGE SIZE\n16 DON\'T CARE + BFA7-BFA0\nSI (INPUT) CMD PA8-7 PA6-0, XCSStarts self-timed erase/program operation\nXXXX XX\nEach transition \nrepresents 8 bitsn = 1st byte read\nn+1 = 2nd byte readBINARY PAGE SIZE\nA16-A8 + 8 DON\'T CARE BITS\n40\n3639E–DFLASH–5/08AT45DB011D23. Read Operations\nThe following block diagram a nd waveforms illustrate  the various read sequences available.\n23.1 Main Memory Page Read\n23.2 Main Memory Page to Buffer Transfer (Data from Flash Page Read into Buffer)FLASH MEMORY ARRAY\nPAGE (256/264 BYTES)\nBUFFER (256/264 BYTES)\nI/O INTERFACEMAIN MEMORY\nPAGE TO\nBUFFER\nMAIN MEMORY\nPAGE READBUFFER\nREAD\nSO\nSI (INPUT) CMD PA8-7 PA6-0, BA8 XCS\nn n+1 SO (OUTPUT)BA7-0\n4 Dummy BytesXADDRESS FOR BINARY PAGE SIZE\nA16 A15-A8 A7-A0\nStarts reading page data into buffer\nSI (INPUT) CMD X···X, PA8-7 PA6-0, XCS\nSO (OUTPUT)XXXX XXXXBINARY PAGE SIZE\n7 DON’T CARE BITS + A16-A8 + 8 DON\'T CARE BITS\n41\n3639E–DFLASH–5/08AT45DB011D\n23.3 Buffer Read\n24. Detailed Bit-level Read Waveform – Ra pidS Serial Interface Mode 0/Mode 3\n24.1 Continuous Array Read (Legacy Opcode E8H)\n24.2 Continuous Array Read (Opcode 0BH)CMDCS\nn n+1X X1 Dummy Byte\nX..X, BFA 8 BFA7- 0BINARY PAGE SIZE\n16 DON\'T CARE + BFA7-BFA0\nEach transition\nrepre sents 8 bitsSI (INPUT)\nSO (OUTPUT)\nSCKCS\nSI\nSOMSBM SB23 10\n1110100067541 0 1 1 98 12 6 3 66 676564 62 33 3 4 3132 29306 8 71 727069\nOPCODE\nAAAA AAA AA\nMSBXXXX XX\nMSBM SBDDDDDDDDDDADDRE SS BITS3 2 DON\'T CARE BIT S\nDATA BYTE 1\nHIGH-IMPEDANCE\nBIT 2047/2111\nOF PAGE nBIT 0  OF\nPAGE n+1\nSCKCS\nSI\nSOMSB MSB2310\n0000101167541 0 1 1 981 2 3 9 4 2 4 3 4140 38 33 34 31 32 29 30 44 47 48 4645\nOPCODE\nAAAA AAA AA\nMSBXXXX XX\nMSB MSBDDDDDDDDDDADDRESS BITS A16 - A0 DON\'T CARE\nDATA BYTE 1\nHIGH-IMPEDANCE36 3735\nXX\n42\n3639E–DFLASH–5/08AT45DB011D24.3 Continuous Array Read (Low Frequency: Opcode 03H)\n24.4 Main Memory Page Read (Opcode: D2H)\n24.5 Buffer Read (Opcode D4H)SCKCS\nSI\nSOMSB MSB2310\n0000001167541 0 1 1 981 2 3 7 3 8 33 36 3534 31 32 29 30 39 40\nOPCODE\nAAAA AAA AA\nMSB MSBDDDDDDDDDDADDRESS BITS A16-A0\nDATA BYTE 1\nHIGH-IMPEDANCE\nSCKCS\nSI\nSOMSB MSB2310\n1101001067541 0 1 1 981 2 6 3 6 6 6 7 6564 62 33 34 31 32 29 30 68 71 72 7069\nOPCODE\nAAAA AAA AA\nMSBXXXX XX\nMSB MSBDDDDDDDDDDADDRESS BITS 32 DON\'T CARE BITS\nDATA BYTE 1\nHIGH-IMPEDANCE\nSCKCS\nSI\nSOMSBM SB23 10\n1101010067541 0 1 1 98 12 394 2 4 3 4140 3738 33 3 6 35 34 3132 29304 4 4 7 4 8 4645\nOPCODE\nXXXX AAA XX\nMSBXXXXXXXX\nMSBM SBDDDDDDDDDDADDRE SS BITS\nBINARY PAGE SIZE = 16 DON\'T CARE + BFA7-BFA0\nSTANDARD DATAFLA SH PAGE SIZE = \n15 DON\'T CARE + BFA 8-BFA0DON\'T CARE\nDATA BYTE 1\nHIGH-IMPEDANCE\n43\n3639E–DFLASH–5/08AT45DB011D\n24.6 Buffer Read (Low Fr equency: Opcode D1H)\n24.7 Read Sector Protecti on Register (Opcode 32H)\n24.8 Read Sector Lockdown Register (Opcode 35H)SCKCS\nSI\nSOMSBM SB23 10\n1101000167541 0 1 1 98 12 3738 33 3 6 35 34 3132 2930 394 0\nOPCODE\nXXXX AAA XX\nMSBM SBDDDDDDDDDDDATA BYTE 1\nHIGH-IMPEDANCEADDRE SS BITS\nBINARY PAGE SIZE = 16 DON\'T CARE + BFA7-BFA0\nSTANDARD DATAFLA SH PAGE SIZE = \n15 DON\'T CARE + BFA 8-BFA0\nSCKCS\nSI\nSOMSB MSB2310\n0011001067541 0 1 1 981 2 3 7 3 8 33 36 3534 31 32 29 30 39 40\nOPCODE\nXXXX XXX XX\nMSB MSBDDDDDDDDDDON\'T CARE\nDATA BYTE 1\nHIGH-IMPEDANCE\nSCKCS\nSI\nSOMSB MSB2310\n0011010167541 0 1 1 981 2 3 7 3 8 33 36 3534 31 32 29 30 39 40\nOPCODE\nXXXX XXX XX\nMSB MSBDDDDDDDDDDON\'T CARE\nDATA BYTE 1\nHIGH-IMPEDANCE\n44\n3639E–DFLASH–5/08AT45DB011D24.9 Read Security Re gister (Opcode 77H)\n24.10 Status Register Read (Opcode D7H)\n24.11 Manufacturer and Device Read (Opcode 9FH)SCKCS\nSI\nSOMSB MSB2310\n0111011167541 0 1 1 981 2 3 7 3 8 33 36 3534 31 32 29 30 39 40\nOPCODE\nXXXX XXX XX\nMSB MSBDDDDDDDDDDON\'T CARE\nDATA BYTE 1\nHIGH-IMPEDANCE\nSCKCS\nSI\nSOMSB23 10\n1101011167541 0 1 1 98 12 21 22 17 20 1918 15 16 1314 2 324\nOPCODE\nMSB MSBDDDDDD DDDD\nMSBDDDDDDDDSTATU S REGI STER DATA STATU S REGI STER DATA\nHIGH-IMPEDANCE\nSCKCS\nSI\nSO6 0\n9FH87 38\nOPCODE\n1FH DEVICE ID BYTE 1 DEVICE ID BYTE 2 00HHIGH-IMPEDANCE14 1615 22 2423 30 3231\nNote:  Each transition shown for SI and SO represents one byte (8 bits)\n45\n3639E–DFLASH–5/08AT45DB011D\n25. Auto Page Rewrite Flowchart\nFigure 25-1. Algorithm for Programming or Reprogramming of the Entire Array Sequentially\nNotes: 1. This type of algorithm is used for applications in whic h the entire array is programmed sequentially, filling the array  page-by-\npage.\n2. A page can be written using either a Main Memory Page Prog ram operation or a Buffer Write operation followed by a Buffer \nto Main Memory Page Program operation.\n3. The algorithm above shows the programming of a single page. The algorithm will be repeated sequentially for each page \nwithin the entire array.START\nMAIN MEMORY PAGE PROGRAM\nTHROUGH BUFFER\n(82H)\nENDprovide address\nand data\nBUFFER WRITE\n(84H)\nBUFFER TO MAIN\nMEMORY PAGE PROGRAM\n(83H)\n46\n3639E–DFLASH–5/08AT45DB011DFigure 25-2. Algorithm for Randomly Modifying Data\nNotes: 1. To preserve data integrity, each page of a DataFlash se ctor must be updated/rewritten at least once within every 10,000  \ncumulative page erase and program operations.\n2. A Page Address Pointer must be maintained to indicate whic h page is to be rewritten. The Auto Page Rewrite command \nmust use the address specified by the Page Address Pointer.\n3. Other algorithms can be used to rewrite portions of the Flas h array. Low-power applications may choose to wait until 10,000 \ncumulative page erase and program operations have accumulated before rewriting all pages of the sector. See application \nnote AN-4 (“Using Atmel’s Serial DataFlash”) for more details.START\nMAIN MEMORY PAGE\nTO BUFFER TRANSFER\n(53H)\nINCREMENT PAGE\nADDRESS POINTER(2)AUTO PAGE REWRITE(2)\n(58H)\nENDprovide address of\npage to modify\nIf planning to modify multiplebytes currently stored withina page of the Flash array\nMAIN MEMORY PAGE PROGRAM\nTHROUGH BUFFER\n(82H)BUFFER WRITE\n(84H)\nBUFFER TO MAIN\nMEMORY PAGE PROGRAM\n(83H)\n47\n3639E–DFLASH–5/08AT45DB011D\n26. Ordering Information\n26.1 Ordering Code Detail\nNotes: 1. The shipping carrier option is not marked on the devices.\n2. Standard parts are shipped with the page size set to 264 bytes. Th e user is able to configure these parts to a 256-byte page \nsize if desired.\n3. Parts ordered with suffix SL954 are shipped in bulk with t he page size set to 256 bytes.  Parts will have a 954 or SL954 \nmarked on them.\n4. Parts ordered with suffix SL955 are shipped in tape and reel with the page size set to 256 bytes.  Parts will have a 954 or \nSL954 marked on them.AT45D 01 SSHB 1D– – B\nAtmel De signator\nProduct Family\nDevice Den sity\n01 = 1-meg abit\nInterface\n1 = SerialPacka ge Option\nSS = 8-lead, 0.150" wide SOIC\nS = 8-lead, 0.20 8" wide SOIC\nM = 8-pad, 5 x 6 x 0.6 mm UDFNDevice Grade\nH = NiPdA u lead finish, ind ustrial\n  temper ature range (-40°C to + 85°C)Shippin g Carrier Option\nB = B ulk (tubes)\nY = Tr ays\nT = T ape and reel\nDevice Revi sion\n26.2 Green Package Options (Pb/Halide-free/RoHS Compliant)\nOrdering Code(1)(2)Package Lead Finish Operating Voltage fSCK (MHz) Operation Range\nAT45DB011D-MH-Y\nAT45DB011D-MH-T\nAT45DB011D-MH-SL954(3)\nAT45DB011D-MH-SL955(4)8MA1\nNiPdAu 2.7V to 3.6V 66Industrial\n(-40°C to +85°C)AT45DB011D-SSH-B\nAT45DB011D-SSH-T\nAT45DB011D-SSH-SL954(3)\nAT45DB011D-SSH-SL955(4)8S1\nAT45DB011D-SH-B\nAT45DB011D-SH-T\nAT45DB011D-SH-SL954(3)\nAT45DB011D-SH-SL955(4)8S2\nPackage Type\n8MA1 8-pad, 5 x 6 x 0.6 mm, Thermally Enhanced Ul tra Thin Dual Flat No Lead Package (UDFN)\n8S1 8-lead, 0.150” Wide, Plastic Gull Wing Small Outline Package (JEDEC SOIC)\n8S2 8-lead, 0.208” Wide, Plastic Gull Wing Small Outline Package (EIAJ SOIC)\n48\n3639E–DFLASH–5/08AT45DB011D27. Packaging Information\n27.1 8MA1 – UDFN\nTITLE DRAWING NO. GPC REV.\n   Packa ge Drawin g Contact:\n packagedrawings@atmel.com 8MA1 YFG D8MA1, 8-pad (5 x 6 x 0.6 mm Body), Therm ally \nEnhanced Pl astic Ultr a Thin D ual Flat No Le ad\nPackage (UDFN)COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\n A 0.45 0.55 0.60  \n A1 0.00 0.02 0.05  \n b 0. 35 0.40 0.4 8\n C  0.152 REF  D 4.90 5.00 5.10 D2 3.80 4.00 4.20\n E 5.90 6.00 6.10 E2 3.20 3.40 3.60\n e  1.27 L 0.50 0.60 0.75 y 0.00 – 0.0 8\n K 0.20 – –\n4/15/0 8Pin 1 ID\nTOP VIEWE\nD\nA1\nASIDE VIEW\nyC\nBOTTOM VIEWE2\nD2\nLbe1\n2\n3\n48\n7\n6\n5Pin #1 Notch\n(0.20 R)0.45K\nPin #1 \nChamfer\n(C 0. 35)Option A\n(Option B)\n49\n3639E–DFLASH–5/08AT45DB011D\n27.2 8S1 – JEDEC SOIC\n1150 E. Cheyenne Mtn. Blvd.\nColor ado Spring s, CO  80906TITLE DRAWING NO.\nRREV.  Note:\n3/17/05\n8S1, 8-lead (0.150" Wide Body), Pl astic Gull Wing \nSmall Outline (JEDEC SOIC)8S1CCOMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\n A1 0.10 – 0.25  \n These drawings are for gener al inform ation only. Refer to JEDEC Dr awing M S-012, V ariation AA for proper dimen sions, toler ances, datums, etc.ØØEE11\nNN\nTOP VIEWCC\nE1E1\nEND VIEW\nAAbbLL\nA1A1ee\nDD\nSIDE VIEW\n50\n3639E–DFLASH–5/08AT45DB011D27.3 8S2 – EIAJ SOIC\nTITLE DRAWING NO.     GPC REV.\n   Packa ge Drawin g Contact:\n packagedrawings@atmel.com 8S2 STN F8S2, 8-lead, 0.20 8” Body, Pl astic Small\nOutline P ackage (EIAJ)4/15/0 8COMMON DIMEN SIONS\n(Unit of Me asure = mm)\nSYMBOL MIN NOM MAX NOTE\nNotes: 1. Thi s drawing i s for gener al inform ation only; refer to EIAJ Dr awing EDR-7 320 for addition al inform ation.\n 2. Mi smatch of the upper and lower die s and re sin burrs aren\'t incl uded.\n 3. Determine s the tr ue geometric po sition.\n 4. V alues b,C apply to pl ated termin al.  The standard thickne ss of the pl ating layer shall measure between 0.007 to .021 mm.A 1.70  2.16 \nA1 0.05  0.25 b 0. 35  0.4 8  4\nC 0.15  0. 35  4\nD 5.1 3  5. 35 \nE1 5.1 8  5.40  2\nE 7.70  8.26 \nL 0.51  0. 85 \nθ   0°   8°\ne            1.27 B SC   3θθ11\nNNEE\nTOP VIEWTOP VIEWCC\nE1E1\nEND VIEWEND VIEW\nAAbbLL\nA1A1ee\nDD\nSIDE VIEWSIDE VIEW\n51\n3639E–DFLASH–5/08AT45DB011D\n28. Revision History\nRevision Level – Release Date History\nA – June 2006 Initial Release\nB – February 2007 Removed RDY/BUSY  pin references.\nC – November 2007Fixed the typographical error in the Block Architecture diagram.\nChanged tVCSL time to 1 ms.\nChanged IDP (Max) to 15 µA.\nAdded Chip Erase time.Changed t\nRDPD time to 35 µs.\nChanged the tXFR and tCOMP  times from 400 µs to 200 µs.\nChanged part number ordering code to reflect NiPdAu lead finish.\n-  Changed AT45DB011D-SSU to AT45DB011D-SSH.\n- Changed AT45DB011D-SU to AT45DB011D-SH.\n- Changed AT45DB011D-MU to AT45DB011D-MH.\nAdded lead finish details to Ordering Information table.\nAdded Ordering Code Detail.\nD – March 2008Changed ICC1 (Typ) and ICC1 (Max), for f = 66 MHz, to 15 mA and 25 \nmA, respectively.\nChanged ICC2 (Max) to 20 mA.\nChanged tBE (Typ) to 18 ms.\nChanged 8M1-A MLF package to 8MA1 UDFN package.\nE – May 2008 Added part number ordering code details for suffixes SL954/955.\n3639E–DFLASH–5/08Headquarters International\nAtmel Corporation\n2325 Orchard Parkway\nSan Jose, CA 95131\nUSATel: 1(408) 441-0311\nFax: 1(408) 487-2600Atmel Asia\nRoom 1219\nChinachem Golden Plaza\n77 Mody Road TsimshatsuiEast Kowloon\nHong Kong\nTel: (852) 2721-9778Fax: (852) 2722-1369Atmel Europe\nLe Krebs\n8, Rue Jean-Pierre Timbaud\nBP 30978054 Saint-Quentin-en-\nYvelines Cedex\nFranceTel: (33) 1-30-60-70-00 \nFax: (33) 1-30-60-71-11Atmel Japan\n9F, Tonetsu Shinkawa Bldg.\n1-24-8 Shinkawa\nChuo-ku, Tokyo 104-0033Japan\nTel: (81) 3-3523-3551\nFax: (81) 3-3523-7581\nProduct Contact\nWeb Sitewww.atmel.comTechnical Support\ndataflash@atmel.comSales Contact\nwww.atmel.com/contacts\nLiterature Requests\nwww.atmel.com/literature\nDisclaimer:  The information in this document is provided in connection with  Atmel products. No license, express or implied, by estoppel or  otherwise, to any\nintellectual property right is granted by this document  or in connection with the sale of Atmel products. EXCEPT AS SET FORTH IN ATMEL ’S TERMS AND CONDI-\nTIONS OF SALE LOCATED ON ATMEL ’S WEB SITE, ATMEL ASSUMES NO LI ABILITY WHATSOEVER AND DISCLAIMS ANY EXPRESS, IMPLIED OR STATUTOR Y\nWARRANTY RELATING TO ITS PRODUCTS INCLUDING, BUT NOT LIMITED TO , THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICU LAR\nPURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE, SPECIAL OR I NCIDEN-\nTAL DAMAGES (INCLUDING, WITHOUT LIMITATION, DA MAGES FOR LOSS OF PROFITS, BUSINESS INTERRUPTION, OR LOSS OF INFORMATION) ARISING  OUT OF\nTHE USE OR INABILITY TO USE THIS DOCUMENT, EVEN IF ATME L HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  Atmel makes no\nrepresentations or warranties with respect to the accuracy or comp leteness of the contents of this document and reserves the rig ht to make changes to specifications\nand product descriptions at any time without notice. Atmel does  not make any commitment to update the information contained her ein. Unless specifically provided\notherwise, Atmel products are not suitable for, and shall not be used in, automotive applications. Atmel’s products are not int ended, authorized, or warranted for use\nas components in applications in tended to support or sustain life.\n© 2008 Atmel Corporation . All rights reserved. Atmel®, logo and combinations thereof, Everywhere Y ou Are®, DataFlash® and others are\nregistered trademarks, RapidS® and others are trademarks of Atmel Corporation or its subsidiaries. Other terms and product names may be\ntrademarks of others.\n'}]
!==============================================================================!
### Component Summary: AT45DB011D-SH-T

#### Key Specifications:
- **Voltage Ratings**: 2.7V to 3.6V
- **Current Ratings**:
  - Active Read Current: 7 mA (typical)
  - Standby Current: 25 µA (typical)
  - Deep Power-down Current: 5 µA (typical)
- **Power Consumption**: 
  - Active Read: 7 mA
  - Standby: 25 µA
  - Deep Power-down: 5 µA
- **Operating Temperature Range**: -40°C to +85°C (Industrial)
- **Package Type**: 8-lead SOIC (0.150" wide)
- **Special Features**:
  - RapidS® Serial Interface (SPI compatible) with a maximum clock frequency of 66 MHz.
  - User-configurable page size (256 or 264 bytes).
  - Supports various erase options (page, block, sector, chip).
  - Hardware and software data protection features.
  - 100,000 program/erase cycles per page minimum.
  - Data retention of 20 years.
  - Green (Pb/Halide-free/RoHS compliant) packaging options.
- **Moisture Sensitive Level**: MSL 3 (JEDEC J-STD-020E)

#### Description:
The **AT45DB011D** is a 1-megabit (128 KB) serial-interface Flash memory device designed for high-speed data storage applications. It utilizes a RapidS serial interface that is compatible with SPI protocols, allowing for fast data transfer rates up to 66 MHz. The memory is organized into 512 pages, each capable of storing either 256 or 264 bytes of data. The device features a built-in SRAM buffer for efficient data handling during programming and reading operations.

#### Typical Applications:
The AT45DB011D is suitable for a wide range of applications, including:
- **Digital Voice and Image Storage**: Ideal for devices that require quick access to stored audio or visual data.
- **Program Code Storage**: Frequently used in embedded systems for storing firmware or application code.
- **Data Logging**: Suitable for applications that require periodic data storage and retrieval, such as sensors and data acquisition systems.
- **Code Shadowing**: The continuous read capability makes it ideal for applications that need to execute code directly from Flash memory.
- **Low-Power Applications**: With its low power consumption in standby and deep power-down modes, it is well-suited for battery-operated devices.

This component is optimized for use in both commercial and industrial environments where reliability, speed, and low power consumption are critical.