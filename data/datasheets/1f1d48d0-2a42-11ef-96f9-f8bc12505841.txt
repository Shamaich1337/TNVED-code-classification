[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of AT45DB641E-SHN2B-T production of ADESTO from the text: DS-45DB641E-027K–DFLASH–2/2019 Features \n\x01Single 1.7V - 3.6V supply \n\x01Serial Peripheral Interface (SPI) compatible \n\x01Supports SPI modes 0 and 3 \n\x01Supports RapidS ™ operation \n\x01Continuous read capability through entire array \n\x01Up to 85MHz \n\x01Low-power read option up to 15MHz \n\x01Clock-to-output time (t V) of 8ns maximum \n\x01User configurable page size \n\x01256 bytes per page \n\x01264 bytes per page (default) \n\x01Page size can be factory pre-configured for 256 byt es \n\x01Two fully independent SRAM data buffers (256/264 by tes) \n\x01Allows receiving data while reprogramming the main memory array \n\x01Flexible programming options \n\x01Byte/Page Program (1 to 256/264 bytes) directly int o main memory \n\x01Buffer Write | Buffer to Main Memory Page Program \n\x01Flexible erase options \n\x01Page Erase (256/264 bytes) \n\x01Block Erase (2KB) \n\x01Sector Erase (256KB) \n\x01Chip Erase (64-Mbits) \n\x01Program and Erase Suspend/Resume \n\x01Advanced hardware and software data protection feat ures \n\x01Individual sector protection \n\x01Individual sector lockdown to make any sector perma nently read-only \n\x01128-byte, One-Time Programmable (OTP) Security Regi ster \n\x0164 bytes factory programmed with a unique identifie r \n\x0164 bytes user programmable \n\x01Hardware and software controlled reset options \n\x01JEDEC Standard Manufacturer and Device ID Read \n\x01Low-power dissipation \n\x01400nA Ultra-Deep Power-Down current (typical) \n\x015µA Deep Power-Down current (typical) \n\x0125µA Standby current (typical) \n\x017mA Active Read current (typical) \n\x01Endurance: 100,000 program/erase cycles per page mi nimum \n\x01Data retention: 20 years \n\x01Complies with full industrial temperature range \n\x01Green (Pb/Halide-free/RoHS compliant) packaging opt ions \n\x018-lead SOIC (0.208" wide) \n\x018-pad Ultra-thin DFN (5 x 6 x 0.6mm) \n\x018-pad Very-thin DFN (6 x 8 x 1.0mm) \n\x0144-ball dBGA (6 x 8 modified ball array) \n\x01Die in Wafer Form AT45DB641E \n64-Mbit DataFlash (with Extra 2-Mbits), 1.7V Minimu m \nSPI Serial Flash Memory \n 2 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Description \nThe AT45DB641E is a 1.7V minimum, serial-interface sequential access Flash memory ideally suited for a  wide variety of \ndigital voice, image, program code, and data storag e applications. The AT45DB641E also supports the Ra pidS serial \ninterface for applications requiring very high spee d operation. Its 69,206,016 bits of memory are orga nized as 32,768 \npages of 256 bytes or 264 bytes each. In addition t o the main memory, the AT45DB641E also contains two  SRAM \nbuffers of 256/264 bytes each. Interleaving between  both buffers can dramatically increase a system\'s ability to write a \ncontinuous data stream. In addition, the SRAM buffe rs can be used as additional system scratch pad mem ory, and \nE2PROM emulation (bit or byte alterability) can be ea sily handled with a self-contained three step read- modify-write \noperation. \nUnlike conventional Flash memories that are accesse d randomly with multiple address lines and a parall el interface, the \nDataFlash ® uses a serial interface to sequentially access its  data. The simple sequential access dramatically re duces \nactive pin count, facilitates simplified hardware l ayout, increases system reliability, minimizes swit ching noise, and \nreduces package size. The device is optimized for u se in many commercial and industrial applications w here  \nhigh-density, low-pin count, low-voltage, and low-p ower are essential. \nTo allow for simple in-system re-programmability, t he AT45DB641E does not require high input voltages for \nprogramming. The device operates from a single 1.7V  to 3.6V power supply for the erase and program and  read \noperations. The AT45DB641E is enabled through the C hip Select pin (CS ) and accessed via a 3-wire interface consisting \nof the Serial Input (SI), Serial Output (SO), and t he Serial Clock (SCK). \nAll programming and erase cycles are self-timed. \n1. Pin Configurations and Pinouts \nFigure 1-1. Pinouts \nNote: 1. The metal pad on the bottom of the DFN package is n ot internally \nconnected to a voltage potential.This pad can be a “no connect” \nor connected to GND. Care must be taken to avoid th e Metal Pad \nshorting on PCB tracks. 1\n2\n3\n48\n7\n6\n5SI \nSCK\nRESET\nCS SO \nGND\nVCC \nWP 8-lead SOIC\nTop View \nSI \nSCK\nRESET\nCS SO \nGND\nVCC \nWP 8\n7\n6\n51\n2\n3\n48-pad UDFN\nTop View \n(through package)\nCS RST\nVccSCK\nGNDSI \nSO CS RST SCK SI CS RST SI \nWP Vcc GND SO \nWP Vcc SO WP \n(NC)(NC)(NC)(NC)(NC)(NC)(NC)(NC)\n(NC)(NC)(NC)(NC)(NC)(NC)(NC)(NC)\n(NC) (NC) (NC)(NC) (NC) (NC)\nHGFEDCBA5 1 4 3 2 644-ball dBGA \n Top View \n 3 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 1-1. Pin Configurations \nSymbol Name and Function Asserted \nState Type \nCS Chip Select: Asserting the CS  pin selects the device. When the CS  pin is deasserted, the \ndevice will be deselected and normally be placed in  the standby mode (not Deep Power-Down \nmode) and the output pin (SO) will be in a high-imp edance state. When the device is \ndeselected, data will not be accepted on the input pin (SI). \nA high-to-low transition on the CS  pin is required to start an operation and a low-to -high \ntransition is required to end an operation. When en ding an internally self-timed operation such \nas a program or erase cycle, the device will not en ter the standby mode until the completion of \nthe operation. Low Input \nSCK Serial Clock:  This pin is used to provide a clock to the device and is used to control the flow of \ndata to and from the device. Command, address, and input data present on the SI pin is \nalways latched on the rising edge of SCK, while out put data on the SO pin is always clocked \nout on the falling edge of SCK. — Input \nSI Serial Input:  The SI pin is used to shift data into the device. The SI pin is used for all data input \nincluding command and address sequences. Data on th e SI pin is always latched on the rising \nedge of SCK. Data present on the SI pin will be ign ored whenever the device is deselected (CS  \nis deasserted). — Input \nSO Serial Output:  The SO pin is used to shift data out from the devi ce. Data on the SO pin is \nalways clocked out on the falling edge of SCK. The SO pin will be in a high-impedance state \nwhenever the device is deselected (CS  is deasserted). — Output \nWP Write Protect:  When the WP  pin is asserted, all sectors specified for protect ion by the Sector \nProtection Register will be protected against progr am and erase operations regardless of \nwhether the Enable Sector Protection command has be en issued or not. The WP pin functions \nindependently of the software controlled protection  method. After the WP  pin goes low, the \ncontents of the Sector Protection Register cannot b e modified. \nIf a program or erase command is issued to the devi ce while the WP  pin is asserted, the device \nwill simply ignore the command and perform no opera tion. The device will return to the idle \nstate once the CS  pin has been deasserted. The Enable Sector Protect ion command and the \nSector Lockdown command, however, will be recognize d by the device when the WP  pin is \nasserted. \nThe WP  pin is internally pulled-high and may be left floa ting if hardware controlled protection \nwill not be used. However, it is recommended that t he WP  pin also be externally connected to \nVCC  whenever possible. Low Input \nRESET Reset:  A low state on the reset pin (RESET ) will terminate the operation in progress and rese t \nthe internal state machine to an idle state. The de vice will remain in the reset condition as long \nas a low level is present on the RESET  pin. Normal operation can resume once the RESET  pin \nis brought back to a high level. \nThe device incorporates an internal power-on reset circuit, so there are no restrictions on the \nRESET  pin during power-on sequences. If this pin and fea ture is not utilized, then it is \nrecommended that the RESET  pin be driven high externally. Low Input \nVCC Device Power Supply:  The V CC  pin is used to supply the source voltage to the de vice. \nOperations at invalid V CC  voltages may produce spurious results and should n ot be attempted. — Power \nGND Ground:  The ground reference for the power supply. GND sho uld be connected to the system \nground. — Ground \n 4 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 2. Block Diagram \nFigure 2-1. Block Diagram \nFlash Memory Array\nI/O InterfaceSCK\nCS \nRESET\nVCC \nGNDWP \nSO SI Page (256/264 bytes)\nBuffer 1 (256/264 bytes) Buffer 2 (256/264 bytes)\n 5 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 3. Memory Array \nTo provide optimal flexibility, the AT45DB641E memo ry array is divided into three levels of granularit y comprising of \nsectors, blocks, and pages. Figure 3-1, Memory Architecture Diagram  illustrates the breakdown of each level and detail s \nthe number of pages per sector and block. Program o perations to the DataFlash can be done at the full page level or at \nthe byte level (a variable number of bytes). The er ase operations can be performed at the chip, sector , block, or page \nlevel. \nFigure 3-1. Memory Architecture Diagram \nSector 0a = 8 pages\n2,048 / 2,112 bytes\nSector 0b = 1,016 pages\n260,096 / 268,224 bytes\nBlock = 2,048 / 2,112 bytes8 Pages Sector 0a\nSector 0b \nPage = 256 / 264 bytesPage 0\nPage 1\nPage 6\nPage 7\nPage 8\nPage 9\nPage 32,766\nPage 32,767Block 0 \nPage 14\nPage 15\nPage 16\nPage 17\nPage 18Block 1 Sector Architecture Block Architecture Page Architecture\nBlock 0\nBlock 1\nBlock 126\nBlock 127\nBlock 128\nBlock 129\nBlock 4,094\nBlock 4,095Block 254\nBlock 255\nBlock 256\nBlock 257Sector 1 \nSector 31 = 1,,024 pages\n262,144 / 270,336 bytesBlock 2\nSector 1 = 1,024 pages\n262,144 / 270,336 bytes\nSector 30 = 1,024 pages\n262,144 / 270,336 bytesSector 2 = 1,024 pages\n262,144 / 270,336 bytes\n 6 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 4. Device Operation \nThe device operation is controlled by instructions from the host processor. The list of instructions a nd their associated \nopcodes are contained in Table 15-1 on page 40  through Table 15-4 on page 41 . A valid instruction starts with the falling \nedge of CS  followed by the appropriate 8-bit opcode and the d esired buffer or main memory address location. Whil e the \nCS  pin is low, toggling the SCK pin controls the load ing of the opcode and the desired buffer or main me mory address \nlocation through the SI (Serial Input) pin. All ins tructions, addresses, and data are transferred with  the Most Significant  \nBit (MSB) first. \nThree address bytes are used to address memory loca tions in either the main memory array or in one of the SRAM \nbuffers. The three address bytes will be comprised of a number of dummy bits and a number of actual de vice address \nbits, with the number of dummy bits varying dependi ng on the operation being performed and the selecte d device page \nsize. Buffer addressing for the standard DataFlash page size (264 bytes) is referenced in the datashee t using the \nterminology BFA8 - BFA0 to denote the 9 address bit s required to designate a byte address within a buf fer. The main \nmemory addressing is referenced using the terminolo gy PA14 - PA0 and BA8 - BA0, where PA14 - PA0 denot es the  \n15 address bits required to designate a page addres s, and BA8 - BA0 denotes the 9 address bits require d to designate a \nbyte address within the page. Therefore, when using  the standard DataFlash page size, a total of 24 ad dress bits are \nused. \nFor the “power of 2” binary page size (256 bytes), the buffer addressing is referenced in the datashee t using the \nconventional terminology BFA7 - BFA0 to denote the eight address bits required to designate a byte add ress within a \nbuffer. Main memory addressing is referenced using the terminology A22 - A0, where A22 - A8 denotes th e 15 address \nbits required to designate a page address, and A7 -  A0 denotes the 8 address bits required to designat e a byte address \nwithin a page. Therefore, when using the binary pag e size, a total of 23 address bits are used. \n 7 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 5. Read Commands \nBy specifying the appropriate opcode, data can be r ead from the main memory or from either one of the two SRAM data \nbuffers. The DataFlash supports RapidS protocols fo r Mode 0 and Mode 3. Please see Section 25., Detailed Bit-level \nRead Waveforms: RapidS Mode 0/Mode 3  diagrams in this datasheet for details on the cloc k cycle sequences for each \nmode. \n5.1 Continuous Array Read (Legacy Command: E8h Opcod e) \nBy supplying an initial starting address for the ma in memory array, the Continuous Array Read command can be utilized to \nsequentially read a continuous stream of data from the device by simply providing a clock signal; no a dditional addressing \ninformation or control signals need to be provided.  The DataFlash incorporates an internal address cou nter that will \nautomatically increment on every clock cycle, allow ing one continuous read from memory to be performed  without the \nneed for additional address sequences. To perform a  Continuous Array Read using the standard DataFlash  page size \n(264 bytes), an opcode of E8h must be clocked into the device followed by three address bytes (which c omprise the 24-bit \npage and byte address sequence) and four dummy byte s. The first 15 bits (PA14 - PA0) of the 24-bit add ress sequence \nspecify which page of the main memory array to read  and the last 9 (BA8 - BA0) of the 24-bit address s equence specify \nthe starting byte address within the page. To perfo rm a Continuous Array Read using the binary page si ze  \n(256 bytes), an opcode of E8h must be clocked into the device followed by three address bytes and four  dummy bytes. \nThe first 15 bits (A22 - A8) of the 23-bit address sequence specify which page of the main memory arra y to read and the \nlast 8 bits (A7 - A0) of the 23-bit address sequenc e specify the starting byte address within the page . The dummy bytes \nthat follow the address bytes are needed to initial ize the read operation. Following the dummy bytes, additional clock \npulses on the SCK pin will result in data being out put on the SO (serial output) pin. \nThe CS  pin must remain low during the loading of the opco de, the address bytes, the dummy bytes, and the rea ding of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no d elays incurred during the page boundary crossover ( the crossover from \nthe end of one page to the beginning of the next pa ge). When the last bit in the main memory array has  been read, the \ndevice will continue reading back at the beginning of the first page of memory. As with crossing over page boundaries, no \ndelays will be incurred when wrapping around from t he end of the array to the beginning of the array. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Re ad is defined by the f CAR1  specification. The Continuous Array Read \nbypasses the data buffers and leaves the contents o f the buffers unchanged. \nWarning: This command is not recommended for new designs. \n5.2 Continuous Array Read (High Frequency Mode: 1Bh Opcode)\nThis command can be used to read the main memory ar ray sequentially at the highest possible operating clock \nfrequency up to the maximum specified by f CAR4 . To perform a Continuous Array Read using the stan dard DataFlash \npage size (264 bytes), the CS  pin must first be asserted, and then an opcode of 1Bh must be clocked into the device \nfollowed by three address bytes and two dummy bytes . The first 15 bits (PA14 - PA0) of the 24-bit addr ess sequence \nspecify which page of the main memory array to read  and the last 9 bits (BA8 - BA0) of the 24-bit addr ess sequence \nspecify the starting byte address within the page. To perform a Continuous Array Read using the binary  page size (256 \nbytes), the opcode 1Bh must be clocked into the dev ice followed by three address bytes (A22 - A0) and two dummy \nbytes. Following the dummy bytes, additional clock pulses on the SCK pin will result in data being out put on the SO \n(Serial Output) pin. \nThe CS  pin must remain low during the loading of the opco de, the address bytes, the dummy bytes, and the rea ding of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no d elays incurred during the page boundary crossover ( the crossover \nfrom the end of one page to the beginning of the ne xt page). When the last bit in the main memory arra y has been read, \nthe device will continue reading back at the beginn ing of the first page of memory. As with crossing o ver page \nboundaries, no delays will be incurred when wrappin g around from the end of the array to the beginning  of the array. \n 8 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 A low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Re ad is defined by the f CAR4 specification. The Continuous Array \nRead bypasses both data buffers and leaves the cont ents of the buffers unchanged. \n5.3 Continuous Array Read (High Frequency Mode: 0Bh Opcode)\nThis command can be used to read the main memory ar ray sequentially at higher clock frequencies up to the maximum \nspecified by f CAR1 . To perform a Continuous Array Read using the stan dard DataFlash page size (264 bytes), the CS  pin \nmust first be asserted, and then an opcode of 0Bh m ust be clocked into the device followed by three ad dress bytes and \none dummy byte. The first 15 bits (PA14 - PA0) of t he 24-bit address sequence specify which page of th e main memory \narray to read and the last 9 bits (BA8 - BA0) of th e 24-bit address sequence specify the starting byte  address within the \npage. To perform a Continuous Array Read using the binary page size (256 bytes), the opcode 0Bh must b e clocked into \nthe device followed by three address bytes (A22 - A 0) and one dummy byte. Following the dummy byte, ad ditional clock \npulses on the SCK pin will result in data being out put on the SO pin. \nThe CS  pin must remain low during the loading of the opco de, the address bytes, the dummy byte, and the read ing of \ndata. When the end of a page in the main memory is reached during a Continuous Array Read, the device will continue \nreading at the beginning of the next page with no d elays incurred during the page boundary crossover ( the crossover \nfrom the end of one page to the beginning of the ne xt page). When the last bit in the main memory arra y has been read, \nthe device will continue reading back at the beginn ing of the first page of memory. As with crossing o ver page \nboundaries, no delays will be incurred when wrappin g around from the end of the array to the beginning  of the array. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Re ad is defined by the f CAR1  specification. The Continuous Array \nRead bypasses both data buffers and leaves the cont ents of the buffers unchanged. \n5.4 Continuous Array Read (Low Frequency Mode: 03h O pcode) \nThis command can be used to read the main memory ar ray sequentially at lower clock frequencies up to m aximum \nspecified by f CAR2 . Unlike the previously described read commands, th is Continuous Array Read command for the lower \nclock frequencies does not require the clocking in of dummy bytes after the address byte sequence. To perform a \nContinuous Array Read using the standard DataFlash page size (264 bytes), the CS  pin must first be asserted, and then \nan opcode of 03h must be clocked into the device fo llowed by three address bytes. The first 15 bits (P A14 - PA0) of the \n24-bit address sequence specify which page of the m ain memory array to read and the last 9 bits (BA8 -  BA0) of the \naddress sequence specify the starting byte address within the page. To perform a Continuous Array Read  using the \nbinary page size (256 bytes), the opcode 03h must b e clocked into the device followed by three address  bytes (A22 - \nA0). Following the address bytes, additional clock pulses on the SCK pin will result in data being out put on the SO pin. \nThe CS  pin must remain low during the loading of the opco de, the address bytes, and the reading of data. Whe n the end \nof a page in the main memory is reached during a Co ntinuous Array Read, the device will continue readi ng at the \nbeginning of the next page with no delays incurred during the page boundary crossover (the crossover f rom the end of \none page to the beginning of the next page). When t he last bit in the main memory array has been read,  the device will \ncontinue reading back at the beginning of the first  page of memory. As with crossing over page boundar ies, no delays will \nbe incurred when wrapping around from the end of th e array to the beginning of the array. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Re ad is defined by the f CAR2  specification. The Continuous Array \nRead bypasses both data buffers and leaves the cont ents of the buffers unchanged. \n5.5 Continuous Array Read (Low Power Mode: 01h Opcod e) \nThis command is ideal for applications that want to  minimize power consumption and do not need to read  the memory \narray at high frequencies. Like the 03h opcode, thi s Continuous Array Read command allows reading the main memory \narray sequentially without the need for dummy bytes  to be clocked in after the address byte sequence. The memory can \nbe read at clock frequencies up to maximum specifie d by f CAR3 . To perform a Continuous Array Read using the stan dard \nDataFlash page size (264 bytes), the CS  pin must first be asserted, and then an opcode of 01h must be clocked into the \ndevice followed by three address bytes. The first 1 5 bits (PA14 - PA0) of the 24-bit address sequence specify which page \n 9 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 of the main memory array to read and the last 9 bit s (BA8 - BA0) of the 24-bit address sequence specif y the starting byte \naddress within the page. To perform a Continuous Ar ray Read using the binary page size (256 bytes), th e opcode 01h \nmust be clocked into the device followed by three a ddress bytes (A22 - A0). Following the address byte s, additional clock \npulses on the SCK pin will result in data being out put on the SO pin. \nThe CS  pin must remain low during the loading of the opco de, the address bytes, and the reading of data. Whe n the end \nof a page in the main memory is reached during a Co ntinuous Array Read, the device will continue readi ng at the \nbeginning of the next page with no delays incurred during the page boundary crossover (the crossover f rom the end of \none page to the beginning of the next page). When t he last bit in the main memory array has been read,  the device will \ncontinue reading back at the beginning of the first  page of memory. As with crossing over page boundar ies, no delays will \nbe incurred when wrapping around from the end of th e array to the beginning of the array. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). The maximum \nSCK frequency allowable for the Continuous Array Re ad is defined by the f CAR3  specification. The Continuous Array \nRead bypasses both data buffers and leaves the cont ents of the buffers unchanged. \n5.6 Main Memory Page Read\nA Main Memory Page Read allows the reading of data directly from a single page in the main memory, byp assing both of \nthe data buffers and leaving the contents of the bu ffers unchanged. To start a page read using the sta ndard DataFlash \npage size (264 bytes), an opcode of D2h must be clo cked into the device followed by three address byte s (which \ncomprise the 24-bit page and byte address sequence)  and four dummy bytes. The first 15 bits (PA14 - PA 0) of the 24-bit \naddress sequence specify the page in main memory to  be read and the last 9 bits (BA8 - BA0) of the 24- bit address \nsequence specify the starting byte address within t hat page. To start a page read using the binary pag e size (256 bytes), \nthe opcode D2h must be clocked into the device foll owed by three address bytes and four dummy bytes. T he first 15 bits \n(A22 - A8) of the 23-bit address sequence specify w hich page of the main memory array to read, and the  last 8 bits (A7 - \nA0) of the 23-bit address sequence specify the star ting byte address within that page. The dummy bytes  that follow the \naddress bytes are sent to initialize the read opera tion. Following the dummy bytes, the additional pul ses on SCK result in \ndata being output on the SO (serial output) pin. \nThe CS  pin must remain low during the loading of the opco de, the address bytes, the dummy bytes, and the rea ding of \ndata. Unlike the Continuous Array Read command, whe n the end of a page in main memory is reached, the device will \ncontinue reading back at the beginning of the same page rather than the beginning of the next page. \nA low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). The maximum \nSCK frequency allowable for the Main Memory Page Re ad is defined by the f SCK  specification. The Main Memory Page \nRead bypasses both data buffers and leaves the cont ents of the buffers unchanged. \n5.7 Buffer Read \nThe SRAM data buffers can be accessed independently  from the main memory array, and utilizing the Buff er Read \ncommand allows data to be sequentially read directl y from either one of the buffers. Four opcodes, D4h  or D1h for  \nBuffer 1 and D6h or D3h for Buffer 2, can be used f or the Buffer Read command. The use of each opcode depends on \nthe maximum SCK frequency that will be used to read  data from the buffers. The D4h and D6h opcode can be used at \nany SCK frequency up to the maximum specified by f CAR1  while the D1h and D3h opcode can be used for lower  \nfrequency read operations up to the maximum specifi ed by f CAR2 .\nTo perform a Buffer Read using the standard DataFla sh buffer size (264 bytes), the opcode must be cloc ked into the \ndevice followed by three address bytes comprised of  15 dummy bits and 9 buffer address bits (BFA8 - BF A0). To perform \na Buffer Read using the binary buffer size (256 byt es), the opcode must be clocked into the device fol lowed by three \naddress bytes comprised of 16 dummy bits and 8 buff er address bits (BFA7 - BFA0). Following the addres s bytes, one \ndummy byte must be clocked into the device to initi alize the read operation if using opcodes D4h or D6 h. The CS  pin \nmust remain low during the loading of the opcode, t he address bytes, the dummy byte (if using opcodes D4h or D6h), \nand the reading of data. When the end of a buffer i s reached, the device will continue reading back at  the beginning of \nthe buffer. A low-to-high transition on the CS  pin will terminate the read operation and tri-stat e the output pin (SO). \n 10 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 6. Program and Erase Commands \n6.1 Buffer Write \nUtilizing the Buffer Write command allows data cloc ked in from the SI pin to be written directly into either one of the \nSRAM data buffers. \nTo load data into a buffer using the standard DataF lash buffer size (264 bytes), an opcode of 84h for Buffer 1 or 87h for \nBuffer 2 must be clocked into the device followed b y three address bytes comprised of 15 dummy bits an d 9 buffer \naddress bits (BFA8 - BFA0). The 9 buffer address bi ts specify the first byte in the buffer to be writt en. \nTo load data into a buffer using the binary buffer size (256 bytes), an opcode of 84h for Buffer 1 or 87h for Buffer 2, must \nbe clocked into the device followed by 16 dummy bit s and 8 buffer address bits (BFA7 - BFA0). The 8 bu ffer address bits \nspecify the first byte in the buffer to be written.  \nAfter the last address byte has been clocked into t he device, data can then be clocked in on subsequen t clock cycles. If \nthe end of the data buffer is reached, the device w ill wrap around back to the beginning of the buffer . Data will continue to \nbe loaded into the buffer until a low-to-high trans ition is detected on the CS  pin. \n6.2 Buffer to Main Memory Page Program with Built-In  Erase \nThe Buffer to Main Memory Page Program with Built-I n Erase command allows data that is stored in one o f the SRAM \nbuffers to be written into an erased or programmed page in the main memory array. It is not necessary to pre-erase the \npage in main memory to be written because this comm and will automatically erase the selected page prio r to the \nprogram cycle. \nTo perform a Buffer to Main Memory Page Program wit h Built-In Erase using the standard DataFlash page size  \n(264 bytes), an opcode of 83h for Buffer 1 or 86h f or Buffer 2 must be clocked into the device followe d by three address \nbytes comprised of 15 page address bits (PA14 - PA0 ) that specify the page in the main memory to be wr itten, and 9 \ndummy bits. \nTo perform a Buffer to Main Memory Page Program wit h Built-In Erase using the binary page size (256 by tes), an opcode \nof 83h for Buffer 1 or 86h for Buffer 2 must be clo cked into the device followed by three address byte s comprised of 1 \ndummy bit, 15 page address bits (A22 - A8) that spe cify the page in the main memory to be written, and  8 dummy bits. \nWhen a low-to-high transition occurs on the CS  pin, the device will first erase the selected page  in main memory (the \nerased state is a Logic 1) and then program the dat a stored in the appropriate buffer into that same p age in main \nmemory. Both the erasing and the programming of the  page are internally self-timed and should take pla ce in a \nmaximum time of t EP . During this time, the RDY/BUSY  bit in the Status Register will indicate that the d evice is busy. \nThe device also incorporates an intelligent erase a nd program algorithm that can detect when a byte lo cation fails to \nerase or program properly. If an erase or programmi ng error arises, it will be indicated by the EPE bi t in the Status \nRegister. \n6.3 Buffer to Main Memory Page Program without Built -In Erase \nThe Buffer to Main Memory Page Program without Buil t-In Erase command allows data that is stored in on e of the SRAM \nbuffers to be written into a pre-erased page in the  main memory array. It is necessary that the page i n main memory to be \nwritten be previously erased in order to avoid prog ramming errors. \nTo perform a Buffer to Main Memory Page Program wit hout Built-In Erase using the standard DataFlash pa ge size  \n(264 bytes), an opcode of 88h for Buffer 1 or 89h f or Buffer 2 must be clocked into the device followe d by three address \nbytes comprised of 15 page address bits (PA14 - PA0 ) that specify the page in the main memory to be wr itten, and 9 \ndummy bits. \nTo perform a Buffer to Main Memory Page Program usi ng the binary page size (256 bytes), an opcode of 8 8h for Buffer \n1 or 89h for Buffer 2 must be clocked into the devi ce followed by three address bytes comprised of 1 d ummy bit,  \n15 page address bits (A22 - A8) that specify the pa ge in the main memory to be written, and 8 dummy bi ts. \n 11 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 When a low-to-high transition occurs on the CS  pin, the device will program the data stored in th e appropriate buffer into \nthe specified page in the main memory. The page in main memory that is being programmed must have been  previously \nerased using one of the erase commands (Page Erase,  Block Erase, Sector Erase, or Chip Erase). The pro gramming of \nthe page is internally self-timed and should take p lace in a maximum time of t P. During this time, the RDY/BUSY  bit in the \nStatus Register will indicate that the device is bu sy. \nThe device also incorporates an intelligent program ming algorithm that can detect when a byte location  fails to program \nproperly. If a programming error arises, it will be  indicated by the EPE bit in the Status Register. \n6.4 Main Memory Page Program through Buffer with Bui lt-In Erase \nThe Main Memory Page Program through Buffer with Bu ilt-In Erase command combines the Buffer Write and Buffer to \nMain Memory Page Program with Built-In Erase operat ions into a single operation to help simplify appli cation firmware \ndevelopment. With the Main Memory Page Program thro ugh Buffer with Built-In Erase command, data is fir st clocked \ninto either Buffer 1 or Buffer 2, the addressed pag e in memory is then automatically erased, and then the contents of the \nappropriate buffer are programmed into the just-era sed main memory page. \nTo perform a Main Memory Page Program through Buffe r using the standard DataFlash page size (264 bytes ), an \nopcode of 82h for Buffer 1 or 85h for Buffer 2 must  first be clocked into the device followed by three  address bytes \ncomprised of 15 page address bits (PA14 - PA0) that  specify the page in the main memory to be written,  and 9 buffer \naddress bits (BFA8 - BFA0) that select the first by te in the buffer to be written. \nTo perform a Main Memory Page Program through Buffe r using the binary page size (256 bytes), an opcode  of 82h for \nBuffer 1 or 85h for Buffer 2 must first be clocked into the device followed by three address bytes com prised of 1 dummy \nbit, 15 page address bits (A22 - A8) that specify t he page in the main memory to be written, and 8 buf fer address bits \n(BFA7 - BFA0) that select the first byte in the buf fer to be written. \nAfter all address bytes have been clocked in, the d evice will take data from the input pin (SI) and st ore it in the specified \ndata buffer. If the end of the buffer is reached, t he device will wrap around back to the beginning of  the buffer. When \nthere is a low-to-high transition on the CS  pin, the device will first erase the selected page  in main memory (the erased \nstate is a Logic 1) and then program the data store d in the buffer into that main memory page. Both th e erasing and the \nprogramming of the page are internally self-timed a nd should take place in a maximum time of t EP . During this time, the \nRDY/BUSY  bit in the Status Register will indicate that the d evice is busy. \nThe device also incorporates an intelligent erase a nd programming algorithm that can detect when a byt e location fails to \nerase or program properly. If an erase or program e rror arises, it will be indicated by the EPE bit in  the Status Register. \n6.5 Main Memory Byte/Page Program through Buffer 1 w ithout Built-In Erase \nThe Main Memory Byte/Page Program through Buffer 1 without Built-In Erase command combines both the Bu ffer Write \nand Buffer to Main Memory Program without Built-In Erase operations to allow any number of bytes (1 to  256/264 bytes) \nto be programmed directly into previously erased lo cations in the main memory array. With the Main Mem ory Byte/Page \nProgram through Buffer 1 without Built-In Erase com mand, data is first clocked into Buffer 1, and then  only the bytes \nclocked into the buffer are programmed into the pre -erased byte locations in main memory. Multiple byt es up to the page \nsize can be entered with one command sequence. \nTo perform a Main Memory Byte/Page Program through Buffer 1 using the standard DataFlash page size (26 4 bytes), an \nopcode of 02h must first be clocked into the device  followed by three address bytes comprised of 15 pa ge address bits \n(PA14 - PA0) that specify the page in the main memo ry to be written, and 9 buffer address bits (BFA8 -  BFA0) that select \nthe first byte in the buffer to be written. After a ll address bytes are clocked in, the device will ta ke data from the input pin \n(SI) and store it in Buffer 1. Any number of bytes (1 to 264) can be entered. If the end of the buffer  is reached, then the \ndevice will wrap around back to the beginning of th e buffer. \nTo perform a Main Memory Byte/Page Program through Buffer 1 using the binary page size (256 bytes), an  opcode of \n02h for Buffer 1 using must first be clocked into t he device followed by three address bytes comprised  of 1 dummy bit, 15 \npage address bits (A22 - A8) that specify the page in the main memory to be written, and 8 buffer addr ess bits (BFA7 - \nBFA0) that selects the first byte in the buffer to be written. After all address bytes are clocked in,  the device will take data \nfrom the input pin (SI) and store it in Buffer 1. A ny number of bytes (1 to 256) can be entered. If th e end of the buffer is \n 12 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 reached, then the device will wrap around back to t he beginning of the buffer. When using the binary p age size, the page \nand buffer address bits correspond to a 23-bit logi cal address (A22-A0) in the main memory. \nAfter all data bytes have been clocked into the dev ice, a low-to-high transition on the CS  pin will start the program \noperation in which the device will program the data  stored in Buffer 1 into the main memory array. Onl y the data bytes \nthat were clocked into the device will be programme d into the main memory. \nExample: If only two data bytes were clocked into the device , then only two bytes will be programmed into main \nmemory and the remaining bytes in the memory page w ill remain in their previous state. \nThe CS  pin must be deasserted on a byte boundary (multipl es of eight bits); otherwise, the operation will be  aborted and \nno data will be programmed. The programming of the data bytes is internally self-timed and should take  place in a \nmaximum time of t P (the program time will be a multiple of the t BP  time depending on the number of bytes being \nprogrammed). During this time, the RDY/BUSY  bit in the Status Register will indicate that the d evice is busy. \nThe device also incorporates an intelligent program ming algorithm that can detect when a byte location  fails to program \nproperly. If a programming error arises, it will be  indicated by the EPE bit in the Status Register. \n6.6 Read-Modify-Write \nA completely self-contained read-modify-write opera tion can be performed to reprogram any number of se quential bytes \nin a page in the main memory array without affectin g the rest of the bytes in the same page. This comm and allows the \ndevice to easily emulate an EEPROM by providing a m ethod to modify a single byte or more in the main m emory in a \nsingle operation, without the need for pre-erasing the memory or the need for any external RAM buffers . The  \nRead-Modify-Write command is essentially a combinat ion of the Main Memory Page to Buffer Transfer, Buf fer Write, and \nBuffer to Main Memory Page Program with Built-in Er ase commands. \nTo perform a Read-Modify-Write using the standard D ataFlash page size (264 bytes), an opcode of 58h fo r Buffer 1 or \n59h for Buffer 2 must be clocked into the device fo llowed by three address bytes comprised of 15 page address bits \n(PA14 - PA0) that specify the page in the main memo ry to be written, and 9 byte address bits (BA8 - BA 0) that designate \nthe starting byte address within the page to reprog ram. \nTo perform a Read-Modify-Write using the binary pag e size (256 bytes), an opcode of 58h for Buffer 1 o r 59h for Buffer 2 \nmust be clocked into the device followed by three a ddress bytes comprised of 1 dummy bit, 15 page addr ess bits (A22 - \nA8) that specify the page in the main memory to be written, and 8 byte address bits (A7 - A0) designat e the starting byte \naddress within the page to reprogram. \nAfter the address bytes have been clocked in, any n umber of sequential data bytes from one to 256/264 bytes can be \nclocked into the device. If the end of the buffer i s reached when clocking in the data, then the devic e will wrap around \nback to the beginning of the buffer. After all data  bytes have been clocked into the device, a low-to- high transition on the \nCS pin will start the self-contained, internal read -modify-write operation. Only the data bytes that w ere clocked into the \ndevice will be reprogrammed in the main memory. \nExample: If only one data byte was clocked into the device, then only one byte in main memory will be reprogram med \nand the remaining bytes in the main memory page wil l remain in their previous state. \nThe CS  pin must be deasserted on a byte boundary (multipl es of eight bits); otherwise, the operation will be  aborted and \nno data will be programmed. The reprogramming of th e data bytes is internally self-timed and should ta ke place in a \nmaximum time of t P. During this time, the RDY/BUSY  bit in the Status Register will indicate that the device is busy. \nThe device also incorporates an intelligent erase a nd programming algorithm that can detect when a byt e location fails to \nerase or program properly. If an erase or program e rror arises, it will be indicated by the EPE bit in  the Status Register. \nNote: The Read-Modify-Write command uses the same op codes as the Auto Page Rewrite command. If no data \nbytes are clocked into the device, then the device will perform an Auto Page Rewrite operation. See th e \nAuto Page Rewrite command description on page 27  for more details. \n 13 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 6.7 Page Erase \nThe Page Erase command can be used to individually erase any page in the main memory array allowing th e Buffer to \nMain Memory Page Program without Built-In Erase com mand or the Main Memory Byte/Page Program through B uffer 1 \ncommand to be utilized at a later time. \nTo perform a Page Erase with the standard DataFlash  page size (264 bytes), an opcode of 81h must be cl ocked into the \ndevice followed by three address bytes comprised of  15 page address bits (PA14 - PA0) that specify the  page in the main \nmemory to be erased, and 9 dummy bits. \nTo perform a Page Erase with the binary page size ( 256 bytes), an opcode of 81h must be clocked into t he device \nfollowed by three address bytes comprised of 1 dumm y bit, 15 page address bits (A22 - A8) that specify  the page in the \nmain memory to be erased, and 8 dummy bits. \nWhen a low-to-high transition occurs on the CS  pin, the device will erase the selected page (the erased state is a  \nLogic 1). The erase operation is internally self-ti med and should take place in a maximum time of t PE . During this time, the \nRDY/BUSY  bit in the Status Register will indicate that the d evice is busy. \nThe device also incorporates an intelligent erase a lgorithm that can detect when a byte location fails  to erase properly. If \nan erase error arises, it will be indicated by the EPE bit in the Status Register. \n6.8 Block Erase \nThe Block Erase command can be used to erase a bloc k of eight pages at one time. This command is usefu l when \nneeding to pre-erase larger amounts of memory and i s more efficient than issuing eight separate Page E rase \ncommands. \nTo perform a Block Erase with the standard DataFlas h page size (264 bytes), an opcode of 50h must be c locked into the \ndevice followed by three address bytes comprised of  12 page address bits (PA14 - PA3), and  \n12 dummy bits. The 12 page address bits are used to  specify which block of 8 pages is to be erased. \nTo perform a Block Erase with the binary page size (256 bytes), an opcode of 50h must be clocked into the device \nfollowed by three address bytes comprised of 1 dumm y bit, 12 page address bits (A22 - A11), and 11 dum my bits. The 12 \npage address bits are used to specify which block o f 8 pages is to be erased. \nWhen a low-to-high transition occurs on the CS  pin, the device will erase the selected block of e ight pages. The erase \noperation is internally self-timed and should take place in a maximum time of t BE . During this time, the RDY/BUSY  bit in \nthe Status Register will indicate that the device i s busy. \nThe device also incorporates an intelligent erase a lgorithm that can detect when a byte location fails  to erase properly. If \nan erase error arises, it will be indicated by the EPE bit in the Status Register. \nTable 6-1. Block Erase Addressing \nPA14 \n/A22 PA13 \n/A21 PA12 \n/A20 PA11/ \nA19 PA10 \n/A18 PA9/ \nA17 PA8/ \nA16 PA7/ \nA15 PA6/ \nA14 PA5/ \nA13 PA4/ \nA12 PA3/ \nA11 PA2/ \nA10 PA1/ \nA9 PA0/ \nA8 Block \n0 0 0 0 0 0 0 0 0 0 0 0 X X X 0\n0 0 0 0 0 0 0 0 0 0 0 1 X X X 1\n0 0 0 0 0 0 0 0 0 0 1 0 X X X 2\n0 0 0 0 0 0 0 0 0 0 1 1 X X X 3\n•\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n•\n1 1 1 1 1 1 1 1 1 1 0 0 X X X 4092 \n1 1 1 1 1 1 1 1 1 1 0 1 X X X 4093 \n1 1 1 1 1 1 1 1 1 1 1 0 X X X 4094 \n1 1 1 1 1 1 1 1 1 1 1 1 X X X 4095 \n 14 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 6.9 Sector Erase \nThe Sector Erase command can be used to individuall y erase any sector in the main memory. \nThe main memory array is comprised of thirty-three sectors, and only one sector can be erased at a tim e. To perform an \nerase of Sector 0a or Sector 0b with the standard D ataFlash page size (264 bytes), an opcode of 7Ch mu st be clocked \ninto the device followed by three address bytes com prised of 12 page address bits (PA14 - PA3), and  \n12 dummy bits. To perform a Sector 1-31 erase, an o pcode of 7Ch must be clocked into the device follow ed by three \naddress bytes comprised of 5 page address bits (PA1 4 - PA10), and 19 dummy bits. \nTo perform a Sector 0a or Sector 0b erase with the binary page size (256 bytes), an opcode of 7Ch must  be clocked into \nthe device followed by three address bytes comprise d of 1 dummy bit, 12 page address bits (A22 - A11),  and  \n11 dummy bits. To perform a Sector 1-31 erase, an o pcode of 7Ch must be clocked into the device follow ed by 1 dummy \nbit, 5 page address bits (A22 - A18), and 18 dummy bits. \nThe page address bits are used to specify any valid  address location within the sector to be erased. W hen a  \nlow-to high transition occurs on the CS  pin, the device will erase the selected sector. Th e erase operation is internally  \nself-timed and should take place in a maximum time of t SE . During this time, the RDY/BUSY  bit in the Status Register will \nindicate that the device is busy. \nThe device also incorporates an intelligent algorit hm that can detect when a byte location fails to er ase properly. If an \nerase error arises, it will be indicated by the EPE  bit in the Status Register. \nTable 6-2. Sector Erase Addressing \n6.10 Chip Erase \nThe Chip Erase command allows the entire main memor y array to be erased can be erased at one time. \nTo execute the Chip Erase command, a 4-byte command  sequence of C7h, 94h, 80h, and 9Ah must be clocked  into the \ndevice. Since the entire memory array is to be eras ed, no address bytes need to be clocked into the de vice, and any data \nclocked in after the opcode will be ignored. After the last bit of the opcode sequence has been clocke d in, the CS  pin \nmust be deasserted to start the erase process. The erase operation is internally self-timed and should  take place in a \ntime of t CE . During this time, the RDY/BUSY  bit in the Status Register will indicate that the device is busy. \nThe Chip Erase command will not affect sectors that  are protected or locked down; the contents of thos e sectors will \nremain unchanged. Only those sectors that are not p rotected or locked down will be erased. PA14 \n/A22 PA13 \n/A21 PA12 \n/A20 PA11/ \nA19 PA10 \n/A18 PA9/ \nA17 PA8/ \nA16 PA7/ \nA15 PA6/ \nA14 PA5/ \nA13 PA4/ \nA12 PA3/ \nA11 PA2/ \nA10 PA1/ \nA9 PA0/ \nA8 Sector \n0 0 0 0 0 0 0 0 0 0 0 0 X X X 0a \n0 0 0 0 0 0 0 0 0 0 0 1 X X X 0b \n0 0 0 0 1 X X X X X X X X X X 1\n0 0 0 1 0 X X X X X X X X X X 2\n•\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n••\n•\n•\n1 1 1 0 0 X X X X X X X X X X 28 \n1 1 1 0 1 X X X X X X X X X X 29 \n1 1 1 1 0 X X X X X X X X X X 30 \n1 1 1 1 1 X X X X X X X X X X 31 \n 15 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 The WP  pin can be asserted while the device is erasing, b ut protection will not be activated until the inter nal erase cycle \ncompletes. \nThe device also incorporates an intelligent algorit hm that can detect when a byte location fails to er ase properly. If an \nerase error arises, it will be indicated by the EPE  bit in the Status Register. \nTable 6-3. Chip Erase Command \nFigure 6-1. Chip Erase \n6.11 Program/Erase Suspend \nIn some code and data storage applications, it may not be possible for the system to wait the millisec onds required for \nthe Flash memory to complete a program or erase cyc le. The Program/Erase Suspend command allows a prog ram or \nerase operation in progress to a particular 256KB s ector of the main memory array to be suspended so t hat other device \noperations can be performed. \nExample: By suspending an erase operation to a particular se ctor, the system can perform functions such as a \nprogram or read operation within a different 256KB sector. Other device operations, such as Read Statu s \nRegister, can also be performed while a program or erase operation is suspended. \nTo perform a Program/Erase Suspend, an opcode of B0 h must be clocked into the device. No address bytes  need to be \nclocked into the device, and any data clocked in af ter the opcode will be ignored. When the CS  pin is deasserted, the \nprogram or erase operation currently in progress wi ll be suspended within a time of t SUSP . One of the Program Suspend \nbits (PS1 or PS2) or the Erase Suspend bit (ES) in the Status Register will then be set to the Logic 1  state. In addition, \nthe RDY/BUSY  bit in the Status Register will indicate that the device is ready for another operation. \nRead operations are not allowed to a 256KB sector t hat has had its program or erase operation suspende d. If a read is \nattempted to a suspended sector, then the device wi ll output undefined data. Therefore, when performin g a Continuous \nArray Read operation and the device\'s internal addr ess counter increments and crosses the sector bound ary to a \nsuspended sector, the device will then start output ting undefined data continuously until the address counter increments \nand crosses a sector boundary to an unsuspended sec tor. \nA program operation is not allowed to a sector that  has been erase suspended. If a program operation i s attempted to an \nerase suspended sector, then the program operation will abort. \nDuring an Erase Suspend, a program operation to a d ifferent 256KB sector can be started and subsequent ly suspended. \nThis results in a simultaneous Erase Suspend/Progra m Suspend condition and will be indicated by the st ates of both the \nES and PS1 or PS2 bits in the Status Register being  set to a Logic 1. \nIf a Reset command is performed, or if the RESET  pin is asserted while a sector is erase suspended,  then the suspend \noperation will be aborted and the contents of the s ector will be left in an undefined state. However, if a reset is performed \nwhile a page is program or erase suspended, the sus pend operation will abort but only the contents of the page that was \nbeing programmed or erased will be undefined; the r emaining pages in the 256KB sector will retain thei r previous \ncontents. Command Byte 1 Byte 2 Byte 3 Byte 4 \nChip Erase C7h 94h 80h 9Ah \nC7h 94h 80h 9Ah CS \nEach transition represents eight bits\n 16 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 6-4. Operations Allowed and Not Allowed During  Suspend \nCommand Operation During \nProgram Suspend in \nBuffer 1 (PS1) Operation During \nProgram Suspend in \nBuffer 2 (PS2) Operation During \nErase Suspend (ES) \nRead Commands \nRead Array (All Opcodes) Allowed Allowed Allowed \nRead Buffer 1 (All Opcodes) Allowed Allowed Allowed \nRead Buffer 2 (All Opcodes) Allowed Allowed Allowed \nProgram and Erase Commands \nBuffer 1 Write Not Allowed Allowed Allowed \nBuffer 2 Write Allowed Not Allowed Allowed \nBuffer 1 to Memory Program w/ Erase Not Allowed Not Allowed Not Allowed \nBuffer 2 to Memory Program w/ Erase Not Allowed Not Allowed Not Allowed \nBuffer 1 to Memory Program w/o Erase Not Allowed Not Allowed Allowed \nBuffer 2 to Memory Program w/o Erase Not Allowed Not Allowed Allowed \nMemory Program through Buffer 1 w/ Erase Not Allowed Not Allowed Not Allowed \nMemory Program through Buffer 2 w/ Erase Not Allowed Not Allowed Not Allowed \nMemory Program through Buffer 1 w/o Erase Not Allowed Not Allowed Allowed \nAuto Page Rewrite through Buffer 1 Not Allowed Not Allowed Not Allowed \nAuto Page Rewrite through Buffer 2 Not Allowed Not Allowed Not Allowed \nRead-Modify-Write through Buffer 1 Not Allowed Not Allowed Not Allowed \nRead-Modify-Write through Buffer 2 Not Allowed Not Allowed Not Allowed \nPage Erase Not Allowed Not Allowed Not Allowed \nBlock Erase Not Allowed Not Allowed Not Allowed \nSector Erase Not Allowed Not Allowed Not Allowed \nChip Erase Not Allowed Not Allowed Not Allowed \nProtection and Security Commands \nEnable Sector Protection Not Allowed Not Allowed Not Allowed \nDisable Sector Protection Not Allowed Not Allowed Not Allowed \nErase Sector Protection Register Not Allowed Not Allowed Not Allowed \nProgram Sector Protection Register Not Allowed Not Allowed Not Allowed \nRead Sector Protection Register Allowed Allowed Allowed \nSector Lockdown Not Allowed Not Allowed Not Allowed \nRead Sector Lockdown Allowed Allowed Allowed \nFreeze Sector Lockdown State Not Allowed Not Allowed Not Allowed \nProgram Security Register Not Allowed Not Allowed Not Allowed \nRead Security Register Allowed Allowed Allowed \nAdditional Commands \nMain Memory to Buffer 1 Transfer Not Allowed  Allowed  Allowed \nMain Memory to Buffer 2 Transfer Allowed Not Allowed Allowed \nMain Memory to Buffer 1 Compare Not Allowed Allowed Allowed \nMain Memory to Buffer 2 Compare Allowed Not Allowed Allowed \nEnter Deep Power-Down Not Allowed Not Allowed Not Allowed \nResume from Deep Power-Down Not Allowed Not Allowed Not Allowed \nEnter Ultra-Deep Power-Down mode Not Allowed Not Allowed Not Allowed \nRead Configuration Register Allowed Allowed Allowed \nRead Status Register Allowed Allowed Allowed \nRead Manufacturer and Device ID Allowed Allowed Allowed \nReset (via Hardware or Software) Allowed Allowed Allowed \n 17 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 6.12 Program/Erase Resume \nThe Program/Erase Resume command allows a suspended  program or erase operation to be resumed and conti nue \nwhere it left off. \nTo perform a Program/Erase Resume, an opcode of D0h  must be clocked into the device. No address bytes need to be \nclocked into the device, and any data clocked in af ter the opcode will be ignored. When the CS  pin is deasserted, the \nprogram or erase operation currently suspended will  be resumed within a time of t RES . The PS1 bit, PS2 bit, or ES bit in \nthe Status Register will then be reset back to a Lo gic 0 state to indicate that the program or erase o peration is no longer \nsuspended. In addition, the RDY/BUSY  bit in the Status Register will indicate that the d evice is busy performing a \nprogram or erase operation. \nDuring a simultaneous Erase Suspend/Program Suspend  condition, issuing the Program/Erase Resume comman d will \nresult in the program operation resuming first. Aft er the program operation has been completed, the Pr ogram/Erase \nResume command must be issued again in order for th e erase operation to be resumed. \nWhile the device is busy resuming a program or eras e operation, any attempts at issuing the Program/Er ase Suspend \ncommand will be ignored. Therefore, if a resumed pr ogram or erase operation needs to be subsequently s uspended \nagain, the system must either wait the entire t RES  time before issuing the Program/Erase Suspend comm and, or it must \ncheck the status of the RDY/BUSY  bit or the appropriate PS1, PS2, or ES bit in the Status Register to determine if the \npreviously suspended program or erase operation has  resumed. \n 18 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 7. Sector Protection \nTwo protection methods, hardware and software contr olled, are provided for protection against inadvert ent or erroneous \nprogram and erase cycles. The software controlled m ethod relies on the use of software commands to ena ble and \ndisable sector protection while the hardware contro lled method employs the use of the Write Protect (W P ) pin. The \nselection of which sectors that are to be protected  or unprotected against program and erase operation s is specified in \nthe Nonvolatile Sector Protection Register. The sta tus of whether or not sector protection has been en abled or disabled \nby either the software or the hardware controlled m ethods can be determined by checking the Status Reg ister. \n7.1 Software Sector Protection \nSoftware controlled protection is useful in applica tions in which the WP  pin is not or cannot be controlled by a host \nprocessor. In such instances, the WP  pin may be left floating (the WP  pin is internally pulled high) and sector protecti on \ncan be controlled using the Enable Sector Protectio n and Disable Sector Protection commands. \nIf the device is power cycled, then the software co ntrolled protection will be disabled. Once the devi ce is powered up, the \nEnable Sector Protection command should be reissued  if sector protection is desired and if the WP  pin is not used. \n7.1.1 Enable Sector Protection \nSectors specified for protection in the Sector Prot ection Register can be protected from program and e rase operations by \nissuing the Enable Sector Protection command. To en able the sector protection, a 4-byte command sequen ce of 3Dh, \n2Ah, 7Fh, and A9h must be clocked into the device. After the last bit of the opcode sequence has been clocked in, the \nCS  pin must be deasserted to enable the Sector Protec tion. \nTable 7-1. Enable Sector Protection Command \nFigure 7-1. Enable Sector Protection \n7.1.2 Disable Sector Protection \nTo disable the sector protection, a 4-byte command sequence of 3Dh, 2Ah, 7Fh, and 9Ah must be clocked into the \ndevice. After the last bit of the opcode sequence h as been clocked in, the CS  pin must be deasserted to disable the \nsector protection. \nTable 7-2. Disable Sector Protection Command Command Byte 1 Byte 2 Byte 3 Byte 4 \nEnable Sector Protection 3Dh 2Ah 7Fh A9h \n3Dh 2Ah 7Fh A9h CS \nEach transition represents eight bitsSI \nCommand Byte 1 Byte 2 Byte 3 Byte 4 \nDisable Sector Protection 3Dh 2Ah 7Fh 9Ah \n 19 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 7-2. Disable Sector Protection \n7.2 Hardware Controlled Protection \nSectors specified for protection in the Sector Prot ection Register and the Sector Protection Register itself can be \nprotected from program and erase operations by asse rting the WP  pin and keeping the pin in its asserted state. The  \nSector Protection Register and any sector specified  for protection cannot be erased or programmed as l ong as the WP  \npin is asserted. In order to modify the Sector Prot ection Register, the WP  pin must be deasserted. If the WP  pin is \npermanently connected to GND, then the contents of the Sector Protection Register cannot be changed. I f the WP  pin is \ndeasserted or permanently connected to V CC , then the contents of the Sector Protection Regist er can be modified. \nThe WP  pin will override the software controlled protecti on method but only for protecting the sectors. \nExample: If the sectors were not previously protected by the  Enable Sector Protection command, then simply \nasserting the WP  pin would enable the sector protection within the maximum specified t WPE  time. When the \nWP  pin is deasserted, however, the sector protection would no longer be enabled (after the maximum \nspecified t WPD  time) as long as the Enable Sector Protection comm and was not issued while the WP  pin was \nasserted. If the Enable Sector Protection command w as issued before or while the WP  pin was asserted, \nthen simply deasserting the WP  pin would not disable the sector protection. In th is case, the Disable Sector \nProtection command would need to be issued while th e WP  pin is deasserted to disable the sector \nprotection. The Disable Sector Protection command i s also ignored whenever the WP  pin is asserted. \nA noise filter is incorporated to help protect agai nst spurious noise that may inadvertently assert or  deassert the WP  pin. \nFigures 7-3 and  Table 7-3  detail the sector protection status for various sc enarios of the WP  pin, the Enable Sector \nProtection command, and the Disable Sector Protecti on command. \nFigure 7-3. WP  Pin and Protection Status \nTable 7-3. WP  Pin and Protection Status 3Dh 2Ah 7Fh 9Ah CS \nEach transition represents eight bitsSI \nTime \nPeriod WP  Pin Enable Sector Protection Command Disable Sector \nProtection Command Sector \nProtection \nStatus Sector \nProtection \nRegister \n1 High Command Not Issued Previously X Disabled Read/Write \n— Issue Command Disabled Read/Write \nIssue Command — Enabled Read/Write \n2 Low X X Enabled Read \n3 High Command Issued During Period 1 or 2 Not Issued Yet Enabled Read/Write \n— Issue Command Disabled Read/Write \nIssue Command — Enabled Read/Write WP 1 2 3\n 20 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 7.3 Sector Protection Register \nThe nonvolatile Sector Protection Register specifie s which sectors are to be protected or unprotected with either the \nsoftware or hardware controlled protection methods.  The Sector Protection Register contains thirty two  bytes of data, of \nwhich byte locations zero through thirty one contai n values that specify whether Sectors 0 through 31 will be protected or \nunprotected. The Sector Protection Register is user  modifiable and must be erased before it can be rep rogrammed. \nTable 7-4  illustrates the format of the Sector Protection Re gister. \nTable 7-4. Sector Protection Register \nNote: 1. The default values for bytes 0 through 31 ar e 00h when shipped from Adesto. \nTable 7-5. Sector 0 (0a, 0b) Sector Protection Regis ter Byte Value \nNote: 1. x = Don’t care \n7.3.1 Erase Sector Protection Register \nIn order to modify and change the values of the Sec tor Protection Register, it must first be erased us ing the Erase Sector \nProtection Register command. \nTo erase the Sector Protection Register, a 4-byte c ommand sequence of 3Dh, 2Ah, 7Fh, and CFh must be c locked into \nthe device. After the last bit of the opcode sequen ce has been clocked in, the CS  pin must be deasserted to initiate the \ninternally self-timed erase cycle. The erasing of t he Sector Protection Register should take place in a maximum time of \ntPE . During this time, the RDY/BUSY  bit in the Status Register will indicate that the d evice is busy. If the device is \npowered-down before the completion of the erase cyc le, then the contents of the Sector Protection Regi ster cannot be \nguaranteed. \nThe Sector Protection Register can be erased with s ector protection enabled or disabled. Since the era sed state (FFh) of \neach byte in the Sector Protection Register is used  to indicate that a sector is specified for protect ion, leaving the sector \nprotection enabled during the erasing of the regist er allows the protection scheme to be more effectiv e in the prevention \nof accidental programming or erasing of the device.  If for some reason an erroneous program or erase c ommand is sent \nto the device immediately after erasing the Sector Protection Register and before the register can be reprogrammed, \nthen the erroneous program or erase command will no t be processed because all sectors would be protect ed. \nTable 7-6. Erase Sector Protection Register Command Sector Number 0 (0a, 0b) 1 to 31 \nProtected \nSee Table 7-5 FFh \nUnprotected 00h \nBit 7:6 Bit 5:4 Bit 3:2 Bit 1:0 \nData \nValue Sector 0a \n(Page 0-7) Sector 0b \n(Page 8-1023) N/A N/A \nSectors 0a and 0b Unprotected 00 00 XX XX 0xh \nProtect Sector 0a 11 00 XX XX Cxh \nProtect Sector 0b 00 11 XX XX 3xh \nProtect Sectors 0a and 0b 11 11 XX XX Fxh \nCommand Byte 1 Byte 2 Byte 3 Byte 4 \nErase Sector Protection Register 3Dh 2Ah 7Fh CFh \n 21 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 7-4. Erase Sector Protection Register \n7.3.2 Program Sector Protection Register \nOnce the Sector Protection Register has been erased , it can be reprogrammed using the Program Sector P rotection \nRegister command. \nTo program the Sector Protection Register, a 4-byte  command sequence of 3Dh, 2Ah, 7Fh, and FCh must be  clocked \ninto the device followed by thirty two bytes of dat a corresponding to Sectors 0 through 31. After the last bit of the opcode \nsequence and data have been clocked in, the CS  pin must be deasserted to initiate the internally self-timed program \ncycle. The programming of the Sector Protection Reg ister should take place in a maximum time of t P. During this time, \nthe RDY/BUSY  bit in the Status Register will indicate that the d evice is busy. If the device is powered-down before  the \ncompletion of the erase cycle, then the contents of  the Sector Protection Register cannot be guarantee d. \nIf the proper number of data bytes is not clocked i n before the CS  pin is deasserted, then the protection status of t he \nsectors corresponding to the bytes not clocked in c annot be guaranteed. \nExample: If only the first two bytes are clocked in instead of the complete thirty two bytes, then the protecti on status of \nthe last thirty sectors cannot be guaranteed. Furth ermore, if more than thirty two bytes of data is cl ocked into \nthe device, then the data will wrap back around to the beginning of the register. For instance, if thi rty three \nbytes of data are clocked in, then the thirty third  byte will be stored at  byte location 0 of the Sector Protection \nRegister. \nThe data bytes clocked into the Sector Protection R egister need to be valid values (0xh, 3xh, Cxh, and  Fxh for Sector 0a \nor Sector 0b, and 00h or FFh for other sectors) in order for the protection to function correctly. If a non-valid value is \nclocked into a byte location of the Sector Protecti on Register, then the protection status of the sect or corresponding to \nthat byte location cannot be guaranteed. \nExample: If a value of 17h is clocked into byte location 2 o f the Sector Protection Register, then the protecti on status \nof Sector 2 cannot be guaranteed. \nThe Sector Protection Register can be reprogrammed while the sector protection is enabled or disabled.  Being able to \nreprogram the Sector Protection Register with the s ector protection enabled allows the user to tempora rily disable the \nsector protection to an individual sector rather th an disabling sector protection completely. \nThe Program Sector Protection Register command util izes Buffer 1 for processing. Therefore, the conten ts of Buffer 1 \nwill be altered from its previous state when this c ommand is issued. \nTable 7-7. Program Sector Protection Register Comman d 3Dh 2Ah 7Fh CFh CS \nEach transition represents eight bitsSI \nCommand Byte 1 Byte 2 Byte 3 Byte 4 \nProgram Sector Protection Register 3Dh 2Ah 7Fh FCh \n 22 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 7-5. Program Sector Protection Register \n7.3.3 Read Sector Protection Register \nTo read the Sector Protection Register, an opcode o f 32h and three dummy bytes must be clocked into th e device. After \nthe last bit of the opcode and dummy bytes have bee n clocked in, any additional clock pulses on the SC K pin will result \nin the Sector Protection Register contents being ou tput on the SO pin. The first byte (byte location 0 ) corresponds to \nSector 0 (0a and 0b), the second byte corresponds t o Sector 1, and the last byte (byte location 31) co rresponds to  \nSector 31. Once the last byte of the Sector Protect ion Register has been clocked out, any additional c lock pulses will \nresult in undefined data being output on the SO pin . The CS  pin must be deasserted to terminate the Read Secto r \nProtection Register operation and put the output in to a high-impedance state. \nTable 7-8. Read Sector Protection Register Command \nNote: 1. XX = Dummy byte \nFigure 7-6. Read Sector Protection Register \n7.3.4 About the Sector Protection Register \nThe Sector Protection Register is subject to a limi t of 10,000 erase/program cycles. Users are encoura ged to carefully \nevaluate the number of times the Sector Protection Register will be modified during the course of the application’s life \ncycle. If the application requires that the Securit y Protection Register be modified more than the spe cified limit of 10,000 \ncycles because the application needs to temporarily  unprotect individual sectors (sector protection re mains enabled \nwhile the Sector Protection Register is reprogramme d), then the application will need to limit this pr actice. Instead, a \ncombination of temporarily unprotecting individual sectors along with disabling sector protection comp letely will need to \nbe implemented by the application to ensure that th e limit of 10,000 cycles is not exceeded. Data Byte \nn3Dh 2Ah 7Fh FCh Data Byte \nn + 1 Data Byte \nn + 31 CS \nEach transition represents eight bitsSI \nCommand Byte 1 Byte 2 Byte 3 Byte 4 \nRead Sector Protection Register 32h XXh XXh XXh \n32h XX XX XX \nData \nnData \nn + 1 CS \nData \nn + 31 SI \nSO \nEach transition represents eight bits\n 23 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 8. Security Features \n8.1 Sector Lockdown \nThe device incorporates a sector lockdown mechanism  that allows each individual sector to be permanent ly locked so \nthat it becomes read-only (ROM). This is useful for  applications that require the ability to permanent ly protect a number of \nsectors against malicious attempts at altering prog ram code or security information. \nWarning: Once a sector is locked down, it can never be erase d or programmed, and it can never be unlocked. \nTo issue the sector lockdown command, a 4-byte comm and sequence of 3Dh, 2Ah, 7Fh, and 30h must be cloc ked into \nthe device followed by three address bytes specifyi ng any address within the sector to be locked down.  After the last \naddress bit has been clocked in, the CS  pin must be deasserted to initiate the internally self-timed lockdown sequence. \nThe lockdown sequence should take place in a maximu m time of t P. During this time, the RDY/BUSY  bit in the Status \nRegister will indicate that the device is busy. If the device is powered-down before the completion of  the lockdown \nsequence, then the lockdown status of the sector ca nnot be guaranteed. In this case, it is recommended  that the user \nread the Sector Lockdown Register to determine the status of the appropriate sector lockdown bits or b ytes and re-issue \nthe Sector Lockdown command if necessary. \nTable 8-1. Sector Lockdown Command \nFigure 8-1. Sector Lockdown \n8.1.1 Read Sector Lockdown Register \nThe nonvolatile Sector Lockdown Register specifies which sectors in the main memory are currently unlo cked or have \nbeen permanently locked down. The Sector Lockdown R egister is a read-only register and contains thirty  two bytes of \ndata which correspond to Sectors 0 through 31. To r ead the Sector Lockdown Register, an opcode of 35h must be \nclocked into the device followed by three dummy byt es. After the last bit of the opcode and dummy byte s have been \nclocked in, the data for the contents of the Sector  Lockdown Register will be clocked out on the SO pi n. The first byte \n(byte location 0) corresponds to Sector 0 (0a and 0 b), the second byte corresponds to Sector 1, and th e last byte (byte \nlocation 31) corresponds to Sector 31. After the la st byte of the Sector Lockdown Register has been re ad, additional \npulses on the SCK pin will result in undefined data  being output on the SO pin. \nDeasserting the CS  pin will terminate the Read Sector Lockdown Regist er operation and put the SO pin into a  \nhigh-impedance state. Table 8-2  details the format the Sector Lockdown Register. \nTable 8-2. Sector Lockdown Register Command Byte 1 Byte 2 Byte 3 Byte 4 \nSector Lockdown 3Dh 2Ah 7Fh 30h \n3Dh 2Ah 7Fh 30h CS \nAddress \nbyte Address \nbyte Address \nbyte SI \nEach transition represents eight bits\nSector Number 0 (0a, 0b) 1 to 31 \nLocked \nSee Table 8-3 FFh \nUnlocked 00h \n 24 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 8-3. Sector 0 (0a and 0b) Sector Lockdown Regi ster Byte Value \nTable 8-4. Read Sector Lockdown Register Command \nFigure 8-2. Read Sector Lockdown Register \n8.1.2 Freeze Sector Lockdown \nThe Sector Lockdown command can be permanently disa bled, and the current sector lockdown state can be \npermanently frozen so that no additional sectors ca n be locked down aside from those already locked do wn. Any \nattempts to issue the Sector Lockdown command after  the Sector Lockdown State has been frozen will be ignored. \nTo issue the Freeze Sector Lockdown command, the CS  pin must be asserted and the opcode sequence of 34 h, 55h, \nAAh, and 40h must be clocked into the device. Any a dditional data clocked into the device will be igno red. When the CS  \npin is deasserted, the current sector lockdown stat e will be permanently frozen within a time of t LOCK . In addition, the SLE \nbit in the Status Register will be permanently rese t to a Logic 0 to indicate that the Sector Lockdown  command is \npermanently disabled. \nTable 8-5. Freeze Sector Lockdown \nFigure 8-3. Freeze Sector Lockdown Bit 7:6 Bit 5:4 Bit 3:2 Bit 1:0 \nData \nValue Sector 0a \n(Page 0-7) Sector 0b \n(Page 8-1023) N/A N/A \nSectors 0a and 0b Unlocked 00 00 00 00 00h \nSector 0a Locked 11 00 00 00 C0h \nSector 0b Locked 00 11 00 00 30h \nSectors 0a and 0b Locked 11 11 00 00 F0h \nCommand Byte 1 Byte 2 Byte 3 Byte 4 \nRead Sector Lockdown Register 35h XXh XXh XXh \n32h XX XX XX \nData \nnData \nn + 1 CS \nData \nn + 31 SI \nSO \nEach transition represents eight bits\nCommand Byte 1 Byte 2 Byte 3 Byte 4 \nFreeze Sector Lockdown 34h 55h AAh 40h \n34h 55h AAh 40h CS \nSI \nEach transition represents eight bits\n 25 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 8.2 Security Register \nThe device contains a specialized Security Register  that can be used for purposes such as unique devic e serialization or \nlocked key storage. The register is comprised of a total of 128 bytes that is divided into two portion s. The first 64 bytes \n(byte locations 0 through 63) of the Security Regis ter are allocated as a One-Time Programmable space.  Once these  \n64 bytes have been programmed, they cannot be erase d or reprogrammed. The remaining 64 bytes of the re gister (byte \nlocations 64 through 127) are factory programmed by  Adesto and will contain a unique value for each de vice. The factory \nprogrammed data is fixed and cannot be changed. \nTable 8-6. Security Register \n8.2.1 Programming the Security Register \nThe user programmable portion of the Security Regis ter does not need to be erased before it is program med. \nTo program the Security Register, a 4-byte opcode s equence of 9Bh, 00h, 00h, and 00h must be clocked i nto the device. \nAfter the last bit of the opcode sequence has been clocked into the device, the data for the contents of the 64-byte user \nprogrammable portion of the Security Register must be clocked in. \nAfter the last data byte has been clocked in, the C S  pin must be deasserted to initiate the internally self-timed program \ncycle. The programming of the Security Register sho uld take place in a time of t P, during which time the RDY/BUSY  bit in \nthe Status Register will indicate that the device i s busy. If the device is powered-down during the pr ogram cycle, then the \ncontents of the 64-byte user programmable portion o f the Security Register cannot be guaranteed. \nIf the full 64 bytes of data are not clocked in bef ore the CS  pin is deasserted, then the values of the byte loc ations not \nclocked in cannot be guaranteed. \nExample: If only the first two bytes are clocked in instead of the complete 64 bytes, then the remaining 62 byt es of the \nuser programmable portion of the Security Register cannot be guaranteed. Furthermore, if more than  \n64 bytes of data is clocked into the device, then t he data will wrap back around to the beginning of t he \nregister. For example, if 65 bytes of data are cloc ked in, then the 65th byte will be stored at byte l ocation 0 of \nthe Security Register. \nWarning: The user programmable portion of the Security Regis ter can only be programmed one time.  \nTherefore, it is not possible, for example, to only  program the first two bytes of the register and th en program \nthe remaining 62 bytes at a later time. \nThe Program Security Register command utilizes Buff er 1 for processing. Therefore, the contents of  \nBuffer 1 will be altered from its previous state wh en this command is issued. \nFigure 8-4. Program Security Register Security Register Byte Number \n0 1 · · · 63 64 65 · · · 127 \nData Type One-Time User Programmable Factory Programmed by Adesto \nData \nn9Bh 00h 00h 00h Data \nn + 1 Data \nn + 63 CS \nSI \nEach transition represents eight bits\n 26 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 8.2.2 Reading the Security Register \nTo read the Security Register, an opcode of 77h and  three dummy bytes must be clocked into the device.  After the last \ndummy bit has been clocked in, the contents of the Security Register can be clocked out on the SO pin.  After the last \nbyte of the Security Register has been read, additi onal pulses on the SCK pin will result in undefined  data being output \non the SO pin. \nDeasserting the CS  pin will terminate the Read Security Register oper ation and put the SO pin into a high-impedance \nstate. \nFigure 8-5. Read Security Register \n77h XX XX XX \nData \nnData \nn + 1 CS \nData \nn + x SI \nSO \nEach transition represents eight bits\n 27 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 9. Additional Commands \n9.1 Main Memory Page to Buffer Transfer \nA page of data can be transferred from the main mem ory to either Buffer 1 or Buffer 2. To transfer a p age of data using \nthe standard DataFlash page size (264 bytes), an op code of 53h for Buffer 1 or 55h for Buffer 2 must b e clocked into the \ndevice followed by three address bytes comprised of  15 page address bits (PA14 - PA0) which specify th e page in main \nmemory to be transferred, and 9 dummy bits. To tran sfer a page of data using the binary page size (256  bytes), an \nopcode of 53h for Buffer 1 and 55h for Buffer 2 mus t be clocked into the device followed by three addr ess bytes \ncomprised of 1 dummy bit, 15 page address bits (A22  - A8) which specify the page in the main memory to  be transferred, \nand 8 dummy bits. \nThe CS  pin must be low while toggling the SCK pin to load  the opcode and the three address bytes from the in put pin \n(SI). The transfer of the page of data from the mai n memory to the buffer will begin when the CS  pin transitions from a \nlow to a high state. During the page transfer time (t XFR ), the RDY/BUSY  bit in the Status Register can be read to \ndetermine whether or not the transfer has been comp leted. \n9.2 Main Memory Page to Buffer Compare \nA page of data in main memory can be compared to th e data in Buffer 1 or Buffer 2 as a method to ensur e that data was \nsuccessfully programmed after a Buffer to Main Memo ry Page Program command. To compare a page of data with the \nstandard DataFlash page size (264 bytes), an opcode  of 60h for Buffer 1 or 61h for Buffer 2 must be cl ocked into the \ndevice followed by three address bytes comprised of  15 page address bits (PA14 - PA0) which specify th e page in the \nmain memory to be compared to the buffer, and 9 dum my bits. To compare a page of data with the binary page size (256 \nbytes), an opcode of 60h for Buffer 1 or 61h for Bu ffer 2 must be clocked into the device followed by three address bytes \ncomprised of 1 dummy bit, 15 page address bits (A22  - A8) which specify the page in the main memory to  be compared \nto the buffer, and 8 dummy bits. \nThe CS  pin must be low while toggling the SCK pin to load  the opcode and the address bytes from the input pi n (SI). On \nthe low-to-high transition of the CS  pin, the data bytes in the selected Main Memory Pa ge will be compared with the data \nbytes in Buffer 1 or Buffer 2. During the compare t ime (t COMP ), the RDY/BUSY  bit in the Status Register will indicate that \nthe part is busy. On completion of the compare oper ation, bit 6 of the Status Register will be updated  with the result of the \ncompare. \n9.3 Auto Page Rewrite \nThis command only needs to be used if the possibili ty exists that static (non-changing) data may be st ored in a page or \npages of a sector and the other pages of the same s ector are erased and programmed a large number of t imes. \nApplications that modify data in a random fashion w ithin a sector may fall into this category. To pres erve data integrity of \na sector, each page within a sector must be updated /rewritten at least once within every 50,000 cumula tive page \nerase/program operations within that sector. The Au to Page Rewrite command provides a simple and effic ient method to \n“refresh” a page in the main memory array in a sing le operation. \nThe Auto Page Rewrite command is a combination of t he Main Memory Page to Buffer Transfer and Buffer t o Main \nMemory Page Program with Built-In Erase commands. W ith the Auto Page Rewrite command, a page of data i s first \ntransferred from the main memory to Buffer 1 or Buf fer 2 and then the same data (from Buffer 1 or Buff er 2) is \nprogrammed back into the same page of main memory, essentially “refreshing” the contents of that page.  To start the \nAuto Page Rewrite operation with the standard DataF lash page size (264 bytes), a 1-byte opcode, 58H fo r Buffer 1 or \n59H for Buffer 2, must be clocked into the device f ollowed by three address bytes comprised of 15 page  address bits \n(PA14-PA0) that specify the page in main memory to be rewritten, and 9 dummy bits. \n 28 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 To initiate an Auto Page Rewrite with the a binary page size (256 bytes), the opcode 58H for Buffer 1 or 59H for Buffer 2, \nmust be clocked into the device followed by three a ddress bytes consisting of 1 dummy bit, 15 page add ress bits  \n(A22 - A8) that specify the page in the main memory  that is to be rewritten, and 8 dummy bits. When a low-to-high \ntransition occurs on the CS  pin, the part will first transfer data from the pa ge in main memory to a buffer and then \nprogram the data from the buffer back into same pag e of main memory. The operation is internally self- timed and should \ntake place in a maximum time of t EP . During this time, the RDY/BUSY  Status Register will indicate that the part is bus y. \nIf a sector is programmed or reprogrammed sequentia lly page by page and the possibility does not exist  that there will be \na page or pages of static data, then the programmin g algorithm shown in Figure 26-1 on page 61  is recommended. \nOtherwise, if there is a chance that there may be a  page or pages of a sector that will contain static  data, then the \nprogramming algorithm shown in Figure 26-2 on page 62  is recommended. Please contact Adesto for availabi lity of \ndevices that are specified to exceed the 50,000 cyc le cumulative limit. \nNote: The Auto Page Rewrite command uses the same op codes as the Read-Modify-Write command. If data \nbytes are clocked into the device, then the device will perform a Read-Modify-Write operation. See the  \nRead-Modify-Write command description on page 12  for more details. \n9.4 Status Register Read \nThe 2-byte Status Register can be used to determine  the device\'s ready/busy status, page size, a Main Memory Page to \nBuffer Compare operation result, the sector protect ion status, Freeze Sector Lockdown status, erase/pr ogram error \nstatus, Program/Erase Suspend status, and the devic e density. The Status Register can be read at any t ime, including \nduring an internally self-timed program or erase op eration. \nTo read the Status Register, the CS  pin must first be asserted and then the opcode D7h  must be clocked into the device. \nAfter the opcode has been clocked in, the device wi ll begin outputting Status Register data on the SO pin during every \nsubsequent clock cycle. After the second byte of th e Status Register has been clocked out, the sequenc e will repeat \nitself, starting again with the first byte of the S tatus Register, as long as the CS  pin remains asserted and the clock pin is \nbeing pulsed. The data in the Status Register is co nstantly being updated, so each repeating sequence may output new \ndata. The RDY/BUSY  status is available for both bytes of the Status R egister and is updated for each byte. \nDeasserting the CS  pin will terminate the Status Register Read operat ion and put the SO pin into a high-impedance \nstate. The CS  pin can be deasserted at any time and does not req uire that a full byte of data be read. \nTable 9-1. Status Register Format – Byte 1 \nNote: 1. R = Readable only Bit Name Type (1) Description \n7 RDY/BUSY Ready/Busy Status R0 Device is busy with an internal operation. \n1 Device is ready. \n6 COMP Compare Result R0 Main memory page data matches buffer data. \n1 Main memory page data does not match buffer data. \n5:2 DENSITY Density Code R 1111 64-Mbit \n1 PROTECT Sector Protection Status R0 Sector protection is disabled. \n1 Sector protection is enabled. \n0 PAGE SIZE Page Size Configuration R0 Device is configured for standard DataFlash page si ze (264 bytes). \n1 Device is configured for “power of 2” binary page s ize (256 bytes). \n 29 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 9-2. Status Register Format – Byte 2 \nNote: 1. R = Readable only \n9.4.1 RDY/BUSY  Bit \nThe RDY/BUSY  bit is used to determine whether or not an interna l operation, such as a program or erase, is in prog ress. \nTo poll the RDY/BUSY  bit to detect the completion of an internally time d operation, new Status Register data must be \ncontinually clocked out of the device until the sta te of the RDY/BUSY  bit changes from a Logic 0 to a Logic 1. \n9.4.2 COMP Bit \nThe result of the most recent Main Memory Page to B uffer Compare operation is indicated using the COMP  bit. If the \nCOMP bit is a Logic 1, then at least one bit of the  data in the Main Memory Page does not match the da ta in the buffer. \n9.4.3 DENSITY Bits \nThe device density is indicated using the DENSITY b its. For the AT45DB641E, the four bit binary value is 1111. The \ndecimal value of these four binary bits does not ac tually equate to the device density; the four bits represent a \ncombinational code relating to differing densities of DataFlash devices. The DENSITY bits are not the same as the \ndensity code indicated in the JEDEC Device ID infor mation. The DENSITY bits are provided only for back ward \ncompatibility to older generation DataFlash devices . \n9.4.4 PROTECT Bit \nThe PROTECT bit provides information to the user on  whether or not the sector protection has been enab led or disabled, \neither by the software-controlled method or the har dware-controlled method. \n9.4.5 PAGE SIZE Bit \nThe PAGE SIZE bit indicates whether the buffer size  and the page size of the main memory array is conf igured for the \n“power of 2” binary page size (256 bytes) or the st andard DataFlash page size (264 bytes). Bit Name Type (1) Description \n7 RDY/BUSY Ready/Busy Status R0 Device is busy with an internal operation. \n1 Device is ready. \n6 RES Reserved for Future Use R 0 Reserved for future use. \n5 EPE Erase/Program Error R0 Erase or program operation was successful. \n1 Erase or program error detected. \n4 RES Reserved for Future Use R 0 Reserved for future use. \n3 SLE Sector Lockdown Enabled R0 Sector Lockdown command is disabled. \n1 Sector Lockdown command is enabled. \n2 PS2 Program Suspend Status \n(Buffer 2) R0 No program operation has been suspended while using  Buffer 2. \n1 A sector is program suspended while using Buffer 2.\n1 PS1 Program Suspend Status \n(Buffer 1) R0 No program operation has been suspended while using  Buffer 1. \n1 A sector is program suspended while using Buffer 1.\n0 ES Erase Suspend R0 No sectors are erase suspended. \n1 A sector is erase suspended. \n 30 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 9.4.6 EPE Bit \nThe EPE bit indicates whether the last erase or pro gram operation completed successfully or not. If at  least one byte \nduring the erase or program operation did not erase  or program properly, then the EPE bit will be set to the Logic 1 state. \nThe EPE bit will not be set if an erase or program operation aborts for any reason, such as an attempt  to erase or \nprogram a protected region or a locked down sector or an attempt to erase or program a suspended secto r. The EPE bit \nis updated after every erase and program operation.\n9.4.7 SLE Bit \nThe SLE bit indicates whether or not the Sector Loc kdown command is enabled or disabled. If the SLE bi t is a Logic 1, \nthen the Sector Lockdown command is still enabled a nd sectors can be locked down. If the SLE bit is a Logic 0, then the \nSector Lockdown command has been disabled and no fu rther sectors can be locked down. \n9.4.8 PS2 Bit \nThe PS2 bit indicates if a program operation has be en suspended while using Buffer 2. If the PS2 bit i s a Logic 1, then a \nprogram operation has been suspended while Buffer 2  was being used, and any command attempts that woul d modify \nthe contents of Buffer 2 will be ignored. \n9.4.9 PS1 Bit \nThe PS1 bit indicates if a program operation has be en suspended while using Buffer 1. If the PS1 bit i s a Logic 1, then a \nprogram operation has been suspended while Buffer 1  was being used, and any command attempts that woul d modify \nthe contents of Buffer 1 will be ignored. \n9.4.10 The ES bit \nThe ES bit indicates whether or not an erase has be en suspended. If the ES bit is a Logic 1, then an e rase operation \n(page, block, sector, or chip) has been suspended. \n 31 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 10. Deep Power-Down \nDuring normal operation, the device will be placed in the standby mode to consume less power as long a s the CS  pin \nremains deasserted and no internal operation is in progress. The Deep Power-Down command offers the ab ility to place \nthe device into an even lower power consumption sta te called the Deep Power-Down mode. \nWhen the device is in the Deep Power-Down mode, all  commands including the Status Register Read comman d will be \nignored with the exception of the Resume from Deep Power-Down command. Since all commands will be igno red, the \nmode can be used as an extra protection mechanism a gainst program and erase operations. \nEntering the Deep Power-Down mode is accomplished b y simply asserting the CS  pin, clocking in the opcode B9h, and \nthen deasserting the CS  pin. Any additional data clocked into the device a fter the opcode will be ignored. When the CS  \npin is deasserted, the device will enter the Deep P ower-Down mode within the maximum time of t EDPD .\nThe complete opcode must be clocked in before the C S  pin is deasserted, and the CS  pin must be deasserted on an \neven byte boundary (multiples of eight bits); other wise, the device will abort the operation and retur n to the standby mode \nonce the CS  pin is deasserted. In addition, the device will de fault to the standby mode after a power cycle. \nThe Deep Power-Down command will be ignored if an i nternally self-timed operation such as a program or  erase cycle is \nin progress. The Deep Power-Down command must be re issued after the internally self-timed operation ha s been \ncompleted in order for the device to enter the Deep  Power-Down mode. \nFigure 10-1. Deep Power-Down \nSCKCS \nSI \nSO MSB\nICC 2 31 0\n1 0 1 1 1 0 0 16 75 4\nOpcode\nHigh-impedance\nStandby Mode CurrentActive Current\nDeep Power-Down Mode CurrenttEDPD\n 32 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 10.1 Resume from Deep Power-Down \nIn order to exit the Deep Power-Down mode and resum e normal device operation, the Resume from Deep Pow er-Down \ncommand must be issued. The Resume from Deep Power- Down command is the only command that the device wi ll \nrecognize while in the Deep Power-Down mode. \nTo resume from the Deep Power-Down mode, the CS  pin must first be asserted and then the opcode ABh  must be \nclocked into the device. Any additional data clocke d into the device after the opcode will be ignored.  When the CS  pin is \ndeasserted, the device will exit the Deep Power-Dow n mode and return to the standby mode within the ma ximum time of \ntRDPD . After the device has returned to the standby mode , normal command operations such as Continuous Arra y Read \ncan be resumed. \nIf the complete opcode is not clocked in before the  CS  pin is deasserted, or if the CS  pin is not deasserted on an even \nbyte boundary (multiples of eight bits), then the d evice will abort the operation and return to the De ep Power-Down \nmode. \nFigure 10-2. Resume from Deep Power-Down \nSCKCS \nSI \nSO MSB\nICC 2 31 0\n1 0 1 0 1 0 1 16 75 4\nOpcode\nHigh-impedance\nDeep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttRDPD\n 33 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 10.2 Ultra-Deep Power-Down \nThe Ultra-Deep Power-Down mode allows the device to  consume far less power compared to the standby and  Deep \nPower-Down modes by shutting down additional intern al circuitry. Since almost all active circuitry is shutdown in this \nmode to conserve power, the contents of the SRAM bu ffers cannot be maintained. Therefore, any data sto red in the \nSRAM buffers will be lost once the device enters th e Ultra-Deep Power-Down mode. \nWhen the device is in the Ultra-Deep Power-Down mod e, all commands including the Status Register Read and Resume \nfrom Deep Power-Down commands will be ignored. Sinc e all commands will be ignored, the mode can be use d as an \nextra protection mechanism against program and eras e operations. \nEntering the Ultra-Deep Power-Down mode is accompli shed by simply asserting the CS  pin, clocking in the opcode 79h, \nand then deasserting the CS  pin. Any additional data clocked into the device a fter the opcode will be ignored. When the \nCS  pin is deasserted, the device will enter the Ultra -Deep Power-Down mode within the maximum time of t EUDPD .\nThe complete opcode must be clocked in before the C S  pin is deasserted, and the CS  pin must be deasserted on an \neven byte boundary (multiples of eight bits); other wise, the device will abort the operation and retur n to the standby mode \nonce the CS  pin is deasserted. In addition, the device will de fault to the standby mode after a power cycle. \nThe Ultra-Deep Power-Down command will be ignored i f an internally self-timed operation such as a prog ram or erase \ncycle is in progress. The Ultra-Deep Power-Down com mand must be reissued after the internally self-tim ed operation \nhas been completed in order for the device to enter  the Ultra-Deep Power-Down mode. \nFigure 10-3. Ultra-Deep Power-Down \nSCKCS \nSI \nSO MSB\nICC 2 31 0\n06 75 4\nOpcode\nHigh-impedance\nUltra-Deep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttEUDPD\n1 1 1 1 0 0 1\n 34 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 10.2.1 Exit Ultra-Deep Power-Down \nTo exit from the Ultra-Deep Power-Down mode, the CS  pin must simply be pulsed by asserting the CS  pin, waiting the \nminimum necessary t CSLU  time, and then deasserting the CS  pin again. To facilitate simple software developme nt, a \ndummy byte opcode can also be entered while the CS  pin is being pulsed just as in a normal operation like the Program \nSuspend operation; the dummy byte opcode is simply ignored by the device in this case. After the CS  pin has been \ndeasserted, the device will exit from the Ultra-Dee p Power-Down mode and return to the standby mode wi thin a \nmaximum time of t XUDPD . If the CS  pin is reasserted before the t XUDPD  time has elapsed in an attempt to start a new \noperation, then that operation will be ignored and nothing will be performed. The system must wait for  the device to return \nto the standby mode before normal command operation s such as Continuous Array Read can be resumed. \nSince the contents of the SRAM buffers cannot be ma intained while in the Ultra-Deep Power-Down mode, t he SRAM \nbuffers will contain undefined data when the device  returns to the standby mode. \nFigure 10-4. Exit Ultra-Deep Power-Down \nChip Select Low \nBy asserting the CS pin, waiting the minimum necess ary t XUDPD  time, and then clocking in the first bit of the ne xt \nOpcode command cycle.  If the first bit of the next  command is clocked in before the t XUDPD time has elapsed, the \ndevice will exit Ultra Deep Power Down, however the  intended operation will be ignored. \nFigure 10-5. Exit Ultra-Deep Power-Down (Chip Select  Low) CS \nSO \nICC High-impedance\nUltra-Deep Power-Down Mode CurrentActive Current\nStandby Mode CurrenttXUDPDtCSLU \n\n 35 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 11. Buffer and Page Size Configuration \nThe memory array of DataFlash devices is actually l arger than other Serial Flash devices in that extra  user-accessible \nbytes are provided in each page of the memory array . For the AT45DB641E, there are an extra eight byte s of memory in \neach page for a total of an extra 256KB (2-Mbits) o f user-accessible memory. \nSome applications, however, may not want to take ad vantage of this extra memory and instead architect their software to \noperate on a “power of 2” binary, logical addressin g scheme. To allow this, the DataFlash can be confi gured so that the \nbuffer and page sizes are 256 bytes instead of the standard 264 bytes. In addition, the configuration of the buffer and \npage sizes is reversible and can be changed from 26 4 bytes to 256 bytes or from 256 bytes to 264 bytes . The configured \nsetting is stored in an internal nonvolatile regist er so that the buffer and page size configuration i s not affected by power \ncycles. The nonvolatile register has a limit of 10, 000 erase/program cycles; therefore, care should be  taken to not switch \nbetween the size options more than 10,000 times. \nDevices are initially shipped from Adesto with the buffer and page sizes set to 264 bytes. Devices can  be ordered from \nAdesto pre-configured for the “power of 2” binary s ize of 256 bytes. For details, see Section 27., Ordering Information \n(Standard DataFlash Page Size) on page 63 .\nTo configure the device for “power of 2” binary pag e size (256 bytes), a 4-byte opcode sequence of 3Dh , 2Ah, 80h, and \nA6h must be clocked into the device. After the last  bit of the opcode sequence has been clocked in, th e CS  pin must be \ndeasserted to initiate the internally self-timed co nfiguration process and nonvolatile register progra m cycle. The \nprogramming of the nonvolatile register should take  place in a time of t EP , during which time the RDY/BUSY  bit in the \nStatus Register will indicate that the device is bu sy. The device does not need to be power cycled aft er the completion of \nthe configuration process and register program cycl e in order for the buffer and page size to be confi gured to 256 bytes. \nTo configure the device for standard DataFlash page  size (264 bytes), a 4-byte opcode sequence of 3Dh,  2Ah, 80h, and \nA7h must be clocked into the device. After the last  bit of the opcode sequence has been clocked in, th e CS  pin must be \ndeasserted to initiate the internally self-timed co nfiguration process and nonvolatile register progra m cycle. The \nprogramming of the nonvolatile register should take  place in a time of t EP , during which time the RDY/BUSY  bit in the \nStatus Register will indicate that the device is bu sy. The device does not need to be power cycled aft er the completion of \nthe configuration process and register program cycl e in order for the buffer and page size to be confi gured to 264 bytes. \nTable 11-1. Buffer and Page Size Configuration Comma nds \nFigure 11-1. Buffer and Page Size Configuration Command Byte 1 Byte 2 Byte 3 Byte 4 \n“Power of 2” binary page size (256 bytes) 3Dh 2Ah 80h A6h \nDataFlash page size (264 bytes) 3Dh 2Ah 80h A7h \nCS \nSI 3Dh 2Ah 80hOpcode\nByte 4\nEach transition represents eight bits\n 36 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 12. Manufacturer and Device ID Read \nIdentification information can be read from the dev ice to enable systems to electronically query and i dentify the device \nwhile it is in the system. The identification metho d and the command opcode comply with the JEDEC Stan dard for \n“Manufacturer and Device ID Read Methodology for SP I Compatible Serial Interface Memory Devices”. The type of \ninformation that can be read from the device includ es the JEDEC-defined Manufacturer ID, the vendor-sp ecific  \nDevice ID, and the vendor-specific Extended Device Information. \nThe Read Manufacturer and Device ID command is limi ted to a maximum clock frequency of f CLK . Since not all Flash \ndevices are capable of operating at very high clock  frequencies, applications should be designed to re ad the \nidentification information from the devices at a re asonably low clock frequency to ensure that all dev ices to be used in the \napplication can be identified properly. Once the id entification process is complete, the application c an then increase the \nclock frequency to accommodate specific Flash devic es that are capable of operating at the higher cloc k frequencies. \nTo read the identification information, the CS  pin must first be asserted and then the opcode 9Fh  must be clocked into \nthe device. After the opcode has been clocked in, t he device will begin outputting the identification data on the SO pin \nduring the subsequent clock cycles. The first byte to be output will be the Manufacturer ID, followed by two bytes of the  \nDevice ID information. The fourth byte output will be the Extended Device Information (EDI) String Len gth, which will be \n01h indicating that one byte of EDI data follows. A fter the one byte of EDI data is output, the SO pin  will go into a  \nhigh-impedance state; therefore, additional clock c ycles will have no affect on the SO pin and no data  will be output. As \nindicated in the JEDEC Standard, reading the EDI St ring Length and any subsequent data is optional. \nDeasserting the CS  pin will terminate the Manufacturer and Device ID Read operation and put the SO pin into a  \nhigh-impedance state. The CS  pin can be deasserted at any time and does not req uire that a full byte of data be read. \nTable 12-1. Manufacturer and Device ID Information \nTable 12-2. Manufacturer and Device ID Details Byte No. Data Type Value \n1 Manufacturer ID 1Fh \n2 Device ID (Byte 1) 28h \n3 Device ID (Byte 2) 00h \n4 [Optional to Read] Extended Device Information (EDI ) String Length 01h \n5 [Optional to Read] EDI Byte 1 00h \nData Type Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Hex \nValue Details \nManufacturer ID JEDEC Assigned Code \n1Fh JEDEC code: 0001 1111 (1Fh for Adesto) \n0 0 0 1 1 1 1 1\nDevice ID (Byte 1) Family Code Density Code \n28h Family code: 001 (AT45Dxxx Family)  \nDensity code: 01000 (64-Mbit) 0 0 1 0 1 0 0 0\nDevice ID (Byte 2) Sub Code Product Variant \n00h Sub code: 000 (Standard Series)  \nProduct variant: 00000 0 0 0 0 0 0 0 0\n 37 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 12-3. EDI Data \nFigure 12-1. Read Manufacturer and Device ID Byte Number Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 Hex \nValue Details \n1RFU Device Revision \n00h RFU: Reserved for Future Use  \nDevice revision: 00000 (Initial Version) 0 0 0 0 0 0 0 0\nSCKCS \nSI \nSO 6 0\n9Fh8 7 46 \nOpcode\n1Fh 00h 01h 00h\nManufacturer ID Device ID\nByte 1Device ID \nByte 2EDI\nString LengthEDI\nData Byte 1High-impedance14 16 15 22 24 23 38 40 39 30 32 31 \nNote:  Each transition shown for SI and SO represents one byte (8 bits)28h\n 38 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 13. Software Reset \nIn some applications, it may be necessary to premat urely terminate a program or erase cycle early rath er than wait the \nhundreds of microseconds or milliseconds necessary for the program or erase operation to complete norm ally. The \nSoftware Reset command allows a program or erase op eration in progress to be ended abruptly and return s the device \nto an idle state. \nTo perform a Software Reset, the CS  pin must be asserted and a 4-byte command sequence  of F0h, 00h, 00h, and 00h \nmust be clocked into the device. Any additional dat a clocked into the device after the last byte will be ignored. When the \nCS  pin is deasserted, the program or erase operation currently in progress will be terminated within a t ime t SWRST . Since \nthe program or erase operation may not complete bef ore the device is reset, the contents of the page b eing programmed \nor erased cannot be guaranteed to be valid. \nThe Software Reset command has no effect on the sta tes of the Sector Protection Register, the Sector L ockdown \nRegister, or the buffer and page size configuration . The PS2, PS1, and ES bits of the Status Register,  however, will be \nreset back to their default states. If a Software R eset operation is performed while a sector is erase  suspended, the \nsuspend operation will abort and the contents of th e page or block being erased in the suspended secto r will be left in an \nundefined state. If a Software Reset is performed w hile a sector is program suspended, the suspend ope ration will abort \nand the contents of the page that was being program med and subsequently suspended will be undefined. T he remaining \npages in the sector will retain their previous cont ents. \nThe complete 4-byte opcode must be clocked into the  device before the CS  pin is deasserted, and the CS  pin must be \ndeasserted on a byte boundary (multiples of eight b its); otherwise, no reset operation will be perform ed. \nTable 13-1. Software Reset \nFigure 13-1. Software Reset Command Byte 1 Byte 2 Byte 3 Byte 4 \nSoftware Reset F0h 00h 00h 00h \nCS \nSI F0h 00h 00h 00h\nEach transition represents eight bits\n 39 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 14. Operation Mode Summary \nThe commands described previously can be grouped in to four different categories to better describe whi ch commands \ncan be executed at what times. \nGroup A commands consist of: \n1. Main Memory Page Read \n2. Continuous Array Read (SPI) \n3. Read Sector Protection Register \n4. Read Sector Lockdown Register \n5. Read Security Register \n6. Buffer 1 (or 2) Read \nGroup B commands consist of: \n1. Page Erase \n2. Block Erase \n3. Sector Erase \n4. Chip Erase \n5. Main Memory Page to Buffer 1 (or 2) Transfer \n6. Main Memory Page to Buffer 1 (or 2) Compare \n7. Buffer 1 (or 2) to Main Memory Page Program with Built-In Erase \n8. Buffer 1 (or 2) to Main Memory Page Program witho ut Built-In Erase \n9. Main Memory Page Program through Buffer 1 (or 2) with Built-In Erase \n10. Main Memory Byte/Page Program through Buffer 1 w ithout Built-In Erase \n11. Auto Page Rewrite \n12. Read-Modify-Write \nGroup C commands consist of: \n1. Buffer 1 (or 2) Write \n2. Status Register Read \n3. Manufacturer and Device ID Read \nGroup D commands consist of: \n1. Erase Sector Protection Register \n2. Program Sector Protection Register \n3. Sector Lockdown \n4. Program Security Register \n5. Buffer and Page Size Configuration \n6. Freeze Sector Lockdown \nIf a Group A command is in progress (not fully comp leted), then another command in Group A, B, C, or D  should not be \nstarted. However, during the internally self-timed portion of Group B commands, any command in Group C  can be \nexecuted. The Group B commands using Buffer 1 shoul d use Group C commands using Buffer 2 and vice vers a. Finally, \nduring the internally self-timed portion of a Group  D command, only the Status Register Read command s hould be \nexecuted. \nMost of the commands in Group B can be suspended an d resumed, except the Buffer Transfer, Buffer Compa re, Auto \nPage Rewrite and Read-Modify-Write operations. If a  Group B command is suspended, all of the Group A c ommands \ncan be executed. See Table 6-4  to determine which of the Group B, Group C, and Gro up D commands are allowed. \n 40 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 15. Command Tables \nTable 15-1. Read Commands \nTable 15-2. Program and Erase Commands Command Opcode \nMain Memory Page Read D2h \nContinuous Array Read (Low Power Mode) 01h \nContinuous Array Read (Low Frequency) 03h \nContinuous Array Read (High Frequency) 0Bh \nContinuous Array Read (High Frequency) 1Bh \nContinuous Array Read (Legacy Command – Not Recomme nded for New Designs) E8h \nBuffer 1 Read (Low Frequency) D1h \nBuffer 2 Read (Low Frequency) D3h \nBuffer 1 Read (High Frequency) D4h \nBuffer 2 Read (High Frequency) D6h \nCommand Opcode \nBuffer 1 Write 84h \nBuffer 2 Write 87h \nBuffer 1 to Main Memory Page Program with Built-In Erase 83h \nBuffer 2 to Main Memory Page Program with Built-In Erase 86h \nBuffer 1 to Main Memory Page Program without Built- In Erase 88h \nBuffer 2 to Main Memory Page Program without Built- In Erase 89h \nMain Memory Page Program through Buffer 1 with Buil t-In Erase 82h \nMain Memory Page Program through Buffer 2 with Buil t-In Erase 85h \nMain Memory Byte/Page Program through Buffer 1 with out Built-In Erase 02h \nPage Erase 81h \nBlock Erase 50h \nSector Erase 7Ch \nChip Erase C7h + 94h + 80h + 9Ah \nProgram/Erase Suspend B0h \nProgram/Erase Resume D0h \nRead-Modify-Write through Buffer 1 58h \nRead-Modify-Write through Buffer 2 59h \n 41 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 15-3. Protection and Security Commands \nTable 15-4. Additional Commands \nTable 15-5. Legacy Commands (1)(2) \nNotes: 1. Legacy commands are not recommended for new  designs. \n2. Legacy commands operate from 2.30V to 3.60V Vcc o nly. Command Opcode \nEnable Sector Protection 3Dh + 2Ah + 7Fh + A9h \nDisable Sector Protection 3Dh + 2Ah + 7Fh + 9Ah \nErase Sector Protection Register 3Dh + 2Ah + 7Fh + CFh \nProgram Sector Protection Register 3Dh + 2Ah + 7Fh + FCh \nRead Sector Protection Register 32h \nSector Lockdown 3Dh + 2Ah + 7Fh + 30h \nRead Sector Lockdown Register 35h \nFreeze Sector Lockdown 34h + 55h + AAh + 40h \nProgram Security Register 9Bh + 00h + 00h + 00h \nRead Security Register 77h \nCommand Opcode \nMain Memory Page to Buffer 1 Transfer 53h \nMain Memory Page to Buffer 2 Transfer 55h \nMain Memory Page to Buffer 1 Compare 60h \nMain Memory Page to Buffer 2 Compare 61h \nAuto Page Rewrite 58h \nAuto Page Rewrite 59h \nDeep Power-Down B9h \nResume from Deep Power-Down ABh \nUltra-Deep Power-Down 79h \nStatus Register Read D7h \nManufacturer and Device ID Read 9Fh \nConfigure “Power of 2” (Binary) Page Size 3Dh + 2Ah + 80h + A6h \nConfigure Standard DataFlash Page Size 3Dh + 2Ah + 80h + A7h \nSoftware Reset F0h + 00h + 00h + 00h \nCommand Opcode \nBuffer 1 Read 54H \nBuffer 2 Read 56H \nMain Memory Page Read 52H \nContinuous Array Read 68H \nStatus Register Read 57H \n 42 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 15-6. Detailed Bit-level Addressing Sequence f or Binary Page Size (256 bytes) \nNote: 1. Shown to indicate when the Auto Page Rewrite  operation is executed. \n2. Shown to indicate when the Read-Modify-Write oper ation is executed. \n3. X = Dummy Bit Page Size = 256 bytes Address Byte Address Byte Address Byte \nAdditional \nDummy \nBytes Opcode Opcode \nReserved \nA22\nA21 \nA20\nA19 \nA18 \nA17 \nA16 \nA15 \nA14 \nA13 \nA12 \nA11 \nA10 \nA9 \nA8 \nA7 \nA6 \nA5\nA4 \nA3\nA2 \nA1\nA0 \n01h 00000001XAAAAAAAAAAAAAAAAAAAAAAA N/A \n02h 00000010XAAAAAAAAAAAAAAAAAAAAAAA N/A \n03h 00000011XAAAAAAAAAAAAAAAAAAAAAAA N/A \n0Bh 00001011XAAAAAAAAAAAAAAAAAAAAAAA 1\n1Bh 00011011XAAAAAAAAAAAAAAAAAAAAAAA 2\n32h 00110010XXXXXXXXXXXXXXXXXXXXXXXX N/A \n35h 00110101XXXXXXXXXXXXXXXXXXXXXXXX N/A \n50h 01010000XAAAAAAAAAAAAXXXXXXXXXXX N/A \n53h 01010011XAAAAAAAAAAAAAAAXXXXXXXX N/A \n55h 01010101XAAAAAAAAAAAAAAAXXXXXXXX N/A \n58h (1) 01011000XAAAAAAAAAAAAAAAXXXXXXXX N/A \n59h (1) 01011001XAAAAAAAAAAAAAAAXXXXXXXX N/A \n58h (2) 01011000XAAAAAAAAAAAAAAAAAAAAAAA N/A \n59h (2) 01011001XAAAAAAAAAAAAAAAAAAAAAAA N/A \n60h 01100000XAAAAAAAAAAAAAAAXXXXXXXX N/A \n61h 01100001XAAAAAAAAAAAAAAAXXXXXXXX N/A \n77h 01110111XXXXXXXXXXXXXXXXXXXXXXXX N/A \n79h 01111001 N/A N/A N/A N/A \n7Ch 01111100XAAAAAXXXXXXXXXXXXXXXXXX N/A \n81h 10000001XAAAAAAAAAAAAAAAXXXXXXXX N/A \n82h 10000010XAAAAAAAAAAAAAAAAAAAAAAA N/A \n83h 10000011XAAAAAAAAAAAAAAAXXXXXXXX N/A \n84h 10000100XXXXXXXXXXXXXXXXAAAAAAAA N/A \n85h 10000101XAAAAAAAAAAAAAAAAAAAAAAA N/A \n86h 10000110XAAAAAAAAAAAAAAAXXXXXXXX N/A \n87h 10000111XXXXXXXXXXXXXXXXAAAAAAAA N/A \n88h 10001000XAAAAAAAAAAAAAAAXXXXXXXX N/A \n89h 10001001XAAAAAAAAAAAAAAAXXXXXXXX N/A \n9Fh 10011111 N/A N/A N/A N/A \nB9h 10111001 N/A N/A N/A N/A \nABh 10101011 N/A N/A N/A N/A \nB0h 10110000 N/A N/A N/A N/A \nD0h 11010000 N/A N/A N/A N/A \nD1h 11010001XXXXXXXXXXXXXXXXAAAAAAAA N/A \nD2h 11010010XAAAAAAAAAAAAAAAAAAAAAAA 4 \nD3h 11010011XXXXXXXXXXXXXXXXAAAAAAAA N/A \nD4h 11010100XXXXXXXXXXXXXXXXAAAAAAAA 1\nD6h 11010110XXXXXXXXXXXXXXXXAAAAAAAA 1\nD7h 11010111 N/A N/A N/A N/A \n 43 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Table 15-7. Detailed Bit-level Addressing Sequence f or Standard DataFlash Page Size (264 bytes) \nNotes: 1. Shown to indicate when the Auto Page Rewrit e operation is executed. \n2. Shown to indicate when the Read-Modify-Write oper ation is executed. \n3. P = Page Address Bit,  B = Byte/Buffer Address Bi t,   X = Dummy Bit Page Size = 264 bytes Address Byte Address Byte Address Byte Additional \nDummy \nBytes Opcode Opcode \nPA14\nPA13\nPA12\nPA11\nPA10\nPA9\nPA8\nPA7\nPA6 \nPA5\nPA4 \nPA3 \nPA2\nPA1 \nPA0 \nBA8 \nBA7 \nBA6 \nBA5\nBA4 \nBA3\nBA2 \nBA1\nBA0 \n01h 00000001PPPPPPPPPPPPPPPBBBBBBBBB N/A \n02h 00000010PPPPPPPPPPPPPPPBBBBBBBBB N/A \n03h 00000011PPPPPPPPPPPPPPPBBBBBBBBB N/A \n0Bh 00001011PPPPPPPPPPPPPPPBBBBBBBBB 1\n1Bh 00011011PPPPPPPPPPPPPPPBBBBBBBBB 2\n32h 00110010XXXXXXXXXXXXXXXXXXXXXXXX N/A \n35h 00110101XXXXXXXXXXXXXXXXXXXXXXXX N/A \n50h 01010000PPPPPPPPPPPPXXXXXXXXXXXX N/A \n53h 01010011PPPPPPPPPPPPPPP XXXXXXXXX N/A \n55h 01010101PPPPPPPPPPPPPPPXXXXXXXXX N/A \n58h (1) 01011000PPPPPPPPPPPPPPPXXXXXXXXX N/A \n59h (1) 01011001PPPPPPPPPPPPPPPXXXXXXXXX N/A \n58h (2) 01011000PPPPPPPPPPPPPPPBBBBBBBBB N/A \n59h (2) 01011001PPPPPPPPPPPPPPPBBBBBBBBB N/A \n60h 01100000PPPPPPPPPPPPPPPXXXXXXXXX N/A \n61h 01100001PPPPPPPPPPPPPPPXXXXXXXXX N/A \n77h 01110111XXXXXXXXXXXXXXXXXXXXXXXX N/A \n79h 01111001 N/A N/A N/A N/A \n7Ch 01111100PPPPPXXXXXXXXXXXXXXXXXXX N/A \n81h 10000001PPPPPPPPPPPPPPPXXXXXXXXX N/A \n82h 10000010PPPPPPPPPPPPPPPBBBBBBBBB N/A \n83h 10000011PPPPPPPPPPPPPPPXXXXXXXXX N/A \n84h 10000100XXXXXXXXXXXXXXXBBBBBBBBB N/A \n85h 10000101PPPPPPPPPPPPPPPBBBBBBBBB N/A \n86h 10000110PPPPPPPPPPPPPPPXXXXXXXXX N/A \n87h 10000111XXXXXXXXXXXXXXXBBBBBBBBB N/A \n88h 10001000PPPPPPPPPPPPPPPXXXXXXXXX N/A \n89h 10001001PPPPPPPPPPPPPPPXXXXXXXXX N/A \n9Fh 10011111 N/A N/A N/A N/A \nB9h 10111001 N/A N/A N/A N/A \nABh 10101011 N/A N/A N/A N/A \nB0h 10110000 N/A N/A N/A N/A \nD0h 11010000 N/A N/A N/A N/A \nD1h 11010001XXXXXXXXXXXXXXXBBBBBBBBB N/A \nD2h 11010010PPPPPPPPPPPPPPPBBBBBBBBB 4\nD3h 11010001XXXXXXXXXXXXXXXBBBBBBBBB N/A \nD4h 11010100XXXXXXXXXXXXXXXBBBBBBBBB 1\nD6h 11010110XXXXXXXXXXXXXXXBBBBBBBBB 1\nD7h 11010111 N/A N/A N/A N/A \n 44 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 16. Power-On/Reset State \nWhen power is first applied to the device, or when recovering from a reset condition, the output pin ( SO) will be in a high \nimpedance state, and a high-to-low transition on th e CSB pin will be required to start a valid instruc tion. The SPI mode \n(Mode 3 or Mode 0) will be automatically selected o n every falling edge of CSB by sampling the inactiv e clock state. \n16.1 Power-Up/Power-Down Voltage and Timing Requirem ents \nDuring power-up, the device must not be READ for at  least the minimum t VCSL  time after the supply voltage reaches the \nminimum V POR  level (V POR  min). While the device is being powered-up, the in ternal Power-On Reset (POR) circuitry \nkeeps the device in a reset mode until the supply v oltage rises above the minimum V cc . During this time, all operations \nare disabled and the device will not respond to any  commands. \nIf the first operation to the device after power-up  will be a program or erase operation, then the ope ration cannot be \nstarted until the supply voltage reaches the minimu m V CC  level and an internal device delay has elapsed. Th is delay will \nbe a maximum time of t PUW . After the t PUW  time, the device will be in the standby mode if CS B is at logic high or active \nmode if CSB is at logic low. For the case of Power- down then Power-up operation, or if a power interru ption occurs (such \nthat VCC drops below V POR  max), the V cc  of the Flash device must be maintained below V PWD  for at least the minimum \nspecified T PWD  time. This is to ensure the Flash device will rese t properly after a power interruption. \nTable 16-1. Voltage and Timing Requirements for Powe r-Up/Power-Down \nFigure 16-1. Power-Up Timing Symbol Parameter Min Max Units \nVPWD  (1) \n1. Not 100% tested (value guaranteed by design and c haracterization). VCC  for device initialization 1.0 V\ntPWD (1) Minimum duration for device initialization 300 µs \ntVCSL Minimum V CC  to chip select low time for Read command 70 µs \ntVR (1) VCC rise time 1 500000 µs/V \nVPOR  Power on reset voltage 1.45 1.6 V\ntPUW Power up delay time before Program or Erase is allo wed 3 ms \nVCC \n V POR  max\nMax V PWDChip Select Not Permitted \nTime tPWDtPUW Full Operation Permitted \ntVR tVCSL Read Operation \nPermitted \n 45 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 17. System Considerations \nThe serial interface is controlled by the Serial Cl ock (SCK), Serial Input (SI), and Chip Select (CS ) pins. These signals \nmust rise and fall monotonically and be free from n oise. Excessive noise or ringing on these pins can be misinterpreted \nas multiple edges and cause improper operation of t he device. PCB traces must be kept to a minimum dis tance or \nappropriately terminated to ensure proper operation . If necessary, decoupling capacitors can be added on these pins to \nprovide filtering against noise glitches. \nAs system complexity continues to increase, voltage  regulation is becoming more important. A key eleme nt of any \nvoltage regulation scheme is its current sourcing c apability. Like all Flash memories, the peak curren t for DataFlash \ndevices occurs during the programming and erasing o perations. The supply voltage regulator needs to be  able to supply \nthis peak current requirement. An under specified r egulator can cause current starvation. Besides incr easing system \nnoise, current starvation during programming or era sing can lead to improper operation and possible da ta corruption. \n 46 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 18. Electrical Specifications \n18.1 Absolute Maximum Ratings* \n18.2 DC and AC Operating Range Temperature under Bias  . . . . . . . -55°C to +125° C \nStorage Temperature. . . . . . . . . . -65°C to +15 0°C \nAll Input Voltages  \n(except V CC  but including NC pins)  \nwith Respect to Ground. . . . . . -0.6V to VCC  + 0.6V \nAll Output Voltages  \nwith Respect to Ground. . . . . . -0.6V to V CC  + 0.6V *Notice: Stresses beyond those listed under “Absolut e Maximum \nRatings” may cause permanent damage to the device. The \n“Absolute Maximum Ratings” are stress ratings only and \nfunctional operation of the device at these or any other \nconditions beyond those indicated in the operationa l \nsections of this specification is not implied. Expo sure to \nabsolute maximum rating conditions for extended per iods \nmay affect device reliability. Voltage extremes ref erenced in \nthe “Absolute Maximum Ratings” are intended to \naccommodate short duration undershoot/overshoot \nconditions and does not imply or guarantee function al device \noperation at these levels for any extended period o f time. \nAT45DB641E \nOperating Temperature (Case) Industrial -40 °C to 85 °C\nVCC  Power Supply 1.7V to 3.6V \n 47 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 18.3 DC Characteristics \nNotes: 1. Typical values measured at 3.0V at 25 °C. \n2. ICC2  during a Buffer Read is 20mA maximum @ 20MHz. Symbol Parameter Condition 1.7V to 3.6V 2.3V to 3.6V \nMin Typ Max Min Typ Max Unit \ns\nIUDPD Ultra-Deep Power-  \nDown Current CS  = VCC. All other \ninputs at 0V or V CC. 0.3 1 0.4 1 µA\nIDPD Deep Power-Down  \nCurrent CS  = VCC. All other \ninputs at 0V or V CC. 5 25 6 25 µA \nISB Standby Current CS  = VCC. All other \ninputs at 0V or V CC. 25 45 25 45 µA\nICC1 Active Current, \nLow  \nPower Read (01h)  \nOperation f = 1MHz; I OUT  = 0mA 6 9 6 9 mA \nf = 15MHz; I OUT  = 0mA 7 11 7 11 mA \nICC2 (1)(2) Active Current,  \nRead Operation f = 50MHz; I OUT  = 0mA 12 17 12 17 mA \nf = 85MHz; I OUT  = 0mA 16 22 16 22 mA \nICC3 Active Current,  \nProgram Operation CS = VCC  14 16 14 16 mA \nICC4 Active Current,  \nErase Operation CS = VCC  8 12 8 12 mA \nILI Input Load Current All inputs at CMOS  \nlevels 1 1 µA\nILO Output Leakage  \nCurrent All inputs at CMOS  \nlevels 1 1 µA\nVIL Input Low Voltage VCC  x 0.3 VCC  x 0.3 V\nVIH Input High Voltage VCC  x 0.7 VCC  + 0.6 VCC  x 0.7 VCC  + 0.6 V\nVOL Output Low \nVoltage IOL  = 100µA 0.4 0.4 V\nVOH Output High \nVoltage IOH  = -100µA VCC  - 0.2V VCC  - 0.2V V\n 48 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 18.4 AC Characteristics \nNote: 1. Values are based on device characterization,  not 100% tested in production.  1.7V to 3.6V 2.3V to 3.6V \nSymbol Parameter Min Max Min Max Units \nfSCK SCK Frequency 50 85 MHz \nfCAR1 SCK Frequency for Continuous Read (0x0B) 50 85 MHz \nfCAR2 SCK Frequency for Continuous Read (Low Frequency)(0 x03) 40 50 MHz \nfCAR3 SCK Frequency for Continuous Read (Low Power Mode  \n– 01h Opcode) 15 15 MHz \nfCAR4 SCK Frequency for Continuous Read (0x1B) 66 104 MHz \ntWH SCK High Time 4.5 4.5 ns \ntWL SCK Low Time 4.5 4.5 ns \ntSCKR (1) SCK Rise Time, Peak-to-peak 0.1 0.1 V/ns \ntSCKF (1) SCK Fall Time, Peak-to-peak 0.1 0.1 V/ns \ntCS Minimum CS  High Time 30 30 ns \ntCSS CS  Setup Time 6 5 ns \ntCSH CS  Hold Time 5 5 ns \ntSU Data In Setup Time 2 2 ns \ntH Data In Hold Time 1 1 ns \ntHO Output Hold Time 0 0 ns \ntDIS (1) Output Disable Time 8 6 ns \ntV Output Valid 7 6 ns \ntWPE WP  Low to Protection Enabled 1 1 µs\ntWPD WP  High to Protection Disabled 1 1 µs\ntLOCK Freeze Sector Lockdown Time (from CS  High) 200 200 µs\ntEUDPD (1) CS  High to Ultra-Deep Power-Down 3 3 µs\ntCSLU Minimum CS  Low Time to Exit Ultra-Deep Power-Down 20 20 ns \ntXUDPD Exit Ultra-Deep Power-Down Time 100 100 µs\ntEDPD (1) CS  High to Deep Power-Down 2 2 µs\ntRDPD Resume from Deep Power-Down Time 35 35 µs\ntXFR Page to Buffer Transfer Time 180 180 µs\ntCOMP Page to Buffer Compare Time 180 180 µs\ntRST RESET  Pulse Width 10 10 µs\ntREC RESET  Recovery Time 1 1 µs\ntSWRST  Software Reset Time 35 35 µs\n 49 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 18.5 Program and Erase Characteristics \nNotes: 1. Values are based on device characterization , not 100% tested in production. \n2. Not 100% tested (value guaranteed by design and c haracterization). \n19. Input Test Waveforms and Measurement Levels \n20. Output Test Load 1.7V to 3.6V 2.3V to 3.6V \nSymbol Parameter Min Typ Max Min Typ Max Units \ntEP Page Erase and Programming  \nTime (256/264 bytes) 10 35 8 35 ms \ntP Page Programming Time 1.5 5 1.5 3 ms \ntBP Byte Programming Time 8 8 µs\ntPE Page Erase Time 7 35 7 35 ms \ntBE Block Erase Time 25 50 25 50 ms \ntSE Sector Erase Time 2.5 6.5 2.5 6.5 s\ntCE Chip Erase Time 80 208 80 208 s\ntSUSP Suspend Time Program 8 12 8 12 \nµs\nErase 20 30 20 30\ntRES Resume Time Program 3 5 3 5\nµs\nErase 3 5 3 5\ntOTPP OTP Security Register Program Time 200 500 200 500 µs\nAC \nDriving\nLevelsAC \nMeasurement\nLevel0.1VCC VCC /2 0.9VCC \ntR, tF < 2ns (10% to 90%)\nDevice\nUnder\nTest\n30pF\n 50 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 21. Utilizing the RapidS Function \nTo take advantage of the RapidS function\'s ability to operate at higher clock frequencies, a full cloc k cycle must be used \nto transmit data back and forth across the serial b us. The DataFlash is designed to always clock its d ata out on the falling \nedge of the SCK signal and clock data in on the ris ing edge of SCK. \nFor full clock cycle operation to be achieved, when  the DataFlash is clocking data out on the falling edge of SCK, the host \ncontroller should wait until the next falling edge of SCK to latch the data in. Similarly, the host co ntroller should clock its \ndata out on the rising edge of SCK in order to give  the DataFlash a full clock cycle to latch the inco ming data in on the \nnext rising edge of SCK. \nFigure 21-1. RapidS Mode \nSCK\nMOSI\nMISO1\n2 3 4 5 6 78 1\n2 3 4 5 6 78\nMOSI = Master Out, Slave In\nMISO = Master In, Slave Out\nThe Master is the host controller and the Slave is the DataFlash.\nThe Master always clocks data out on the rising edge of SCK and always clocks data in on the falling edge of SCK.\nThe Slave always clocks data out on the falling edge of SCK and always clocks data in on the rising edge of SCK.\nA. Master clocks out first bit of BYTE-MOSI on the rising edge of SCK\nB. Slave clocks in first bit of BYTE-MOSI on the next rising edge of SCK\nC. Master clocks out second bit of BYTE-MOSI on the same rising edge of SCK\nD. Last bit of BYTE-MOSI is clocked out from the Master\nE. Last bit of BYTE-MOSI is clocked into the slave\nF. Slave clocks out first bit of BYTE-SO \nG. Master clocks in first bit of BYTE-SO\nH. Slave clocks out second bit of BYTE-SO\nI. Master clocks in last bit of BYTE-SOAB\nC DE\nFG1\nH BYTE-MOSIMSB LSB\nBYTE-SOMSB LSBSlave  CS\nI\n 51 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 21-2. Command Sequence for Read/Write Operati ons for Page Size 256 bytes  \n(Except Status Register Read, Manufacturer and Devi ce ID Read) \nFigure 21-3. Command Sequence for Read/Write Operati ons for Page Size 264 bytes  \n(Except Status Register Read, Manufacturer and Devi ce ID Read)  \n SI (INPUT) CMD 8-bits 8-bits 8-bits \nPage Address\n(A22 - A8)X X X X X X X X   X X X X X X X X LSB X X X X X X X X \nByte/Buffer Address \n(A7 - A0/BFA7 - BFA0) MSB\n1 Dummy Bit\nPage Address\n(PA14 - PA0) Byte/Buffer Address \n(BA8 - BA0/BFA8 - BFA0) SI (INPUT) CMD 8-bits 8-bits 8-bits\nX X X X X X X X X X X X LSB X X X X X X X X MSB X X X X\n 52 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 22. AC Waveforms \nFour different timing waveforms are shown in Figure 22-1  through Figure 22-4 . Waveform 1 shows the SCK signal being \nlow when CS  makes a high-to-low transition and Waveform 2 show s the SCK signal being high when CS  makes a  \nhigh-to-low transition. In both cases, output SO be comes valid while the SCK signal is still low (SCK low time is specified \nas t WL ). Timing Waveforms 1 and 2 conform to RapidS seria l interface but for frequencies up to 85MHz. Wavefo rms 1 \nand 2 are compatible with SPI Mode 0 and SPI Mode 3 , respectively. \nWaveform 3 and 4 illustrate general timing diagram for RapidS serial interface. These are similar to W aveform 1 and 2, \nexcept that output SO is not restricted to become v alid during the t WL  period. These timing waveforms are valid over the \nfull frequency range (maximum frequency = 85MHz) of  the RapidS serial case. \nFigure 22-1. Waveform 1 = SPI Mode 0 Compatible \nFigure 22-2. Waveform 2 = SPI Mode 3 Compatible CS \nSCK\nSI SO tCSS\nValid In tH tSU tWH tWL tCSHtCS \ntV\nHigh-impedance\nValid Out tHO tDIS\nHigh-impedance\nCS \nSCK\n SO tCSS\nValid In tH tSU tWL tWH tCSHtCS \ntV\nHigh ZValid Out tHO tDIS\nHigh-impedance\nSI \n 53 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 22-3. Waveform 3 = RapidS Mode 0 \nFigure 22-4. Waveform 4 = RapidS Mode 3 CS \nSCK\nSI SO tCSS\nValid In tH tSU tWH tWL tCSHtCS \ntV\nHigh-impedance\nValid Out tHO tDIS\nHigh-impedance\nCS \nSCK\n SO tCSS\nValid In tH tSU tWL tWH tCSHtCS \ntV\nHigh ZValid Out tHO tDIS\nHigh-impedance\nSI \n 54 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 23. Write Operations \nThe following block diagram and waveforms illustrat e the various write sequences available. \nFigure 23-1. Block Diagram \nFigure 23-2. Buffer Write \nFigure 23-3. Buffer to Main Memory Page Program Flash Memory Array\nI/O InterfaceSCK\nCS \nRESET\nVCC \nGNDWP \nSO SI Page (256/264 bytes)\nBuffer 1 (256/264 bytes) Buffer 2 (256/264 bytes)\nCS \nSI (Input) CMD X X BFA7-0 n n + 1 Last ByteCompletes Writing into Selected Buffer \nBinary Page Size\n16 Dummy Bits + BFA7-BFA0 \nn  = 1st byte read \nn+1 = 2nd byte read Each transition represents eight bits\nCS \nSI (Input) CMD A15-A8 XXXX XXXX X,A22-A16Starts Self-timed Erase/Program Operation \nBinary Page Size\nA22-A8 + 8 Dummy Bits\nEach transition represents eight bits\n 55 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 24. Read Operations \nThe following block diagram and waveforms illustrat e the various read sequences available. \nFigure 24-1. Block Diagram \nFigure 24-2. Main Memory Page Read Flash Memory Array\nPage (256/264 bytes)\nBuffer 2 (256/264 bytes) Buffer 1 (256/264 bytes)\nI/O InterfaceMain Memory\nPage To \nBuffer 1Main Memory\nPage To \nBuffer 2\nMain Memory\nPage ReadBuffer 1\nReadBuffer 2\nRead\nSO \n \nCS \nSI (Input)\nSO (Output) nCMD PA14-7 PA6-0, BA8 BA7-0 X XAddress for Binary Page Size\nX,A22-A16 A15-A8 A7-A0\nn n + 14 Dummy Bytes\n 56 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 24-3. Main Memory Page to Buffer Transfer  \nData From the selected Flash Page is read into eith er SRAM Buffer \nFigure 24-4. Buffer Read CS \nSI (Input) CMD PA14-7 PA6-0, XX XXXX XXXXStarts Reading Page Data into Buﬀer \nBinary Page Size\n      X, A22-A16   +      A15- A8   +  8 Dummy Bits\nSO (Output)\nCS \nSI (Input)\nSO (Output) nCMD XXXX XXXX XXXX XXXX BFA7-0 XAddress for Binary Page Size\n                                  16 Dummy Bits +                              BFA7-BFA0 \nn n + 1No Dummy Byte (opcodes D1H and D3H)\n1 Dummy Byte (opcodes D4H and D6H)\nEach transition represents eight bits\n 57 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 25. Detailed Bit-level Read Waveforms: RapidS Mode 0 /Mode 3 \nFigure 25-1. Continuous Array Read (Legacy Opcode E8 h) \nFigure 25-2. Continuous Array Read (Opcode 0Bh) \nFigure 25-3. Continuous Array Read (Opcode 01h or 03 h) SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 1 0 1 0 0 0 6 7 5 4 10 11 9 8 12 63 66 67 65 64 62 33 34 31 32 29 30 68 71 72 70 69 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits 32 Dummy Bits\nData Byte 1\nHigh-impedance\nBit 2048/2112\nof Page nBit 0  of\nPage n+1 \nSCKCS \nSI \nSO MSB MSB2 3 1 0\n0 0 0 0 1 0 1 16 7 5 4 10 11 9 8 12 39 42 43 41 40 38 33 34 31 32 29 30 44 47 48 46 45 \nOpcode\nA A A A A A A A A\nMSBX X X X X X\nMSB MSBD D D D D D D D D DAddress Bits A22 - A0 Dummy Bits \nData Byte 1 \nHigh-impedance 36 37 35 \nX X\nSCKCS \nSI \nSO MSB MSB2 3 1 0\n0 0 0 0 0 0 1 16 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nA A A A A A A A A\nMSB MSBD D D D D D D D D DAddress Bits A22-A0 \nData Byte 1 \nHigh-impedance \n 58 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 25-4. Main Memory Page Read (Opcode D2h) \nFigure 25-5. Buffer Read (Opcode D4h or D6h) \nFigure 25-6. Buffer Read – Low Frequency (Opcode D1h  or D3h) SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 0 1 0 6 7 5 4 10 11 9 8 12 63 66 67 65 64 62 33 34 31 32 29 30 68 71 72 70 69 \nOpcode\nA A A A A A A A A \nMSB X X X X X X \nMSB MSB D D D D D D D D D D Address Bits 32 Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 1 0 0 6 7 5 4 10 11 9 8 12 39 42 43 41 40 37 38 33 36 35 34 31 32 29 30 44 47 48 46 45 \nOpcode\nX X X X A A A X X \nMSB X X X X X X X X \nMSB MSB D D D D D D D D D D Address Bits\nBinary Page Size = 16 Dummy Bits + BFA7-BFA0 \nStandard DataFlash Page Size = \n15 Dummy Bits + BFA8-BFA0 Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n1 1 0 1 0 0 0 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X A A A X X \nMSB MSB D D D D D D D D D D Data Byte 1\nHigh-impedanceAddress Bits\nBinary Page Size = 16 Dummy Bits + BFA7-BFA0 \nStandard DataFlashPage Size = \n15 Dummy Bits + BFA8-BFA0 \n 59 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 25-7. Read Sector Protection Register (Opcode  32h) \nFigure 25-8. Read Sector Lockdown Register (Opcode 3 5h) \nFigure 25-9. Read Security Register (Opcode 77h) SCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 1 1 0 0 1 0 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 0 1 1 0 1 0 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\nSCK CS \nSI \nSO MSB MSB 2 3 1 0 \n0 1 1 1 0 1 1 1 6 7 5 4 10 11 9 8 12 37 38 33 36 35 34 31 32 29 30 39 40 \nOpcode\nX X X X X X X X X \nMSB MSB D D D D D D D D D Dummy Bits\nData Byte 1\nHigh-impedance\n 60 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 25-10. Status Register Read (Opcode D7h) \nFigure 25-11. Manufacturer and Device Read (Opcode 9 Fh) \nFigure 25-12.Reset Timing \nNote: 1. The CS  signal should be in the high state before the RESE T  signal is deasserted. SCK CS \nSI \nSO MSB 2 3 1 0 \n1 1 0 1 0 1 1 1 6 7 5 4 10 11 9 8 12 21 22 17 20 19 18 15 16 13 14 23 24 \nOpcode\nMSB MSB D D D D D D D D D D \nMSB D D D D D D D D Status Register Data Status Register Data\nHigh-impedance\nSCKCS \nSI \nSO 6 0\n9Fh8 7 46 \nOpcode\n1Fh 00h 01h 00h\nManufacturer ID Device ID\nByte 1Device ID \nByte 2EDI\nString LengthEDI\nData Byte 1High-impedance14 16 15 22 24 23 38 40 39 30 32 31 \nNote:  Each transition shown for SI and SO represents one byte (8 bits)28h\nCS \nSCK\nRESET\nSO (Output)High Impedance High Impedance\nSI (Input)tRSTtREC tCSS\n 61 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 26. Auto Page Rewrite Flowchart \nFigure 26-1. Algorithm for Programming or Re-program ming of the Entire Array Sequentially \nNotes: 1. This type of algorithm is used for applicat ions in which the entire array is programmed sequen tially, filling the \narray page-by-page. \n2. A page can be written using either a Main Memory Page Program operation or a buffer write operation \nfollowed by a buffer to Main Memory Page Program op eration. \n3. The algorithm above shows the programming of a si ngle page. The algorithm will be repeated sequentia lly \nfor each page within the entire array. START\nMain Memory Page Program\nthrough Buffer\n(82h, 85h)\nENDProvide Address\nand Data\nBuffer Write\n(84h, 87h)\nBuffer To Main\nMemory Page Program\n(83h, 86h)\n 62 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 Figure 26-2. Algorithm for Programming or Re-program ming of the Entire Array Randomly \nNotes: 1. To preserve data integrity, each page of an  DataFlash sector must be updated/rewritten at leas t once within \nevery 50,000 cumulative page erase and program oper ations. \n2. A page address pointer must be maintained to indi cate which page is to be rewritten. The Auto Page \nRewrite command must use the address specified by t he page address pointer. \n3. Other algorithms can be used to rewrite portions of the Flash array. Low-power applications may choo se to \nwait until 50,000 cumulative page erase and program  operations have accumulated before rewriting all \npages of the sector. START\nMain Memory Page\nto Buffer Transfer\n(53h, 55h)\nIncrement Page\nAddress Pointer(2)Auto Page Rewrite(2)\n(58h, 59h)\nENDProvide Address of\nPage to Modify\nIf planning to modify multiple\nbytes currently stored within\na page of the Flash array\nMain Memory Page Program\nthrough Buffer\n(82h, 85h)Buffer Write\n(84h, 87h)\nBuffer to Main\nMemory Page Program\n(83h, 86h)\n 63 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 27. Ordering Information (Standard DataFlash Page Si ze) \n27.1 Ordering Detail \n27.2 Ordering Codes (Standard DataFlash Page Size) \nNotes: 1. The shipping carrier suffix is not marked o n the device. \n2. Contact Adesto for mechanical drawing or Die Sales information. Device Grade\nH = Green, NiPdAu lead finish, \n  Industrial temperature range \n  (–40°C to +85°C) \nU = Green, Matte Sn or Sn alloy, \n  Industrial temperature range \n  (–40°C to +85°C) Designator\nProduct Family\nDevice Density\nDevice RevisionShipping Carrier Option \nPackage Option 64 = 6-Mbit\nInterface\n1 = Serial45DB = DataFlashB   =  Bulk (tubes)\nT = Tape and reel \nY = Trays \nOperating Voltage \nN = 1.7V minimum (1.7V to 3.6V) \nS  = 8-lead, 0.208” wide SOIC \nM  = 8-pad, 5 x 6 x 0.6mm UDFN \nMW = 8-pad, 6 x 8 x 1.0mm VDFN \nCC  = 9-ball,  3 x 3 (1mm pitch) UBGA \nUUN = 44-ball 6 x 8 (0.5mm pitch) dBGA\nDWF = Die in Wafer FormA T 4 5 D B 6 4 1 E - S H N 2 B - B \nPage Size Option \n“  ” = Standard (264 bytes/page)\n2B = Binary (256 bytes/page)\nUUN = 44-ball, 6 x 8 dBGA \nDWF = Die in Wafer Form \nOrdering Code Package Lead Finish Operating Voltage fSCK Device Grade \nAT45DB641E-SHN-B (1) \n8S2 \nNiPdAu \n1.7V to 3.6V 85MHz Industrial \n(-40 °C to 85 °C) AT45DB641E-SHN-T (1) \nAT45DB641E-MHN-Y (1) \n8MA1 \nAT45DB641E-MHN-T (1) \nAT45DB641E-MWHN-Y (1) \n8MW1 \nAT45DB641E-MWHN-T (1) \nAT45DB641E-UUN-T 44-WLCSP SnAgCu \nAT45DB641E-DWF (2) DWF \n 64 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 27.3 Ordering Codes (Binary Page Size)\nNotes: 1. The shipping carrier suffix is not marked o n the device. \n2. Parts ordered with suffix code ‘2B’ are shipped i n tape and reel (T&R) with the page size set to  \n256 bytes. This option is only available for shippi ng in T&R (-T). Package Type \n8S2 8-lead 0.208" wide, Plastic Gull Wing Small Outline  (EIAJ SOIC) \n8MA1 8-pad (5 x 6 x 0.6mm body), Thermally Enhanced Plas tic Ultra Thin Dual Flat No-lead (UDFN) \n8MW1 8-pad (6 x 8 x 1.0mm body), Thermally Enhanced Plas tic Very Thin Dual Flat No-lead (VDFN) \n44-WLCSP 44-ball modified 6 x 8 array x 0.5mm pitch, die Bal l Grid Array (dBGA) \nDWF Die in Wafer Form \nOrdering Code Package Lead Finish Operating Voltage fSCK Device Grade \nAT45DB641E-SHN2B-T (1)(2) 8S2 \nNiPdAu \n1.7V to 3.6V 85MHz Industrial \n(-40 °C to 85 °C) AT45DB641E-MHN2B-T (1)(2) 8MA1 \nAT45DB641E-MWHN2B-T (1)(2) 8MW1 \nAT45DB641E-UUN2B-T 44-WLCSP SnAgCu \nPackage Type \n8S2 8-lead 0.208" wide, Plastic Gull Wing Small Outline  (EIAJ SOIC) \n8MA1 8-pad (5 x 6 x 0.6mm body), Thermally Enhanced Plas tic Ultra Thin Dual Flat No-lead (UDFN) \n8MW1 8-pad (6 x 8 x 1.0mm body), Thermally Enhanced Plas tic Very Thin Dual Flat No-lead (VDFN) \n44-WLCSP 44-ball modified 6 x 8 array x 0.5 mm pitch, die Ba ll Grid Array (dBGA) \n 65 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 28. Packaging Information \n28.1 8S2 – 8-lead EIAJ SOIC \nTITLE DRAWING NO.     GPC REV.\nPackage Drawing Contact: \ncontact@adestotech.com8S2 STN F 8S2, 8-lead, 0.208” Body, Plastic Small\nOutline Package (EIAJ)  \n4/15/08COMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX NOTE  \nNotes: 1. This drawing is for general information only; refer to EIAJ Drawing EDR-7320 for additional information. \n 2. Mismatch of the upper and lower dies and resin burrs aren\'t included. \n 3. Determines the true geometric position. \n 4. Values b,C apply to plated terminal.  The standard thickness of the plating layer shall measure between 0.007 to .021 mm. A 1.70  2.16 \nA1 0.05  0.25 \nb 0.35  0.48  4 \nC 0.15  0.35  4 \nD 5.13  5.35 \nE1 5.18  5.40  2 \nE 7.70  8.26 \nL 0.51  0.85 \nq   0°   8° \ne            1.27 BSC   3 q 1 \nN E \nTOP VIEW C \nE1 \nEND VIEW \nA b L \nA1 e \nD \nSIDE VIEW \n 66 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 28.2 8MA1 – 8-pad UDFN \nTITLE DRAWING NO. GPC REV.\nPackage Drawing Contact: \ncontact@adestotech.com 8MA1 YFG D  \n 8MA1, 8-pad (5 x 6 x 0.6 mm Body), Thermally  \nEnhanced Plastic Ultra Thin Dual Flat No Lead \nPackage (UDFN)  \n COMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX N O T E \n A 0.45 0.55 0.60   \n A1 0.00 0.02 0.05   \n b 0.35 0.40 0.48 \n C  0.152 REF  \n D 4.90 5.00 5.10 \n D2 3.80 4.00 4.20 \n E 5.90 6.00 6.10 \n E2 3.20 3.40 3.60 \n e  1.27 \n L 0.50 0.60 0.75 \n y 0.00 – 0.08 \n K 0.20 – – \n 4/15/08Pin 1 ID \nTOP VIEW E \nD \nA1 \nA SIDE VIEW \ny C \nBOTTOM VIEW E2 \nD2 \nL b e 1 \n2 \n3 \n4 8 \n7 \n6 \n5 Pin #1 Notch \n (0.20 R) 0.45 K \nPin #1  \n Cham f e r  \n (C 0.35) Option A \n(Option B) \n 67 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 28.3 8MW1 - 8-pad VDFN  \nDRAWING NO. REV .  TITLE \nPackage Drawing Contact: \ncontact@adestotech.com 8MW1 F8/4/17\n8MW1 , 8-pad (6 x 8 x 1.0 mm Body), Thermally \nEnhanced Plastic Very Thin Dual Flat No Lead \nPackage (VDFN) Bottom View Top View Side View \nCOMMON DIMENSIONS \n(Unit of Measure = mm) \nSYMBOL MIN NOM MAX NOTE \n0.80 \n–\n0.35 \n5.90 \n4.25 \n7.90 \n3.35 \n0.45 A\nA1 \nb\nC\nD\nD1 \nE\nE1 \ne\nL\nK–\n–\n0.40 \n0.203 REF \n6.00 \n8.00 \n1.27 \n0.50 \n1.05 REF 1.00 \n0.05 \n0.48 \n6.10 \n4.90 \n8.10 \n5.00 \n0.55 Pin 1 ID E\nD\nA1 \nAC\nPin #1 ID E1 \nD1 \nLbe\nK1\nPin #1 \nChamfer\n(C 0.40 max) Option A \nPin #1 \nNotch \n(0.20 R) Option B 2\n3\n48\n7\n6\n5\n 68 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 28.4 44-WLCSP — 44-ball die Ball Grid Array \n44-WLCSP — 44-ball die Ball Grid Array - Pinout Dia gram \nCS RST\nVccSCK\nGNDSI \nSO CS RST SCK SI CS RST SI \nWP Vcc GND SO \nWP Vcc SO WP \n(NC)(NC)(NC)(NC)(NC)(NC)(NC)(NC)\n(NC)(NC)(NC)(NC)(NC)(NC)(NC)(NC)\n(NC) (NC) (NC)(NC) (NC) (NC)\nHGFEDCBA5 1 4 3 2 6\n 69 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 DRAWING NO. REV .  TITLE GPC 12/23/13 \n44-WLCSP, 44-ball, 3.5 x 4.2mm body, modified 6 x 8 array  \n0.5mm pitch, die Ball Grid Array (dBGA), WLCSP GCL Package Drawing Contact: \ncontact@adestotech.com646747PO 0A ®\n 70 AT45DB641E \nDS-45DB641E-027K–DFLASH–2/2019 29. Revision History \nDoc. Rev. Date Comments \nDS-45DB641E-027A 8/2013 Initial document release. \nDS-45DB641E-027B 10/2013 Updated spec in Continuous Array Read (1Bh Opcode) to fCAR4 . Corrected Low Power \nRead Option (up to 15MHz). Corrected Ultra-Deep Pow er-Down current (400nA typical). \nUpdated spec for Input High Voltage (Max) to V CC  + 0.6V. Updated DC and AC \nparameters, and Program and Erase Characteristics. Updated datasheet status to \nPreliminary. \nDS-45DB641E-027C 11/2013 Corrected Memory Architecture Diagram, Figure 3.1. \nDS-45DB641E-027D 1/2014 Added Exit Ultra-Deep Power-Down (Chip Select Low).  \nDS-45DB641E-027E 1/2014 Updated specifications for I DPD , I SB , I CC2 , f CAR2 , and t XUDPD . Removed Preliminary status. \nDS-45DB641E-027F 4/2015 Added WLCSP package. Expanded explanation of Power up/Power down (Section 16).  \nCorrected Table 6-4 (Additional Commands, “Main Mem ory to Buffer”). Corrected \nOrdering Code Detail Diagram (voltage range). \nDS-45DB641E-027G 6/2015 Added Die in Wafer Form package option. Updated 44- WLCSP package title. \nDS-45DB641E-027H 1/2016 Corrected page size reference in Ordering Detail Di agram. Updated UUN package \ndiagram. \nDS-45DB641E-027I 1/2017 Added patent information. \nDS-45DB641E-027J 8/2017 Updated 6 x 8 VDFN package drawing. \nDS-45DB641E-027K 2/2019 Removed 9CC, 9-ball UBGA package option. \nCorporate Office \nCalifornia | USA \nAdesto Headquarters \n3600 Peterson Way \nSanta Clara, CA 95054 \nPhone: (+1) 408.400.0578 \nEmail: contact@adestotech.com \n© 2019 Adesto Technologies. All rights reserved.  /   Rev.: DS-45DB641E-027K–DFLASH–2/2019 \nDisclaimer: Adesto Technologies Corporation makes n o warranty for the use of its products, other than those expressly contained in the Company\'s standard  warranty which is detailed in Adesto\'s Terms \nand Conditions located on the Company\'s web site. T he Company assumes no responsibility for any errors  which may appear in this document, reserves the ri ght to change devices or specifications \ndetailed herein at any time without notice, and doe s not make any commitment to update the information  contained herein. No licenses to patents or other intellectual property of Adesto are granted by the \nCompany in connection with the sale of Adesto produ cts, expressly or by implication. Adesto\'s products  are not authorized for use as critical components in life support devices or systems. Adesto ®, the Adesto logo, CBRAM ®, and DataFlash ® are registered trademarks or trademarks of Adesto Technologies. All other marks are the property of t heir respective \nowners. Adesto products in this datasheet are cover ed by certain Adesto patents registered in the Unit ed States and potentially other countries. Please r efer to \nhttp://www.adestotech.com/patents for details. \n'}]
!==============================================================================!
### Component Summary: AT45DB641E-SHN2B-T

#### Key Characteristics and Specifications:
- **Voltage Ratings**: 1.7V to 3.6V
- **Current Ratings**:
  - Active Read Current: 7mA (typical at 85MHz)
  - Standby Current: 25µA (typical)
  - Deep Power-Down Current: 5µA (typical)
  - Ultra-Deep Power-Down Current: 400nA (typical)
- **Power Consumption**:
  - Active Read: 7mA (typical)
  - Standby: 25µA (typical)
  - Deep Power-Down: 5µA (typical)
  - Ultra-Deep Power-Down: 400nA (typical)
- **Operating Temperature Range**: -40°C to +85°C (Industrial)
- **Package Type**: 8-lead SOIC (0.208" wide)
- **Special Features**:
  - Supports SPI modes 0 and 3
  - Continuous read capability through the entire array
  - Low-power read option up to 15MHz
  - Two independent SRAM data buffers
  - Advanced hardware and software data protection features
  - Endurance: 100,000 program/erase cycles per page minimum
  - Data retention: 20 years
- **Moisture Sensitive Level**: MSL 3 (JEDEC J-STD-020E)

#### Description:
The **AT45DB641E** is a 64-Mbit (8MB) serial flash memory device from Adesto Technologies, designed for a wide range of digital storage applications. It operates on a single supply voltage ranging from 1.7V to 3.6V and features a Serial Peripheral Interface (SPI) for communication. The device is optimized for high-speed operation, supporting clock frequencies up to 85MHz, and includes advanced features such as two SRAM buffers for efficient data handling.

#### Typical Applications:
The AT45DB641E is suitable for various applications, including:
- **Digital Voice and Image Storage**: Ideal for devices that require high-speed data storage and retrieval.
- **Program Code Storage**: Used in embedded systems for storing firmware and application code.
- **Data Logging**: Suitable for applications that require continuous data logging and retrieval.
- **Consumer Electronics**: Commonly found in devices like cameras, audio recorders, and other multimedia devices.
- **Industrial Applications**: Used in systems requiring robust data storage solutions under industrial conditions.

This component is particularly beneficial in scenarios where low power consumption and high data retention are critical, making it a versatile choice for modern electronic designs.