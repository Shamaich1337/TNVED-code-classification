[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': "Give me information about the component of AD9548BCPZ-REEL7 production of ANALOG DEVICES from the text: Quad/ Octal Input Network Clock \nGenerator/Synchronizer  \nData Sheet AD9548  \n \nFEATURES  \nSupports Stratum 2 stability in holdover mode  \nSupports reference switchover with phase build -out  \nSupports hitless reference switchover  \nAuto/manual ho ldover and reference switchover  \n4 pairs of reference input pins with each pair configurable as \na single differential input or as 2  independent single -\nended inputs  \nInput reference frequencies from 1 Hz to 750 MHz  \nReference validation and frequency monitoring  (1 ppm)  \nProgrammable input reference switchover priority  \n30-bit programmable input reference div ider  \n4 pairs of clock output pins with each pair configurable as a \nsingle differential LVDS/ LVPECL  output o r as 2 single -\nended CMOS outputs  \nOutput frequencies up to 450  MHz  \n30-bit integer and  10-bit fractional programmable feedback \ndivider  \nProgrammable digital loop f ilter  covering loop bandwidths \nfrom 0.001 Hz to 100 kHz  \nOptional low noise LC -VCO system clock multiplier  \nOptional crystal resonator for system clock input  \nOn-chip EEPROM to store  multiple power -up profiles  \nSoftware controlled power -down  \n88-lead  LFCSP package  APPLICATIONS  \nNetwork synchronization  \nCleanup of r eference clock jitter  \nGPS 1 pulse per second  synchronization  \nSONET/SDH clocks up to OC -192, including FEC  \nStratum 2 holdover, jitter cleanup , and phase transient \ncontrol  \nStratum 3E and Stratu m 3 reference clocks  \nWireless base station  controllers  \nCable  infrastructure  \nData communications  \nGENERAL DESCRIPTION  \nThe AD9548 provides synchronization for many systems , \nincluding synchronous optical networks (SONET/SDH). The \nAD9548 generates an output c lock synchronized to one of up to \nfour differential or eight  single -ended external input references. \nThe digital PLL allows for reduction of input  time jitter or phase \nnoise associated with the external references.  The AD9548 \ncontinuously generates a clean (low jitter), valid output clock \neven when all references have failed by means of  a digitally \ncontrolled loop an d holdover circuitry . \nThe AD9548 operates over a n industrial temperature range  of \n−40°C to +85°C . \nFUNCTIONAL BLOCK DIA GRAM  \nREFERENCE INPUTS\nAND\nMONITOR MUX\nSTATUS AND\nCONTROL PINSSERIAL CONTROL INTERFACE\n(SPI or I 2C)EEPROMDIGITAL\nPLLCLOCK DISTRIBUTION\nSYNCDACCLOCK\nMULTIPLIERSTABLE\nSOURCEANALOG\nFILTER\nAD9548\nCHANNEL 0\nDIVIDER\nCHANNEL 1\nDIVIDER\nCHANNEL 2\nDIVIDER\nCHANNEL 3\nDIVIDER\n08022-001 \nFigure 1. \n \n \n Rev.  G Document Feedback  \nInformation furnished by Analog Devices is believed to be accurate and reliable. However, no \nresponsibility is assumed by Analog Devices for its use, nor for any infringements of patents or other \nrights of third parties that may result from its use. Specif ications subject to change without notice. No \nlicense is granted by implication or otherwise under any patent or patent rights of Analog Devices. Trademarks and registered trademarks are the property of their respective owners.    \n \nOne Technology Way, P.O. Box 9106,  Norwood, MA 02062- 9106, U.S.A.  \nTel: 781.329.4700  ©2009– 2014 Analog Devices, Inc. All rights reserved.  \nTechnical Support  www.analog.com   \nAD9548 Data Sheet\n \nRev. G | Page 2 of 111 TABLE OF CONTENTS \nFeatures .............................................................................................. 1 \xa0\nApplications ....................................................................................... 1 \xa0\nGeneral Description ......................................................................... 1 \xa0\nFunctional Block Diagram .............................................................. 1 \xa0\nRevision History ............................................................................... 3 \xa0\nSpecifications ..................................................................................... 4 \xa0\nSupply Voltage ............................................................................... 4 \xa0\nSupply Current .............................................................................. 4 \xa0\nPower Dissipation ......................................................................... 4 \xa0\nLogic Inputs (M7 to M0, RESET, TDI, TCLK, TMS) .............. 5 \xa0\nLogic Outputs (M7 to M0, IRQ, TDO) ..................................... 5 \xa0\nSystem Clock Inputs (SYSCLKP/SYSCLKN) ........................... 5 \xa0\nDistribution Clock Inputs (CLKINP/CLKINN) ...................... 6 \xa0\nReference Inputs (REFA/REFAA to REFD/REFDD) .............. 7 \xa0\nReference Monitors ...................................................................... 7 \xa0\nReference Switchover Specifications .......................................... 8 \xa0\nDistribution Clock Outputs (OUT0 to OUT3) ........................ 8 \xa0\nDAC Output Characteristics (DACOUTP/DACOUTN) ....... 9 \xa0\nTime Duration of Digital Functions ........................................ 10 \xa0\nDigital PLL .................................................................................. 10 \xa0\nDigital PLL Lock Detection ...................................................... 10 \xa0\nHoldover Specifications ............................................................. 10 \xa0\nSerial Port Specifications—SPI Mode ...................................... 11 \xa0\nSerial Port Specifications—I2C Mode ...................................... 11 \xa0\nJitter Generation ......................................................................... 12 \xa0\nAbsolute Maximum Ratings .......................................................... 14 \xa0\nESD Caution ................................................................................ 14 \xa0\nPin Configuration and Function Descriptions ........................... 15 \xa0\nTypical Performance Characteristics ........................................... 18 \xa0\nInput/Output Termination Recommendations .......................... 23 \xa0\nGetting Started ................................................................................ 24 \xa0\nPower-On Reset .......................................................................... 24 \xa0\nInitial M0 to M7 Pin Programming ......................................... 24 \xa0\nDevice Register Programming .................................................. 24 \xa0\nTheory of Operation ...................................................................... 26 \xa0\nOverview ...................................................................................... 26 \xa0\nReference Clock Inputs .............................................................. 27 \xa0\nReference Monitors .................................................................... 27 \xa0\nReference Profiles ....................................................................... 28 \xa0\nReference Switchover ................................................................. 30 \xa0Digital PLL (DPLL) Core .......................................................... 32 \xa0\nDirect Digital Synthesizer ......................................................... 34 \xa0\nTuning Word Processing ........................................................... 35 \xa0\nLoop Control State Machine ..................................................... 36 \xa0\nSystem Clock Inputs ................................................................... 37 \xa0\nSYSCLK PLL Multiplier ............................................................. 38 \xa0\nClock Distribution ..................................................................... 40 \xa0\nStatus and Control .......................................................................... 44 \xa0\nMultifunction Pins (M0 to M7) ............................................... 44 \xa0\nIRQ Pin ........................................................................................ 45 \xa0\nWatchdog Timer ......................................................................... 46 \xa0\nEEPROM ..................................................................................... 46 \xa0\nSerial Control Port ......................................................................... 51 \xa0\nSPI/I2C Port Selection ................................................................ 51 \xa0\nSPI Serial Port Operation .......................................................... 51 \xa0\nI2C Serial Port Operation .......................................................... 56 \xa0\nInput/Output Programming Registers ........................................ 59 \xa0\nBuffered/Active Registers .......................................................... 59 \xa0\nAutoclear Registers ...................................................................... 59 \xa0\nRegister Access Restrictions ........................................................ 59 \xa0\nRegister Map ................................................................................... 60 \xa0\nRegister Map Bit Descriptions ...................................................... 70 \xa0\nSerial Port Configuration (Register 0x0000 to \nRegister 0x0005) ......................................................................... 70 \xa0\nSystem Clock (Register 0x0100 to Register 0x0108) ............. 71 \xa0\nGeneral Configuration (Register 0x0200 to Register 0x0214) .. 72 \xa0\nDPLL Configuration (Register 0x0300 to Register 0x031B) 75 \xa0\nClock Distribution Output Configuration (Register 0x0400 to Register 0x0419) ........................................................................... 77\n\xa0\nReference Input Configuration (Register 0x0500 to Register 0x0507) ......................................................................... 81\n\xa0\nProfile Registers (Register 0x0600 to Register 0x07FF) ........ 83 \xa0\nOperational Controls (Register 0x0A00 to Register 0x0A10) ... 92 \xa0\nClock Part Serial ID (Register 0x0C00 to Register 0x0C07) 97 \xa0\nStatus Readback (Register 0x0D00 to Register 0x0D19) ...... 97 \xa0\nNonvolatile Memory (EEPROM) Control (Register 0x0E00 to Register 0x0E03) ........................................................................ 101\n\xa0\nEEPROM Storage Sequence (Register 0x0E10 to Register 0x0E3F) ........................................................................ 101\n\xa0\nPower Supply Partitions ............................................................... 106 \xa0\n3.3 V Supplies ............................................................................ 106 \xa0\nData Sheet AD9548\n \nRev. G | Page 3 of 111 1.8 V Supplies ........................................................................... 106 \xa0\nThermal Performance .................................................................. 107 \xa0\nCalculating Digital Filter Coefficients ....................................... 108 \xa0\nCalculation of the \uf061 Register Values ..................................... 109 \xa0\nCalculation of the β Register Values ...................................... 109 \xa0Calculation of the \uf067 Register Values ....................................... 110 \xa0\nCalculation of the \uf064 Register Values ....................................... 110 \xa0\nOutline Dimensions ...................................................................... 111 \xa0\nOrdering Guide ......................................................................... 111 \xa0\n \nREVISION HISTORY\n12/14—Rev. F to Rev. G \nChanges to Figure 7 Caption to Figure 12 Caption .................... 19 \nChanges to System Clock Period Section .................................... 39 \nChanges to Table 36 ........................................................................ 62 \n 6/14—Rev. E to Rev. F Changes to Table 21 ........................................................................ 15 Added Figure 34; Renumbered Sequentially ............................... 23 \nChanged Initial Pin Programming Section to Initial M0 to M7 \nPin Programming Section .............................................................. 24 Changes to Frequency Tuning Word History Section ............... 36 Added Disabling Accidental Automatic EEPROM Download Section .............................................................................................. 48 Changes to Buffered/Active Registers Section ............................ 59 \nChanges to Register Map Section, Opt Column, Table 36 ........ 60 \nChanges to Table 65 ........................................................................ 76  12/13—Rev. D to Rev. E Changes to Calculating Digital Filter Coefficients Section .....109 \nChanges to Calculation of the \uf061 Register Values Section ........110 \n \n6/13—Rev. C to Rev. D Change to Table 16 .......................................................................... 10 Changes to IRQ Pin Section .......................................................... 46 \nChanges to Programming the EEPROM to Include a Clock  \nPart ID Section ................................................................................ 50 Changes to Bit 0, Table 121 ............................................................ 94 Changes to Status Readback (Register 0x0D00 to Register 0x0D19) Section .............................................................................. 98  \n2/13—Rev. B to Rev. C \nChange to Pin 53, Description Column, Table 21 ...................... 17 Added Figure 33, Renumbered Sequentially ............................... 23 Changes to Automatic Priority-Based Reference Switchover Section; Added T able 23, Renumbered Sequentially ...................... 30 \nChanges to Low Loop Bandwidth Applications Using a \nTCXO/OCXO Section .................................................................... 37 Changes to EEPROM Upload Section and EEPROM  Download Section ........................................................................... 48 Added Programming the EEPROM to Include a Clock  \nPart ID Section ................................................................................ 50 Changes to Read Section ................................................................ 52 Added Figure 56 .............................................................................. 54 \nChanges to t\nC Parameter, Description Column, Table 33 .......... 55 \nAdded Table Summary Statement, Table 36 ................................ 60 Changes to Table 36 ........................................................................ 60 Added User Scratch Pad (Eight Bytes), Address 0x0C00 to Address 0x0C07, Table 36 .............................................................. 67 \nChanges to Table 39 ........................................................................ 70 \nAdded Clock Part Serial ID (Register 0x0C00 to  Register 0x0C07) Section and Table 131 ...................................... 98 Changes to Table 142 .................................................................... 102 Added Table 153 ............................................................................ 105 \nAdded Table 154 ............................................................................ 106 \n 7/11—Rev. A to Rev. B Changed AD9584 to AD9548 ........................................................ 32 Changed 437,749,988,378,041 to 43,774,988,378,041 ................ 34 \nChange to Calculating Digital Filter Coefficients Section ....... 107 \n 10/10—Rev. 0 to Rev. A Changes to Timing Parameter, Table 17 ...................................... 11 Added Low Loop Bandwidth Applications Using a TCXO/OCXO \nSection and Choosing a System Clock Oscillator Frequency \nSection .............................................................................................. 37 Moved System Clock Period Section ............................................ 39 Changes to Addr 0002, Table 35.................................................... 60 Changes to Addr 0600, Table 35.................................................... 62 Changes to Addr 0632, Table 35.................................................... 63 \nChanges to Addr 0680, Table 35.................................................... 64 \nChanges to Addr 06B2, Table 35 ................................................... 65 Changes to Address 0002 Description, Table 38 ......................... 70 Changes to Bit 7 and Bit 6, Table 78 ............................................. 83 Changes to Address 0629 and Address 062A, Table 87 and Bit 7 \nand Bit 6, Table 88 ........................................................................... 85 \nChanges to Address 065B and Address 065C, Table 97 and Bit 7 and Bit 6, Table 98 ........................................................................... 87 Changes to Address 06A9 and Address 06AA, Table 107 ......... 89 Changes to Bit 7 and Bit 6, Table 108 ........................................... 90 \nChanges to Address 06DB and Address 06DC, Table 117 ......... 92 \n \n4/09—Revision 0: Initial Version\n \nAD9548 Data Sheet \n \nSPECIFICATIONS \nMinimum (m in) and maximum ( max) values apply for the full range of supply voltage and operating temperature variation s. Typical (t yp) \nvalues apply for AVDD3 = DVDD_I/O  = 3.3 V ; AVDD  = DVDD = 1.8 V ; T A= 25°C ; IDAC = 20 mA (full scale) , unless otherwise noted.  \nSUPPLY VOLTAGE  \nTable 1. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nSUPPLY VOLTAGE       \nDVDD3  3.135 3.30 3.465 V Pin 7, Pin 82  \nDVDD  1.71  1.80  1.89 V Pin 1, Pin 6, Pin 12, Pin 14, Pin 15, Pin 77, Pin 83, Pin 88 \nAVDD3  3.135 3.30 3.465 V Pin 21, Pin 22, Pin 47, Pin 60, Pin 66, Pin 67, Pin 73 \n3.3 V S upply ( Typical)  3.135 3.30 3.465 V Pin 31, Pin 37, Pin 38, Pin 44 \n1.8 V S upply ( Alternative)  1.71 1.80 1.89 V Pin 31, Pin 37, Pin 38, Pin 44  \nAVDD  1.71 1.80 1.89 V Pin 23, Pin 24, Pin 29, Pin 34, Pin 41, Pin 50, Pin 55, Pin 59, \nPin 63, Pin 70, Pin 74 \nSUPPLY CURRENT  \nThe test conditions for the maximum (m ax) supply current are the same as the test condit ions for the All B locks Running  parameter  of Table 3. \nThe test conditions for the typical (typ)  supply current are the same as the test conditions for the Typical Configuration  parameter  of Table  3. \nTable 2. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nSUPPLY CURRENT       \nIDVDD3   1.5 3 mA Pin 7, Pin 82  \nIDVDD  190 215 mA Pin 1, Pin 6, Pin 12, Pin 14, Pin 15, Pin 77, Pin 83, Pin 88  \nIAVDD3   52 75 mA Pin 21, Pin 22, Pin 47, Pin 60, Pin 66, Pin 67, Pin 73 \nIAVDD3       \n3.3 V Supply (T ypical)   24 110 mA Pin 31, Pin 37, Pin 38, Pin 44  \n1.8 V Supply (Alternative)   24 110 mA Pin 31, Pin 37, Pin 38, Pin 44  \nIAVDD  135 163 mA Pin 23, Pin 24, Pin 29, Pin 34, Pin 41, Pin 50, Pin 55, Pin 59, \nPin 63, Pin 70, Pin 74 \nPOWER DISSIPATION  \nTable 3. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nPOWER DISSIPATION       \nTypical C onfiguration   800 1100 mW  fSYSCLK  = 20 MHz1; fS = 1 GHz2; fDDS = 122.88 MHz3; one \nLVPECL clock distribution output running at 122.88  MHz \n(all others powered down); one input reference running \nat 100 MHz (all others powered down)  \nAll Blocks Running   900 1400  mW  fSYSCLK  = 20 MHz1; fS = 1 GHz2; fDDS = 399 MHz3; all clock \ndistribution outputs configured as LVPECL at 399 MHz; all \ninput references configured as differential at 100 MHz; \nfractional -N active (R = 10, S = 39, U = 9, V = 10)  \nFull Power -Down   13  mW  Conditions = typical configuration; no external pull -up or  \npull- down resistors  \nRev. G | Page 4 of 111 \nData Sheet AD9548 \n \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nIncremental Power Dissipation      Conditions = typical configuration; table values show the \nchange in power due to the indicated operation.  \nSYSCLK PLL Off   −105  mW  fSYSCLK  = 1 GHz1; high frequency direct input mode . \nInput Reference O n      \nDifferential   7  mW   \nSingle -Ended   13  mW   \nOutput Distribution Driver On       \nLVDS   70  mW   \nLVPECL   75  mW   \nCMOS   65  mW  A single 3.3 V CMOS output with a 10 pF load.  \n1 fSYSCLK  is the frequency at the SYSCLKP and SYSCLKN pins.  \n2 fS is the sample rate of the output DAC.  \n3 fDDS is the output frequency of the DDS.  \nLOGIC INPUTS  (M7  TO M 0, RESET , TDI, TCLK, TMS ) \nTable 4. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nLOGIC INPUTS (M7 to M0, RESET, TDI, TCLK, TMS)       \nInput High Voltage (V IH) 2.1   V  \nInput Low Voltage (V IL)   0.8 V  \nInput Current (I INH, IINL)  ±80 ±200 µA  \nInput Capacitance (C IN)  3  pF  \nLOGIC OUTPUTS  (M7  TO M 0, IRQ, TDO)  \nTable 5. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nLOGIC OUTPUTS (M7 to M 0, IRQ, TDO)       \nOutput High Voltage (V OH) 2.7   V IOH = 1 mA  \nOutput Low Voltage (V OL)   0.4 V IOL = 1 m A \nIRQ Leakage Current      Open- drain mode  \nActive Low Output Mode    1 μA VOH = 3.3 V \nActive High Output Mode    1 μA VOL =-0 V \nSYSTEM CLOCK INPUTS ( SYSCLK P/SYSCLK N) \nTable 6. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nSYSTEM CLOCK PLL B YPASSED       \nInput Frequency Range  500  1000 MHz   \nMinimum Input Slew Rate  1000    V/μs  Min imum limit imposed for jitter \nperformance  \nDuty Cycle  40  60 %  \nCommon -Mode Voltage   1.2  V Internally generated  \nDifferential Input Voltage Sensitivity  100   mV p -p Minimum voltage across pins required to ensure switching between logic states; \nthe instantaneous voltage on either pin must not exce ed the supply rails; can \naccommodate single -ended input by ac \ngrounding unused input  \nInput Capacitance   2  pF Single -ended, each pin  \nInput Resistance   2.5  kΩ  \nRev. G | Page 5 of 111  \nAD9548 Data Sheet \n \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nSYSTEM CLOCK PLL ENABLED       \nPLL Output Frequency Range  900  1000 MHz   \nPhase -Frequency Detector (PFD) Rate    150 MHz   \nFrequency Multiplication Range  6  255  Assumes valid system clock and PFD rates  \nVCO Gain   70  MHz/V   \nHigh Frequency Path       \nInput Frequency Range  100.1  500 MHz   \nMinimum Input Slew Rate  200   V/μs Min imum limit imposed for j itter \nperformance  \nFrequency Divider Range 1  8  Binary steps (M = 1, 2, 4, 8)  \nCommon -Mode Voltage   1  V Internally generated  \nDifferential Input Voltage Sensitivity  100   mV p -p Minimum voltage across pins required to \nensure switching between logic states; \nthe instantaneous voltage on either pin \nmust not exceed the supply rails; can \naccommodate single -ended inp ut by ac \ngrounding unused input  \nInput Capacit ance   3  pF Single -ended, each pin  \nInput Resistance   2.5  kΩ  \nLow Frequency Path       \nInput Frequency Range  3.5  100 MHz   \nMinimum Input Slew Rate  50   V/μs Min imum limit imposed for jitter \nperformance  \nCommon -Mode Voltage   1.2  V Internally generated  \nDifferential Input Voltage Sensitivity  100   mV p -p Minimum voltage across pins required to \nensure switching between logic states; \nthe instantaneous voltage on either pin \nmust not exceed the supply rails; can \naccommodate single -ended input by ac \ngrounding unused input  \nInput Capacitance   3  pF Single -ended, each pin  \nInput Resistance   4  kΩ  \nCrystal Resonator Path       \nCrystal Resonator Frequency Range  10  50 MHz  Fundamental mode, AT cut  \nMaximum Crystal Motional R esistance    100 Ω See the System Clock Inputs  section for \nrecommendations  \nDISTRIBUTION CLOCK  INPUTS  (CLKINP/ CLKINN ) \nTable 7. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nDISTRIBUTION CLOCK INPUTS (CLKINP/CLKINN)       \nInput Frequency Range  62.5  500 MHz   \nMinimum Slew Rate 75   V/μs Min imum limit imposed for jitter  \nperformance . \nCommon -Mode Voltage   700  mV Internally generated.  \nDifferential Input Voltage Sensitivity  100   mV p -p Capacitive coupling required; can accommodate single -ended input \nby ac grounding unused input; the \ninstantaneous voltage on either pin \nmust not exceed the supply rails.  \nDifferential Input Power Sensitivity  −15   dBm  The same as voltage sensitivity but specified as power into a 50 Ω  load.  \nInput Capacitance   3  pF  \nInput Resistance   5  kΩ Each pin has a 2.5 kΩ  internal dc -\nbias resistance.  \nRev. G | Page 6 of 111 \nData Sheet AD9548 \n \nREFER ENCE INPUTS (REF A/REF AA TO  REF D/REF DD)  \nTable 8. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nDIFFERENTIAL  OPERATION       \nFrequency Range       \nSinusoidal Input  10  750 MHz   \nLVPECL Input  1  750 × 106 Hz  \nLVDS Input  1  750 × 106 Hz  \nMinimum Input Slew Rate  40   V/μs Min imum limit impos ed for jitter \nperformance  \nCommon -Mode Input Voltage   2  V Internally generated  \nDifferential Input Voltage Sensitivity   ±65   mV Minimum differential voltage across \npins required to ensure switching \nbetween logic levels; the instantaneous voltage on either  pin \nmust not exceed the supply rails  \nInput Resistance   25  kΩ  \nInput Capacitance   3  pF  \n      \nMinimum Pulse Width High  620   ps  \nMinimum Pulse Width Low  620   ps  \nSINGLE-ENDED OPERATION       \nFrequency Range (CMOS)  1  250 ×106 Hz  \nMinimum Input Slew Rate  40   V/μs  Min imum limit imposed for jitter \nperformanc e \nInput Voltage High (V IH)      \n1.2 V to 1.5 V Threshold Setting  0.9   V  \n1.8 V to 2.5 V Threshold Setting  1.2   V  \n3.0 V to 3.3 V Threshold Setting  1.9   V  \nInput Voltage Low (V IL)      \n1.2 V to 1.5 V Threshold Setting    0.27 V  \n1.8 V to 2.5 V Thre shold Setting    0.5 V  \n3.0 V to 3.3 V Threshold Setting    1.0 V  \nInput Resistance   45  kΩ  \nInput Capacitance   3  pF  \nMinimum Pulse Width High  1.5   ns  \nMinimum Pulse Width Low  1.5   ns  \nREFERENCE MONITORS  \nTable 9. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nREFERENCE MONITORS       \nReference Monitor       \nLoss of Reference Detection \nTime   1.2 sec Calculated using the n ominal  phase d etector  period  \n(NPDP = R/fREF)1 \nFrequency Out -of Range Limits  9.54 × 10−7  0.1 Δf/f REF Programmable (lower bound subject to quality of SYSCLK ) \nValidation Timer  0.001   65.535  sec Programmable in 1  ms increments  \nRed etect Timer  0.001  65.535 sec Programmable in 1  ms increments  \n1 fREF is the frequency of the active re ference; R is the frequency division factor determined by the R -divider.  \n \nRev. G | Page 7 of 111  \nAD9548 Data Sheet \n \nREFERENCE SWITCHOVER  SPECIFICATIONS  \nTable 10. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nREFERENCE SWITCHOVER SPECIFI CATIONS       \nMaximum Output Phase Pert urbation (Phase \nBuild -Out Switchover )  40 200 ps Assumes a jitter -free reference; satisfies \nTelcordia GR -1244- CORE requirements  \nMaximum Time/Time Slope (Hitless Switchover)  315  65,535 ns/s ec Minimum/max imum values a re \nprogrammable upper bounds; a m inimum \nvalue  ensures <10% error; satisfies \nTelcordia GR -1244- CORE requirements  \nTime Required to Switch to a New Reference       \nHitless S witchover   5  sec Calculated using the n ominal p hase \ndetector  period ( NPDP = R/fREF)1 \nPhase Build -Out Switchover   3  sec Calculated using the  nominal p hase \ndetector  period ( NPDP = R/fREF)1 \n1 fREF is the frequency of the active reference; R is the frequency division factor determined by the R -divider.  \nDISTRIBUTION CLOCK O UTPUTS (OUT0  TO OUT3)  \nTable 11. \nParameter  Min  Typ  Max  Unit  Test Conditio ns/Comments  \nLVPECL M ODE      Using in ternal current setting resistor  \nMaximum Output Frequency  725  MHz   \nRise/Fall Time (20%  to 80%)   180 315 ps 100 Ω  termination across output pins  \nDuty Cycle  45  55 %  \nDifferential Output Voltage Swing  630 770 910 mV Magnitude of voltage across pins; output \ndriver static  \nCommon -Mode Output Voltage  AVDD3 − 1.5 AVDD3 − 1.3  AVDD3 − 1.05 V Output driver static  \nLVDS MODE      Using internal current setting resistor (nominal 3.12 k Ω) \nMaximum Output Frequency  725  MHz   \nRise/Fall Time1 (20% to 80%)   200 350 ps 100 Ω  termination across the output pair  \nDuty Cycle  40  60 %  \nDifferential Output Voltage Swing      \nBalanced, V OD 247  454 mV Voltage swing between output pins; output driver static  \nUnbalanced, ΔV OD   50 mV Absol ute difference between voltage \nswing of normal pin and inverted pin; \noutput driver static  \nOffset Voltage       \nCommon -Mode, V OS 1.125  1.375 V Output driver static  \nCommon -Mode Difference, ΔV OS   50 mV Voltage difference between pins; output \ndriver static  \nShort -Circuit Output Current  13 24 mA Output driver static  \nCMOS MODE      Weak drive option not supported for \noperating the CMOS drivers using a 1.8 V \nsupply  \nMaximum Output Frequency      \n3.3 V Supply      10 pF load  \nStrong Drive Strength Setting   250  MHz   \nWeak Drive Strength Setting   25  MHz   \n1.8 V Supply   150  MHz   \nRev. G | Page 8 of 111  \nData Sheet AD9548 \n \nParameter  Min  Typ  Max  Unit  Test Conditio ns/Comments  \nRise/Fall Time1 (20% to 80%)      10 pF load  \n3.3 V Supply       \nStrong Drive Strength Setting   0.5 2 ns  \nWeak Drive Strength Setting   8 14.5 ns  \n1.8 V Supply   1.5 2.5 ns  \nDuty Cycle  40  60 % 10 pF load  \nOutput Voltage High (V OH)     Output driver static; strong drive strength \nsetting  \nAVDD3 = 3.3 V, I OH = 10 mA  2.6   V  \nAVDD3 = 3.3 V, I OH = 1 mA  2.9   V  \nAVDD3 = 1.8 V, I OH = 1 mA 1.5   V  \nOutput V oltage Low (V OL)     Output driver static; strong drive strength \nsetting  \nAVDD3 = 3.3 V, I OL = 10 mA    0.3 V  \nAVDD3 = 3.3 V, I OL = 1 mA    0.1 V  \nAVDD3 = 1.8 V, I OL = 1 mA    0.1 V  \nOUTPUT TIMING SKEW      10 pF load  \nBetween LVPECL Outputs   14 125 ps Rising edge only; any divide value \nBetween LVDS Outputs   13 138 ps Rising edge only; any divide value \nBetween CMOS  3.3 V Outputs       \nStrong Drive Strength Setting   23 240 ps  \nWeak Drive Strength Setting   24  ps  \nBetween CMOS 1.8 V Outputs   40  ps Weak dr ive not supported at 1.8 V  \nBetween LVPECL Outputs and LVDS \nOutputs   14 140 ps  \nBetween LVPECL Outputs and CMOS \nOutputs   19  ps  \nZERO -DELAY TIMING SKEW   ±5  ns Output relative to active input reference; \noutput distribution synchronization to \nactive refer ence feature enabled; assumes \nmanual phase offset compensation of deterministic latency  \n1 The listed values are for the slower edge (rise or fall).  \nDAC OUTPUT CHARACTER ISTICS (DACOUTP/ DACOUT N) \nTable 12. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nDAC OUTPUT CHARACTERISTICS \n(DACOUT P/DACOUTN)       \nFrequency Range  62.5  450 MHz   \nOutput Offset Voltage    15 mV This is the single -ended voltage at \neither DAC output pin (no external \nload) when the internal DAC code implies that no current is delivered \nto that pin.  \nVoltage Compliance Range  VSS − 0.5 0.5 VSS + 0.5 V  \nOutput Resistance   50  Ω Single -ended, each pin has an \ninternal 50 Ω  termina tion to VSS . \nOutput Capacitance   5  pF  \nFull-Scale Output Current  20  mA Programmable (8 mA to 31 mA; see \nthe DAC Output  section) . \nGain Error  −12  +12  % FS  \nRev. G | Page 9 of 111  \nAD9548 Data Sheet \n \nTIME DURATION OF DIG ITAL FUNCTIONS  \nTable 13. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nTIME DURATION OF DIGITAL FUNCTIONS       \nEEPROM -to-Register Download Time  25  ms Using default  EEPROM storage \nsequence (see Register 0x 0E10 to \nRegister 0x0E3F)  \nRegister -to-EEPROM Upload  Time  200  ms Using default EEPROM storage \nsequence (see Register 0x 0E10 to \nRegister 0x0E3F \nMinimum Power -Down Exit Time  10.5  μs Dependent on loop -filter bandwi dth \nMaximum Time f rom  Assertion of the RESET \npin to the M0 to M7 Pins Entering High \nImpedance State   45  ns  \nDIGITAL PLL  \nTable 14. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nDIGITAL PLL       \nPhase -Frequency Detector (PF D) \nInput Frequency Range  1  107 Hz Maximum f PFD1: fS/1002 \nLoop Bandwidth 0.001  105 Hz Programmable design parameter; maximum  \nfLOOP = fREF/(20R)3 \nPhase Margin  30  89 Degrees  Programmable design parameter  \nReference Input (R) Division Factor  1  230  1, 2, …, 1,073,741,824 \nInteger Feedback (S) Division Factor  8  230  8, 9, …, 1,073,741,824 \nFractional Feedback Divide Ratio  0  0.999  Maximum value: 1022/1023 \n1 fPFD is the frequency at the input to the phase -frequency detector.  \n2 fS is the sample rate of the output DAC.  \n3 fREF is the frequency of the active reference; R is the frequency division factor determined by the R -divider.  \nDIGITAL PLL LOCK DETECTION  \nTable 15. \nParameter  Min  Typ  Max  Unit  Test Cond itions/Comments \nPHASE LOCK DETECTOR       \nThreshold Programming Range  0.001  65.5 ns  \nThreshold Resolution   1  ps  \nFREQUENCY LOCK DETECTOR       \nThreshold Programming Range  0.001  16,700 ns Reference -to-feedback period difference  \nThreshold Resolution   1  ps  \nHOLDOVER SPECIFICATI ONS  \nTable 16. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments  \nHOLDOVER SPECIFICATIONS       \nFrequency Accuracy   <0.01   ppb Excludes frequency drift of SYSCLK  source; \nexcludes frequency drift of input  reference prior \nto entering holdover  \nRev. G | Page 10 of 111  \nData Sheet AD9548 \n \nSERIAL PORT SPECIFIC ATIONS —SPI MODE  \nTable 17. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nCS     Internal 30 kΩ pull -up resistor  \nInput Logic 1 Voltage   2.0  V  \nInput Logic 0 Voltage   0.8  V  \nInput Logic 1 Current   30  µA  \nInput Logic 0 Current   110  µA  \nInput Capacitance   2  pF  \nSCLK      Internal 30 kΩ pull -down resistor  \nInput Logic 1 Voltage   2.0  V  \nInput Logic 0 Voltage   0.8  V  \nInput Logic 1 Current   1  µA  \nInput Logic 0 Current   1  µA  \nInput Capacitance   2  pF  \nSDIO       \nAs an I nput       \nInput Logic 1 Voltage   2.0  V  \nInput Logic 0 Voltage   0.8  V  \nInput Logic 1 Current   1  µA  \nInput Logic 0 Current   1  µA  \nInput Capacitance   2  pF  \nAs an O utput      \nOutput Logic 1 Voltage  2.7   V 1 mA load current  \nOutput Logic 0 Voltage    0.4 V 1 mA load current  \nSDO       \nOutput Logic 1 Voltage  2.7   V 1 mA load current  \nOutput Logic 0 V oltage    0.4 V 1 mA load current  \nTIMING       \nSCLK       \nClock Rate, 1 /tCLK   40 MHz   \nPulse Width High, t HI 10   ns  \nPulse Width Low, t LO 12   ns  \nSDIO to SCLK Setup, t DS 3   ns  \nSCLK to SDIO Hold, t DH 0   ns  \nSCLK to Valid SDIO and SDO, t DV   15 ns  \nCS to SCLK Setup (tS) 10   ns  \nCS to SCLK Hold (t C) 0   ns  \nCS Minimum Pulse Width High  6   ns  \nSERIAL PORT SPECIFIC ATIONS —I2C MODE  \nTable 18. \nParameter  Min  Typ Max  Unit  Test Conditions/Comments \nSDA, SCL ( AS INPUT )     No internal pull -up/down resistor . \nInput Logic 1 Voltage  0.7 × DVDD3    V  \nInput Logic 0 Voltage    0.3 × DVDD3  V  \nInput Current  −10   +10  µA For VIN = 10% to 90%  DVDD3.  \nHysteresis of Schmitt Tr igger Inputs  0.015 × DVDD3      \nPulse W idth of Spikes That Must Be \nSuppressed by the Input Filter, t SP   50 ns  \nSDA ( AS OUTPUT )      \nOutput Logic 0 Voltage    0.4 V IO = 3 mA . \nOutput Fall Time from V IHmin to V ILmax 20 + 0.1 Cb1  250 ns 10 pF ≤ C b ≤ 400 p F. \nRev. G | Page 11 of 111 \nAD9548 Data Sheet \n \nParameter  Min  Typ Max  Unit  Test Conditions/Comments \nTIMING       \nSCL Clock Rate    400 kHz  \nBus-Free Time Between a Stop and Start \nCondition, t BUF 1.3   µs  \nRepeated Start Condition Setup Time , tSU; STA  0.6   µs  \nRepeated Hold Time Start Condition, t HD; STA  0.6   µs After this period, the first clock \npulse is generated . \nStop Condition Setu p Time, tSU; STO  0.6   µs  \nLow Period of the SCL Clock , tLO 1.3   µs  \nHigh Period of the SCL Clock , tHI 0.6   µs  \nSCL/SDA Rise Time, t R 20 + 0.1  Cb1  300 ns  \nSCL/SDA Fall Time, t F 20 + 0.1 Cb1  300 ns  \nData Setup Time, t SU; DAT  100   ns  \nData Hold Time, t HD; DAT  100   ns  \nCapacitive Load for Each Bus Line , C b1   400 pF  \n1 Cb is the capacitance (pF) of a single  bus line.  \nJITTER GENERATION  \nTable 19. \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nJITTER GENERATION       \nfREF = 1 Hz1; fDDS = 122.88 MHz2; fLOOP = 0.01 Hz3     fSYSCLK  = 20 MHz4 OCXO; f S = 1 GHz5; Q-\ndivider = 1; default SysClk PLL charge pump \ncurrent; results valid for LVPE CL, LVDS, and \nCMOS output logic types  \nBandwidth: 100 Hz to 61 MHz   0.81  ps rms  Random jitter  \nBandwidth: 5 kHz to 20 MHz   0.73  ps rms  Random jitter  \nBandwidth: 20 kHz to 80 MHz   0.79  ps rms  Random jitter  \nBandwidth: 50 kHz to 80 MHz   0.78  ps rms  Random jitter  \nBandwidth: 4 MHz to 80 MHz   0.37   ps rms  Random jitter  \nfREF = 8 kHz1; fDDS = 155.52 MHz2; fLOOP = 100 Hz3     fSYSCLK  = 50 MHz4 crystal;  \nfS = 1 GHz5; Q-divider = 1; default S YSCLK  \nPLL charge pump current; results valid for \nLVPECL, LVDS , and CMOS output logic types  \nBandwidth: 100 Hz to 77 MHz   0.71   ps rms  Random jitter  \nBandwid th: 5 kHz to 20 MHz   0.34  ps rms  Random jitter  \nBandwidth: 20 kHz to 80 MHz   0.43  ps rms  Random jitter  \nBandwidth: 50 kHz to 80 MHz   0.43  ps rms  Random jitter  \nBandwidth: 4 MHz to 80 MHz   0.31  ps rms  Random jitter  \nfREF = 19.44 MHz1; fDDS = 155.52 MHz2; fLOOP = 1 kHz3     fSYSCLK  = 50 MHz4 crystal;  \nfS = 1 GHz5; Q-divider = 1; default SYSCLK  \nPLL charge pump current; results valid for \nLVPECL, LVDS , and CMOS output logic types  \nBandwidth: 100 Hz to 77 MHz   1.05  ps rms  Random jitter  \nBandwidth: 5 kHz to 20 MHz   0.34  ps rms  Random jitter  \nBandwidth: 20 kHz to 80 MHz   0.43  ps rms  Random ji tter \nBandwidth: 50 kHz to 80 MHz   0.43  ps rms  Random jitter  \nBandwidth: 4 MHz to 80 MHz   0.32  ps rms  Random jitter  \nRev. G | Page 12 of 111  \nData Sheet AD9548 \n \nParameter  Min  Typ  Max  Unit  Test Conditions/Comments \nfREF = 19.44 Hz1; fDDS = 311.04 MHz2; fLOOP = 1 kHz3     fSYSCLK  = 50 MHz4 crystal; f S = 1 GHz5; \nQ-divider = 1; default SYSCLK  PLL charge \npump current; results valid for LVPECL, \nLVDS , and CMOS output logic types  \nBandw idth: 100 Hz to 100 MHz   0.67   ps rms  Random jitter  \nBandwidth: 5 kHz to 20 MHz   0.31  ps rms  Random jitter  \nBandwidth: 20 kHz to 80 MHz   0.33  ps rms  Random jitter  \nBandwidth: 50 kHz to 80 MHz   0.33  ps rms  Random jitter  \nBandwidth: 4 MHz to 80 MHz   0.16  ps rms  Random jitter  \n1 fREF is the frequency of the active reference.  \n2 fDDS is the output frequency of the DDS.  \n3 fLOOP is the DPLL digital loop filter bandwidth.  \n4 fSYSCLK  is the frequency at the SYSCLKP and SYSCLKN pins.  \n5 fS is the sample rate of the output DAC.  \n \nRev. G | Page 13 of 111  \nAD9548 Data Sheet \n \nABSOLUTE MAXIMUM RAT INGS  \nTable 20. \nParameter  Rating  \nAnalog Supply Voltage (AVDD)  2 V \nDigital Supply Voltage (DVDD)  2 V \nDigital I/O Supply Voltage (DVDD 3) 3.6 V  \nDAC Supply Voltage ( AVDD3)  3.6 V  \nMaximum Digital Input Voltage  −0.5 V to D VDD3  + 0.5 V  \nStorage Temperature Range  −65°C to +150°C \nOperating Temperature Range  −40°C to +85°C \nLead Temperature (Soldering 10 sec)  300°C  \nJunction Temperature  150°C Stresses at or above those listed under Absolute M aximum \nRatings may cause permanent damage to the product. This is a \nstress rating only; functional operation of the product at these or any other conditions above those indicated in the operational section of this specification is not implied. Operation be yond \nthe maximum operating conditions for extended periods may affect product reliability.  \n \nESD CAUTION  \n \n \n \n \nRev. G | Page 14 of 111 \nData Sheet AD9548 \n \nPIN CONFIGURATION AND FU NCTION DESCRIPTIONS  \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16DVDD\nSCLK/SCL\nSDIO\nSDO\nDVDD\nDVDD3\nTCLK\nTMS\nTDO\nTDI\nDVDD\nRESET\nDVDD\nDVDD\nNC\n17 VSS\n18 DACOUTP\n19 DACOUTN\n20 VSS\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n36\n3735\n38\n39\n40\n4158\n57\n56\n55\n54\n53\n52\n51\n50\n49\n48\n47\n46\n45596061626364656678\n77\n76\n75\n74\n73\n72\n71\n70\n69\n68\n6779808182838485868788\nAD9548\nTOP VIEW\n(Not to Scale)\n21 AVDD3\n22 AVDD3\n42\n43\n44NCAVDD\nTDC_VRT\nTDC_VRB\nNOTES\n1. NC = NO CONNECT.\n2. THE EXPOSED PAD MUST BE CONNECTED TO GROUND (VSS).REFBREFBB\nSYSCLK_VREG\nAVDD3AVDDAVDD\nSYSCLKNSYSCLKPVSS\nVSSREFAREFAAAVDD\nAVDD3M7\nM6\nM5\nM4\nDVDD\nDVDD3\nAVDD\nAVDDDVDD\nIRQ\nNC\nAVDD3\nREFDD\nREFCC\nREFCREFDM3\nM2\nM1\nM0\nAVDD3\nSYSCLK_LF\nNC\nNC88-LEAD LFCSP\n12mm × 12mm\n0.5mm PITCH\nAVDD3DVDD\nAVDD\nVSS\nCLKINN\nCLKINP\nVSS\nAVDD\nAVDD3\nAVDDAVDD\nOUT1P\nOUT1N\nAVDD3\nOUT2P\nOUT3P\nOUT3NOUT2NOUT_RSET\nAVDD3\nOUT0P\nOUT0N\nAVDD3AVDD\n08022-002CS/SDA\n \nFigure 2. 88-Lead LFCSP Pin Configuration  \n \nTable 21. Pin Function Descriptions \nPin No.  Mnemonic  Input/\nOutput  Pin Type  Description  \n1, 6, 12, 77, \n83, 88 DVDD  I Power  1.8 V Digital Supply.  \n2 SCLK/SCL  I 3.3 V CMOS Serial Programming Clock. Data clock for serial programming.  \n3 SDIO  I/O 3.3 V CMOS Serial D ata Input/Output. When the device is in 4 -wire mode, data is written via \nthis pin. In 3 -wire mode, both data reads and writes occur on this pin. There is no \ninternal pull -up/pull -down resistor on this pin.  \n4 SDO  O 3.3 V CMOS Serial Data Output. Use this p in to read data in 4 -wire mode (high impedance in \n3-wire mode). There is no internal pull -up/pull -down resistor on this pin.  \n5 CS/SDA  I 3.3 V CMOS Chip Select (SPI). Active low. When programming a device, this pin must be held \nlow. In systems where more than one AD9548 is present, this pin enables \nindividual programming of each AD9548 (in I2C® mode , this is a serial data pin). \nThis pin has an internal 10 kΩ  pull -up resistor but only in SPI mode.  \n7, 82 DVDD3  I Power  3.3 V I/O Digital Supply. \n8 TCLK  I  JTAG Clock. Internal pull- down resistor; no connecti on if JTAG is not used.  \n9 TMS  I  JTAG Mode. Internal pull-up resistor; no connection if JTAG is not used.  \n10 TDO  O  JTAG Output. No connection if JTAG is not used . \n11 TDI I  JTAG Input. Internal pull -up resistor; no connection if JTAG is not used.  \n13 RESET  I 3.3 V CMOS Chip Reset. When this active high pin is asserted, the chip goes into reset. This pi n \nhas an internal 50 kΩ  pull -down resistor.  \n14, 15 DVDD  I Power  1.8 V DAC Decode Digital Supply. Group t hese pins with the other DVDD pins.  \n16, 45, 46  NC   No Connect.  \n17, 20, 25, \n28, 51, 54  VSS O Ground  Analog Ground. Connect to ground.  \n18 DACOUTP  O Differential \noutput  DAC Output. DACOUTP contains an internal 50 Ω pull -down resistor.  \n19 DACOUTN  O Differential output  Comple mentary DAC Output. DACOUTN contains an internal 50 Ω  pull -down \nresistor.  \nRev. G | Page 15 of 111 \nAD9548 Data Sheet \n \nPin No.  Mnemonic  Input/\nOutput  Pin Type  Description  \n21, 22 AVDD3  I Power  3.3 V Analog (DAC) Power Supply. \n23, 24 AVDD  I Power  1.8 V Analog (DAC) Power Supply. \n26 CLKINN  I Differential \ninput  Clock Distribution Input. In standard operating mode, this pin is connected to the filtered DACOUTN output. This internally biase d input is typically ac -coupled  and, \nwhen c onfigured as such, can accept any differential signal whose single -ended \nswing is at least 400 mV.  \n27 CLKINP  I Differential \ninput  Clock Distribution Input. In standard operating mode, this pin is connected to the filtered DACOUTP output . \n29 AVDD  I Power  1.8 V Analog  (Input Receiver) Power Supply.  \n30 OUT_RSET  O Current set \nresistor  Connect an optional 3.12 kΩ  resistor from this pin to ground (see the Output \nCurrent Control with an External Resistor  section).  \n31, 37, 38, \n44 AVDD3  I Power  Analog Supply for Output Driver. These pins are normally 3.3 V but can be 1.8  V. \nPin 31 powers Out0 x. Pin 37 powers OUT1x . Pin 38 powers OUT2x . Pin 44 powers \nOUT3 x. Apply power to these pins even if the corresponding outputs (OUT0P/  \nOUT0 N, OUT1P/  OUT1 N, OUT2P/  OUT2 N, and OUT3P/  OUT3 N) are not used. See \nthe Power Supply Partitions  section.  \n32 OUT0P  O LVPECL,  \nLVDS, or \nCMOS  Output 0. This output can be configured as LVPECL, LVDS, or single -ended CMOS. \nLVPECL and LVDS operati on require a 3.3  V output driver power supply. CMOS \noperation can be either 1.8  V or 3.3 V, depending on the output driver power \nsupply.  \n33 OUT0N  O LVPECL,  \nLVDS, or CMOS  Complementary Output 0. This output can be configured as LVPECL, LVDS, or \nsingle -ende d CMOS.  \n34, 41 AVDD  I Power  1.8 V Analog  (Output Divider) Power Supply.  \n35 OUT1P  O LVPECL,  \nLVDS, or \nCMOS  Output 1. This output can be configured as LVPECL, LVDS, or single -ended CMOS. \nLVPECL and LVDS operation require a 3.3 V output driver power supply. CMOS operation can be either 1.8 V or 3.3 V, depending on the output driver power \nsupply.  \n36 OUT1N  O LVPECL,  \nLVDS, or \nCMOS  Complementary Output 1. This output can be configured as LVPECL, LVDS, or \nsingle -ended CMOS.  \n39 OUT2P  O LVPECL,  \nLVDS, or \nCMOS  Output 2. This output can be configured as LVPECL, LVDS, or single -ended CMOS. \nLVPECL and LVDS operation require a 3.3 V output driver power supply. CMOS operation can be either 1.8 V or 3.3 V, depending on the output driver power \nsupply.  \n40 OUT2N  O LVPECL,  \nLVDS, or \nCMOS  Complementary Output 2. This output can be configured as LVPECL, LVDS, or \nsingle -ended CMOS.  \n42 OUT3P  O LVPECL,  \nLVDS, or CMOS  Output 3. This output can be configured as LVPECL, LVDS, or single -ended CMOS. \nLVPECL and LVDS operation require a 3. 3 V output driver power supply. CMOS \noperation can be either 1.8 V or 3.3 V, depending on the output driver power \nsupply.  \n43 OUT3N  O LVPECL,  \nLVDS, or CMOS  Complementary Output 3. This output can be configured as LVPECL, LVDS, or \nsingle -ended CMOS.  \n47 AVD D3 I Power  3.3 V Anal og (System Clock) Power Supply.  \n48 SYSCLK_VREG  I  System Clock Loop Filter Voltage Regulator. Connect a 0.1 μF capacitor from this \npin to ground. This pin is also the ac ground reference for the integrated SYSCLK \nPLL multiplier’s external loop filter (see the SYSCLK PLL Multiplier  section).  \n49 SYSCLK_LF O  System Clock Multiplier Loop Filter. When using the frequency multiplier to drive \nthe system clock, an external loop filter can be attached to this pi n. \n50, 55 AVDD  I Power  1.8 V Anal og (System Clock) Power Supply.  \nRev. G | Page 16 of 111 \nData Sheet AD9548 \n \nPin No.  Mnemonic  Input/\nOutput  Pin Type  Description  \n52 SYSCLKN  I Differential \ninput  Complementary System Clock Input. Complementary signal to SYSCLKP . SYSCLKN contains internal dc biasing and should be ac -coupled with a 0. 01 μF capacit or, \nexcept when using a crystal. When using a crystal, connect the crystal across \nSYSCLKP and SYSCLKN . When using a crystal, the user should  consider placing a \n0 Ω series resistor on the  SYSCLKN  pin. I n the event that the power dissipated in \nthe crystal must  be reduced, the user can replace the 0  Ω resistor with a large r \nresistor  (for example, 500 Ω . However, this series resistor is rarely needed. (See \nFigure 34). \n53 SYSCLKP  I Differential \ninput  System  Clock Input. SYSCLKP contains internal dc biasing and should be ac -\ncoupled with a 0.01 μF capacitor, except when using a crystal, in which case \nconnect the crystal across SYSCLKP and SYSCLKN. Single -ended 1.8 V CMOS is \nalso an option but can introduce a s pur if the doubler is enabled and the duty \ncycle is not 50%. When using SYSCLKP as a single -ended input, connect a 0.01 μF \ncapacitor from SYSCLKN to ground.  \n56, 75 NC I  No Connection. These pins should be left floating.  \n59 AVDD  I Power  1.8 V Analog Powe r Supply.  \n57, 58 TDC_VRB, TDC_VRT  I  Use capacitive decoupling on these pins (see Figure 40). \n60, 66, 67, \n73 AVDD3  I Power  3.3 V Analog (Reference Input) Power Supply.  \n61 REFA  I Differential \ninput  Reference A Input. This intern ally biased input is typically ac -coupled and, when \nconfigured as such, can accept any differential signal with single -ended swing up \nto 3.3 V. If dc -coupled, input can be LVPECL, CMOS, or LVDS. \n62 REFAA  I Differential input  Complementary Reference A Inpu t. Complementary signal to the input provided \non Pin 61. The user can configure this pin as a separate single -ended input.  \n63, 70, 74  AVDD  I Power  1.8 V Analog (Reference Input) Power Supply.  \n64 REFB  I Differential input  Reference B Input. This internall y biased input is typically ac -coupled and, when \nconfigured as such, can accept any differential signal with single -ended swing up \nto 3.3 V. If dc -coupled, input can be LVPECL, CMOS, or LVDS. \n65 REFBB I Differential \ninput  Complementary Reference B Input. Complementary signal to the input provided on Pin 64. The user can configure this pin as a separate single -ended input.  \n68 REFC I Differential \ninput  Reference C Input. This internally biased input is typically ac -coupled and, when \nconfigured as such, can accept any differential signal with single -ended swing up \nto 3.3 V. If dc -coupled, input can be LVPECL, CMOS, or LVDS. \n69 REFCC  I Differential input  Complementary Reference C Input. Complementary signal to the input provided on Pin 68. The user can config ure this pin as a separate single -ended input.  \n71 REFD  I Differential \ninput  Reference D Input. This internally biased input is typically ac -coupled and, when \nconfigured as such, can accept any differential signal with single -ended swing up \nto 3.3 V. If dc -coupled, input can be LVPECL, CMOS, or LVDS. \n72 REFDD  I Differential \ninput  Complementary Reference D Input. Complementary signal to the input provided on Pin 71. The user can configure this pin as a separate single -ended input.  \n76 IRQ O Logic  Interru pt Request Line.  \n78, 79, 80, 81, 84, 85, \n86, 87 M0, M1, M2, \nM3, M4, M5, \nM6, M7  I/O 3.3 V CMOS Configurable I/O Pins. These pins are configured under program control.  M0 to \nM2 control the serial port mode selection (see Table 29), and M3 to M7 cont rol \nthe EEPROM loading at start up or reset (see the Initial M0 to M7 Pin Programming  \nsection ). Note that there  are no internal pull -up or pull -down resistors on these \npins, and the us er should place pull-up or pull -down resistors on each of these \npins to avoid unpredictable start -up behavior . \nEP VSS O Exposed \npad  The exposed pad must be connected to ground (VSS).  \n \nRev. G | Page 17 of 111 \nAD9548 Data Sheet \n \nTYPICAL PERFORMANCE CHARACTERISTICS  \nfR = input reference clock  frequen cy; fO = clock  frequency;  fSYS = SYSCLK input  frequency ; fS = internal system clock frequency ; LBW  = DPLL  \nloop bandwidth ; PLL off  = SYSCLK  PLL bypassed ; PLL on = SYSCLK  PLL enabled ; ICP = SYSCLK PLL charge pump current; LF  = SYSCLK  \nPLL loop filter . AVDD, A VDD3, and  DVDD at nominal supply voltage,  fS = 1 GHz , ICP = automatic mode , LF = internal , unless otherwise noted . \n–160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 173fs (–75.4dBc)\n20kHz TO 80MHz: 315fs (–70.2dBc) (EXTRAPOLATED)\n08022-068 \nFigure 3. Additive Phase Noise (Output Driver = LVPECL),  \nfR = 19.44 MHz, f O = 155.52 MHz,  \nLBW = 1 kHz, f SYS = 1 GHz, PLL Off  \n–160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 333fs (–69.8dBc)\n20kHz TO 80MHz: 430fs (–67.6dBc) (EXTRAPOLATED)\n08022-056 \nFigure 4. Additive Phase Noise (Output Driver = LVPECL),  \nfR = 19.44 MHz, f O = 155.52 MHz,  \nLBW = 1 kHz, f SYS = 50 MHz (Crystal), PLL On  –160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 103fs (–74.0dBc)\n20kHz TO 80MHz: 160fs (–70.1dBc)\n08022-066 \nFigure 5. Additive Phase Noise (Output Dr iver = LV PECL),  \nfR = 19.44 MHz, f O = 311.04 MHz,  \nLBW = 1 kHz, f SYS = 1 GHz, PLL Off  \n–160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 310fs (–64.4dBc)\n20kHz TO 80MHz: 330fs (–63.9dBc)\n08022-067 \nFigure 6. Additive Phase Noise (Output Driver = LVPECL),  \nfR = 19.44 MHz, f O = 311.04 MHz,  \nLBW = 1 kHz, f SYS = 50 MHz (Crystal), PLL On  \nRev. G | Page 18 of 111 \nData Sheet AD9548 \n \n–160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 361fs (–69.0dBc)\n20kHz TO 80MHz: 441fs (–67.3dBc) (EXTRAPOLATED)\n08022-069 \nFigure 7. Absolute  Phase Noise (Output Driver = LVPECL),  \nfR = 19.44 MHz, f O = 155.52 MHz,  \nLBW = 1 kHz, f SYS = 50 MHz, PLL On  \n–160–150–140–130–120–110–100–90–80–70\n10 100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 10MHz: 717fs (–65.1dBc)\n12kHz TO 20MHz: 725fs (–65.0dBc)\n20kHz TO 80MHz: 790fs (–64.3dBc)\n08022-044 \nFigure 8. Absolut e Phase Noise (Output Driver = LVPECL),  \nfR = 1 Hz, f O = 122.88 MHz,  \nLBW =  0.05 Hz, f SYS = 20 MHz (OCXO), PLL On  \n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)–160–150–140–130–120–110–100–90–80–70\nINTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 336fs (–69.7dBc)\n20kHz TO 80MHz: 425fs (–67.6dBc) (EXTRAPOLATED)\n08022-052 \nFigure 9. Absolut e Phase Noise (Output Driver = LVPECL),  \nfR = 8 kHz, f O = 155.52 MHz,  \nLBW = 100 Hz, f SYS = 50 MHz (Crystal), PLL On  –160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y (Hz)ROHDE & SCHWARZ\nSMA100 (1GHz)ROHDE & SCHWARZ\nSMA100 (50MHz)50MHz CRYSTAL\n08022-058 \nFigure 10. Absolute Phase N oise Comparison of SYSCLK Input Options \n(Output Driver = LVPECL),  \nfR = 19.44 MHz, f O = 311.04 MHz, LBW = 1 kHz  \n–160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 356fs (–69.2dBc)\n20kHz TO 80MHz: 435fs (–67.4dBc) (EXTRAPOLATED)\n08022-054 \nFigure 11. Absolut e Phase Noise (Output Driver = LVPECL),  \nfR = 1 Hz, f O = 155.52 MHz,  \nLBW = 0.05 Hz, f SYS = 50 MHz, PLL On  \n–160–150–140–130–120–110–100–90–80–70\n100 1k 10k 100k 1M 10M 100MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)INTEGRATED RMS JITTER (PHASE NOISE):\n5kHz TO 20MHz: 245fs (–72.4dBc)\n20kHz TO 80MHz: 300fs (–64.3dBc) (EXTRAPOLATED)\n08022-051 \nFigure 12. Absolut e Phase N oise (Output Driver = LVPECL),  \nfR = 19.44 MHz, f O = 155.52 MHz,  \nLBW = 1 kHz, f SYS = 50 MHz (Crystal), PLL On with  \n2x Frequency Multiplier, I CP = 375 μA, LF = External (350 kHz)  \nRev. G | Page 19 of 111 \nAD9548 Data Sheet \n \nROHDE & SCHWARZ\nSMA100 (1GHz)\nROHDE & SCHWARZ\nSMA100 (50MHz)20MHz OCXO\n–170–160–150–140–130–120–110–100–90\n100 1k 10k 100k 1M 10MPHASE NOISE (dBc/Hz)\nFREQUENC Y OFFSET (Hz)\n08022-053 \nFigure 13. Phase Noise of SYSCLK Input Sources  \n \n \nLVDS\n00.20.40.60.81.0\n0 100 200 300 400 500 600 700AMPLITUDE (V)\nFREQUENC Y (MHz)LVPECL\n08022-049 \nFigure 14. Amplitude vs. Toggle Rate,  \nLVPECL and LVDS  \n10pF LOAD\n20pF LOAD\n1.01.52.02.53.03.54.0\n0 100 200 300 400 500AMPLITUDE (V)\nFREQUENC Y (MHz)\n08022-055 \nFigure 15. Amplitude vs. Toggle Rate,  \n3.3 V CMOS (Strong Mode)  –70–60–50–40–30–20–10010\n10 100 1k 10k 100k\nFREQUENC Y OFFSET (Hz)CLOSED-LOO P GAIN (dB)\n08022-047CLOSED-LOOPPEAK ING:0.04dB\n \nFigure 16. Jitter Transfer Bandwidth, Output Driver = LVPECL, \nfR = 19.44 MHz, f O = 155.52 MHz,  \nLBW = 100 Hz (Phase Margin = 88°), f SYS = 1 GHz, PLL Off  AMPLITUDE (V)\nFREQUENCY (MHz)\n08022-0620.51.01.52.0\n0 50 100 150 250 2005pF LOAD\n10pF LOAD20pF LOAD\n \nFigure 17. Amplitude vs. Toggle Rate,  \n1.8 V CMOS  \n10pF LOAD5pF LOAD\n1.01.52.02.53.03.54.0\n0 10 20 30 40 50AMPLITUDE (V)\nFREQUENC Y (MHz)\n08022-063 \nFigure 18. Amplitude vs. Toggle Rate,  \n3.3 V CMOS (Weak Mode)  \nRev. G | Page 20 of 111 \nData Sheet AD9548 \n \nLVDSLVPECL\n50607080120\n110\n100\n90130140\n0 100 200 300 400 500POWER (mW)\nFREQUENC Y (MHz)\n08022-064 \nFigure 19. Power Consumption vs. Frequency,  \nLVPECL and LVDS  \n(Single Channel)  \n20406080100120140160\n0 50 100 150 200 250 300 350POWER (mW)\nFREQUENC Y (MHz)10pF LOAD\n08022-0605pF LOAD20pF LOAD\n \nFigure 20. Power Consumption vs. Frequency,  \n3.3 V CMOS (Strong Mode)  \n–1.0–0.8–0.6–0.4–0.200.20.40.60.81.0\n0 1 2 3 4 5DIFFERENTIA LAMPLITUDE (V)\nTIME (ns)\n08022-050 \nFigure 21. Output Waveform,  \nLVPECL (400 MHz)  \nPOWER (mW)\nFREQUENCY (MHz)\n08022-061152025303540\n0 50 100 150 20010pF LOAD 5pF LOAD20pF LOAD\n \nFigure 22. Power Consumption vs. Frequency,  \n1.8 V CMOS  \n20pF LOAD 5pF LOAD\n2022242628303234\n10 15 20 25 30 35 40POWER (mW)\nFREQUENC Y (MHz)10pF LOAD\n08022-059 \nFigure 23. Power Consumption vs. Frequency,  \n3.3 V CMOS (Weak Mode)  \n–0.5–0.4–0.3–0.2–0.100.10.20.30.40.5\n0 1 2 3 4 5DIFFERENTIA LAMPLITUDE (V)\nTIME (ns)\n08022-048 \nFigure 24. Output Waveform,  \nLVDS (400 MHz)  \nRev. G | Page 21 of 111 \nAD9548 Data Sheet \n \n–0.500.51.01.52.02.53.03.5\n0 2 4 6 8 10 12 14 16AMPLITUDE (V)\nTIME (ns)20pF LOAD10pF LOAD\n08022-057 \nFigure 25. Output Waveform,  \n3.3 V CMOS (100 MHz, Strong Mode)  \n–0.500.51.01.52.0\n0 2 4 6 8 10 12 14 16AMPLITUDE (V)\nTIME (ns)20pF LOAD10pF LOAD\n08022-065 \nFigure 26. Output Waveform,  \n1.8 V CMOS (100 MHz)  5pF LOAD\n20 pF LOAD\n–0.500.51.01.52.02.53.03.5\n0 10 20 30 40 50 60 70 80AMPLITUDE (V)\nTIME (ns)\n08022-046 \nFigure 27. Output Waveform,  \n3.3 V CMOS (20 MHz, Weak Mode)  \n \n \n  \n \n  \n \n \n    \n \n \nRev. G | Page 22 of 111 \nData Sheet AD9548\n \nRev. G | Page 23 of 111 INPUT/OUTPUT TERMINATION RECOMMENDATIONS \n \nAD9548\n100ΩHIGH\nIMPEDANCE\nINPUTDOWNSTREAM\nDEVICE\n0.1µF0.1µF\n3.3V LVDS\nOUTPUT\n08022-003\nFigure 28. AC-Coupled LVDS or LVPECL Output Driver \nAD9548\n100Ω DOWNSTREAM\nDEVICE 3.3V\nLVPECL-\nCOMPATIBLE\nOUTPUT\n08022-004 \nFigure 29. DC-Coupled LVDS or LVPECL Output Driver \n100Ω\n0.1µF0.1µF\nAD9548\nSELF-BIASED\nREFERENCE\nINPUT(OPTIONAL)\n08022-005 \nFigure 30. Reference Input \n100Ω\n0.1µF0.1µF\nAD9548\nSELF-BIASED\nSYSCLK\nINPUT(OPTIONAL)\n08022-006 \nFigure 31. SYSCLKx Input 0.1µF0.1µF\nAD9548\nSELF-BIASED\nCLKINx\nINPUT\n08022-007(OPTIONAL)100Ω\nFigure 32. CLKINx Input \nSYSCLKP300Ω\n150Ω0.1µF\nSYSCLKNAD95483.3V\nCMOS\nTCXO\n0.1µF\n08022-134 \nFigure 33. System Clock Input (SYSCLKP/SYSCLKN) When Using a \nTCXO/OCXO with 3.3 V CMOS Output \n08022-133SYSCLKP\nSYSCLKNAD954810MHz TO 50MHz FUNDAMENTAL\nAT-CUT CRYSTAL WITH 10pF\nLOAD CAPACITANCE (C LOAD )15pF\n15pF0Ω\n(OPTIONAL)\nNOTES\n1. THE RECOMMENDED CLOAD  = 10pF IS SHOWN. THE VALUES OF THE 15pF\nSHUNT CAPACITORS SHOWN HERE MUST EQUAL 2 × (CLOAD  − CSTRAY ),\nWHERE CSTRAY  IS TYPICALLY 2pF TO 5pF). THE SERIES RESISTOR\nCONNECTED TO SYSCLKN IS NORMALLY NOT REQUIRED, BUT CAN BEUSEFUL TO LIMIT THE POWER DISSIPATED IN THE CRYSTAL.\nFigure 34. System Clock Inpu t (XOA/XOB) in Crystal Mode \n \n \nAD9548 Data Sheet\n \nRev. G | Page 24 of 111 GETTING STARTED \nPOWER-ON RESET \nThe AD9548 monitors the voltage on the power supplies at \npower-up. When DVDD3 is greater than 2.35 V ± 0.1 V and \nDVDD (Pin 1, Pin 6, Pin 12, Pin 77, Pin 83, and Pin 88) is greater than 1.4 V ± 0.05 V , the device generates a 75 ns reset \npulse. The power-up reset pulse is internal and independent of \nthe RESET pin. This internal power-up reset sequence eliminates the need for the user to provide external power supply sequencing. Within 45 ns after the leading edge of the internal reset pulse, the M0 to M7 multifunction pins behave as high impedance \ndigital inputs and remain so until programmed otherwise. \nINITIAL M0 TO M7 PIN PROGRAMMING \nDuring a device reset (either via the power-up reset pulse or the \nRESET pin), the multifunction pins (M0 to M7) behave as high \nimpedance inputs, but upon removal of the reset condition, \nlevel-sensitive latches capture the logic pattern present on the multifunction pins. The AD9548 requires that the user supply \nthe desired logic state to the M0 to M7 pins by means of pull-up \nand/or pull-down resistors (nominally 10 kΩ to 30 kΩ). \nThe initial state of the M0 to M7 pins following a reset is \nreferred to as FncInit, Bits[7:0]. Bits[7:0] of FncInit map directly \nto the logic states of M7:0, respectively. The three LSBs of \nFncInit (FncInit, Bits[2:0]) determine whether the serial port interface behaves according to the SPI or I\n2C protocol. \nSpecifically, FncInit, Bits[2:0] = 000 selects the SPI interface, while any other value selects the I\n2C port with the three LSBs of \nthe I2C bus address set to the value of FncInit, Bits[2:0]. \nThe five MSBs of FncInit (FncInit, Bits[7:3]) determine the \noperation of the EEPROM loader. On the falling edge of RESET, \nif FncInit, Bits[7:3] = 00000, then the EEPROM contents are not transferred to the control registers and the device registers assume their default values. However, if FncInit, Bits[7:3] ≠ 00000, then the EEPROM controller transfers the contents of the EEPROM \nto the control registers with condition = FncInit, Bits[7:3] (see \nthe EEPROM section). \nDEVICE REGISTER PROGRAMMING \nThe initial state of the M0 to M7 pins establishes the serial \ninput/output port protocol (SPI or I2C). Using the appropriate \nserial port protocol, and assuming that an EEPROM download \nis not used, program the device according to the recommended sequence described in the Program the System Clock Functionality \nsection through the Generate the Output Clock section. \nProgram the System Clock Functionality \nThe system clock parameters reside in the 0100 register address \nspace. They include the following: \n\uf0b7 System clock PLL controls \n\uf0b7 System clock period \n\uf0b7 System clock stability timer It is essential to program the system clock period because many of \nthe AD9548 subsystems rely on this value. It is highly recommended \nto program the system clock stability timer, as well. This is especially important when using the system clock PLL but also \napplies if using an external system clock source, especially if the \nexternal source is not expected to be completely stable when \npower is applied to the AD9548. \nInitialize the System Clock \nAfter the system clock functionality is programmed, issue an \ninput/output update using Register 0x0005, Bit 0 to invoke the system clock settings. \nCalibrate the System Clock (Only if Using SYSCLK PLL) \nSet the calibrate system clock bit in the sync/cal register \n(Address 0x0A02, Bit 0) and issue an input/output update. Then \nclear the calibrate system clock bit and issue another input/output \nupdate. This action allows time for the calibration to proceed \nwhile programming the remaining device registers. \nProgram the Multifunction Pins (Optional) \nThis step is required only if the user intends to use any of the \nmultifunction pins for status or control. The multifunction pin parameters reside in the 0x0200 to 0x0207 register address \nspace. The default configuration of the multifunction pins is as \nan undesignated high impedance input pin. \nProgram the IRQ Functionality (Optional) \nThis step is required only if the user intends to use the IRQ feature. \nIRQ control resides in the 0x0200 to 0x0207 register address space. \nIt includes the following: \n\uf0b7 IRQ pin mode control \n\uf0b7 IRQ mask \nThe IRQ mask default values prevent interrupts from being \ngenerated. The IRQ pin mode default is open-drain NMOS. \nProgram the Watchdog Timer (Optional) \nThis step is required only if the user intends to use it. Watchdog \ntimer control resides in the 0x0200 register address space. The \nwatchdog timer is disabled by default. \nProgram the DAC Full-Scal e Current (Optional) \nThis step is required only if the user intends to use a full-scale \ncurrent setting other than the default value. DAC full-scale \ncurrent control resides in the 0x0200 register address space. \nData Sheet AD9548\n \nRev. G | Page 25 of 111 Program the Digital Phas e-Locked Loop (DPLL) \nThe DPLL parameters reside in the 0x0300 register address \nspace. They include the following: \n\uf0b7 Free-run frequency (DDS frequency tuning word) \n\uf0b7 DDS phase offset \n\uf0b7 DPLL pull-in range limits \n\uf0b7 DPLL closed-loop phase offset \n\uf0b7 Phase slew control (for hitless reference switching) \n\uf0b7 Tuning word history control (for holdover operation) \nProgram the Clock Distribution Outputs \nThe clock distribution parameters reside in the 0x0400 register \naddress space. They include the following: \n\uf0b7 Output power-down control \n\uf0b7 Output enable (disabled by default) \n\uf0b7 Output synchronization \n\uf0b7 Output mode control \n\uf0b7 Output divider functionality \nProgram the Reference Inputs \nThe reference input parameters reside in the 0x0500 register \naddress space. They include the following: \n\uf0b7 Reference power-down \n\uf0b7 Reference logic family \n\uf0b7 Reference profile assignment control \n\uf0b7 Phase build-out control \nProgram the Reference Profiles \nThe reference profile parameters reside in the 0x0600 to 0x0700 \nregister address space. They include the following: \n\uf0b7 Reference priority \n\uf0b7 Reference period \n\uf0b7 Reference period tolerance \n\uf0b7 Reference validation timer \n\uf0b7 Reference redetect timer \n\uf0b7 Digital loop-filter coefficients \n\uf0b7 Reference prescaler (R-divider) \n\uf0b7 Feedback dividers (S, U, and V) \n\uf0b7 Phase and frequency lock detector controls Generate the Reference Acquisition \nAfter the registers are programmed, issue an input/output \nupdate using Register 0x0005, Bit 0 to invoke all of the register settings programmed up to this point. \nIf the settings are programmed for manual profile assignment, \nthe DPLL locks to the first available reference that has the highest priority. If the settings are programmed for automatic profile assignment, then write to the reference profile detect register (Address 0x0A0D) to select the state machines that require starting. Next, issue an input/output update \n(Address 0x0005, Bit 0) to start the selected state machines. \nUpon completion of the reference detection sequence, the DPLL locks to the first available reference with the highest \npriority. \nGenerate the Output Clock \nIf the registers are programmed for automatic clock distribution \nsynchronization via DPLL phase or frequency lock, the synthesized \noutput signal appears at the clock distribution outputs (assuming the output is enabled and that the DDS output signal has been routed to the CLKIN input pins). Otherwise, set and \nthen clear the sync distribution bit (Address 0x0A02, Bit 1) or \nuse a multifunction pin input (if programmed accordingly) to generate a clock distribution sync pulse, which causes the synthesized output signal to appear at the clock distribution \noutputs. \n     \n \n    \n \nAD9548 Data Sheet\n \nRev. G | Page 26 of 111 THEORY OF OPERATION \nTW CLAMP\nAND\nHISTORYPROG.\nDIGITAL\nLOOP\nFILTERTDC/PFD\n÷R÷SDIGITAL PLL CORE\nHOLDOVER\nLOGIC\nCONTROL\nLOGICLOW NOISE\nCLOCK\nMULTIPLIER\nAMP\nSYSCLK PORTINPUT\nREF\nMONITOR\nIRQ AND\nSTATUS\nLOGIC\nDIGITAL\nINTERFACEIRQ\nSYSCLKN SYSCLKPCLKINNCLKINP\nM0 TO M7REFA\nREFAAOUT0P\nPHASE\nCONTROLLERDDS/DACAD9548\n4 OR 8OUT0NOUT_RSET\nOUT1P\nOUT1N\nOUT2P\nOUT2N\nOUT3POUT3N POST\nDIVPOST\nDIVPOST\nDIVPOST\nDIV\nCLOCK\nDISTRIBUTIONREFB\nREFBB\nREFC\nREFCC\nREFD\nREFDDDIFFERENTIAL\nOR\nSINGLE-ENDED\nEXTERNAL\nANALOG\nFILTER\n08022-009 \nFigure 35. Detailed Block Diagram \nOVERVIEW \nThe AD9548 provides clocking outputs directly related in phase \nand frequency to the selected (active) reference but with jitter \ncharacteristics primarily governed by the system clock. The \nAD9548 supports up to eight reference inputs and a wide range \nof reference frequencies. The core of this product is a digital phase-locked loop (DPLL). The DPLL has a programmable digital loop filter that greatly reduces jitter transferred from the active reference to the output. The AD9548 supports both \nmanual and automatic holdover. While in holdover, the \nAD9548 continues to provide an output as long as the DAC \nsample clock is present. The holdover output frequency is a time average of the output frequency history just prior to the \ntransition to the holdover condition. \nThe device offers manual and automatic reference switchover \ncapability if the active reference is degraded or fails completely. A direct digital synthesizer (DDS) and integrated DAC \nconstitute a digitally controlled oscillator (DCO). The DCO \noutput is a sinusoidal signal (450 MHz maximum) at a frequency determined by the active reference frequency and the programmed values of the reference prescaler (R) and feedback divider (S). Although not explicitly shown in Figure 35, the \nS-divider has both an integer and fractional component, which \nis similar to a fractional-N synthesizer. The SYSCLKx input provides the sample clock for the DAC, \nwhich is either a directly applied high frequency source or a low frequency source coupled with the integrated PLL-based \nfrequency multiplier. The low frequency option also allows for \nthe use of a crystal resonator connected directly across the \nSYSCLKx inputs. \nThe DAC output routes directly off-chip, where an external \nfilter removes the sampling artifacts before returning the signal on-chip at the CLKINx inputs. Once on-chip, an integrated comparator converts the filtered sinusoidal signal to a clock signal (square wave) with very fast rise and fall times. \nThe clock distribution section provides four output drivers. \nEach driver is programmable either as a single differential \nLVPECL/LVDS output or as a dual single-ended CMOS output. Furthermore, each of the four outputs has a dedicated 30-bit programmable postdivider. The clock distribution section operates at up to 725 MHz. This enables use of a band-pass \nreconstruction filter (for example, a SAW filter) to extract a \nNyquist image from the DAC output spectrum, thereby allowing output frequencies that exceed the typical 450 MHz \nlimit at the DAC output. \nData Sheet AD9548 \n \nREFERENCE CLOCK INPU TS \nFour pairs of pins provide access to the reference clock receivers.  \nEach pair is configurable  either  as a single differential receiver  \nor as two independent single -ended receivers . To accommodate \ninput  signals  with slow rising and falling edges , both the \ndifferential and sing le-ended input receivers employ  hysteresis. \nHysteresis also ensures that a disconnected or floating input \ndoes not cause the receiver to oscillate spontaneousl y. \nWhen configured for differential operation, the input receivers \naccommodate either ac - or dc-coupled input signals. The \nreceiver is internally  dc biased in order to handle ac -coupled \noperation.  \nWhen configured for single -ended operation, the input \nrecei vers exhibit a pull -down load of 4 5 kΩ (typical) . Three user \nprogrammable threshold voltage ranges are available for each \nsingle -ended receiver.  \nREFERENCE MONITOR S \nThe reference monitors depend on a known and accurate \nsystem clock period . Therefore , the functioning of the reference \nmonitors  is not reliable until the system clock is stable . To avoid \nan incorrect valid indication, the reference monitors indicate \nfault status until the system clock stability timer  expires  (see the \nSystem Clock Stability Timer  section).  \nReference Period Monitor  \nEach reference input has a dedicated monitor that repeatedly \nmeasures the reference period. The AD9548 uses the reference \nperiod measureme nts to determine the validity of the reference \nbased on a set of user provided parameters in the profile \nregister  area of the register map  (see the Profile Registers \n(Register 0 X0600 to Register 0X07FF ) section) . The AD9548 \nalso uses the reference period monitor to assi gn a particular \nreference to a p rofile when the user programs the device for \nautomatic profile assignment.  \nThe monitor works  by comparing the measured period of a \nparticular reference input with  the parameters  stored in the \nprofile register assigned to that same reference input. The \nparameters include the reference period, an inner tolerance, and \nan outer tolerance. A 50 -bit nu mber defines t he reference \nperiod  in units of femtoseconds. The 50 -bit range allows for a \nreference period  entry of up to 1.125 sec. However, an actual \nreference signal wit h a period in excess of 1 sec  is beyond the \nrecommended operating range of the devic e. A 20-bit number \ndefines the inner and outer tolerances . The value stored in the \nregister is the reciprocal of the tolerance  specification. For \nexample, a to lerance specification of 50 ppm yields a register \nvalue of 1/(50 ppm)  = 1/0.000050 = 20,000 (0x04E20) . \nThe use of two tolerance values provides hysteresis for the \nmonitor decision logic. The inner tolerance applies to a previously faulted reference and specifies the largest  period \ntolerance that a previously faulted reference can exhibit before it \nqualifies as non faulted . The outer tolerance applies to an already \nnonfaulted  reference. It specifies the largest  period tolerance \nthat a nonfaulted reference can  exhibit before being faulted.  \nTo produce decision hysteresis, t he inner tolerance must be less \nthan the outer tolerance . That is, a faulted reference must meet \ntighte r requirements to become nonfaulted than a nonfaulted \nreference must meet to become faulted.  \nReference Validation Timer  \nEach reference input has a dedicated validation timer. The validat ion timer establishes the amount of time that a \npreviously faulted reference must remain fault free before the \nAD9548 declares it nonfaulted . The timeout period of the \nvalidation timer is programmable via a 16 -bit register (see the \nvalidation register cont ained within each of the eight p rofile  \nregister s in the register map , Address 0x0600 to Address  0x07FF ). \nThe 16 -bit number stored in the validation register represents \nunits of milliseconds, which yie lds a maximum timeout period \nof 65,535 ms. \nNote that a validation period of 0  must be programmed to \ndisable  the validation timer. With the validation timer disabled , \nthe user must validate a reference manually via the fo rce \nvalidation t imeout register ( Address 0x0A0E).  \nReference Redetect Timer  \nEach reference input has a dedicated redetect ti mer. The \nredetect timer is useful only with  the device programmed for \nautomatic profile selection. The redetect timer  establishes the  \namount of time that a reference must remain faulted before the \nAD9548 attempts to re assign it to a new profile. The timeout \nperiod of the redetect timer is program mable via a 16 -bit \nregister (see the r edetect timeout register conta ined within each \nof the eight p rofile  registers  in the register map , Address 0x0600 \nto Address 0x 07FF ). The 16 -bit number stored in the redetect \ntimeout register represents units of millis econds, which yields a \nmaximu m timeout period of 65,535 ms.  \nNote that a timeout period of 0  must be programmed to disable \nthe redetect timer.  \nReference Validation  Override Control \nRegister 0x0A0E  to Register 0x0A10 provide the user with the \nability to over ride the reference validation logic enabling a \ncertain level of troubleshooting capability. Each of the eight input references has a dedicated block of validation logic as \nshown in  Figure 36. The state of the valid  signal at the o utput is \nwhat defines a particular reference as valid (1) or not (0), which includes the validation period (if activated) as prescribed by the \nvalidation timer. The override controls are the thr ee control bits \non the left side of the diagram.  \n \nRev. G | Page 27 of 111 \nAD9548 Data Sheet \n \nDQ\nR\n01EN\nFAULTEDVALID\nFORCE VALIDATION\nTIMEOUT\nREF FAULTREF MONITOR\nBYPASS\nREF MONITOR\nOVERRIDEREGISTER CONTROL BITSREFERENCE VALIDATION LOGIC\n(8 COPIES, 1 PER REFERENCE INPUT)\nREFERENCE\nMONITORRVALIDATION TIMER\nTIMEOUT\n08022-010 \nFigure 36. Reference Validation Override \n \nThe main feature to note is that any time faulted = 1, the output \nlatch is reset, which forces valid = 0 (indicating an invalid reference)  \nregardless of the state of any other signal. Under the def ault \ncondition ( that is, all three control  bits are  0), the reference \nmonitor is the primary source of the validation process. This is because , under the default condition , the ref fault  signal from \nthe reference monitor is identically equal to the faulted  signal.  \nThe function of the faulted  signal is fourfold. \n• Any time faulted = 1, then valid = 0, regardless of the state \nof any other control signal. Therefore , faulted = 1 indicates \nan invalid reference.  \n• Any time the faulted  signal transitions from 0 to 1 ( that is , \nfrom nonfaulted to faulted), the validation timer is \nmomentarily reset, which means that , when it is enabled , it \nmust exhaust its full counting sequence before it expires.  \n• When faulted = 0 (that is, the reference is not faulted), the \nvalidation ti mer is allowed to perform its t iming sequence. \nWhen faulted  = 1 (that is , the reference is faulted), the \nvalidation timer is reset and halted.  \n• The faulted  signal passes through an inverter , converting it \nto a non faulted  signal, which appears at the input o f the \nvalid  latch . This allows the valid  latch to capture  the state \nof the nonfaulted  signal  when the validation timer expires.  \nThe ref monitor bypass control bit enables bypassing of the ref  \nfault  signal generated by the reference monitor. When r ef \nmonito r bypass = 1, the state of the faulted  signal is dictated by \nthe ref monitor override control bit. This is useful when the \nuser relies on an external reference monitor rather than the internal m onitor resident in the device. The user programs the \nref monit or override bit based on the status of the external \nmonitor. On the other hand , when r ef monitor bypass = 0, the \nref monitor o verride control bit allows the user to man ually test \nthe operation of both the valid latch and the validation timer . In \nthis case,  the user relies on the signal generated by the internal \nreference mo nitor  (ref fault) but uses the  ref monitor o verride \nbit to emulate a fa ulted reference. That is, when ref m onitor \noverride = 1, then faulted = 1, but when r ef monitor o verrid e = 0 , \nthen faulted = ref fault . \nIn addition, the user has the ability to emulate a timeout of th e \nvalidation timer via the appropriate force validation timeout \ncontrol bit  in Register 0x0A0E . Writing a Logic 1 to any of these auto clearing bit s triggers the valid  latch , which is identically \nequivalent to a timeout of the validation timer.  \nREFERENCE P ROFILES  \nThe AD9548 has eight i ndependent profile registers. A profile \nregister co ntains  50 bytes that establish a particular set of device \nparameters . Each of the eight input references can be assigned \nto any one of the eight profiles (that is, more  than one reference \ncan be assigned to the same profile). The profiles allow  the user \nto prescribe the specific device functi onality that should take \neffect when one of the input  references (assigned to the profile) \nbecomes the active reference. Each profile register has the same format and  stores  the following  device parameters : \n• Reference pr iority  \n• Reference period value ( in femto seconds ) \n• Inner tolerance value (1/ tolerance ) \n• Outer tolerance value (1/ tolerance ) \n• Validation timer value (m illiseconds ) \n• Redetect timer value ( millis econds ) \n• Digital loop filter coefficients  \n• Reference prescaler setting ( R-divider ) \n• Feedback divider settings (S, U , and V)  \n• DPLL phase lock detector threshold level  \n• DPLL phase lock detector fill rate  \n• DPLL phase lock detector drain  rate \n• DPLL frequency lock detector threshold level  \n• DPLL frequency lock detector fill rate  \n• DPLL freq uency lock detector drain  rate \nReference- to-Profile Assignment  Control \nThe user can manually assign a reference to a profile or let the \ndevice make the assignment automatically. The  manual r eference  \nprofile s election register  (Address 0x0503 to Address 0x0506)  is \nwhere  the user programs whether a reference- to-profile \nassignment is manual or automatic . The manual reference \nprofile s election register is a 4 -byte register  partitioned into \neight half bytes (or nibbles). The eight  nibble s form a one -to-one \ncorre spondence  with  the eight  reference inputs:  one nibble for \nREF A, the next for REF AA, and so on.  For a reference configured  \nas a differential input, h owever, the device ignores the nibble \nassociated with the two -letter input. For example, if the B \nRev. G | Page 28 of 111 \nData Sheet AD9548 \n \nreferenc e is differential, then  only the REF B nibble matters (the \ndevice ignores the REF BB nibble).  \nThe MSB of each  nibble is the manual p rofile bit , whereas  the three \nLSBs  of each nibble  identify one of the eight profiles (0  to 7). A \nLogic 1  for the m anual profile bit assigns  the associated reference to \nthe profile identified by  the three  LSBs of the nibble . A Logic 0 for \nthe m anual profile bit configures the associated reference for \nautomatic reference -to-profile assignment (the three  LSBs are \nignored in this cas e). Note that references configure d for automatic \nreference -to-profile assignment  require activation (see the \nReference- to-Profile Assignment State Machine section).  \nReference- to-Profile Assignment State Machine  \nThe functional flexibility of the AD9548 resides in the way that \nit assigns a particular input reference to one of the eight \nreference profiles . The reference- to-profile assignment state \nmachine effectively  builds a reference -to-profile table that maps \nthe index of each input reference to a profile  (see Table 22). \nEach entry in the profile column consists of a profile number \n(0 to 7) or a null  value. A null value appears when  a \nreference- to-profile assignment does not exist for a particular \nreference input (following a reset, for example).  The \ninformation in  Table 22 appears in the register map \n(Register  0x0D0C  to Regi ster 0x0D13) so that the user has \naccess to the reference -to-profile assignments on a real -time \nbasis. Register 0x 0D0C contains the information for REF A, \nRegister 0x0D0D contains the information for REF AA, and so \non to Register 0x0D13 for REF DD. Bit 7 o f each register is the \nnull indicator for that particular ref erence. If Bit 7  = 0, then the \nprofile assignment for that pa rticular reference is null. If B it 7 = 1, \nthen that particular reference is  assigned to t he profile (0  to 7) \nidentified by B its[6:4]. Note that B its[6:4] are meaningless \nunless Bit 7  = 1. \nTable 22. Reference-to -Profile Table  \nReference Input  Reference Index  Profile  \nA 0 Profile number (or null \nvalue)  \nAA 1 Profile number (or null \nvalue)  \nB 2 Profile number (or null  \nvalue)  \nBB 3 Profile number (or null \nvalue)  \nC 4 Profile number (or null \nvalue)  \nCC 5 Profile number (or null \nvalue)  \nD 6 Profile number (or null \nvalue)  \nDD 7 Profile number (or null \nvalue)  \nFollowing a reset, the reference -to-profile assignment state \nmachine is inactive to avoid improper ly assigning a reference to \na profile  before the system clo ck stabilizes. T he reason is that the state machine relies on accurate information from the \nreference monitors, which , in turn , rely on a stable system clock. \nBeca use the reference -to-profile assignment state machine is \ninactive at power -up, t he user must initiate it manually  by \nwriting to the reference profile detect register (Address 0A0D) . \nThe state machine activate s immedia tely, unless the system \nclock i s not st abilized , in which case, activation occurs upon \nexpiration of t he system clock stability timer . Note that \ninitialization of the state machine is on a per -reference basis. \nThat is, each reference input  is associated with an independent \ninitialization contro l bit.  \nWhen  initialized for process ing a reference, the state machine \ncontinuously monitors that reference  until the occurrence of a \ndevice  reset. This is true even when  the user programs a \nreference for manual profile selection , in which case , the state \nmachine associated with that particular reference operates with \nits activity masked . The masked background activity  allow s for \nseamless operation if  the user subsequently reprogram s the \nreference for automatic profile selection.  \nReference- to-Profile Assignm ent  \nWhen a  reference is programmed for  manual pr ofile assignment  \n(see Register 0x 0503 to Register 0x0506) , the reference- to-profile \nassignment state machine simply puts  the programm ed manual \nprofile number into the profile column of  the reference -to-profil e \ntable  (see Table 22) in the row associated with the appropriate \nreference . However, w hen the user programs a reference for \nautomatic profile assignment,  the state machine must figure out \nwhich profile to assign to the reference.  \nAs long as a null entry appears in the reference -to-profile table  \nfor a particular input reference , the validation log ic for that \nreference  enters a period estimation  mode. Note that a null \nentry is the default state following a reset, but it also occurs \nwhen a reference redetect timer expires. The period estimation \nmode enables the validation logic to make a blind estimate of \nthe period of the input reference with a tolerance  of 0.1%. The \nvalidation logic remains in the period est imation  mode  until it \nsuccessfully estimates the reference period.  \nUpon a successful  reference period measurement by the \nvalidation logic, the state machine compares the measured period to the nominal reference period programmed into each \nof the eight profiles. The  state machine a ssigns the  reference to \nthe profile with the closest match to the measured period. If \nmore than one profile exact ly match es the reference period , \nthen the state machine chooses the profile  with the lowest \nnumeric index. For example, if the reference period  in both \nProfile 3 and Profile 5 match es the measured period, then \nProfile 3 is given  the assignment.  \nTo safeguard against making a poor reference -to-profile \nassignment, t he state machine ensures that the  measured \nreference period is within 6.25% of  the nominal reference \nperiod that appears in the  closest match profile . Otherwise, the \nstate machine does not make a profile assignment  and leaves \nthe null entry in the reference- to-profile table . \nRev. G | Page 29 of 111 \nAD9548 Data Sheet \n \nAs long as there are input references programmed for automatic \nprofile assignment, and for which the  profile assignment is null, \nthe state machine continue s to cycle through those references \nsearching for a profile match. Furthermore, unless an input \nreference is assigned to a profile , it is considered invalid and \nexclu ded as a candidate for a reference switchover.  \nREFERENCE SWITCH OVER  \nAn attractive feature of the AD9548 is its versatile reference \nswitc hover  capability. The flexib ility of the reference switchover \nfunctionality resides in  a sophisticated prioritizatio n algorithm \ncoupled with register -based controls. This scheme provide s the \nuser with  maximum control over  the state machine that handles \nreference switchover . \nThe main reference switchover control resides in the loop m ode \n(Address 0x0A01). The u ser selection mode bits (Register  0x0A01 , \nBits[ 4:3]) allow the user to select one of the reference switchover \nstate machine’s four operating modes, as follows:  \n• Automatic mode  (Add ress A01, Bits[ 4:3] = 00) \n• Fallback mode  (Address 0A01 , Bits[ 4:3] = 01) \n• Holdover mode  (Address 0A01 , Bits[ 4:3] = 10) \n• Manual mode  (Address 0A01 , Bits[ 4:3] = 11) \nIn automatic mode , a fully automatic priority -based algorithm \nselect s which reference is  the acti ve reference.  When programmed \nfor automati c mode, the device ignores the user selection refere nce \nbits (Register 0x0A01, Bits[ 2:0]). However, when programmed for \nany of the other three modes , the device make s use of the user \nreference bits. The se bits  spec ify a particular input reference \n(000  = REF A, 001  = REF AA ... , 111 = REF DD) . \nIn fallback mode, the u ser reference is the active reference \nwhenever it is  valid . Otherwise , the device switch es to a new \nreferen ce using the automatic, priority -based algorithm.  \nIn holdover mode, the us er reference i s the active reference \nwhenever  it is valid. O therwise , the device switches to holdover \nmode.  \nIn manual mode, the u ser reference i s the active reference \nwhether it is valid  or not . Note that , when using this mode , the \nuser must program the reference- to-profile assignment (see \nRegister 0x0503 to Register 0x 0506) as manual for the \nparticular reference declared as the user r eference . The reason is \nthat if  the us er reference fails and its redetect timer expires, then \nits profile assignment (shown in Table 22) becomes null. This \nmeans that the active reference (user r eference) does not have an \nassigned profile , which places the AD9548  into an undefined state.  \nThe user also has the option to force the device directly into holdover or free -run operation  via the user holdover and u ser \nfree-run bits (Register 0x 0A01, Bit  6 and Bit 5 , respectively ]). In \nfree-run mode, the free running frequency t uning word register  \n(Address  0x0300 to Address 0x0305) define s the DDS output \nfrequency. In h oldover mode, the DDS output frequency \ndepends on the holdover control settings (see the \nHoldover  \nsection).  Automatic Priority -Based Reference Switch over  \nThe AD9548 has a two-tiered , automatic , priority -based  \nalgorithm  that is in effect for both automatic and fallback \nreference switchover . The algorithm relies on the fact that  each \nreference profile contains both a selection priority and a promoted  \npriority. The selection and promoted priority values range from \n0 (highest priority) to 7 (lowest priority). The selecti on priority \ndetermines the order in which references are chosen as the active reference. The promoted priority is a separate priority value \ngiven to a reference only after  it becomes the active reference.  \nAn automatic reference switchover occurs on failure  of the \nactive reference or when a previously failed reference becomes \nvalid and its selection priority is higher than the promoted priority  \nof the curren tly active reference (assuming  that the automatic or \nfallback reference switchover is in effect ). When  performing  an \nautomatic reference switchover,  the AD9548 chooses a reference \nbased on the priority settings within the profiles. That is, the \ndevice switches to th e reference with the highest selection priority  \n(lowest numeric priority value) . It does so by  using the reference -\nto-profile  table (see Table 22) to determine the reference \nassociated with  the profile  exhibiting the highest prior ity. \nIf multiple references share the same profile , then the device \nchooses the reference having  the lowest  index value . For \nexample, if the A, B , and CC  references (Index  0, Index 2, and \nIndex 5, respectively) share the same profile , then a switchover \nto Reference A occurs  because R eference A has the lowest  index \nvalue . Note, however , that only valid  references are included  in \nswitchover  of the selection process.  The switchover cont rol logic \nignores any reference  with a status indication of invalid.  \nWhen u sing multiple differential reference inputs, physically \nconnect the reference input signal with the highest priority to the reference input with the lowest index value. For exa mple, a \ndifferential signal on Reference Input B should not have a \npriority that  exceeds a differential signal on Reference Input A. \nA differential reference  on Reference Input C should not have a \npriority that exceeds a differential signal on Reference Input B, \nand a differential signal on Reference Input D should not have a priority  that exceeds a differential signal on Reference Input C. \nA differential reference on Reference Input A has no priority restrictions. Table 23 shows four valid priority settings for four \ndifferential reference inputs.  \nTable 23. Valid Differential Reference Priority Examples\n1 \nReference \nInput  A Reference Input B Reference Input C Reference Input D \n0 1 2 3 \n0 0 0 0 \n3 3 4 4 \n2 2 3 7 \n1 Any reference input configured for a CMOS input is exempt from these \nconsiderations.  \n \nRev. G | Page 30 of 111  \nData Sheet AD9548\n \nRev. G | Page 31 of 111 The promoted priority parameter allows the user to assign a \nhigher priority to a reference after it becomes the active reference. For example, suppose four references have a selection priority of 3 and a promoted priority of 1, and the remaining \nreferences have a selection priority or 2 and a promoted priority \nof 2. Now, assume that one of the Priority 3 references becomes active because all of the Priority 2 references have failed. Some-time later, however, a Priority 2 reference becomes valid. The switchover logic normally attempts to automatically switch over \nto the Priority 2 reference because it has higher priority than the \npresently active Priority 3 reference. However, because the Priority 3 reference is active, its promoted priority of 1 is in effect. This is a higher priority than the newly validated reference’s priority of 2, so the switchover does not occur. This mechanism enables the user to give references preferential \ntreatment while they are selected as the active reference. An \nexample of promoted vs. nonpromoted priority switching appears in state diagram form in Figure 37. Figure 38 shows a block diagram of the interrelationship between the reference inputs, monitors, validation logic, profile selection, and priority selection functionality. \nA\nACTIVE\nB\nACTIVE\nC\nACTIVEA FAULTED\nB FAULTEDALL VALIDINITIAL\nSTATE\nA VALID\nB VALIDA VALID\nB VALIDINPUT PRIORITY PROMOTED\nA0 0B1 0\nC2 1\nD3 2PRIORITY TABLE\nCOMMON\nWITHOUT PROMOTION\nWITH PROMOTION\n08022-011 \nFigure 37. Example of Priority Promotion \n \nPROFILE\nSELECTIONVALIDATION\nLOGICPRIORITY\nSELECTION\n÷R MONITORSA/AA\nB/BB\nC/CCD/DDTDCLOOP\nCONTROLLER\n………………\n08022-012 \nFigure 38. Reference Clock Block Diagram\nAD9548 Data Sheet\n \nRev. G | Page 32 of 111 Phase Build-Out Reference Switching \nPhase build-out reference switching is the term given to a \nreference switchover that completely masks any phase \ndifference between the previous reference and the new \nreference. That is, there is virtually no phase change detectable \nat the output when a phase build-out switchover occurs. \nThe AD9548 handles phase build-out switching based on \nwhether the new reference is a phase master. A phase master is \nany reference with a selection priority value that is less than the phase master threshold priority value (that is, higher priority). \nThe phase master threshold priority value resides in the phase \nbuild-out switching register (Address 0x0507), whereas the selection priority resides in the profile registers (Address 0x0600 to Address 0x07FF). By default, the phase master threshold priority is 0; therefore, no references can be phase masters until the user changes the phase master threshold priority. \nWhenever the AD9548 switches from one reference to another, \nit compares the selection priority value stored in the profile \nassigned to the new reference with the phase master threshold priority. The AD9548 performs a phase build-out switchover \nonly if the new reference is not a phase master. \nHitless Reference Switchin g (Phase Slew Control) \nHitless reference switching is the term given to a reference \nswitchover that limits the rate of change of the phase of the \noutput clock while the PLL is in the process of acquiring phase lock. This prevents the output frequency offset from becoming \nexcessive. \nThe all-digital nature of the DPLL core (see the Digital PLL \n(DPLL) Core section) gives the user numerical control of the \nrate at which phase changes occur at the DPLL output. When \nenabled, a phase slew controller monitors the phase difference between the feedback and reference inputs to the DPLL. The phase slew controller has the ability to place a user specified limit on the rate of change of phase, thus providing a mechanism for hitless reference switching. \nThe user sets a limit on the rate of change of phase by storing \nthe appropriate value in the 16-bit phase slew rate limit register \n(Address 0x0316 to Address 0x0317). The 16-bit word (representing ns/sec) puts an upper bound on the rate of change of the phase at the output of the DPLL during a reference switchover. A phase slew rate value of 0 (default) disables the phase slew controller. \nThe accuracy of the phase slew controller depends on both the \nphase slew limit value and the system clock frequency. \nGenerally, an increase in the phase slew rate limit value or a decrease in the system clock frequency tends to reduce the error. As such, the accuracy is best for the largest phase slew limit value and the lowest system clock frequency. For example, assuming the use of a 1 GHz system clock, a phase slew limit \nvalue of 315 ns/sec (or more) ensures an error of less than 10%, \nwhereas a phase slew rate limit value above ~3100 ns/sec ensures an error of less than 1%. On the other hand, assuming the use of a 500 MHz system clock, the same phase slew rate limit values ensure an error of less than 5% or 0.5%, \nrespectively. \nDIGITAL PLL (DPLL) CORE  \nDPLL Overview \nA diagram of the digital PLL core of the AD9548 appears in \nFigure 39. The phase/frequency detector, feedback path, lock \ndetectors, phase offset, and phase slew rate limiting that comprise this second generation DPLL are all digital implementations. \nR+1REF A\nTDC\nAND\nPFDDIGITAL\nLOOP\nFILTERDDS/\nDACDACOUTCLOSED-LOOP\nPHASE OFFSETPHASE SLEW\nLIMITLOCK\nDETECT\nREF DDDPPL CORE\n2fR fTDC\nfDDS\nS + 1 + U/V\n08022-013 \nFigure 39. Digital PLL Core  \nThe start of the DPLL signal chain is the reference signal, f R, \nwhich is the frequency of the reference input. A reference prescaler reduces the frequency of this signal by an integer factor, R + 1, where R is the 30-bit value stored in the appropriate profile register and 0 ≤ R ≤ 1,073,741,823. Therefore, the \nfrequency at the output of the R-divider (or the input to TDC) \nis \n1\uf02b\uf03dRffR\nTDC  \nA time-to-digital converter (TDC) samples the output of the \nR-divider. The TDC/PFD produces a time series of digital words and delivers them to the digital loop filter. The digital \nloop filter offers the following advantages: \n\uf0b7 Determination of the filter response by numeric \ncoefficients rather than by discrete component values \n\uf0b7 The absence of analog components (R/L/C), which \neliminates tolerance variations due to aging \n\uf0b7 The absence of thermal noise associated with analog \ncomponents \n\uf0b7 The absence of control node leakage current associated with analog components (a source of reference feed-\nthrough spurs in the output spectrum of a traditional \nanalog PLL) \nThe digital loop filter produces a time series of digital words at its output and delivers them to the frequency tuning input of a DDS, with the DDS replacing the function of the VCO in an \nanalog PLL. The digital words from the loop filter tend to steer \nthe DDS frequency toward frequency and phase lock with the input signal (f\nTDC). The DDS provides an analog output signal \nvia an integrated DAC, effectively mimicking the operation of \nan analog VCO. \n \nData Sheet AD9548\n \nRev. G | Page 33 of 111 The DPLL includes a feedback divider that causes the DDS to \noperate at an integer-plus-fractional multiple (S + 1 + U/V) of f\nTDC. S is the 30-bit value stored in the profile register and has a \nrange of 7 ≤ S ≤ 1,073,741,823. U and V are the 10-bit numerator \nand denominator values of the optional fractional divide \ncomponent and are also stored in the profile register. Together \nthey establish the nominal DDS frequency (f DDS), given by \n\uf0f7\uf0f8\uf0f6\uf0e7\uf0e8\uf0e6\uf02b \uf02b\uf02b\uf03dVUSRffR\nDDS 11 \nNormally, fractional-N designs exhibit distinctive phase noise \nand spurious artifacts resulting from the modulation of the \ninteger divider based on the fractional value. Such is not the case for the AD9548 because it uses a purely digital means to \ndetermine phase errors. Because the phase errors incurred by modulating the feedback divider are deterministic, it is possible \nto compensate for them digitally. The result is a fractional-N \nPLL with no discernable modulation artifacts. \nTDC/PFD \nThe TDC is a highly integrated functional block that \nincorporates both analog and digital circuitry. There are two pins associated with the TDC that the user must connect to \nexternal components. Figure 40 shows the recommended \ncomponent values and their connections. \nFor best performance, place components as close as possible to \nthe device pins. Components with low effective series resistance \n(ESR) and low parasitic inductance yield the best results. \nAD9548\n10µF0.1µF\n0.1µF 0.1µFTDC_VRT TDC_VRB58 57\n08022-014 \nFigure 40. TDC Pin Connections \nThe phase-frequency detector (PFD) is an all-digital block. It \ncompares the digital output from the TDC (which relates to the active reference edge) with the digital word from the feedback block (which relates to the rollover edge of the DDS accumulator after division by the feedback divider). It uses a \ndigital code pump and digital integrator (rather than a \nconventional charge pump and capacitor) to generate the error \nsignal that steers the DDS frequency toward phase lock. \nClosed-Loop Phase Offset \nThe all-digital nature of the TDC/PFD provides for numerical \ncontrol of the phase offset between the reference and feedback \nedges. This allows the user to adjust the relative timing of the distribution output edges relative to the reference input edges by programming the 40-bit fixed phase lock offset register (Address 0x030F to Address 0x0313). The 40-bit word is a signed (twos complement) number that represents units of \npicoseconds. \nIn addition, the user can adjust the closed-loop phase offset \n(positive or negative) in incremental fashion. To do so, program the desired step size in the 16-bit incremental phase lock offset \nstep size register (Address 0x0314 to Address 0x0315). This is \nan unsigned number that represents units of picoseconds. The programmed step size is added to the current closed-loop phase offset each time the user writes a Logic 1 to the increment phase offset bit (Register 0x0A0C, Bit 0). Conversely, the programmed \nstep size is subtracted from the current closed-loop phase offset \neach time the user writes a Logic 1 to the decrement phase offset bit (Register 0x0A0C, Bit 1). The serial input/output port control logic clears both of these bits automatically. The user can remove the incrementally accumulated phase by writing a Logic 1 to the reset incremental phase offset bit (Register 0x0A0C, Bit 2), \nwhich is also cleared automatically. Alternatively, rather than \nusing the serial input/output port, the multifunction pins can be \nset up to perform the increment, decrement, and clear functions. \nNote that the incremental phase offset is completely independent of \nthe offset programmed into the fixed phase lock offset register. However, if the phase slew limiter is active (see the Hitless Reference Switching (Phase Slew Control) section), then any \ninstantaneous change in closed-loop phase offset (fixed or \nincremental) will be subject to possible slew limitation by the \naction of the phase slew limiter. \nProgrammable Digital Loop Filter \nThe AD9548 loop filter is a third order digital IIR filter that is \nanalogous to the third order analog loop shown in Figure 41. \nC3\nC2C1R2R3\n08022-015 \nFigure 41. Third Order Analog Loop Filter \nThe filter requires four coefficients as shown in Figure 42. \nThe AD9548 evaluation board software automatically generates \nthe required loop filter coefficient values based on the user’s design criteria. The Calculating Digital Filter Coefficients section contains the design equations for calculating the loop \nfilter coefficients manually. \nLOOP FILTER\n(THIRD ORDER IIR)IN OUTFRACTIONAL\n(16-BIT)\n1/2x\n(6-BIT)\n2x\n(3-BIT)\n2x\n(4-BIT)FRACTIONAL\n(17-BIT)\n1/2x\n(6-BIT)FRACTIONAL\n(17-BIT)\n1/2x\n(6-BIT)FRACTIONAL\n(15-BIT)\n1/2x\n(5-BIT)\n48 51\n08022-016 \nFigure 42. Third Order Digital IIR Loop Filter \n \nAD9548 Data Sheet\n \nRev. G | Page 34 of 111 Each coefficient has a fractional component representing a \nvalue from 0 up to, but not including, unity. Each coefficient also has an exponential component representing a power of 2 with a negative exponent. That is, the user enters a positive \nnumber (x) that the hardware interprets as a negative exponent \nof two (2\n−x). Thus, the \uf062 , \uf067\uf02c and \uf064 coefficients always represent \nvalues less than unity. The \uf061 coefficient, however, has two \nadditional exponential components, but the hardware interprets these as a positive exponent of 2 (that is, 2\nx). This allows the \uf061  \ncoefficient to be a value greater than unity. The positive \nexponent appears as two separate terms in order to provide \nsufficient dynamic range. \nDPLL Phase Lock Detector \nThe DPLL contains an all-digital phase lock detector. The user \ncontrols the threshold sensitivity and hysteresis of the phase detector via the profile registers. \nThe phase lock detector behaves in a manner analogous to \nwater in a tub (see Figure 43). The total capacity of the tub is \n4096 units with −2048 denoting empty, 0 denoting the 50% point, and +2048 denoting full. The tub also has a safeguard to prevent overflow. Furthermore, the tub has a low water mark at −1024 and a high water mark at +1024. To change the water \nlevel, the user adds water with a fill bucket or removes water \nwith a drain bucket. The user specifies the size of the fill and drain buckets via the 8-bit fill rate and drain rate values in the \nprofile registers. \nThe water level in the tub is what the lock detector uses to \ndetermine the lock and unlock conditions. Whenever the water level is below the low water mark (−1024), the detector \nindicates an unlock condition. Conversely, whenever the water \nlevel is above the high water mark (+1024), the detector indicates a lock condition. While the water level is between the marks, the detector simply holds its last condition. This concept appears graphically in Figure 43 with an overlay of an example of the \ninstantaneous water level (vertical) vs. time (horizontal) and the \nresulting lock/unlock states. \nDuring any given PFD phase error sample, the detector either \nadds water with the fill bucket or removes water with the drain bucket (one or the other but not both). The decision of whether to add or remove water depends on the threshold level specified by the user. The phase lock threshold value is a 16-bit number \nstored in the profile registers and is expressed in picoseconds. \nThus, the phase lock threshold extends from 0 ns to ±65.535 ns and represents the magnitude of the phase error at the output of \nthe PFD. \nThe phase lock detector compares each phase error sample at \nthe output of the PFD to the programmed phase threshold value. If the absolute value of the phase error sample is less than \nor equal to the programmed phase threshold value, then the \ndetector control logic dumps one fill bucket into the tub. Otherwise, it removes one drain bucket from the tub. Notice that it is not the polarity of the phase error sample, but its magnitude relative to the phase threshold value, that determines whether to fill or drain. If more filling is taking place than draining, the water level in the tub eventually rises above the high water mark (+1024), which causes the phase lock detector \nto indicate lock. If more draining is taking place than filling, \nthen the water level in the tub eventually falls below the low water mark (−1024), which causes the phase lock detector to indicate unlock. The ability to specify the threshold level, fill rate, and drain rate enables the user to tailor the operation of \nthe phase lock detector to the statistics of the timing jitter \nassociated with the input reference signal. \n02048\n–20481024\n–1024LOCK LEVEL\nUNLOCK LEVELLOCKED UNLOCKEDPREVIOUS\nSTATE\nFILL\nRATEDRAIN\nRATE\n08022-017 \nFigure 43. Lock Detector Diagram \nNote that whenever the AD9548 enters the free-run or holdover \nmode, the DPLL phase lock detector indicates unlocked. In \naddition, whenever the AD9548  performs a reference \nswitchover, the state of the lock detector prior to the switch is \npreserved during the transition period. \nDPLL Frequency Lock Detector \nThe operation of the frequency lock detector is identical to that \nof the phase lock detector. The only difference is that the fill or \ndrain decision is based on the period deviation between the reference and feedback signals of the DPLL instead of the phase \nerror at the output of the PFD. \nThe frequency lock detector uses a 24-bit frequency threshold \nregister specified in units of picoseconds. Thus, the frequency threshold value extends from 0 μs to ±16.777215 μs. It represents \nthe magnitude of the difference in period between the reference \nand feedback signals at the input to the DPLL. For example, if the reference signal is 1.25 MHz and the feedback signal is 1.38 MHz, then the period difference is approximately 75.36 ns \n(|1/1,250,000 − 1/1,380,000| ≈ 75.36 ns). \nDIRECT DIGITAL SYNTHESIZER \nDDS Overview \nOne of the primary building blocks of the digital PLL is a direct \ndigital synthesizer (DDS). The DDS behaves like a sinusoidal \nsignal generator. The frequency of the sinusoid generated by the \nDDS is determined by a frequency tuning word (FTW), which \nis a digital (that is, numeric) value. Unlike an analog sinusoidal generator, a DDS uses digital building blocks and operates as a sampled system. Thus, it requires a sampling clock (f\nS) that \nserves as the fundamental timing source of the DDS. The accumulator behaves as a modulo-2\n48 counter with a \nprogrammable step size (FTW). A block diagram of the DDS \nappears in Figure 44. \n \nData Sheet AD9548\n \nRev. G | Page 35 of 111 DAC\n(14-BIT)PHASE\nOFFSET\nQ D\nfSFREQUENCY\nTUNING WORD\n(FTW)DAC+\nDAC–14 1948\n19 ANGLE TO\nAMPLITUDE\nCONVERSION48 4848-BIT ACCUMULATOR\n16\n08022-018 \nFigure 44. DDS Block Diagram \nThe input to the DDS is the 48-bit FTW . The FTW serves as a \nstep size value. On each cycle of f S, the accumulator adds the \nvalue of the FTW to the running total at its output. For \nexample, given FTW = 5, the accumulator counts by fives, \nincrementing on each f S cycle. Over time, the accumulator \nreaches the upper end of its capacity (248 in this case), at which \npoint, it rolls over but retains the excess. The average rate at which the accumulator rolls over establishes the frequency of the output sinusoid. The average rollover rate of the accumulator establishes the output frequency (f\nDDS) of the DDS and is given by \nS DDS fFTWf \uf0f7\uf0f8\uf0f6\uf0e7\uf0e8\uf0e6\uf03d482 \nSolving this equation for FTW yields \n\uf0fa\uf0fa\n\uf0fb\uf0f9\n\uf0ea\uf0ea\n\uf0eb\uf0e9\n\uf0f7\uf0f7\n\uf0f8\uf0f6\n\uf0e7\uf0e7\n\uf0e8\uf0e6\uf03d\nSDDS\nffFTW482 round  \nFor example, given that f S = 1 GHz and f DDS = 155.52 MHz, then \nFTW = 43,774,988,378,041 (0x27D028A1DFB9). \nNote that the minimum DAC output frequency is 62.5 MHz; \ntherefore, normal operation requires an FTW that yields an \noutput frequency in excess of this lower bound. \nDDS Phase Offset \nThe relative phase of the sinusoid generated by the DDS is \nnumerically controlled by adding a phase offset word to the output \nof the DDS accumulator. This is accomplished via the open-loop \nphase offset register (Address 0x030D to Address 0x030E), which is a programmable 16-bit value (Δphase). The resulting \nphase offset, ΔΦ (in radians), is given by \n\uf0f7\n\uf0f8\uf0f6\uf0e7\n\uf0e8\uf0e6\uf044\uf03d \uf0441622Φphase\uf070  \nPhase offset and relative time offset are directly related. The \ntime offset is ( \uf044phase/216)/fDDS (in seconds), where f DDS is the \noutput frequency of the DDS (in hertz). \nDAC Output \nThe output of the digital core of the DDS is a time series of \nnumbers representing a sinusoidal waveform. The DAC \ntranslates the numeric values to an analog signal. The DAC output signal appears at two pins that constitute a balanced current source architecture (see Figure 45). CURRENT\nSWITCH\nARRAY\nSWITCH\nCONTROLIFSISCALEAVDD3\nDACOUTP DACOUTNCURRENT\nMIRROR\nGND21\n22\nGND18 19\nCODE\n08022-019CODE\n50Ω 50Ω1410\nIFS (1–            )\n214 – 1CODEIFS (            )\n214 – 1\n \nFigure 45. DAC Output Pins \nThe value of I FS is programmable via the 10-bit DAC full-scale \ncurrent word in the DAC current register (Address 0x0213 to Address 0x0214). The value of the 10-bit word (I\nSCALE ) sets I FS \naccording to the following formula: \n\uf028\uf029\uf028 \uf029SCALEI16372 μA 120FSI \uf02b \uf0b4 \uf03d  \nTUNING WORD PROCESSING \nThe frequency tuning words that dictate the output frequency of the DDS come from one of three sources (see Figure 46). \n\uf0b7 The free running frequency tuning word register \n\uf0b7 The output of the digital loop filter \n\uf0b7 The output of the tuning word history processor \n08022-070TUNING WORD\nHISTORY\nPROCESSORTUNING WORD\nHISTORY\nFREE-RUN\nTUNING WORD\nTUNING WORD\nUPDATE\nFROM DIGITAL\nLOOP FILTERTO DDS TUNING\nWORD\nROUTING\nCONTROLTUNING\nWORD\nCLAMP\nLOWER\nTUNING\nWORDUPPER\nTUNING\nWORD \nFigure 46. Tuning Word Processing \n \n \nAD9548 Data Sheet \n \nWhen the DPLL is in free -run mode, the  DDS tuning word is \nthe value stored in the free running frequency tuning word \nregister (Address 0x 0300 to Address 0x 0305). When the DPL L \nis operating normally (closed loop), the DDS tuning word \ncomes from the output of the digital loop filter, which chang es \ndynamically in order to maintain phase lock with the input \nreference signal (assuming that the device has not performed an automatic switch to holdover mode). When the DPLL is in holdover mode, the DDS tuning word depends on a historical \nrecord of past tuning words during the time that the DPLL \noperat ed in closed -loop mode.  \nHowever, regardless of the operating mode, the DDS output \nfrequency is ultimately subject to the boundary conditions imposed by the frequency clamp logic , as explained in the \nFrequency Clamp  section . \nFrequency Clamp  \nThe user controls the frequency clamp boundaries via the \npull-in range limits registers (Address 0x0307 to Address  0x030C) . \nThese registers allow the user to fix the DDS output frequency \nbetween an  upper and lower bound with a granularity of 24 bits . \nNote that these upper and lower bounds apply regardless of the frequency tuning word that appears at the input to the DDS . \nThe register value relates to the absolute upper or lower \nfrequency bound (f\nCLA MP) as \nfCLAMP  = fS × (N/224) \nwhere N is the value stored in the upper - or lower -limit  register, \nand fS is the system sample rate.  \nEven though the frequency clamp limits put a bound on the \nDDS output frequency, the DPLL is still free to steer the DDS freque ncy within the clamp limits. The default register values \nset the clamp range from  0 Hz ( dc) to f\nS, effectively eliminating \nthe frequency clamp functionality until the user alters the \nregister values . \nFrequency Tuning Word History  \nThe AD9548 has the ability to track the history of the tuning \nword samples generated by the DPLL digital loop filter output.  \nIt does so by periodically computing the averag e tuning word \nvalue over a user specified interval.  The user programs the \ninter val via the 24 -bit h istory accumulation timer register \n(Address 0x0318 to Address 0x 031A).  This 24 -bit value \nrepresents a time interval (T AVG) in milliseconds that extends \nfrom 1 ms to a maximu m of 4:39:37.215 (hr:min:sec).  \nNote that  history  accumulation timer  = 0 should not be \nprogrammed because  it may cause improper device operation . \nThe control logic performs a calculation of the average tuning \nword during the  TAVG interval  and stores the resul t in the \nholdover history register ( Address 0D14 to Address 0D19) . \nComputation of the average for each T AVG interval is \nindependent of the previous interval (that is, the average is a memoryless average as opposed to a true moving average) . In \naddition, at the end of each T\nAVG interval, the device generates an internal strobe pulse. The strobe pulse sets the h istory \nupdated bit in the IRQ m onitor register ( assuming the bit  is \nenabled via the IRQ m ask register ). Furthermore, the strobe \npulse is available as an output signal via the multifunction pins (see the Multifunction Pins (M0 to M7)  section) . \nHistory accumulation begins whenever the device switches to a \nnew reference.  The user should be aware that the first tuning \nword history interval includes  the initial DPLL acquisition, and \nthe DPLL tuning word values during acquisition can corrupt the \naverage value of the first holdover history interval. To avoid \nholdover history corruption  during loop acquisition , the user can \nclear the ho ldover history after DPLL phase lock by setting Bit 2 \nof Register 0x0A03.  By default, the device clears any previous \nhistory when  it switches to a new reference.  Furthermore, the \nuser can clear the tuning word history under software control \nvia Register 0x0A03, Bit 2, or under hardware control via the \nmultifunction pins (see the Multifunction Pins (M0 to M7)  \nsection). However, the user has the option of programming the \ndevice to retain  (rather than clear) the old history by setting  the \npersistent history bit (Register 0x 031B , Bit 3 ). \nWhenever  the tuning word history is non existent (that is, after a \npower -up, reset, or switchover to a new reference with the \npersistent history bit cleared), the device waits for the history \naccumulatio n timer (T\nAVG) to expire before storing  the first \nhistory value in the holdover h istory register . \nIn cases where TAVG is quite large (4½ hours, for example), a \nproblem arises in that the first averaged result does not become available until the full T\nAVG interval passes . Thus, it is possible \nthat as much  as 4½ hours can elapse before the first averaged \nresult is available.  If the device ha s to switch to holdover mode \nduring this time , a tuning word history  is not available.  \nTo alleviate t his problem, the us er has access to the incremental \naverage bits in the h istory mode register ( Register 0x031B , \nBits[ 2:0]). If the history has been cleared, then t his 3 -bit value, \nK (0 ≤ K ≤ 7), specifies the number of intermediate averages to \ntake during the first, and only  the first, T AVG interval.  When \nK = 0, no intermediate averages are calculate d; therefore, the \nfirst average occurs after interval T AVG (the def ault operating \nmode ). However, if K  = 4, for example, sixteen  intermediate \naverages are taken during the first T AVG interval.  \nThese average computations occur at T AVG/16, TAVG/8, TAVG/4, \nTAVG/2, and T AVG (notice  that the denominator exhibits a \nsequence of powers of 2  beginning with T AVG/2K). The \ncalculation of intermediate averages occurs only during the first  \nTAVG interval.  All subsequent average computations occur at  \nevenly spaced  intervals of T AVG. \nLOOP CONTROL STATE M ACHINE  \nThe loop control state machin e is responsible for monitoring, \ninitiating, and sequencing change s to the DPLL loop. Generally, \nit automatically controls the transition  between input references \nand the  entry and exit of holdover  mode.  In controlling loop  \nstate changes, the state machine  also arbitrate s the application \nRev. G | Page 36 of 111 \nData Sheet AD9548 \n \nof new loop  filter coefficients, divider settings, and phase \ndetector offsets  based on the p rofile settings . The user can \nmanually force t he device into holdover or free- run mode via \nthe l oop mode register ( Address 0x0A01),  as well as force the  \nselect ion of  a specific input reference.  \nSwitchover  \nSwitchover occurs when the loop controller switches directly \nfrom one input  reference to another. Functionally, the AD9548 \nhandles a reference switch over  by briefly entering  holdover \nmode and then  immediately recovering.  During the switchover \nevent, however, the AD9548 preserves the status  of the lock \ndetectors to avoid phantom unlock indications . \nHoldover  \nThe holdo ver state of the DPLL is an open -loop operating mode . \nThat is , the device no longer operates as a closed -loop system . \nInstead, the output freq uency remains constant and is dependent \non the device programming and availability of tuning  word history . \nIf a tunin g word history exists (see the Frequency Tuning Word \nHistory  section), then the holdover frequency is the average  \nfrequency just prior to entering the holdover state.  If there is no \ntuning word history, then the holdover frequen cy depends on \nthe state of the s ingle sample fallback bit in the h istory mode \nregister ( Register 0x031B , Bit 4).  If the single sample fallbac k bit \nis Logic 0, then the holdover frequency i s the frequency defined in \nthe f ree running frequency t uning word register (Address  0x0300 \nto Address 0x0305) . If the s ingle sample fallback bit is Logic 1, \nthen  the holdover frequency is the last instantaneou s frequency \noutput by the DDS  just prior to the device entering holdover mode \n(note that this is not the average frequency prior to holdover) . \nThe initial holdover frequency  accuracy depends on the loop \nbandwidth of the DPLL and  the time elapsed to compute  a tuning  \nword history . The longer the historical average , the more accurate  \nthe initial holdover frequency  (assuming a drift -free system clock) . \nFurthermore , the stability of the system clock establishes the \nstability and long -term accuracy of the holdove r output frequency . \nAnother consideration is the 48 -bit frequency tuning resolution \nof the DDS  and its relationship to fractional frequency error, \n∆fO/fO, as follows: \nOS\nOO\nff\nff\n492=∆ \nwhere fS is the sample rate of the output DAC, and fO is the DDS  \noutput frequency.  \nThe worst -case scenario is maximum f S (1 GHz)  and minimum f O \n(62.5 MHz), which yields ∆f O/fO = 2.8 × 10−14, less than one  part \nin 10 trillion . \nRecovery from Holdover  \nWhen  in holdover and  a valid reference becomes available, the \ndevice exi ts holdover operation . The loop state machine restores \nthe DPLL to closed -loop operation , locks to the selected reference, and sequences the recovery of all the loop parameters based on \nthe p rofile settings for the active reference . \nNote that, if  the user holdover bit ( Register 0x0A01 , Bit 6) is set, \nthe device does not automatically exit holdover when a valid \nreference is available.  However, automatic recover y can occur \nafter clearing the u ser holdover bit.  \nSYSTEM CLOCK  INPUTS  \nFunctional Description  \nThe sy stem clock circuit provides a low jitter, stable, high frequency  \nclock for use by the rest of the chip . The user has the option of \ndirectly driving the SYSCLK x inputs with a high frequency \nclock source at the desired system clock rate.  Alternatively, the \nSYSCLK x input can be configured to operate in conjunction \nwith  the internal SYSCLK  PLL. The SYSCLK  PLL can synthesize  \nthe system clock by means of  a crystal resonator connected \nacross the SYSCLK x input pins or by means of direct application  \nof a low frequen cy clock source.  \nThe SYSCLK x inputs are internally biased to a dc level of ~1 V .  Take  \ncare to ensure that any external connections do not disturb the dc  \nbias because this may significantly degrade performance. Generally,  \nthe recommendation is  that the SYSC LKx inputs be ac -coupled \nto the signal source (except when using a crystal resonator ). \nLow Loop Bandwidth Applications Using a TCXO/OCXO  \nFor many applications, the use of a crystal oscillator is a cost -\neffective and simple choice. The stability is good enough to support  \nloop bandwidths down to 50 Hz, and the holdover performance is good enough for all except the most demanding applications.  \nIn cases where Stratum 2 or Stratum 3 holdover performance is needed, or in cases where the loop bandwidth must be <5 0 Hz, \neither a TCXO or O CXO  must be used . If the loop bandwidths \nare lower than 10 mHz , an OCXO must be used . Choose  a \nTCXO/OCXO with a high output frequency and CMOS output to achieve the best performance.  The AN-1079 Application Note , \nDetermining  the Maximum Tolerable Frequenc y Drift Rate of the \nAD9548  System Clock in Low Loop Bandwidth Applications , \ndiscu sses system c lock performance considerations  for low loop \nbandwidth applications.  \nWhen interfacing the TCXO/OCXO, a voltage divider on the \noutput should be used to reduce the voltage swing to 1 V p -p, \nand that signal should be ac -coupled to the SYSCLKP pin . The \nSYSCLKN pin can be bypassed to ground with a 0.01 µF capacitor.  \nChoosing the System Clock Oscillator Frequency  \nThe best performance of the AD9548 is achieved when the system \nclock is not an integer multip le of the DDS output frequency.  \nAs an example, using a 19.44 MHz oscillator for the system clock in \na 156.25 MHz Ethernet application yields better perfor mance than \na 25 MHz oscillator.  \nAnother good system cloc k choice for many communications \napplications is a 49.152 MHz crystal used in IEEE 1394 (FireWire) because nearly all output frequencies are not integer related to this frequency , and the crystal is readily available . \n \nRev. G | Page 37 of 111 \nAD9548 Data Sheet \n \n2×\n÷NVCO\nCALIBRATIONLOCK\nDETECT\nSYSTEM\nCLOCK÷MLOOP\nFILTERSYSCLKN\nSYSCLKPSYSCLK_VREG SYSCLK_LF\nHFXTALLF48\n52\n5349\nPFD\nAND\nCHARGE\nPUMP\n08022-020 \nFigure 47. System Clock Block Diagram  \n \nSystem Clock Details  \nA block diagram of the system clock appears in Figure 47. The \nsignal at the SYSCLKx input pins becomes the internally buffered  \nDAC sampling clock (f S) via one of three paths.  \n• High fr equency direct (HF)  \n• Low frequency synthesized (LF)  \n• Crystal resonator synthesized (XTAL)  \nNote that both the LF and XTAL paths require the use of the \nSYSCLK PLL (see the SYSCLK PLL Multiplier  section).  \nThe main purpose of the HF pat h is to allow the direct use of a high \nfrequency (500 MHz to 1 GHz) external clock source for clocking  \nthe AD9548. This path is optimized for high frequency and low  \nnoise floor. Note that the HF input also provides a path to SYSCLK PLL (see the SYSCLK PLL Multiplier  section), which includes \nan input divider (M) programmable for divide -by -1, -2, -4, or - 8. \nThe purpose of the divider is t o limit the frequency at the input \nto the PLL to less than 150 MHz (the maximum PFD rate) . \nThe LF path permits the user to provide an LVPECL, LVDS, \nCMOS , or sinusoidal low frequency clock for multiplication  by \nthe integrated SYSCLK PLL . The LF path handles  input \nfrequencies from 3. 5 MHz up to 100 MHz.  However,  when \nusing a sinusoidal input signal,  it is best to use a frequency in \nexcess of  20 MHz . Otherwise, the resulting low slew rate can \nlead to substandard noise performance.  Note that the LF path \ninclude s an optional 2× frequency multiplier to double the rate \nat the input to the SYSCLK PLL and potentially reduce the PLL \nin-band noise.  However,  to avoid exceeding the maximum PFD \nrate of 150 MHz,  using the 2× frequency multiplier is valid only \nfor input fr equencies below 125 MHz . \nThe XTAL path enables the connection of a crystal resonator \n(typically 10 MHz to 50 MHz) across the SYSCLK x input pins. \nAn internal amplifier provides the negative resistance required to induce oscillation.  The internal amplifier ex pects  a 3.2  mm × \n2.5 mm AT cut , fundamental mode crystal with a maximum \nmotional resistance of 100 Ω. The following crystals, listed in alphabet ical order, may meet these criteria . Note that , whereas  \nthese crystals may meet the preceding criteria according to their data sheets, Analog D evices, Inc., does not guarantee their \noperation with the AD9548, nor does Analog Devices endorse \none crystal manufacturer/supplier over another.  \n• AVX/Kyocera CX3225SB  \n• ECS ECX -32 \n• Epson/Toyocom TSX -3225  \n• Fox FX3225BS \n• NDK NX3225SA  \n• Siward SX -3225  \nSYSCLK  PLL MULTIPLIER  \nThe SYSCLK PLL m ultiplier is an integer -N design and relies on \nan integrated LC tank and VCO. It  provides a means to convert \na low frequency clock input to the desired system clock frequency , f\nS (900 MHz to 1 GHz). The SYSCLK PLL m ultiplier \naccepts input signals between 3.5  MHz and 500  MHz , but \nfrequencies in excess of 150 MHz require the M- divider to \nensure compliance with the maximum PFD rate (150 MHz).  \nThe PLL contains a feedback divider (N) that is programmable  \nfor divide values between 6  and 255.  The nominal VCO gain is \n70 M H z / V.  \nLock Detector  \nThe SYSCLK  PLL has a built -in lock detect or. Register 0x0100, \nBit 2 determines whether the lock detector is activ e. When \nactive  (default) , the user controls the sensitivity of the lock \ndetector via th e lock detect divider bits ( Register 0x0100, Bits[ 1:0]). \nNote that 0  must be written to the system clock stability timer \n(Register 0x0106 to Register 0x 0108) whenever th e lock \ndetector is disabled ( Register 0x0100, Bit 2  = 1). \nThe SYSCLK  PLL phase detector operates at t he PFD rate , \nwhich is f VCO/N. Each PFD sample indicates whether the \nreference and feedback signals are phase aligned ( within a \ncertain threshold  range) . \nWhile the PLL is in the process of acquiring a lock condition, \nthe PFD samples typically consi st of an arbitrary sequence of \nin-phase and out -of-phase indications.  As the PLL approaches \ncomplete phase l ock, the number of consecutive in -phase  PFD \nRev. G | Page 38 of 111 \nData Sheet AD9548 \n \nsamples grow s larger.  Therefore , one way of indicating  a locked \ncondition is to c ount the number of consecutive in -phase PFD \nsamples and, if it exceeds a certain value, then declare the PLL \nlocked.  \nThis is exactly the role of the lock d etect divider bits . When the loc k \ndetector is enabled ( Register 0x0100, Bit 2 = 0), the lock d etect \ndivider bits  determine  the number of consecutive in -phase  \ndecisions required (128, 256, 512,  or 1024)  before the lock detector \ndeclares a locked condition . The default setting is 128.  \nChar ge Pump  \nThe charge pump operates in either automatic or manual mode \nbased on the c harge pump mode bit (Register  0x0100, Bit 6).  \nWhen  Register 0x0100, Bit 6 =  0, the AD9548 automatically \nselects the appropriate cha rge pump current based on the \nN-divider value.  Note that the user cannot control th e charge \npump c urrent bits ( Register 0x0100, Bits[ 5:3]) in automatic \nmode.  When Register 0x0100, Bit 6  = 1, the user determi nes the \ncharge pump current via th e charge pump current bits \n(Register  0x0100, Bits[ 5:3]). The charge pump current varies from \n125 μA to 1 mA in 125 μA steps.  The default setting is 500  μA. \nSYSCLK  PLL Loop Filter  \nThe AD9548 has an internal second  order loop filter that  \nestablishes the loop d ynamics for input signals between \n12.5 MHz and 100  MHz.  By default, the device uses the internal \nloop filter.  However, an external loop filter opti on is available by \nsetting the e xternal loop filter e nable bit ( Register 0x0100, Bit  7). \nThis bypasses the in ternal loop filter and allow s the device to \nuse an externally connected second order loop filter , as shown in \nFigure 48. \nSYSCLK_VREG\nR1AD9548\nSYSCLK_LF\nC1\nC248 49\n08022-021 \nFigure 48. External Loop Filter Schematic  \nTo determine the external loop filter compon ents, the u ser \ndecides on the desired open- loop bandwidth (f OL) and phase \nmargin ( φ). These parameters allow calculation of the loop filter \ncomponents, as fo llows: \n()\uf8f7\uf8f7\n\uf8f8\uf8f6\n\uf8ec\uf8ec\n\uf8ed\uf8eb+π=φsin11\nVCO CPOL\nKINfR1  \n()\n()22φtan\nOLVCO CP\nfNKIC1π=  \n( )()\n()\uf8f7\uf8f7\n\uf8f8\uf8f6\n\uf8ec\uf8ec\n\uf8ed\uf8eb−\nπ=φcosφsin1\n22\nOLVCO CP\nf NKIC2  \nwhere : \nKVCO is 7 × 107 V/ns (typical).  \nICP is the programmed charge pump current  (amperes).  N is the pr ogrammed feedback divider value.  \nfOL is the desired open -loop bandwidth ( in hertz ). \nΦ is the desired phase margin ( in radians).  \nFor example, assuming that N = 40, I CP = 0.5 mA, f OL = 400 kHz , \nand Φ  = 50°, then  the loop filter calculations yield  R1 = 3.31 kΩ, \nC1 = 330 pF, and C2  = 50.4 pF.  \nSystem Clock Period  \nMany of the user programmable parameters of the AD9548 have  \nabsolute time unit s. To make this possible, the AD9548 requires \na priori knowledge of the period of the system clock. To accommodat e this requirement, the user programs the 21 -bit \nnominal system clock period in the nominal SYSCLK period register s (Address 0x0103 to Address 0x 0105).  The contents of \nthis register reflect the actual period of the system clock in femtoseconds. The user mu st properly program this register to \nensure proper operation of the device because many of its \nsubsystems rely on this value.  \nSystem Clock Stability Timer  \nThe system clock stability timer (Register 0x0106 to Register \n0x0108)  is a 20 -bit value programmed in  milliseconds. If the \nprogrammed timer value is 0, then the timer immediately \nindicates that it has timed out.  If the programmed timer value is \na nonzero value  and the SYSCLK  PLL is enabled, then the timer \nstarts timing when the SYSCLK  PLL lock detector in dicates lock  \nand times out after the prescribed period . However, when the \nuser disables  the SYSCLK  PLL, then the timer ignores the \nSYSCLK PLL lock detector and starts  timing  as soon as  the \nSYSCLK  PLL is disabled . The user can  monitor the status of the \nstability timer via Register 0x0D01, Bit 4 , via the multifunction \npins or via the IRQ pin . \nNote that  the system clock stability timer must be programmed \nbefore the SYSCLK  PLL is either activated or disabled . \nSYSCLK  PLL Calibration  \nWhen using the SYSCLK  PLL, it  is necessary to calibrate t he LC \nVCO to ensure that the PLL can remain locked to the system clock input signal.  Assuming the presence of either an external \nSYSCLK  input signal or a crystal resonator, the calibration \nprocess executes after the user sets an d then clears the c alibrate \nsystem clock bit in the c al/sync register ( Register 0x0A02, Bit 0).  \nDuring the calibration process, the device calibrates the VCO amplitude and frequency. The status of the system clock calibration proc ess is user accessible via  the system c lock register \n(Register 0x0D01, Bit 1 ). It is also available via the IRQ monitor \nregister ( Register 0D02, Bit 1) provided the status bit is  enabled \nvia the IRQ m ask register.  \nWhen the calibration sequence is complete, the SYSCLK  PLL \neventually  attain s a lock condition, at which point the system \nclock stability timer begins its countdown sequence.  Expiration \nof the timer indicates that the SYSCLK  PLL is sta ble, which is \nreflected in the system c lock register ( Register 0x0D01, Bit 4).  \nRev. G | Page 39 of 111 \nAD9548 Data Sheet\n \nRev. G | Page 40 of 111 Note that the monitors/detectors associated with the input \nreferences (REFA/AA – REFD/DD) are internally disabled until \nthe SYSCLK PLL indicates that it is stable. \nCLOCK DISTRIBUTION \nThe clock distribution block of the AD9548 provides an \nintegrated solution for generating multiple clock outputs based \non frequency dividing the DPLL output. The distribution \noutput consists of four channels (OUT0 to OUT3). Each of the \nfour output channels has a dedicated divider and output driver, \nas appears in Figure 49. \nQ0SYNC\nCONTROL\nENABLEn/MODEnSYNC SOURCECLKINP\nOUT1P\nOUT1N\nOUT2P\nOUT2N\nOUT3P\nOUT3NOUT1\nOUT3OUT2OUT0CLKINN\nOUT_RSET\nOUT0P\nOUT0NRESETENABLE\n4 4 4\n08022-022 \nFigure 49. Clock Distribution \nClock Input (CLKINx) \nThe clock input handles input signals from a variety of logic \nfamilies (assuming proper terminations and sufficient voltage \nswing). It also handles sine wave input signals such as those \ndelivered by the DAC reconstruction filter. Its default operating \nfrequency range is 62.5 MHz to 500 MHz. \nSuper-Nyquist Operation \nTypically, the maximum usable frequency at the DAC output is \nabout 45% of the system clock frequency. However, because it is a sampled DAC, its output spectrum contains Nyquist images. \nOf particular interest are the images appearing in the first Nyquist zone (50% to 100% of the system clock frequency). Super-Nyquist operation takes advantage of these higher frequencies, but this implies that the CLKINx input operates in excess of 500 MHz, \nwhich is outside of its default operating limits. \nThe CLKINx receiver actually consists of two separate receivers—\nthe default receiver and an optional high frequency receiver, \nwhich handles input signals up to 800 MHz. To select the high \nfrequency receiver, write a Logic 1 to Register 0x0400, Bit 4. \nSuper-Nyquist operation requires a band-pass filter at the DAC \noutput instead of the usual low-pass reconstruction filter. Super-Nyquist operation is viable as long as the image frequency does not exceed the 800 MHz input range of the receiver. Furthermore, to provide acceptable jitter performance, which is a consideration for image signals with low amplitude, the signal at \nthe CLKINx input must meet the minimum slew rate \nrequirements. \nClock Dividers \nThe output clock distribution dividers are referred to as Q0 to Q3, \ncorresponding to the OUT0 to OUT3 output channels, respectively. \nEach divider is programmable with 30 bits of division depth. The \nactual divider ratio is one more than the programmed register \nvalue; therefore, a register value of 3, for example, results in a divide ratio of 4. Thus, each divider offers a range of divide \nratios from 1 to 2\n30 (1 to 1,073,741,824). \nWith an even divide ratio, the output signal always exhibits a \n50% duty cycle. When the clock divider is bypassed (a divide \nratio of 1), the output duty cycle is the same as the input duty \ncycle. Odd output divide ratios (excluding 1) exhibit automatic \nduty cycle correction given by \nNX NCycle Duty Output21 2\uf02d \uf02b\uf03d  \nwhere N (which must be an odd number) is the divide ratio and \nX is the normalized fraction of the high portion of the input \nperiod (that is, 0 < X < 1). \nFor example, if N = 5 and the input duty cycle is 20% (X = 0.2), \nthen the output duty cycle is 44%. Note that, when the user programs \nan output as noninverting, then the device adjusts the falling \nedge timing to accomplish the duty cycle correction. Conversely, \nthe device adjusts the rising edge timing for an inverted output. \nOutput Power-Down \nEach of the output channels offers independent control of \npower-down functionality via the distribution settings register \n(Address 0x0400). Each output channel has a dedicated power-down bit for powering down the output driver. However, if all four outputs are powered down, the entire distribution output \nenters a deep sleep mode. \nEven though each channel has a channel power-down control \nsignal, it may sometimes be desirable to power down an output \ndriver while maintaining the divider’s synchronization with the \nother channel dividers. This is accomplished by either of the \nfollowing methods: \n\uf0b7 In CMOS mode, use the divider output enable control bit \nto stall an output. This provides power savings while maintaining dc drive at the output. \n\uf0b7 In LVDS/LVPECL mode, place the output in tristate mode \n(this works in CMOS mode as well). \nOutput Enable \nEach of the output channels offers independent control of \nenable/disable functionality via the distribution enable register \n(Address 0x0401). The distribution outputs use synchronization \nData Sheet AD9548 \n \nlogic to control enable/ disable activity  to avoid  the produ ction \nof runt pulses and ensure that outputs with the sa me divide \nratio s become active/inactive  in unison.  \nOutput Mode  \nThe user has independent control of the operating  mode of \neach of the four output chann els via the d istribution channe l \nmodes register ( Address 0x0404 to Address 0x 0407).  The \noperating m ode control includes  \n• Logic family and pin functionality  \n• Output drive strength  \n• Output polarity  \nThe three least significant bits  of each of the four distribution \nchannel mode regist ers comprise the m ode bits. The m ode \nvalue selects the desired logic family and pin functionality o f an \noutput channel , as given in  Table 24. \nTable 24. Output Channel Logic Family and Pin Functionality  \nMode Bits [2:0]  Logic Family and Pin Functionality  \n000 CMOS (both pins)  \n001 CMOS (positive pin); tri state  (negative pin)  \n010 Tristate (positive pin);  CMOS (negative pin)  \n011 Tristate (both pins)  \n100 LVDS  \n101 LVPECL  \n110 Unused  \n111 Unused  \nRegardless of the selected logic family, each is capable of dc \noperation.  However, the upper frequency is limited  by the load \nconditions, drive strength, and impedance matching inherent in  \neach logic family. Practical limitations set the maximum CM OS \nfrequency to approximately 25 0 MHz, wh ereas  LVPECL and \nLVDS are capable of 725 MHz.  \nIn addition to the three mode bits , each of the four distribution \nchannel m ode registers includes the following control bits:  \n• Polarity i nvert  \n• CMOS p hase invert  \n• Drive s trength  \nThe p olarity invert bit enables the user to choose between \nnormal polarity and inverted polarity.  Normal polarity i s the \ndefault state.  Inverted polarity reverses the representation of \nLogic 0 and Logic 1 regardless of the logic family. \nThe CMOS p hase invert bit applies only when  the mode bits \nselect the CMOS logic family.  In CMOS mode, both output pins \nof the channel have a dedicated CMOS driver.  By default, both \ndrivers deliver identical signals.  However, setting the CMOS \nphase inver t bit causes the signal on an OUTxN  pin to be the \nopposite  of the signal appearing on the OUTxP pin.  \nThe d rive strength bit allows the us er to control whether the output  \nuses weak  (0) or strong  (1) drive capability  (applies to CMOS \nand LVDS but not LVPECL) . For the CMOS family , the strong \nsetting implies normal CMOS drive capability, wh ereas the weak setting implies low capacitive loading  and allows for reduced  \nEMI. For the LVDS family, the weak  setting provides  3.5 mA \ndrive current for standard LVDS  operation , whereas  the strong \nsetting provides  7 mA  for double terminated  or double voltage \nLVDS operation.  Note that 3.5 mA and 7  mA are the n ominal \ndrive current values when using the internal current setting resistor.  \nOutput Current Control with an External Resistor  \nBy default, the output drivers have an internal  current setting \nresistor (3.1 2 kΩ nominal) that establishes the nominal drive \ncurrent for the LVDS and LVPECL operating modes. Instead of \nusing the internal resistor, the user can set the external d istribution  \nresistor bit (Register 0x0400 , Bit 5) and connect an  external resistor  \nto the OUT_RSET pin . Note that this feature supports an \nexternal resistor value of 3.12 kΩ  only, allowing for tighter \ncontrol of the output current than is possible by using the internal current setting resistor. However, if the user elects to \nuse a non standard external resistance, t he following equations \nprovi de the  output drive current as a function of the external \nresistance (R) : \nRILVDS8325.10\n0= \nRILVDS665.21\n1=  \nRILVPECL76.24=  \nThe numeric subscript associated with the LVDS output current \ncorresp onds to the logic state of the d rive strength bit in the \ndistribution channel modes register ( Address 0x0404 to \nAddress  0x00407).  For R  = 3.12 kΩ, the equations yield  ILVDS0 = \n3.5 mA, I LVDS1 = 7.0 mA , and I LVPECL  = 8.0 mA.  Note that t he device \nmaintains a constant 1.238 V (nominal) across the external resistor.  \nClock Distribution Synchronization  \nA block diagram of the distribution synchro nization \nfunctionality appears in  Figure 50. The synchronization \nsequence begins with t he primary synchronization signal , \nwhich ultimately results in delivery of a synchronization strobe \nto the clock distribution logic.  \nAs indicat ed, the primary synchronization signal origin ates \nfrom four possible sources.  \n• Direct s ync source via t he sync distribution bit \n(Regis ter 0x0A02, Bit 1)  \n• Automatic sync source  based on frequency or phase lock \ndetection as controlled via the a utomati c synchronization \nregister ( Address 0x0403)  \n• Multifunctio n pin sync source via one  of the multifunction \npins (M0 to  M7)  \n• EEPROM s ync source via t he EEPROM  \nAll four sources of the primary synchronization signal are logic OR’ed, so any one of them can synchronize the c lock \ndistribution output at any time.  When using the multifunction \npins, the synchronization event is the falling edge of the selected \nRev. G | Page 41 of 111 \nAD9548 Data Sheet \n \nsignal.  When  using the sync d istribution bit, the user sets and \nthen clears the bit.  The synchronization event is the cle aring \noperation; that is, the L ogic 1 to Logic 0 transition of the bit.  \nThe primary synchronization signal can synchronize the \ndistrib ution  output directly , or it can enable a secondary \nsynchronization signal.  This functionality depends on the two \nsync source bits in the d istribution synchronization register \n(Register 0x0402 , Bits[ 5:4]). \nWhen s ync source = 00 (direct), the falling edge of the primary \nsynchroniz ation signal synchronizes the distribution output  \ndirectly . \nWhen s ync source = 01, the rising edge  of the primary \nsynchronization signal triggers the circuitry that detects a rising edge of the active input r eference.  The detection of the rising \nedge is what synchronizes the distribution output.  \nWhen sync s ource = 10, the rising edge of the primary \nsynchronization signal triggers the circuitry that detects a \nrollover of the DDS accumulator  (after processing by the DPLL \nfeedback divider) . This corresponds to the zero crossing of the \noutput of the phase -to-amplitude converter in the DDS (less the \nopen-loop phase o ffset stored in Register 0x 030D  to Register \n0x030E ). The detection of the DPLL feedback edge is what \nsynchronizes the distribution output.  \nActive Reference Synchronization ( Zero Delay)  \nActive reference synchronization is the term applied to the ca se \nwhen  sync source = 01 (Register  0x0402, Bits[5:4]) . Referring to  \nFigure 50, this means that the active referen ce sync path is \nactive because B it 4 = 1, enabling the lower AND gate and  \ndisabling the upper AND gate. The edge dete ctor in the active \nreference sync block monitors the rising edges of the active reference (the mux selects the ac tive reference automatically). \nThe edge detector is armed via the primary synchronization \nsignal, which is one of the fou r inputs to the OR gat e (typically \nthe direct sync source) . As soon as the edge detector is armed, \nits output goes high, which stalls the output dividers in the clock distribution block. Furthermore, once  armed, a rising \nedge from  the active reference forces the output of  the e dge \ndetector  low. This restarts the output dividers , thereby  \nsynchronizing  the clock distribution block.  The term zero  delay applies because it provides a means to edge \nalign the output signal with the  active  input  reference signal . \nTypically,  zero -delay architecture s use  the output signal in the \nfeedback loop of a PLL to track input/output edge alignment.  \nActive reference synchronization, however, o perates open -loop.  \nThat is, synchronization of the output via the distribution \nsynchronization logic occurs  on a single edge of the active \nreference.  \nThe fact that an active reference edge triggers the falling edge of \nthe synchronization pulse means that the falling edge is asynchronous to the signal that clocks the distribution output \ndividers (CLKINx). Therefo re, the output clock distribution \nlogic reclocks the internal synchronization pulse to synchronize \nit with the CLKINx signal. This means that the output dividers restart after a deterministic delay associated with the reclocking circuitry. This determinist ic delay has two components. The \nfirst deterministic delay component is four or five periods of the \nCLKINx signal. The one period uncertainty is due to the \nunknown position of the asynchronous reference clock edge relative to the CLKINx signal. The second deterministic delay \ncomponent is one output peri od of the distribution divider.  \n \n \nRev. G | Page 42 of 111 \nData Sheet AD9548\n \nRev. G | Page 43 of 111 MULTIFUNCTION PIN\nSYNC SOURCE0\n1REGISTER\n0402[5]\nSYSCLK/4DPLL\nFEEDBACK\nEDGE\nREGISTER\n0402[4]\nREF A\nREF AA\nREF D\nREF DDRESETEDGE\nDETECT\nEDGE\nDETECTARM\nEDGE\nDETECTARMDIRECT SYNC\nDPLL EDGE SYNC\nACTIVE REFERENCE SYNCEEPROM SYNC\nSOURCEPRIMARY\nSYNCHRONIZATION\nSIGNALDIRECT SYNC\nSOURCE\n(REGISTER 0A02[1])\nAUTOMATIC SYNC\nSOURCE\n(REGISTER 0403)TO CLOCK\nDISTRIBUTIONSYNCHRONIZATIONCONTROL\nSTALL\nDIVIDERS\nSYNC OUTPUTDISTRIBUTION\n08022-023TO MULTIFUNCTIONPIN STATUS LOGIC\n \nFigure 50. Output Synchronization Block Diagram \n \nThe deterministic delay, expressed as t LATENCY  in the following \nequations is a function of the frequency division factor (Q n) of \nthe channel divider associated with the zero-delay channel. \ntLATENCY  = (Qn + 4) × tCLK_IN  \nor t\nLATENCY  = (Qn + 5) × tCLK_IN  \nIn addition to deterministic delay, there is random delay (t PROP) \nassociated with the propagation of the reference signal through \nthe input reference receiver, as well as the propagation of the \nclock signal through the clock distribution logic. The total delay is \ntDELAY  = tLATENCY  + tPROP \nThe user can compensate for t DELAY  by using the phase offset \ncontrols of the device to move the edge timing of the \ndistribution output signal relative to the input reference edge. One method is to use the open-loop phase offset registers \n(Address 030D to Address 030E) for timing adjustment. \nHowever, be sure to use sufficiently small phase increments to make the adjustment. Too large a phase step can result in the clock distribution logic missing a CLKINx edge, thus ruining the edge alignment process. The appropriate phase increment \ndepends on the transient response of any external circuitry \nconnected between the DACOUTx and CLKINx pins. \nThe other method is to use the closed-loop phase offset registers \n(Address 0x030F to Address 0x0315) for timing adjustment. However, be sure to use a sufficiently small phase vs. time profile. Changing the phase too quickly can cause the DPLL to lose lock, thus ruining the edge alignment process. The AD9548 \nphase slew limit register (Address 0x0316 to Address 0x0317) can \nbe used to limit the rate of change of phase automatically, thereby \nmitigating the potential loss-of-lock problem. \nTo guarantee synchronization of the output dividers, it is \nimportant to make any edge timing adjustments after the synchronization event. Furthermore, when making timing adjustments, the distribution outputs can be disabled and then enabled after the adjustment is complete. This prevents the \ndevice from generating output clock signals during the timing \nadjustment process. \nNote that the form of zero-delay synchronization described here \ndoes not track propagation time variations within the distribution clock input path or the reference input path (on or off chip) over temperature, supply, and so on. It is strictly a one-time \nsynchronization event. \nSynchronization Mask \nEach output channel has dedicated synchronization mask bits \n(Register 0x0402, Bits[3:0]). When the mask bit associated with \na particular channel is set, then that channel does not respond to the synchronization signal. This allows the device to operate \nwith the masked channels active and the unmasked channels \nstalled while they wait for a synchronization pulse. \n \nAD9548 Data Sheet \n \nSTATUS AND CONTROL  \nMULTIFUNCTION PINS  (M0  TO M7)  \nThe AD9548 has e ight digital CMOS input/output  pins (M0 to M7) \nthat are configurable  for a variety of  uses.  The function of these \npins is programmable via the register map.  Each pin can control \nor monitor an assortmen t of internal functions based on the \ncontents  of Register  0x0200 to Register 0x 0207.  To monitor an \ninternal function  with a multifunction pin , write a L ogic 1  to the \nmost significant bit  of the register associated with the desired \nmultifunction  pin. The va lue of the seven least significant bits  of \nthe register defines  the control  function , as shown in  Table 25. \nTable 25. Multifunction Pin Output Functions, Register 0x 0200 \nto Register  0x0207 (Bit 7 = 1) \nBits[ 6:0]  \nValue  Output Function  Source  Proxy  \n0 Static L ogic 0   \n1 Static L ogic 1   \n2 System clock divided  \nby 32   \n3 Watchdog timer \noutput   \n4 EEPROM upload in \nprogress  Register 0x0D00 , Bit 0 \n5 EEPROM download in \nprogress  Register 0x0D00, Bit 1 \n6 EEPROM fault de tected  Register 0x0D00, Bit 2 \n7 SYSCLK  PLL lock \ndetected  Register 0x0D01 , Bit 0 \n8 SYSCLK  PLL calibration \nin progress  Register 0x0D01, Bit 1 \n9 Unused   \n10 Unused   \n11 SYSCLK  PLL stable  Register 0x0D01 , Bit 4 \n12 to 15 Unused   \n16 DPLL free running Regist er 0x0D0A , Bit 0 \n17 DPLL active  Register 0x0D0A , Bit 1 \n18 DPLL in holdover  Register 0x0D0A , Bit 2 \n19 DPLL in reference \nswitchover  Register 0x0D0A , Bit 3 \n20 Active reference : phase \nmaster  Register 0x0D0A , Bit 6 \n21 DPLL phase locked  Register 0x0D0A , Bit 4 \n22 DPLL frequency locked  Register 0x0D0A , Bit 5 \n23 DPLL phase slew \nlimited  Register 0x0D0A , Bit 7 \n24 DPLL frequency \nclamped  Register 0x0D0B , Bit 7 \n25 Tuning word history \navailable  Register 0x0D0B , Bit 6 \n26 Tuning word history \nupdated  Register 0x0D05, Bit 4 \n27 to 31 Unused   \n32 Reference A fault  Register 0x0D0C, Bit 2 \n33 Reference AA fault  Register 0x0D0D , Bit 2  \n34 Reference B fault  Register 0x0D0E , Bit 2 Bits[ 6:0]  \nValue  Output Function  Source  Proxy  \n35 Reference BB fault  Register 0x0D0F , Bit 2 \n36 Reference C fault  Register 0x0D10, Bit 2 \n37 Reference CC fault  Register 0x0D11, Bit 2 \n38 Reference D fault  Register 0x0D12, Bit 2 \n39 Reference DD fault  Register 0x0D13, Bit 2 \n40 to 47 Unused   \n48 Reference A valid  Register 0x0D0C , Bit 3 \n49 Reference AA valid  Register 0x0D0D , Bit 3  \n50 Reference B valid  Register  0x0D0E , Bit 3 \n51 Reference BB valid  Register 0x0D0F , Bit 3 \n52 Reference C valid  Register 0x0D10, Bit 3 \n53 Reference CC valid  Register 0x0D11, Bit 3 \n54 Reference D valid  Register 0x0D12, Bit 3 \n55 Reference DD valid  Register 0x0D13, Bi t 3 \n56 to 63 Unused   \n64 Reference A  active \nreference  Register 0x0D0B , \nBits[ 2:0] \n65 Reference AA active \nreference  Register 0x0D0B , \nBits[ 2:0] \n66 Reference B  active \nreference  Register 0x0D0B , \nBits[ 2:0] \n67 Reference BB  active \nreference  Register 0x0D0B , \nBits[2:0] \n68 Reference C active \nreference  Register 0x0D0B , \nBits[ 2:0] \n69 Reference CC active \nreference  Register 0x0D0B , \nBits[ 2:0] \n70 Reference D active \nreference  Register 0x0D0B , \nBits[ 2:0] \n71 Reference DD  active \nreference  Register 0x0D0B , \nBits[ 2:0] \n72 to 79 Unused   \n80 Clock distribution sync \npulse  Register 0x0D03, Bit 3 \n81 to 127 Unused   \nRev. G | Page 44 of 111 \nData Sheet AD9548 \n \nTo control an internal function with a multifunction pin , write a \nLogic 0  to the most significant bit  of the register associated with \nthe desired multifunction pin.  The monitored function depends \non the value of the seven least significant bits  of the register, as \nshown in  Table 26. \nTable 26. Multifu nction Pin Input Functions , Register 0x0200 \nto Register 0x 0207 (Bit 7 = 0) \nBits[6:0]  \nValue  Output Function  Destination Proxy  \n0 Unused  (default)  \n1 I/O u pdate  Register 0x0005, Bit 0  \n2 Full power -down  Register 0x0A00, Bit 0  \n3 Watchdog reset  Register 0x0A03 , Bit 0 \n4 IRQ reset  Register 0x0A03, Bit 1  \n5 Tuning word history reset  Register 0x0A03, Bit 2  \n6 to 15 Unused   \n16 Holdover  Register 0x0A01, Bit 6  \n17 Free run  Register 0x0A01, Bit 5  \n18 Reset incremental phase offset  Register 0x0A0C , Bit 2  \n19 Increment incremental phase \noffset  Register 0x0A0C , Bit 0  \n20 Decrement incremental  phase \noffset  Register 0x0A0C , Bit 1  \n21 to 31 Unused   \n32 Override Reference M onitor A  Register 0x0A0F , Bit 0  \n33 Override Reference M onitor  AA Register 0x0A0F , Bit 1  \n34 Override Reference M onitor B  Register 0x0A0F , Bit 2  \n35 Override Reference M onitor  BB Register 0x0A0F , Bit 3  \n36 Override Reference M onitor C  Register 0x0A0F , Bit 4  \n37 Override Reference M onitor  CC Register 0x0A0F , Bit 5 \n38 Override R eference Monitor D  Register 0x0A0F , Bit 6  \n39 Override Reference M onitor  DD Register 0x0A0F , Bit 7  \n40 to 47 Unused   \n48 Force validation T imeout A  Register 0x0A0E , Bit 0  \n49 Force validation Ti meout AA  Register 0x0A0E , Bit 1  \n50 Force validation T imeout B  Register 0x0A0E , Bit 2  \n51 Force validation T imeout BB  Register 0x0A0E , Bit 3  \n52 Force validation T imeout C  Register 0x0A0E , Bit 4  \n53 Force validation T imeout CC  Register 0x0A0E , Bit 5  \n54 Force validation T imeout D  Register 0x0A0E , Bit 6  \n55 Force validation T imeout DD  Register 0x0A0E , Bit 7 \n56 to 63  Unused   \n64 Enable OUT0  Register 0x0401, Bit 0  \n65 Enable OUT1  Register 0x0401, Bit 1  \n66 Enable OUT2  Register 0x0401, Bit 2  \n67 Enable OUT3  Register 0x0401, Bit 3  \n68 Enable OUT0, OUT1, OUT2, OUT3  Register 0x0401, \nBits[3:0]  \n69 Sync clock distribution outputs  Register 0x0A02, Bit 1 \n70 to \n127 Unused   \nIf more than one multifunction pin  operates on  the same \ncontrol signal , then internal priority logic ensures that only one \nmultifunction pin serves as  the signal source . The selected pin is the one with the lowest numeric suffix.  For example, if both M3 \nand M7 operate on the same control signal, then M3 is used as \nthe signal source and the redundant pins are ignored . \nAt power -up, the multifunction pins can be used to force the \ndevice into certain configurations as defined in the i nitial pin \nprogramming  section.  This functionality, however, is valid only \nduring power -up or following a reset, after which the pins can \nbe reconfigured via the serial programming port  or via the \nEEPROM . \nIRQ PIN  \nThe AD9548 has a dedicated interrupt request ( IRQ ) pin. The \nIRQ p in output mode register ( Register 0x0208, Bits[ 1:0]) \ncontrols how the IRQ pin asserts an interrupt based on the value of the two bits , as follows: \n00— The IRQ pin is h igh impe dance when deasserted and active \nlow when asserted  and requires  an external pull -up resistor \n(this is the default operating mode).  \n01— The IRQ pin is high impedance when de asserted  and active \nhigh when asserted and requires  an external pull -down \nresistor.  \n10—The IRQ pin is Logic 0 when deasserted and L ogic 1 when \nasserted.  \n11— The IRQ pin is Logic 1 when de asserted  and L ogic 0 when \nasserted.  \nThe AD9548 asserts the IRQ pin whenever any of th e bits in the \nIRQ m onitor register ( Address 0x0D02 to Address 0x 0D09)  are \nLogic 1.  Each bit in this register is associated with an internal \nfunction capable of producing an interrupt.  Furthermore, each \nbit of the IRQ m onitor register is the result of a logical AND of \nthe associated internal interrupt signal and th e corresponding \nbit in the IRQ m ask register ( Address 0x0209  to Address \n0x0210).  That is, the bits in the IRQ m ask register have a one -\nto-one correspon dence with the bits in t he IRQ m onitor  \nregister.  Whenever an internal function produces an interrupt \nsignal an d the associated IRQ m ask bit is set, then th e \ncorresponding bit in the IRQ m onitor register is set.  The user \nshould be aware that clearing a bit in the IRQ m ask register  \nremoves only the mask associated with the internal interrupt \nsignal.  It does not clear the corresponding bit in the IRQ \nmonitor  register . \nThe IRQ pin is the result of a logical OR of all the IRQ m onitor \nregister bits. Thus , the AD9548 asserts  the IRQ  pin so long as \nany of the IRQ m onitor register bits are L ogic 1.  Note that  it is \npossible to have multiple bits set in the IRQ m onitor register.  \nTherefore, when the AD9548 asserts the IRQ pin , it may \nindicate an interrupt from several different internal functions.  \nThe IRQ m onitor register provides the user with a means to \ninterrog ate the AD9548 to determine which internal function(s)  \nproduced the interrupt . \n \nRev. G | Page 45 of 111 \nAD9548 Data Sheet \n \nTypically, when the AD9548 assert s the IRQ pin,  the user \ninterrogates the IRQ m onitor register to identify the source of  \nthe interrupt request . After servicing an indicated interrupt, the \nuser should  clear the associated IRQ m onitor register bit via the \nIRQ c learing register ( Address 0x0A04 to Address 0x 0A0B).  \nThe bits in the IRQ c learing register have a one -to-one \ncorrespon dence with the bits in the IRQ m onitor  register . Note \nthat the IRQ c learing register is autoclearing.  The IRQ pin \nremains asser ted until the user clears a ll of the bits in the IRQ \nmonitor register that indicate an interrupt.  \nIt is also possible to c ollectively  clear all of the IRQ m onitor \nregister bits by setting the r eset all IRQs bit in the r eset function  \nregister ( Register 0x0A03, Bit 1) . Note that this is an \nauto clearing bit.  Setting this bit results in deassertion of the IRQ \npin. Alternatively, the user can program any of the \nmultifunction pins to clear all IRQs. This allows the user to \nclear all IRQs by means of a hardware pi n rather than by a serial \ninput/output  port operation . \nNote that the IRQ function detects a state change in the function  \nthat is being monitored. However, if IRQs are cleared (or if they \nare enabled for the first time), an IRQ will not be generated for a pre-existing condition. The state must ch ange after the IRQ is \nenabled. For example, if REFA is already invalid before a “REFA \ninvalid”  IRQ is enabled, an IRQ will not be generated.  \nWATCHDOG TIMER  \nThe watchdog timer is a general -purpose programmable timer.  \nTo set the timeout period , the user writes to the 16 -bit \nwatchdog t imer register ( Address 0x0211 to Address 0x 0212).  \nA value of 0  in this register disables the timer.  A nonzero value \nsets the timeout period in milliseconds, giving the watchdog timer a  rang e of 1 ms to 65.535 sec. The relative accuracy of t he \ntimer is approximately 0.1% with an uncertainty  of 0.5 ms. \nIf enable d, the timer runs continuously  and generates  a timeout \nevent  whenever the timeout  period expires.  The user has access \nto the watchdog timer status via the IRQ mechanism  and the \nmultifunction pins  (M0 to M7) . In the case of the multifunction \npins, the t imeout event of the watchdog timer is  a pulse that \nlasts 32 system clock periods.  \nThere are two ways to reset the watchdog timer (thereby \npreventing it from causing a time out event ). The first is by \nwriting a Logic 1 to the auto clearing reset watchdog bit in the \nreset function  register ( Register 0x0A03, Bit 0 ). Alternatively, \nthe user can program any of the multifunction pins to  reset the \nwatchdog timer . This  allows the user to reset the timer by \nmeans of a hardware pin rather than  by a serial input/output  port \noperation . EEPROM  \nEEPROM Overview  \nThe AD95 48 contains an integrated 2048- byte, electroni cally \nerasable , programmable read -only memory (EEPROM).  The \nAD9548 can be configured to perform a download at power -up \nvia the multifunction pins (M3  to M7) , but up loads and \ndownloads can also be  done on demand via the EEPROM \ncontrol register  (Address 0x0E00 to Address 0x 0E03).  \nThe EEPROM provides the ability to upload  and down load \nconfiguration settings to  and from the  register map.  Figure 51 \nshows a functional diagram of the EEPROM.  \nRegister  0x0E10 to Register 0x 0E3F represent a 48 -byte scratch \npad that enables the user to store a sequence of instructions for \ntransferring  data to the EEPROM  from the device settings \nportion of the register map . Note that the default values for \nthese registers provide a sample sequence for saving/retrieving \nall of the AD9548  EEPROM -accessible registers. Figure 51 \nshows  the connectivity between the EEPROM and the controller  \nthat manages data transfer between the EEPROM and the \nregister map.  \nThe controller oversees the process of transferring EEPROM  data \nto and from the register map.  There are two modes of operation \nhandled by the controller —saving data to the EEPROM  (upload \nmode)  or retrieving data from the EEPROM  (download mode) . \nIn either case, the controller relies on a specific instruct ion set.  \nEEPROM\n(000 TO 7FF)DATA\nDATADATA\nEEPROM\nADDRESS\nPOINTERM7\nM6\nM5\nM4\nM3\nREGISTER MAPDEVICE SETTINGS\n(0100 TO 0A10)SCRATCH PAD\n(0E10 TO 0E3F)\nSERIAL\nINPUT/OUTPUT\nPORTCONDITION\n(0E01 [4:0])SCRATCHPAD\nADDRESS\nPOINTERDEVICE\nSETTINGS\nADDRESS\nPOINTEREEPROM\nCONTROLLER\n08022-024 \nFigure 51. EEPROM Functional Diagram \n \nRev. G | Page 46 of 111 \nData Sheet AD9548\n \nRev. G | Page 47 of 111 Table 27. EEPROM Controller Instruction Set \nInstruction \nValue (Hex) Instruction Type Bytes Required Description \n0x00 to 0x7F Data 3 A data instruction tells the controller to transfer data to or from the device settings part of \nthe register map. A data instruction requires two additional bytes that together indicate a \nstarting address in the register map. Encoded in  the data instruction is the number of bytes \nto transfer, which is one more than the instruction value. \n0x80 I/O update 1 When the controller encounters this instru ction while downloading from the EEPROM, it \nissues a soft I/O update (see Register 0x0005 in Table 42). \n0xA0 Calibrate 1 When the controller encounters this instru ction while downloading from the EEPROM, it \ninitiates a system clock calibration sequ ence (see Register 0x0A02 in Table 121). \n0xA1 Distribution sync 1 When the controller encounters this instru ction while downloading from the EEPROM, it \nissues a sync pulse to the output distribution  synchronization (see Register 0x0A02 in Table \n121). \n0xB0 to 0xCF Condition 1 0xB1 to 0xCF are condition instructions an d correspond to Condition 1 through Condition \n31, respectively. 0xB0 is the null condition instruction. See the EEPROM Conditional Processing section for details. \n0xFE Pause 1 When the controller encounters this instructio n in the scratch pad while uploading to the \nEEPROM, it resets the scratch pad address point er and holds the EEPROM address pointer at \nits last value. This allows storage of more  than one instruction sequence in the EEPROM. \nNote that the controller does not copy this  instruction to the EEPROM during upload. \n0xFF End 1 When the controller encounters this instructio n in the scratch pad while uploading to the \nEEPROM, it resets both the scratch pad address pointer and the EEPROM address pointer and then enters an idle state. \nWhen the controller encounters this instru ction while downloading from the EEPROM, it \nresets the EEPROM address pointer an d then enters an idle state. \n \nEEPROM Instructions \nTable 27 lists the EEPROM controller instruction set. The \ncontroller recognizes all instruction types whether it is in \nupload or download mode, except for the pause instruction, which it only recognizes in upload mode. \nThe input/output update, calibrate, distribution sync, and end \ninstructions are mostly self-explanatory. The others, however, \nwarrant further detail, as described in the following paragraphs. \nData instructions are those that have a value from 0x00 to 0x7F. \nA data instruction tells the controller to transfer data between the EEPROM and the register map. The controller needs the \nfollowing two parameters to carry out the data transfer: \n\uf0b7 The number of bytes to transfer \n\uf0b7 The register map target address \nThe controller decodes the number of bytes to transfer directly \nfrom the data instruction itself by adding one to the value of the \ninstruction. For example, the data instruction, 1A, has a decimal value of 26; therefore, the controller knows to transfer 27 bytes (one more than the value of the instruction). Whenever the controller encounters a data instruction, it knows to read the \nnext two bytes in the scratch pad because these contain the \nregister map target address. \nNote that, in the EEPROM scratch pad, the two registers that \ncomprise the address portion of a data instruction have the MSB of the address in the D7 position of the lower register address. The bit weight increases left to right, from the lower register address to the higher register address. Furthermore, the starting address always indicates the lowest numbered register map address in the range of bytes to transfer. That is, the controller always starts at the register map target address and counts upward regardless of whether the serial input/output \nport is operating in I\n2C, SPI LSB-first, or SPI MSB-first mode. \nAs part of the data transfer process during an EEPROM upload, \nthe controller calculates a 1-byte checksum and stores it as the final \nbyte of the data transfer. As part of the data transfer process during \nan EEPROM download, however, the controller again calculates a 1-byte checksum value but compares the newly calculated checksum with the one that was stored during the upload process. If an upload/download checksum pair does not match, the controller sets the EEPROM fault status bit. If the upload/download checksums \nmatch for all data instructions encountered during a download \nsequence, the controller sets the EEPROM complete status bit. \nCondition instructions are those that have a value from 0xB0 to \n0xCF. Condition instructions 0xB1 to 0xCF represent Condition 1 to Condition 31, respectively. The 0xB0 condition instruction is special because it represents the null condition \n(see the EEPROM Conditional Processing section). \nA pause instruction, like an end instruction, is stored at the end \nof a sequence of instructions in the scratch pad. When the \ncontroller encounters a pause instruction during an upload sequence, it keeps the EEPROM address pointer at its last value. This way the user can store a new instruction sequence in the scratch pad and upload the new sequence to the EEPROM. The new sequence is stored in the EEPROM address locations \nimmediately following the previously saved sequence. This \nAD9548 Data Sheet\n \nRev. G | Page 48 of 111 process is repeatable until an upload sequence contains an end \ninstruction. The pause instruction is also useful when used in conjunction with condition processing. It allows the EEPROM to contain multiple occurrences of the same register(s), with \neach occurrence linked to a set of conditions (see the EEPROM \nConditional Processing section). \nEEPROM Upload \nTo upload data to the EEPROM, first ensure that the write \nenable bit (Register 0x0E00, Bit 0) is set. Then, on setting the \nautoclearing save to EEPROM bit (Register 0x0E02, Bit 0), the \ncontroller initiates the EEPROM data storage process. When \nan EEPROM save/load transfer is complete, wait a minimum \nof 10 μs before starting the next EEPROM save/load transfer. \nUploading EEPROM data requires that the user first write an \ninstruction sequence into the scratch pad registers. During the upload process, the controller reads the scratch pad data byte by byte, starting at Register 0x0E10 and incrementing the scratch \npad address pointer as it goes until it reaches a pause or end \ninstruction. \nAs the controller reads the scratch pad data, it transfers the data \nfrom the scratch pad to the EEPROM (byte by byte) and increments the EEPROM address pointer accordingly, unless it encounters a data instruction. A data instruction tells the controller to transfer data from the device settings portion of \nthe register map to the EEPROM. The number of bytes to \ntransfer is encoded within the data instruction, and the starting address for the transfer appears in the next two bytes in the \nscratch pad. \nWhen the controller encounters a data instruction, it stores the \ninstruction in the EEPROM, increments the EEPROM address pointer, decodes the number of bytes to be transferred, and \nincrements the scratch pad address pointer. Then it retrieves the \nnext two bytes from the scratch pad (the target address) and increments the scratch pad address pointer by 2. Next, the controller transfers the specified number of bytes from the \nregister map (beginning at the target address) to the EEPROM. \nWhen it completes the data transfer, the controller stores an \nextra byte in the EEPROM to serve as a checksum for the \ntransferred block of data. To account for the checksum byte, the \ncontroller increments the EEPROM address pointer by one more than the number of bytes transferred. Note that, when the controller transfers data associated with an active register, it actually transfers the buffered contents of the register (see the \nBuffered/Active Registers section for details on the difference \nbetween buffered and active registers). This allows for the transfer of nonzero autoclearing register contents. Note that conditional processing does not occur during an upload sequence. (see the EEPROM Conditional Processing section). \nEEPROM Download \nAn EEPROM download results in data transfer from the \nEEPROM to the device register map. To download data, the \nuser sets the autoclearing load from the EEPROM bit (Register 0x0E03, Bit 1). This commands the controller to initiate the EEPROM download process. During download, the controller reads the EEPROM data byte by byte, incrementing the EEPROM address pointer as it goes, until it reaches an end \ninstruction. As the controller reads the EEPROM data, it \nexecutes the stored instructions, which include transferring stored data to the device settings portion of the register map whenever it encounters a data instruction. When an EEPROM save/load transfer is complete, wait a minimum of 10 μs before \nstarting the next EEPROM save/load transfer. \nNote that conditional processing is applicable only when \ndownloading (see the EEPROM Conditional Processing section). \nAutomatic EEPROM Download \nFollowing a power-up, an assertion of the RESET pin, or a soft \nreset (Register 0x0000, Bit 5 = 1), if FncInit[7:3] ≠ 0 (see the \nInitial M0 to M7 Pin Programming section), then the instruction sequence stored in the EEPROM executes automatically with condition = FncInit[7:3]. In this way, a previously stored set of \nregister values downloads automatically on power-up or with a \nhard or soft reset. See the EEPROM Conditional Processing section for details regarding conditional processing and the way it modifies the download process. \nDisabling Accidental Automatic EEPROM Download \nIt is possible to bypass EEPROM downloading when M3 to M7 \nare either accidentally left floating or are pulled high. The \nfollowing steps ensure that EEPROM loading is bypassed: \n1. Register 0x0E10 = 0xFF (end of data). \n2. Register 0x0E00 = 0x01 (EEPROM write enable). \n3. Register 0x0E02 = 0x01 (save to EEPROM). \n4. Wait until Register 0xD00 equals 0x00. \nEEPROM Conditional Processing \nThe condition instructions allow conditional execution of \nEEPROM instructions during a download sequence. During an \nupload sequence, however, they are stored as is and have no effect on the upload process. \nNote that, during EEPROM downloads, the condition instructions \nthemselves and the end instruction always execute unconditionally. \nConditional processing makes use of two elements: the condition \n(from Condition 1 to Condition 31) and the condition tag board. \nThe relationships among the condition, the condition tag board, \nand the EEPROM controller appear schematically in Figure 52. \n \nData Sheet AD9548\n \nRev. G | Page 49 of 111 EXAMPLE\nCONDITION 3 AND\nCONDITION 13\nARE TAGGED\nEEPROM\nEEPROM CONTROLLERUPLOAD\nPROCEDURECONDITION\nHANDLER\nDOWNLOAD\nPROCEDURECONDITION\nTAG BOARD\n1 6 5 4 3 2\n11 109 87\n30 31 2423 22 21 20 19 18 17 1615 14 13 12\n25 26 27 28 29\nIF B1 ≤  INSTRUCTION ≤ CF,\nTHEN TAG DECODED CONDITION\nEXECUTE/SKIP\nINSTRUCTION(S)\nSCRATCH\nPADCONDITIONCONDITION = 0E01, BITS[4:0]\nELSE\nCONDITION = FncInit, BITS[7:3]\nENDIFM7 M3\nIF INSTRUCTION = B0,\nTHEN CLEAR ALL TAGSFncInit, BITS[7:3]REGISTER\n0E01, BITS[4:0]\nSTORE CONDITION\nINSTRUCTIONS AS\nTHEY ARE READ FROM\nTHE SCRATCH PAD.WATCH FOR\nOCCURRENCE OF\nCONDITION\nINSTRUCTIONS\nDURING\nDOWNLOAD.\nIF {NO TAGS} OR {CONDITION = 0}\n   EXECUTE INSTRUCTIONSELSE\n   IF {CONDITION IS TAGGED}\n      EXECUTE INSTRUCTIONS   ELSE      SKIP INSTRUCTIONS   ENDIFENDIF55 5\n08022-025IF {0E01, BITS[4:0] ≠ 0}\n \nFigure 52. EEPROM Conditional Processing \n \nThe condition is a 5-bit value with 32 possibilities. Condition = 0 \nis the null condition. When the null condition is in effect, the \nEEPROM controller executes all instructions unconditionally. The remaining 31 possibilities, condition = 1 through condition = 31, modify the EEPROM controller’s handling of a download sequence. The condition originates from one of two sources (see Figure 52), as follows: \n\uf0b7 FncInit, Bits[7:3], which is the state of the M3 to M7 \nmultifunction pins at power-up (see the Initial M0 to M7 \nPin Programming section) \n\uf0b7 Register 0x0E01, Bits[4:0] \nIf Register 0x0E01, Bits[4:0] ≠ 0, then the condition is the value stored in Register 0x0E01, Bits[4:0]; otherwise, the condition is FncInit, Bits[7:3]. Note that a nonzero condition present in \nRegister 0x0E01, Bits[4:0] takes precedence over FncInit, \nBits[7:3]. \nThe condition tag board is a table that is maintained by the \nEEPROM controller. When the controller encounters a condition instruction, it decodes the 0xB1 through 0xCF instructions as condition = 1 through condition = 31, respectively, and tags that particular condition in the condition tag board. However, the 0xB0 \ncondition instruction decodes as the null condition, for which the \ncontroller clears the condition tag board, and subsequent download instructions execute unconditionally (until the controller \nencounters a new condition instruction). During download, the EEPROM controller executes or skips \ninstructions depending on the value of condition and the \ncontents of the condition tag board. Note, however, that condition instructions and the end instruction always execute unconditionally during download. If condition = 0, then all instructions during download execute unconditionally. If \ncondition ≠ 0 and there are any tagged conditions in the \ncondition tag board, then the controller executes instructions only if the condition is tagged. If the condition is not tagged, then the controller skips instructions until it encounters a condition instruction that decodes as a tagged condition. Note that the condition tag board allows for multiple conditions to be \ntagged at any given moment. This conditional processing \nmechanism enables the user to have one download instruction sequence with many possible outcomes depending on the value of the condition and the order in which the controller \nencounters condition instructions. \nAD9548 Data Sheet \n \nTable 28 lists a sample EEPROM download in struction sequence.  \nIt illustrates the use of condition instructions and how they alter \nthe download sequen ce. The table begins with the assumption \nthat no conditions are in effect. That is, the most recently executed  \ncondition instruction is 0x B0 or no conditional instructions \nhave been processed . \nTable 28. EEPROM Conditional Processing Example  \nInstruction  Action  \n0x08 Transfer the s ystem clock register  content s \nregardless of the current condition.  0x01 \n0x00 \n0xB1  Tag Condition 1. \n0x19 Transfer the c lock distribution register contents \nonly if condition = 1. 0x04  \n0x00 \n0xB2  Tag Condition 2. \n0xB3  Tag Condition 3. \n0x07 Transfer the r eference input register contents only \nif condition = 1, 2, or 3 . 0x05 \n0x00 \n0x0A  Calibrat e the system clock only if condition = 1, 2, \nor 3 . \n0xB0  Clear the condition tag board . \n0x80 Execute an I/O u pdate regardless of the value of \nthe condition.  \n0x0A  Calibrate the system clock regardless of the value \nof the condition . \nStoring Multiple Devic e Setups in EEPROM  \nConditional processing makes it possible to create a number of \ndifferent device setups, store them in EEPROM, and download \na specific setup on demand.  To do so, first program the device \ncontrol registers for a specific setup.  Then, store  an upload \nsequence in the EEPROM scratch pad with the following \ngeneral form:  \n1. Condition instruction  (0xB1 to 0xCF) to identify  the setup \nwith a specific condition  (1 to 31) \n2. Data instructions (to save the register contents) along with \nany required c alibrat e and/or input/output  update \ninstructions  \n3. Pause instruction  (0xFE) \nWith the upload sequence written to the scratch pad, p erform \nan EEPROM upload  (Register 0x0E02, Bit 0 ). \nReprogram the devic e control registers  for the next desired \nsetup.  Then s tore a new u pload sequence in the EEPROM \nscratch pad with the following general form:  1. Condition  instruction  (0xB0) \n2. The next desired c ondition instruction  (0xB1 to 0xCF, but \ndifferent than the one used during the previous upload  to \nidentify a new setup)  \n3. Data instructio ns (to save the register contents) along with \nany req uired c alibrate and/or input/output  update \ninstructions  \n4. Pause instruction  (FE) \nWith the upload sequence written to the scratch pad, perform an EEPROM upload (Register 0x 0E02, Bit 0).  \nRepeat the process of programming the device  control registers  \nfor a new setup, storing a new upload sequence  in the EEPROM \nscratch pad  (Step 1  through Step 4 ), and executing an EEPROM \nupload (Register 0x 0E02, Bit 0) until all of the desired setups \nhave been uploaded to the E EPROM.  \nNote that, on  the final  upload sequence  stored in the scratch \npad, the pause  instruction (FE) must be replaced with an e nd \ninstruction  (FF) . \nTo download a specific setup  on demand, first store the condition  \nassociated with the desired setup in Regis ter 0x0E01, Bits[ 4:0]. \nThen perform an EEPROM download (Register  0x0E03, Bit 1). \nAlternatively, to download a spe cific setup at power -up, apply \nthe required logic levels necessary to encode the desired \ncondition on the M3 to M7 multifunction pins . Then pow er up \nthe device; an automatic EEPROM download occur s. The \ncondition (as established by the M3 to M7 multifunction pins ) \nguides the download sequence and results in a specific setup . \nKeep in mind that the number of setups that can be stored in \nthe EEPROM i s limited.  The EEPROM can hold a total of 2048 \nbytes.  Each non data instruction requires one byte of storage.  \nEach d ata instruction, however, requires N  + 4 bytes of storage, \nwhere N is the number of transferred register bytes and the \nother four bytes inclu de the data instruction  itself  (one byte), \nthe target address ( two bytes) , and the  checksum calculated by \nthe EEPROM controller during the upload sequence (one byte).  \nProgrammi ng the EEPROM to Include a Clock Part ID  \nA special EEPROM loading sequence is re quired to use the \nclock part ID registers. These registers provide  for part and \nrevision identification.  \nThe default EEPROM loading sequence from Register 0x0E10 to Register 0x0E31 is unchanged. The following steps must be \ninserted into the EEPROM storage sequence to use the clock \npart ID registers:  \n1. Register 0x0E32 = 0x07 (write 8 bytes)  \n2. Register 0x0E33 = 0x0C (at Register 0x0C00)  \n3. Register 0x0E34 = 0x00  \n4. Register 0x0E35 = 0x 80 (input/output  update)  \n5. Register 0x0 E36 = 0x FF (end of data)  \n \nRev. G | Page 50 of 111 \nData Sheet AD9548\n \nRev. G | Page 51 of 111 SERIAL CONTROL PORT \nM7\nM0M1M2M3M4M5M613-BIT ADDRESS\nSPACE\nREAD ONLY\nREGION\nREAD/WRITE\nREGION\nANALOG BLOCKS AND\nDIGITAL COREPOWER-ON RESET SERIAL CONTROL ARBITER\nSPI\nI2C\nEEPROM\nCONTROLLER\n400kHzMULTI-\nFUNCTION\nPIN CONTROL\nLOGICSCLK/SCL\nCS/SDA\nSDIO\nSDO\nEEPROM\n08022-026 \nFigure 53. Serial Port Functional Diagram \n \nThe AD9548 serial control port is a flexible, synchronous serial \ncommunications port that provides a convenient interface to \nmany industry-standard microcontrollers and microprocessors. The AD9548 serial control port is compatible with most \nsynchronous transfer formats, including Philips I2C, Motorola SPI, and Intel SSR protocols. The serial control port allows \nread/write access to the AD9548 register map. \nIn SPI mode, single or multiple byte transfers are supported. \nThe SPI port configuration is programmable via Register 0x0000. This register is integrated into the SPI control logic rather than in the register map and is distinct from the I\n2C Register 0x0000. \nIt is also inaccessible to the EEPROM controller. \nA functional diagram of the serial control port, including its \nrelationship to the EEPROM, appears in Figure 53. \nAlthough the AD9548 supports both the SPI and I2C serial port \nprotocols, only one is active following power-up (as determined \nby the multifunction pins, M0 to M2, during the startup sequence). That is, the only way to change the serial port protocol is to reset the device (or cycle the device power supply). Both protocols use a common set of control pins as shown in Figure 54. \nAD9548 SCLK/SCL\nCSB/SDASDOSDIO2\n543SERIAL\nCONTROL\nPORT\n08022-027 \nFigure 54. Serial Control Port \nSPI/I²C PORT SELECTION \nBecause the AD9548 supports both SPI and I2C protocols, the active serial port protocol depends on the logic state of the three \nmultifunction pins, M0 to M2, at startup. If all three pins are set \nto Logic 0 at startup, then the SPI protocol is active. Otherwise, the I2C protocol is active with seven different I2C slave address settings based on the startup logic pattern on the M0 to M2 pins (see Table 29). Note that the four MSBs of the slave address are \nhardware coded as 1011. \nTable 29. Serial Port Mode Selection \nM2 M1 M0 Serial Port Mode \n0 0 0 SPI \n0 0 1 I²C (address = 1001001) \n0 1 0 I²C (address = 1001010) \n0 1 1 I²C (address = 1001011) \n1 0 0 I²C (address = 1001100) \n1 0 1 I²C (address = 1001101) \n1 1 0 I²C (address = 1001110) \n1 1 1 I²C (address = 1001111) \nSPI SERIAL PORT OPERATION \nPin Descriptions \nThe SCLK (serial clock) pin serves as the serial shift clock. This \npin is an input. SCLK synchronizes serial control port read and \nwrite operations. The rising edge SCLK registers write data bits, and the falling edge registers read data bits. The SCLK pin supports a maximum clock rate of 40 MHz. \nThe SDIO (serial data input/output) pin is a dual-purpose pin \nand acts as either an input only (unidirectional mode) or as \nboth an input and an output (bidirectional mode). The AD9548 \ndefault SPI mode is bidirectional. \nThe SDO (serial data output) pin is useful only in unidirectional \ninput/output mode. It serves as the data output pin for read \noperations. \nThe CS\n (chip select) pin is an active low control that gates read \nand write operations. This pin is internally connected to a 30 kΩ \npull-up resistor. When CS is high, the SDO and SDIO pins go \ninto a high impedance state. \n   \n \nAD9548 Data Sheet \n \nSPI Mode Operation  \nThe SPI port supports both  3-wire (bidirectional) and  4-wire \n(unidirectional) hardware configurations and both  MSB -first \nand LSB -first data formats.  Both the hardware configuration \nand data format features are programmable . By default, the \nAD9548 uses the bidirectional MSB -first mode. The reason that \nbidirectional is the default  mode is so that  the user can still \nwrite to the device , if it is wired for unidirectional operation, to  \nswitch to unidirectional mode.  \nAssertion (active low) of the CS pin initiates a write or read \noperation to the AD9548 SPI port.  For data transfers of three \nbytes or fewer  (excluding the  instruction word ), the device \nsupports t he CS stalled high mode (see Table 30). In this mode, \nthe CS pin can  be temporarily deasserted  on any byte boundary, \nallowing time for the system controller to process the next \nbyte. CS can be deasserted only on byte boundaries, however . \nThis applies to both the instruction and data  portions  of the \ntransfer.  \nDuring stall high period s, the serial control port state machine \nenters a wait state until all data is sent. If the syst em controller \ndecides to abort a transfer midstream , then the  state machine must \nbe reset by either completing the transfer or by asserting  the CS pin \nfor at least one complete SCLK cycle (but less than eight SCLK \ncycles). Deassertin g the CS pin on a nonbyte boundary \nterminates the serial transfer and flushes the buffer.  \nIn the streaming mode (see Table 30), any number of data bytes \ncan be transferred in a continuous stream. The regist er address \nis automatically incremented or decremented.  CS must be \ndeasserted  at the end of the last byte transferred, thereby ending \nthe stream mode.  \nTable 30. Byte Transfer Count  \nW1 W0 Bytes to Transfer  \n0 0 1 \n0 1 2 \n1 0 3 \n1 1 Streaming mode \nCommunication Cycle —Instruction Plus Data  \nThe SPI protocol consists of a two -part communication cycle. \nThe first part is  a 16-bit instruction word that is  coincident with \nthe first 16 SCLK rising edges  and a payload . The instruction \nword provides the AD9548 serial control port with information \nregarding the  payload . The instruction word includes the  R/W \nbit that indicates the direction of the payload transfer (that is, a \nread or write operation) . The instruction word also indicates  \nthe number of bytes in the payload  and the starting register \naddress of the first payload byte.  \n \n \n \n Write  \nIf the instruction wor d indicates  a write operation, the payload \nis written  into the serial control port buffer of the AD9548. \nData  bits are registered on the rising edge of SCLK.  The le ngth of \nthe transfer (1, 2, or 3 bytes or streaming mode) depends on the \nW0 and W1 bits (see Table 30) in the instruction byte. When \nnot streaming , CS can be deasserted  after each sequence of \neight bits to st all the bus (except after the last byte, where it ends \nthe cycle) . When the bus is stalled, the serial transfer resumes \nwhen CS is asserted . Deasserting  the CS pin on a nonbyte \nboundary resets the serial contro l port.  Reserved or blank \nregisters are not skipped over automatically d uring a write  \nsequence. T herefore, the user must know what bit pattern to \nwrite to the reserved registers to preserve proper operation of the part. Generally, it does not matter what d ata is written to blank \nregisters , but it is customary to write 0s . \nMost of the serial port registers are buffered  (see the \nBuffered/Active Registers  section for details on the difference \nbetween buffered and active registers ). Therefore , data written \ninto buffered registers does not take e ffect  immediately . An \nadditional operation is needed to transfer buffered  serial control \nport contents to the registers that actually control the device . \nThis is accomplished with an input/ou tput update operation, \nwhich is performed in one of two ways.  One is by w riting a \nLogic 1 to Registe r 0x0005, Bit  0 (this bit is self -clearing).  The \nother is to use an external signal via an appropriately programmed multifunction pin.  The user can change as many \nregister bits as desired  before executing an input/output  update. \nThe input/output  update operation transfers the buffer register \ncontents to the ir active register  counterpart s. \nRead \nThe AD9548 supports the long instruction mode  only. If the \ninstruction word indicates  a read operation, the next N  × 8 \nSCLK cycles clock out the data from the address specified in the \ninstruction word . N is the number of data bytes re ad and \ndepends on the W0 and W1 bits of the instruction word . \nDuring a SPI read, serial data on SDIO (or SDO in the case of \n4-wire mode) trans itions on the SCLK falling edge  and is \nnormally sampled on the SCLK rising edge. To read the last bit \ncorrectly, t he SPI host must be able to tolerate a zero hold time. If \nzero hold time is not possible, the user can either use streaming \nmode and delay the rising edge of CS, or sample the serial data on \nthe SCLK falling edge. However, to sample the data on the \nSCLK falling edge  correctly , the user must ensure that the setup \ntime is greater than t DV (time data valid ). Blank registers are not \nskipped over during readback.  \nA readback operation  takes  data from  either the serial control \nport buffer re gisters or the active registers , as determined by \nRegister 0x0004 , Bit 0.  \nRev. G | Page 52 of 111 \nData Sheet AD9548 \n \nSPI Instruction Word (16 Bits)  \nThe MSB of the  16-bit instruction word is R/ W, which indicates \nwhether the instruction is a read or a write. The next two bits,  \nW1 and W0, indic ate the number of bytes in the transfer  (see \nTable 30). The final 13  bits are the register address ( A12 to A0), \nwhich indicates  the starting register address of the read/ write \noperation  (see Table 32). \nSPI MSB- /LSB -First Transfers  \nThe AD9548 instruction word and payload  can be MSB -first or \nLSB-first. The default for the AD9548 is MSB -first. The \nLSB-first mode can be set by writing a 1 to Regis ter 0x0000, \nBit 6. Immediately after the LSB -first bit is set, subsequent serial \ncontrol port operations are LSB -first.  \nWhen MSB -first mode is active, the instruction and data bytes \nmust be written from MSB to LSB. Multibyte data transfers in \nMSB -first format start with an i nstruction byte that includes the \nregister address of the most significant payload  byte. Subse quent \ndata bytes must follow in order from high address to low \naddress. In MSB -first mode, the serial control port internal \naddress generator decrements for each data byte of the \nmulti byte transfer cycle.  \nWhen R egister 0x0000, Bit 6  = 1 (LSB -first), the in struction and \ndata bytes must be written from LSB to MSB. Multibyte  data \ntransfers in LSB -first format start with an in struction byte that includes the register address of the least si gnificant payload  byte \nfollowed by multiple data bytes. The serial contr ol port inte rnal \nbyte address generator increments for each byte of the multibyte transfer cycle.  \nFor mu ltibyte MSB -first (default) input/output  operations, the \nserial control port register address decrements from the \nspecified starting address toward A ddress 0x0000.  For multi byte \nLSB-first input/output  operations, the serial control port register \naddress increments  from the starting address toward \nAddress  0x1FFF.  Unused addresses ar e not skipped during \nmultibyte input/output  operations ; therefore, t he user  should \nwrite the default value to a reserved register and 0 s to unmapped \nregisters. Note that it is more efficient to issue a new write \ncommand than to write the default value to more than two \nconsecutive reserved (or unmapped) registers.  \nTable 31. Streaming Mode (No Addresses Are Skipped)  \nWrite Mode  Address Direction  Stop Sequence  \nLSB F irst Increment  0x0000 ... 0x1FFF \nMSB F irst Decrement  0x1FFF ... 0x0000 \n \n  \nTable 32. Serial Control Port, 16 -Bit Instruct ion Word, MSB -First  \nMSB                LSB  \nI15 I14 I13 I12 I11 I10 I9 I8 I7 I6 I5 I4 I3 I2 I1 I0 \nR/W W1 W0 A12 A11 A10 A9  A8  A7  A6 A5 A4 A3 A2 A1 A0 \n \nCS\nSCLK DON'T CARE\nSDIO A12W0 W1 R/W A11 A10 A9 A8 A7 A6 A5 A4 A3 A2 A1 A0 D7D6 D5 D4 D3 D2 D1 D0 D7 D6 D5 D4 D3 D2 D1 D0 DON'T CARE DON'T CAREDON'T CARE\n16-BIT INSTRUCTION HEADER REGISTER (N) DATA REGISTER (N – 1) DATA\n08022-029 \nFigure 55. Serial Control Port Write —MSB- First, 16- Bit Instruction, Two Bytes of Data  \n \nCS\nSCLK\nSDIO\nSDO\nREGISTER (N) DATA 16-BIT INSTRUCTION HEADER REGISTER (N – 1) DATA REGISTER (N – 2) DATA REGISTER (N – 3) DATAA12W0W1 R/W A11A10 A9A8A7A6A5A4A3A2A1A0DON'T CARE DON'T CARE\nDON'T CARE\nDON'T\nCARED7 D6 D5D4D3D2D1D0D7D6D5D4D3D2D1D0D7 D6D5D4D3D2D1D0D7D6D5D4D3D2D1D0\n08022-030 \nFigure 56. Serial Control Port Read —MSB- First, 16- Bit Instruction, Four Byte s of Data  \nRev. G | Page 53 of 111 \nAD9548 Data Sheet\n \nRev. G | Page 54 of 111 tS\nDON'T CARE\nDON'T CARE W 1 W 0 A 1 2 A 1 1 A 1 0 A 9A 8A 7A 6A 5D 4D 3D 2D 1 D 0 HIGH-IMEPDANCE R/WtDS\ntDHtHIGH\ntLOWtCLKtC\nCS\nSCLK\nSDIO\n08022-153 \nFigure 57. Serial Control Port Read—MSB-Fir st, 16-Bit Instruction, One Byte of Data \n \n \ntS\nDON'T CARE\nDON'T CARE W 1 W 0 A 1 2 A 1 1 A 1 0 A 9A 8A 7A 6A 5D 4D 3D 2D 1D 0DON'T CAREDON'T CARE\nR/WtDS\ntDHtHI\ntLOtCLKtC\nCS\nSCLK\nSDIO\n08022-031 \nFigure 58. Serial Control Port Write—MSB-Firs t, 16-Bit Instruction, Timing Measurements \n \nDATA BIT N – 1 DATA BIT NCS\nSCLK\nSDIO\nSDOtDV\n08022-032 \nFigure 59. Timing Diagram for Serial Control Port Register Read \n \nCS\nSCLK DON'T CARE DON'T CARE\n16-BIT INSTRUCTION HEADER REGISTER (N) DATA REGISTER (N + 1) DATASDIO DON'T CARE DON'T CARE A0 A1 A2 A3 A4 A5 A6 A7 A8 A9A10 A11 A12 D1 D0 R/W W1 W0 D2 D3 D4 D5 D6 D7 D0 D1 D2 D3 D4 D5 D6 D7\n08022-033 \nFigure 60. Serial Control Port Write—LSB-First, 16-Bit Instruction, Two Bytes of Data \n \nCS\nSCLK\nSDIOtHI tLOtCLKtS\ntDS\ntDHtC\nBIT N BIT N + 1\n08022-034 \nFigure 61. Serial Control Port Timing—Write \n \nData Sheet AD9548 \n \nTable 33. Serial Control Port Timing  \nParameter  Description  \ntDS Setup time between data  and the rising edge of SCLK . \ntDH Hold time between data and the rising edge of SCLK . \ntCLK Period of the clock . \ntS Setup time between  the CS falling edge and the SCLK rising edge (start of the communication cycle) . \ntC Setup time between the SCLK rising edge and the CS rising edge (end of the communication cycle) . To ensure that SDIO/SDO \ndo not tristate before the last data bit (D 0) is read, it is recommended that a  ½ SCLK cycle be used for tC. \ntHI Minimum period that  SCLK should be in a l ogic high state . \ntLO Minimum p eriod that SCLK should be in a l ogic low state . \ntDV SCLK to valid SDIO and SDO (see Figure 59). \n \n \nRev. G | Page 55 of 111 \nAD9548 Data Sheet\n \nRev. G | Page 56 of 111 I²C SERIAL PORT OPERATION \nThe I2C interface has the advantage of requiring only two \ncontrol pins and is a de facto standard throughout the I2C \nindustry. However, its disadvantage is programming speed, which \nis 400 kbps maximum. The AD9548 I2C port design is based on \nthe I2C fast mode standard from Philips, so it supports both the 100 kHz standard mode and 400 kHz fast mode. Fast mode imposes a glitch tolerance requirement on the control signals. That is, the input receivers ignore pulses of less than 50 ns \nduration. \nThe AD9548 I2C port consists of a serial data line (SDA) and a \nserial clock line (SCL). In an I2C bus system, the AD9548 is \nconnected to the serial bus (data bus SDA and clock bus SCL) as \na slave device; that is, no clock is generated by the AD9548. \nThe AD9548 uses direct 16-bit memory addressing instead of \ntraditional 8-bit memory addressing. \nThe AD9548 allows up to seven unique slave devices to occupy \nthe I\n2C bus. These are accessed via a 7-bit slave address \ntransmitted as part of an I2C packet. Only the device with a \nmatching slave address responds to subsequent I2C commands. \nThe device slave address is 1001xxx (the three right bits are \ndetermined by the M0 to M2 pins). The four MSBs (1001) are hardwired, while the three LSBs (xxx, determined by the M0 to M2 pins) are programmable via the power-up state of the multifunction pins (see the Initial M0 to M7 Pin Programming section). I2C Bus Characteristics \nA summary of the various I2C protocols appears in Table 34. \nTable 34. I2C Bus Abbreviation Definitions \nAbbreviation Definition \nS Start \nSr Repeated start \nP Stop \nA Acknowledge \nA  Nonacknowledge \nW Write \nR Read \nThe transfer of data is shown in Figure 62. One clock pulse is generated for each data bit transferred. The data on the SDA \nline must be stable during the high period of the clock. The \nhigh or low state of the data line can only change when the \nclock signal on the SCL line is low. \nDATA LINE\nSTABLE;\nDATA VALIDCHANGE\nOF DATA\nALLOWED\n08022-035SDA\nSCL\n \nFigure 62. Valid Bit Transfer \nStart/stop functionality is shown in Figure 63. The start condition \nis characterized by a high-to-low transition on the SDA line while SCL is high. The start condition is always generated by the master to initialize a data transfer. The stop condition is \ncharacterized by a low-to-high transition on the SDA line while \nSCL is high. The stop condition is always generated by the master to terminate a data transfer. Every byte on the SDA line must be eight bits long. Each byte must be followed by an \nacknowledge bit; bytes are sent MSB first. \n \nSDA\nSTART CONDITION STOP CONDITIONSCL\nSP\n08022-036 \nFigure 63. Start and Stop Conditions \n \n12 89 12 3 TO 7 3 TO 7 89 10SDA\nSCL\nSMSB\nACK FROM\nSLAVE-RECEIVERACK FROM\nSLAVE-RECEIVER\nP\n08022-037 \nFigure 64. Acknowledge Bit \n \nData Sheet AD9548\n \nRev. G | Page 57 of 111 The acknowledge bit (A) is the ninth bit attached to any 8-bit \ndata byte. An acknowledge bit is always generated by the \nreceiving device (receiver) to inform the transmitter that the byte has been received. It is done by pulling the SDA line low during the ninth clock pulse after each 8-bit data byte. \nThe nonacknowledge bit ( A\n) is the ninth bit attached to any \n8-bit data byte. A nonacknowledge bit is always generated by \nthe receiving device (receiver) to inform the transmitter that the \nbyte has not been received. It is done by leaving the SDA line \nhigh during the ninth clock pulse after each 8-bit data byte. \nData Transfer Process \nThe master initiates data transfer by asserting a start condition. \nThis indicates that a data stream follows. All I2C slave devices connected to the serial bus respond to the start condition. \nThe master then sends an 8-bit address byte over the SDA line, \nconsisting of a 7-bit slave address (MSB first) plus an R/ W\n bit. \nThis bit determines the direction of the data transfer, that is, \nwhether data is written to or read from the slave device \n(0 = write, 1 = read). \nThe peripheral whose address corresponds to the transmitted \naddress responds by sending an acknowledge bit. All other devices on the bus remain idle while the selected device waits \nfor data to be read from or written to it. If the R/ W\n bit is 0, the \nmaster (transmitter) writes to the slave device (receiver). If the R/W\n bit is 1, the master (receiver) reads from the slave device \n(transmitter). \nThe format for these commands is described in the Data \nTransfer Format section. Data is then sent over the serial bus in the format of nine clock \npulses, one data byte (eight bits) from either master (write mode) or slave (read mode) followed by an acknowledge bit from the receiving device. The number of bytes that can be \ntransmitted per transfer is unrestricted. In write mode, the first \ntwo data bytes immediately after the slave address byte are the internal memory (control registers) address bytes, with the high address byte first. This addressing scheme gives a memory address of up to 2\n16 − 1 = 65,535. The data bytes after these two \nmemory address bytes are register data written to or read from the control registers. In read mode, the data bytes after the slave address byte are register data written to or read from the control \nregisters. \nWhen all data bytes are read or written, stop conditions are \nestablished. In write mode, the master (transmitter) asserts a stop condition to end data transfer during the 10\nth clock pulse \nfollowing the acknowledge bit for the last data byte from the \nslave device (receiver). In read mode, the master device \n(receiver) receives the last data byte from the slave device (transmitter) but does not pull SDA low during the ninth clock pulse. This is known as a nonacknowledge bit. By receiving the nonacknowledge bit, the slave device knows the data transfer is \nfinished and enters idle mode. The master then takes the data \nline low during the low period before the 10\nth clock pulse, and \nhigh during the 10th clock pulse to assert a stop condition. \nA start condition can be used in place of a stop condition. Furthermore, a start or stop condition can occur at any time, \nand partially transferred bytes are discarded. \n12 89 12 3 TO 7 3 TO 7 89 1 0ACK FROM\nSLAVE-RECEIVERACK FROM\nSLAVE-RECEIVERSDA\nSCL\nSMSB\nP\n08022-038 \nFigure 65. Data Transfer Process (Master Write Mode, 2-Byte Transfer) \n 12 89 12 3 TO 7 3 TO 7 89 1 0ACK FROM\nMASTER-RECEIVERNON-ACK FROM\nMASTER-RECEIVERSDA\nSCL\nS P\n08022-039 \nFigure 66. Data Transfer Process (M aster Read Mode, 2-Byte Transfer) \nAD9548 Data Sheet\n \nRev. G | Page 58 of 111 Data Transfer Format \nWrite byte format—the write byte protocol is used to write a register address to the RAM starting from the specified RAM addres s. \nS Slave \naddress W A RAM address high \nbyte A RAM address low \nbyte A RAM \nData 0 A RAM \nData 1 A RAM \nData 2 A P \n \nSend byte format—the send byte protocol is used to set up the register address for subsequent reads. \nS Slave address W A RAM address high byte A RAM address low byte A P \n \nReceive byte format—the receive byte protocol is used to read the data byte(s) from RAM starting from the current address. \nS Slave address R A RAM Data 0 A RAM Data 1 A RAM Data 2 A  P \n \nRead byte format—the combined format of the send byte and the receive byte. \nS Slave \nAddress W A RAM \nAddress \nHigh Byte A RAM \nAddress \nLow Byte A Sr Slave \nAddress R A RAM \nData 0 A RAM \nData 1 A RAM \nData 2 A  P \nI²C Serial Port Timing \nSS r S PSDA\nSCLtSPtHD; STA\ntSU; STAtSU; DAT\ntHD; DATtHD; STA\ntHItLO\ntSU; STOtBUF tR\ntFtR tF\n08022-040 \nFigure 67. I²C Serial Port Timing \nTable 35. I2C Timing Definitions  \nParameter Description \nfSCL Serial clock \ntBUF Bus free time between stop and start conditions \ntHD; STA  Repeated hold time start condition \ntSU; STA  Repeated start condition setup time \ntSU; STO  Stop condition setup time \ntHD; DAT  Data hold time \ntSU; DAT  Date setup time \ntLO SCL clock low period \ntHI SCL clock high period \ntR Minimum/maximum receive SCL and SDA rise time \ntF Minimum/maximum receive SCL and SDA fall time \ntSP Pulse width of voltage spikes that must be suppressed by the input filter \n \n   \nData Sheet AD9548\n \nRev. G | Page 59 of 111 INPUT/OUTPUT PROGRAMMING REGISTERS \nThe register map spans an address range from 0x0000 through \n0x0E3F (0 to 3647, decimal). Each address provides access to one byte (eight bits) of data. Each individual register is identified by its four-digit hexadecimal address (for example, Register 0x0A10). In \nsome cases, a group of addresses collectively defines a register \n(for example, the IRQ mask register consists of Register 0x0209, Register 0x020A, Register 0x020B, Register 0x020C, Register 0x020D, Register 0x020E, Register 0x020F, and \nRegister 0x0210). \nIn general, when a group of registers defines a control parameter, \nthe LSB of the value resides in the D0 position of the register with \nthe lowest address. The bit weight increases right to left, from the \nlowest register address to the highest register address. For example, the default value of the incremental phase lock offset step size register (Address 0x0314 to Address 0x0315) is the 16-bit \nhexadecimal number, 0x03E8 (not 0xE803). \nNote that the EEPROM storage sequence registers (Address 0x0E10 \nto Address 0x0E3F) are an exception to the above convention (see the EEPROM Instructions section). \nBUFFERED/ACTIVE REGISTERS \nThere are two broad categories of registers in the AD9548 —\nbuffered and active (see Figure 68). Buffered registers need an input/output update to apply their contents to the internal device functions. In contrast, active registers do not require an input/output update to transfer data between the buffer registers and the internal device functions. In operation, the user programs as many buffer registers as desired and then issues an input/output \nupdate. The input/output update occurs by writing to Register \n0x0005, Bit 0 = 1 (or by the external application of the necessary logic level to one of the multifunction pins previously programmed as an input/output update input). The contents of buffer registers connected directly to the internal device functions affect those \nfunctions immediately. The contents of buffer registers that connect \nto active registers do not affect the internal device functions until \nthe input/output update event occurs. \nAn L in the Opt column of the register map indicates an active \n(or live) register. An S or a C in the Opt column of the register map identifies a buffered register. An S entry means that the input/output update signal to the active register is synchronized \nwith the serial port clock or with an input signal driving one of \nthe multifunction pins. On the other hand, a C entry means that the input/output update signal to the active register is synchronized with a clock signal derived from the internal \nsystem clock (f\nS/32), as shown in Figure 68. \nWhen reading back a register that has both buffered and active \ncontents, the user can use Register 0x0004, Bit 0 to select \nwhether to read back the buffer or active contents. Readback of \nthe active contents occurs when Register 0x0004, Bit 0 = 0, and readback of the buffer contents occurs when Register 0x0004, Bit 0= 1. Note that a read-only active register requires an \ninput/output update before reading its contents. \nACTIVE C\nREGISTERSACTIVE S\nREGISTERSI/O UPDATE\nTO INTERNAL DEVICE FUNCTIONSBUFFER REGISTERSFROM\nMULTIFUNCTION\nPIN LOGIC\nSERIAL\nCONTROL\nPORTfS/32EDGE\nDETECT\nCS/SDA\nSCLK/SCLSDIO\nSDO5\n3\n4\n2\n08022-041 \nFigure 68. Buffered and Active Registers \nAUTOCLEAR REGISTERS \nAn A in the Opt column of the register map identifies an autoclear \nregister. Typically, the active value for an autoclear register takes \neffect following an input/output update. The bit is cleared by the \ninternal device logic upon completion of the prescribed action. \nREGISTER ACCESS RESTRICTIONS \nRead and write access to the register map may be restricted based \non the register in question, the source and direction of access, and \nthe current state of the device. Each register can be classified as one \nor more access types. When more than one type applies, the most \nrestrictive condition that applies at the moment is used. \nWhenever access is denied to a register, all attempts to read the \nregister return a 0 byte, and all attempts to write to the register are ignored. Access to nonexistent registers is handled in the same way \nas for a denied register. \nRegular Access \nRegisters with regular access do not fall into any other category. \nBoth read and write access to registers of this type can be from \neither the serial ports or EEPROM controller. Only one of these sources can have access to a register at any given time (access is mutually exclusive). When the EEPROM controller is active, either \nin load or store mode, it has exclusive access to these registers. \nRead-Only Access  \nAn R in the Opt column of the register map identifies read-only \nregisters. Access is available at all times, including when the \nEEPROM controller is active. \nExclusion from EEPROM Access \nAn E in the Opt column of the register map identifies a register \nwith contents that are inaccessible to the EEPROM. The contents of \nthis type of register cannot be transferred directly to the EEPROM or vice versa. Note that read-only registers (R) are inaccessible to the EEPROM, as well. \n \nAD9548 Data Sheet \n \nREGISTER MAP  \nThe register addresses and defaults are hexadecimal values. Use the default value when writing to registers and/or bits marke d as unused.  \nRegister addresses  that are not listed in Table 36  are not used, and writing to those registers has no effect. The user should write the \ndefault value to sections of registers marked reserved. In the Opt  (Option) column, A = autoclear; E = inaccessible to the EEPROM; \nL = live register (input/ou tput update not required); R = read only; S = buffered reg ister (update synchronous with serial port  clock); and \nC = buffered register (update synchronous with SYSCLK/32). S ee the I nput /Output  Programming Registers  section for det ails. \nTable 36. \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \nSerial Port Control and Part Identification \n0x0000 L, E SPI c ontrol  Uni-\ndirectional  LSB f irst/  \nInc Addr  Soft r eset  Long  \ninstruction  Unused  0x10 \n0x0000 Dup I2C control  Unused Soft r eset  Unused  0x00 \n0x0001 L E Reserved  Unused    \n0x0002 R, L Reserved  Silicon revision number  0xC6 \n0x0003 R, L Device ID  0x48 \n0x0004 L,E  Read back  Unused  Read b uffer  \nregister  0x00 \n0x0005 L, A, \nE I/O update  Unused  I/O update  0x00 \nSystem Clock (SYSCLK)  \n0x0100  S  External \nloop  filter \nenable  Charge pump \nmode \n(auto/  \nman) Charge pump current [ 2:0] Lock detect timer \ndisable  Lock detect divider [ 1:0] 0x18 \n0x0101 S  N-divider [ 7:0] 0x28 \n0x0102 S  Unused  M-divider \nreset  M-divider [ 1:0] 2×frequency  \nmultiplier \nenable  PLL e nable  SYSCLK  reference select \n[1:0] 0x45 \n0x0103 C Nom SYSCLK  \nperiod  Nominal s ystem clock period (femtoseconds) [15:0]  \n[1 ns @ 1 ppm accuracy]  0x40 \n0x0104 C 0x42 \n0x0105 C Unused  Nominal s ystem clock period [ 20:16]  0x0F \n0x0106 C System clock \nstability  System c lock stability period (milliseconds) [15:0]  0x01 \n0x0107 C 0x00 \n0x0108 C Unused  System c lock stability period (milliseconds) [19:16]  0x00 \nGeneral Configuration  \n0x0200 S M0 M0 i n/out M0 function [ 6:0] 0x00 \n0x0201 S M1 M1 in/out M1 function [ 6:0] 0x00 \n0x0202 S M2 M2 in/o ut M2 function [ 6:0] 0x00 \n0x0203 S M3 M3 i n/out M3 function [6:0]  0x00 \n0x0204 S M4 M4 i n/out M4 function [6:0]  0x00 \n0x0205 S M5 M5 i n/out M5 function [6:0]  0x00 \n0x0206 S M6 M6 i n/out M6 function [6:0]  0x00 \n0x0207 S M7 M7 i n/out M7 function [6:0]  0x00 \n0x0208 C IRQ pin \noutput  mode  Unused  IRQ p in output mode [ 1:0] 0x00 \n0x0209 C IRQ mask Unused  SYSCLK  \nunlocked  SYSCLK  \nlocked  Unused  Unused  SYSCLK  Cal \ncomplete  SYSCLK  Cal \nstarted  0x00 \n0x020A  C Unused  Distr ibution  \nsync Watchdog  \ntimer  EEPROM  \nfault  EEPROM  \ncomplete  0x00 \n0x020B  C Switching  Closed  Free -run Holdover  Freq  \nunlocked  Freq  \nlocked  Phase  \nunlocked  Phase  \nlocked  0x00 \n0x020C  C Unused  History  \nupdated  Frequency  \nunclamped  Freque ncy \nclamped  Phase slew  \nunlimited  Phase slew  \nlimited  0x00 \n0x020D  C Ref AA  \nnew p rofile  Ref AA  \nvalidated  Ref AA  fault \ncleared  Ref AA  fault  Ref A  \nnew p rofile  Ref A  \nvalidated  Ref A  \nfault \ncleared  Ref A  \nfault  0x00 \n0x020E  C Ref BB \nnew profile  Ref BB \nvalidated  Ref BB fault cleared  Ref BB fault  Ref B  \nnew p rofile  Ref B  \nvalidated  Ref B  \nfault cleared  Ref B  \nfault  0x00 \n0x020F  C Ref CC  \nnew profile  Ref CC  \nvalidated  Ref CC  \nfault cleared  Ref CC  \nfault  Ref C  \nnew p rofile  Ref C  \nvalidated  Ref C  \nfault cleared  Ref C  \nfault  0x00 \nRev. G | Page 60 of 111 \nData Sheet AD9548 \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0210 C Ref DD  \nnew profil e Ref DD  \nvalidated  Ref DD  \nfault \ncleared  Ref DD  \nfault  Ref D  \nnew pr ofile  Ref D  \nvalidated  Ref D  \nfault \ncleared  Ref D  \nfault  0x00 \n0x0211 C Watchdog  \ntimer  Watchdog timer (ms) [ 15:0]  [up to 65.5 sec ] 0x00 \n0x0212 C 0x00 \n0x0213 S DAC c urrent  DAC full-scale curr ent [7:0] 0xFF \n0x0214 S DAC \nshutdown Unused  DAC full-scale current [ 9:8] 0x01 \nDPLL  \n0x0300 C Free running frequency tuning w ord Free running frequency  tuning word [47:0]  0x00 \n0x0301 C 0x00 \n0x0302 C 0x00 \n0x0303 C 0x00 \n0x0304 C 0x00 \n0x0305 C 0x00 \n0x0306 A, C Update TW  Unused  Update TW  0x00 \n0x0307 C Pull-in \nrange limits  Pull-in range lower limit [23:0]  0x00 \n0x0308 C 0x00 \n0x0309 C 0x00 \n0x030A  C Pull-in range upper limit [23:0]  0xFF \n0x030B  C 0xFF \n0x030C  C 0xFF \n0x030D  C Open loo p \nphase  offset  DDS p hase offset word [15:0]  0x00 \n0x030E  C 0x00 \n0x030F  C Closed loop  \nphase offset  Fixed p hase lock offset [39:0]  (picoseconds; signed)  0x00 \n0x0310 C 0x00 \n0x0311 C 0x00 \n0x0312 C 0x00 \n0x0313 C 0x00 \n0x0314 C Incremental p hase lock offset step size [ 15:0]  \n(picoseconds)  0xE8 \n0x0315 C 0x03 \n0x0316 C Phase slew  \nlimit  Phase slew rate limit [15:0]  (ns/sec ) 0x00 \n0x0317 C 0x00 \n0x0318 C History  \naccumulation timer  History a ccumulation timer [ 23:0]  (milliseconds) 0x30 \n0x0319 C 0x75 \n0x031A  C 0x00 \n0x031B  C History  \nmode  Unused  Single sample fallback  Persistent history  Incremental average [ 2:0] 0x00 \nClock Distribution Output  \n0x0400 S Distribution settings  Unused  External distribution \nresistor  Receiver \nmode  OUT3 power -\ndown  OUT2 \npower -\ndown  OUT1 \npower -\ndown  OUT0 power -\ndown  0x00 \n0x0401 S Dist ribution \nenable  Unused  OUT3 enable  OUT2 enable  OUT1 enable  OUT0 enable  0x00 \n0x0402 S Distribution synchroniza -\ntion  Unused  Sync source [ 1:0] OUT3 sync mask OUT2 sync m ask OUT1 sync m ask OUT0 sync mask 0x00 \n0x0403 C Automatic synchroniza -\ntion  Unused  Automatic s ync mode [ 1:0] 0x00 \n0x0404 S Distribution  \nchannel  \nmodes  Unused  OUT0 \nCMOS \nphase \ninvert  OUT0 polarity \ninvert  OUT0 \ndrive \nstrength OUT0 m ode  0x03 \n0x0405 S Unused  OUT1 \nCMOS \nphase \ninvert  OUT1 polarity \ninvert  OUT1 \ndrive \nstrength OUT1 m ode  0x03 \n0x0406 S Unused  OUT2 \nCMOS \nphase invert  OUT2 polarity invert  OUT2 drive strength OUT2 m ode  0x03 \nRev. G | Page 61 of 111 \nAD9548 Data Sheet \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0407 S Unused  OUT3 \nCMOS \nphase \ninvert  OUT3 \npolarity \ninvert  OUT3 \ndrive \nstrength OUT3 m ode  0x03 \n0x0408 S Distribution \nchannel \ndividers  Q0 [ 23:0]  0x00 \n0x0409 S 0x00 \n0x040A  S 0x00 \n0x040B  S Unused  Q0 [ 29:24]  0x00 \n0x040C  S Q1 [ 23:0]  0x00 \n0x040D  S 0x00 \n0x040E  S 0x00 \n0x040F  S Unused  Q1 [ 29:24]  0x00 \n0x0410 S Q2 [23:0]  0x00 \n0x0411 S 0x00 \n0x0412 S 0x00 \n0x0413 S Unused  Q2 [ 29:24]  0x00 \n0x0414 S Q3 [ 23:0]  0x00 \n0x0415 S 0x00 \n0x0416 S 0x00 \n0x0417 S Unused  Q3 [ 29:24]  0x00 \nReference I nputs  \n0x0500 S Reference  \npower -down  Ref DD \npower -\ndown  Ref D \npower -\ndown  Ref CC \npower -\ndown  Ref C power -\ndown  Ref BB power -\ndown  Ref B power -\ndown  Ref AA power -\ndown  Ref A power -\ndown  0x00 \n0x0501 S Reference  \nlogic family  Ref BB l ogic family [ 1:0] Ref B l ogic family [1:0] Ref AA l ogic family [1:0] Ref A logic family  [1:0] 0x00 \n0x0502 S Ref DD logic family [1:0]  Ref D logic family [1:0] Ref CC Logic Family [ 1:0] Ref C Logic Family [ 1:0] 0x00 \n0x0503 C Manual reference  \nprofile \nselection  Enable Ref \nAA manual \nprofile  Ref AA m anual profile [2:0] Enable Ref \nA manual profile  Ref A manual p rofile [2:0]  0x00 \n0x0504 C Enabl e Ref \nBB Manual \nProfile  Ref BB m anual profile [2:0] Enable Ref B \nmanual profile  Ref B m anual profile [ 2:0] 0x00 \n0x0505 C Enable Ref \nCC Manual \nProfile  Ref CC m anual profile [2:0] Enable Ref \nC m anual \nprofile  Ref C m anual profile [ 2:0] 0x00 \n0x0506 C Enabl e Ref \nDD Manual Profile  Ref DD manual profile [2:0] Enable Ref \nD manual \nprofile  Ref D manual profile [2:0] 0x00 \n0x0507 C Phase build-\nout switching  Unused  Phase m aster threshold priority [2:0] 0x00 \nProfile Registers —Profile 0  \n0x0600 L Priorities  Phase lock \nscale  Unused  Promoted priority [2:0]  Selection priority [2:0]  0x00 \n0x0601 L Reference period  Nominal period (femtoseconds)  [47:0]  (up to 1.125 sec ) 0x00 \n0x0602 L 0x00 \n0x0603 L 0x00 \n0x0604 L 0x00 \n0x0605 L 0x00 \n0x0606 L 0x00 \n0x0607 L Unused Nominal period [ 49:48]  0x00 \n0x0608 L Tolerance  Inner tolerance (1/tolerance) [ 15:0]  (removes fault status; 1 0% down to 1 ppm ) 0x00 \n0x0609 L 0x00 \n0x060A  L Unused  Inner tolerance [19:16]  0x00 \n0x060B  L Outer tolerance (1/tolerance) [ 15:0 ] (indicat es fault status; 1 0% down to 1 ppm)  0x00 \n0x60C  L 0x00 \n0x060D  L Unused  Outer tolerance [ 19:16]  0x00 \n0x060E  L Validation  Validation t imer (milliseconds) [ 15:0 ] (up to 65.5 sec)  0x00 \n0x060F  L 0x00 \n0x0610 L Redetect  \ntimeout  Redetect t imer (millisecon ds) [15:0]  [up to 65.5 seconds]  0x00 \n0x0611  L 0x00 \nRev. G | Page 62 of 111 \nData Sheet AD9548 \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0612 L Digital loop \nfilter \ncoefficients  Alpha -0 linear [ 15:0 ] 0x00 \n0x0613 L 0x00 \n0x0614 L Alpha -2 exponent [1:0] Alpha -1 exponent [5:0] 0x00 \n0x0615 L Beta -0 linear [6:0]  Alpha -2 \nexponent \n[2] 0x00 \n0x0616 L Beta -0 linear [14:7]  0x00 \n0x0617 L Unused  Beta -1 exponent [ 4:0] Beta -0 linear [ 16:15 ] 0x00 \n0x0618 L Gamma- 0 linear [15:0]  0x00 \n0x0619 L 0x00 \n0x061A  L Unused  Gamma- 1 exponent [ 4:0] Gamma- 0 \nlinear [16]  0x00 \n0x061B  L Delta -0 linear [ 7:0] 0x00 \n0x061C  L Delta -1 \nexponent \n[0] Delta -0 linear [ 14:8]  0x00 \n0x061D  L Alpha -3 exponent [3:0] Delta -1 exponent [4:1]  0x00 \n0x061E  L Frequency \nmultiplication  R [23:0 ] 0x00 \n0x061F  L 0x00 \n0x0620 L 0x00 \n0x0621 L Unused  R [29:24]  0x00 \n0x0622 L S [23:0 ] 0x00 \n0x0623 L 0x00 \n0x0624 L 0x00 \n0x0625 L Unused  S [29:24 ] 0x00 \n0x0626 L V [7:0] 0x00 \n0x0627 L U [3:0]  Unused  V [9:8] 0x00 \n0x0628 L Unused  U [9:4] 0x00 \n0x0629 L Lock detectors  Phase lock threshold  (picoseconds)  [15:0 ] 0x00 \n0x062A  L 0x00 \n0x062B  L Phase lock f ill rate [7:0] 0x00 \n0x062C  L Phase lock drain  rate [ 7:0] 0x00 \n0x062D  L Frequency l ock threshold  (picoseconds)  [23:0]  0x00 \n0x062E  L 0x00 \n0x062F  L 0x00 \n0x0630 L Frequency l ock fill rate [7:0] 0x00 \n0x0631 L Frequency l ock drain rate [7:0] 0x00 \nProfile Registers —Profile 1  \n0x0632 L Priorities  Phase lock \nscale  Unused  Promoted priority [2:0]  Selection priority [2:0]  0x00 \n0x0633 L Reference period  Nominal period ( femtoseconds ) [47:0]  (up to 1.125 sec ) 0x00 \n0x0634 L 0x00 \n0x0635 L 0x00 \n0x0636  L 0x00 \n0x0637  L 0x00 \n0x0638 L 0x00 \n0x0639 L Unused  Nominal period [ 49:48]  0x00 \n0x063A  L Tolerance  Inner t olerance (1/tolerance) [ 15:0 ] (removes fault status; 1 0% down to 1  ppm)  0x00 \n0x063B  L 0x00 \n0x063C  L Unused  Inner tolerance [19:16]  0x00 \n0x06CD  L Outer tolerance (1/tolerance) [ 15:0 ] (indicates fault status; 1 0% down to 1 ppm)  0x00 \n0x063E  L 0x00 \n0x063F  L Unused  Outer tolerance [ 19:16]  0x00 \n0x0640 L Validation  Validation timer (milliseconds) [ 15:0]  (up to 65.5 sec ) 0x00 \n0x0641 L 0x00 \n0x0642 L Redetect timeout  Redetect timer (milliseconds) [ 15:0]  (up to 65.5 sec ) 0x00 \n0x0643 L 0x00 \nRev. G | Page 63 of 111 \nAD9548 Data Sheet \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0644 L Digital loop \nfilter \ncoefficients  Alpha -0 linear [ 15:0 ] 0x00 \n0x0645 L 0x00 \n0x0646 L Alpha -2 exponent [1:0] Alpha -1 exponent [5:0] 0x00 \n0x0647 L Beta -0 linear [ 6:0] Alpha -2 \nexponent [2] 0x00 \n0x0648 L Beta -0 linear [ 14:7]  0x00 \n0x0649 L Unused  Beta -1 exponent [4:0] Beta -0 linear [16:15 ] 0x00 \n0x064A  L Gamma- 0 linear [15:0]  0x00 \n0x064B  L 0x00 \n0x064C  L Unused  Gamma- 1 exponent [ 4:0] Gamma- 0 \nlinear [16]  0x00 \n0x064D  L Delta -0 linear [ 7:0] 0x00 \n0x064E  L Delta -1 \nexponent [0 ] Delta -0 linear [ 14:8]  0x00 \n0x064F  L Alpha -3 exponent [3:0] Delta -1 exponent [4:1]  0x00 \n0x0650 L Frequency \nmultiplication  R [23:0]  0x00 \n0x0651 L 0x00 \n0x0652 L 0x00 \n0x0653 L Unused  R [29:24]  0x00 \n0x0654 L S [23:0 ] 0x00 \n0x0655 L 0x00 \n0x0656 L 0x00 \n0x0657 L Unused  S [29:24 ] 0x00 \n0x0658 L V [7:0] 0x00 \n0x0659 L U [3:0] Unused  V [9:8] 0x00 \n0x065A  L Unused  U [9:4] 0x00 \n0x065B  L Lock \ndetectors  Phase lock threshold  (picoseconds)  [15:0 ] 0x00 \n0x065C  L 0x00 \n0x065D  L Phase lock fill rate [7:0] 0x00 \n0x065E  L Phase l ock drain  rate [7:0] 0x00 \n0x065F  L Frequency l ock threshold  (picoseconds)  [23:0 ] 0x00 \n0x0660  L 0x00 \n0x0661 L 0x00 \n0x0662 L Frequency lock fill rate [7:0] 0x00 \n0x0663 L Frequency l ock drain  rate [7:0] 0x00 \n0x0664 \nto 0x067F    Unused   \nProfile R egisters —Profile 2  \n0x0680 L Priorities  Phase lock scale  Unused  Promoted priority [2:0]  Selection p riority [2:0]  0x00 \n0x0681 L Reference period  Nominal p eriod ( femtoseconds ) [47:0]  (up to 1.125 sec ) 0x00 \n0x0682 L 0x00 \n0x0683 L 0x00 \n0x0684 L 0x00 \n0x0685 L 0x00 \n0x0686 L 0x00 \n0x0687 L Unused  Nominal period [ 49:48]  0x00 \n0x0688 L Tolerance  Inner tolerance (1/tolerance) [ 15:0]  (removes fault status; 1 0% down to 1 ppm)  0x00 \n0x0689 L 0x00 \n0x068A  L Unused  Inne r tolerance [ 19:16]  0x00 \n0x068B  L Outer t olerance (1/tolerance) [ 15:0 ] (indicates fault status; 1 0% down to 1 ppm)  0x00 \n0x068C  L 0x00 \n0x068D  L Unused  Outer tolerance [ 19:16]  0x00 \n0x068E  L Validation  Validation timer (milliseconds) [15:0]  (up to 65.5 sec ) 0x00 \n0x068F  L 0x00 \n0x0690 L Redetect timeout  Redetect timer (milliseconds) [15:0] (up to 65.5 seconds ) 0x00 \n0x0691  L 0x00 \nRev. G | Page 64 of 111 \nData Sheet AD9548 \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0692 L Digital loop \nfilter \ncoefficients  Alpha -0 linear [15:0]  0x00 \n0x0693 L 0x00 \n0x0694 L Alpha -2 exponent [1:0]  Alpha -1 exponent [5:0]  0x00 \n0x0695 L Beta -0 linear [ 6:0] Alpha -2 \nexponent [2] 0x00 \n0x0696 L Beta -0 linear [14:7]  0x00 \n0x0697 L Unused  Beta -1 exponent [ 4:0] Beta -0 linear [16:15]  0x00 \n0x0698 L Gamma- 0 linear [ 15:0]  0x00 \n0x0699 L 0x00 \n0x069A  L Unused  Gamma- 1 exponent [ 4:0] Gamma- 0 \nlinear [ 16] 0x00 \n0x069B  L Delta -0 linear [ 7:0] 0x00 \n0x069C  L Delta -1 \nexponent \n[0] Delta -0 linear [ 14:8]  0x00 \n0x069D  L Alpha -3 exponent [ 3:0] Delta -1 exponent [4:1]  0x00 \n0x069E  L Frequency \nmultiplication  R [23:0]  0x00 \n0x069F  L 0x00 \n0x06A0  L 0x00 \n0x06A1  L Unused  R [29:24]  0x00 \n0x06A2  L S [23:0 ] 0x00 \n0x06A3  L 0x00 \n0x06A4  L 0x00 \n0x06A5  L Unused  S [29:24 ] 0x00 \n0x06A6  L V [7:0] 0x00 \n0x06A7  L U [3:0] Unused  V [9:8] 0x00 \n0x06A8  L Unused  U [9:4] 0x00 \n0x06A9  L Lock \ndetectors  Phase lock threshold  (picoseconds)  [15:0 ] 0x00 \n0x06AA  L 0x00 \n0x06AB  L Phase lock f ill rate [ 7:0] 0x00 \n0x06AC  L Phase lock drain  rate [ 7:0] 0x00 \n0x6AD  L Frequency l ock threshold  (picoseconds)  [23:0]  0x00 \n0x06AE  L 0x00 \n0x06AF  L 0x00 \n0x06B0  L Frequency l ock fill rate [7:0] 0x00 \n0x06B1  L Frequency l ock drain rate [7:0] 0x00 \nProfile Register s—Profile 3  \n0x06B2  L Priorities  Phase lock \nscale  Unused  Promoted priority [2:0]  Selection priority [2:0]  0x00 \n0x06B3  L Reference period  Nominal period ( femtoseconds ) [47:0]  (up to 1.125 sec ) 0x00 \n0x06B4  L 0x00 \n0x06B5  L 0x00 \n0x06B6  L 0x00 \n0x06B7  L 0x00 \n0x06B8  L 0x00 \n0x06B9  L Unused  Nominal period [ 49:48]  0x00 \n0x06BA  L Tolerance  Inner tolerance (1/tolerance) [ 15:0]  (removes fault status;  10% down to 1 ppm)  0x00 \n0x06BB  L 0x00 \n0x06BC  L Unused  Inner tolerance [ 19:16]  0x00 \n0x06BD  L Outer tolerance (1/tolerance) [ 15:0 ] (indicates fault status; 1 0% down to 1 ppm ) 0x00 \n0x06BE  L 0x00 \n0x06BF  L Unused  Outer t olerance [19:16]  0x00 \n0x06C0  L Validation  Validation timer (milliseconds) [ 15:0]  (up to 65.5 sec ) 0x00 \n0x06C1  L 0x00 \n0x06C2  L Red etect  \ntimeout  Redetect timer (milliseconds) [ 15:0]  (up to 65.5 sec ) 0x00 \n0x06C3  L 0x00 \nRev. G | Page 65 of 111 \nAD9548 Data Sheet \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x06C4  L Digital loop \nfilter \ncoefficients  Alpha -0 linear [ 15:0 ] 0x00 \n0x06C5  L 0x00 \n0x06C6  L Alpha -2 exponent [ 1:0] Alpha -1 exponent [ 5:0] 0x00 \n0x06C7  L Beta -0 linear [ 6:0] Alpha -2 \nexponent [2]  0x00 \n0x06C8  L Beta -0 linear [ 14:7]  0x00 \n0x06C9  L Unused  Beta -1 exponent [ 4:0] Beta -0 \nlinear \n[16:15]  00  \n0x06CA  L Gamma- 0 linear [ 15:0]  0x00 \n0x06CB  L 0x00 \n0x06CC  L Unused  Gamma- 1 exponent [ 4:0] Gamma- 0 \nlinear [ 16] 0x00 \n0x06CD  L Delta -0 linear [ 7:0] 0x00 \n0x06CE  L Delta -1 \nexponent \n[0] Delta -0 linear [ 14:8]  0x00 \n0x06CF  L Alpha -3 exponent [ 3:0] Delta -1 exponent [ 4:1] 0x00 \n0x06D0 L Frequency \nmultiplication  R [23:0]  0x00 \n0x06D1 L 0x00 \n0x06D2 L 0x00 \n0x06D3 L Unused  R [29:24]  0x00 \n0x06D4 L S [23:0 ] 0x00 \n0x06D5 L 0x00 \n0x06D6 L 0x00 \n0x06D7 L Unused  S [29:24 ] 0x00 \n0x06D8 L V [7:0] 0x00 \n0x06D9 L U [3:0] Unused  V [9:8]  0x00 \n0x06DA  L Unused  U [9:4] 0x00 \n0x06DB  L Lock detectors  Phase l ock threshol d (picoseconds)  [15:0 ] 0x00 \n0x06DC  L 0x00 \n0x06DD  L Phase lock fill rate [ 7:0] 0x00 \n0x06DE  L Phase lock drain rate [7:0] 0x00 \n0x06DF  L Frequency l ock threshold  (picoseconds)  [23:0 ] 0x00 \n0x06E0  L 0x00 \n0x06E1  L 0x00 \n0x06E2  L Frequency l ock fill rate [7:0] 0x00 \n0x06E3  L Frequency l ock drain rate [7:0] 0x00 \n0x06E4-\n0x06FF  L  Unused   \nProfile Registers —Profile 4 T hrough Profile 7  \n0x0700-\n0x07FF  L Profile 4 through \nProfile  7 The functionality of the Profile 4 through Profile  7 address locations ( Address 0x to Address 0x07FF) is identical to that \nof the Profile 0 through Profile  3 address locations ( Address 0x0600 to  Address 0x06FF) .  \nOperational Controls   \n0x0A00  S General  \npower -down  Reset Sans \nreg map  Unused  SYSCLK  \npower -\ndown  Reference  \npower -\ndown TDC  \npower -\ndown  DAC  \npower -\ndown  Dist  \npower -\ndown  Full \npower -\ndown  0x00 \n0x0A01  C Loop  mode Unused  User  \nholdover  User  \nfree-run User s election mode [ 1:0] User r eference selection [2:0] 0x00 \n0x0A02  L  Cal/s ync Unused  Sync  \ndistribution  Calibrate  \nsystem c lock  0x00 \n0x0A03  A, C Reset  Func  Unused  Clear LF  Clear CCI  Clear phase \naccumulator  Reset auto \nsync Reset  \nTW h istory  Reset  \nall IRQs  Reset  \nwatchdog  0x00 \n0x0A04  A, C  IRQ clearing  Unused  SYSCLK  \nunlocked  SYSCLK  \nlocked  Unused  Unused  SYSCLK Cal  \ncomplete  SYSCLK Cal  \nstarted  0x00 \n0x0A05  A, C Unused  Distribu tion \nsync Watchdog  \ntimer  EEPROM  \nfault  EEPROM  \ncomplete  0x00 \n0x0A06  A, C Switching  Closed  Free -run Holdover  Freq  \nunlocked  Freq  \nlocked  Phase  \nunlocked  Phase  \nlocked  0x00 \n0x0A07  A, C Unused  History  \nupdated  Freq unclamp ed Freq  \nclamped  Phase slew  \nunlimited  Phase slew  \nlimited  0x00 \nRev. G | Page 66 of 111 \nData Sheet AD9548 \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0A08  A, C Ref AA  \nnew profile  Ref AA  \nvalidated  Ref AA  \nfault \ncleared  Ref AA  \nfault  Ref A  \nnew p rofile  Ref A  \nvalidated  Ref A  \nfault \ncleared  Ref A  \nfault  0x00 \n0x0A09  A, C Ref BB \nnew p rofile  Ref BB validated  Ref BB \nfault \ncleared  Ref BB \nfault  Ref B  \nnew p rofile  Ref B  \nvalidated  Ref B  \nfault \ncleared  Ref B  \nfault  0x00 \n0x0A0A  A, C Ref CC  \nnew profile  Ref CC  \nvalidated  Ref CC  \nfault cleared  Ref CC  \nfault  Ref C  \nnew p rofile  Ref C  \nvalidated  Ref C  \nfault cleared  Ref C \nfault  0x00 \n0x0A0B  A, C Ref DD  \nnew profile  Ref DD  \nvalidated  Ref DD  \nfault cleared  Ref DD  \nfault  Ref D  \nnew p rofile  Ref D  \nvalidated  Ref D  \nfault \ncleared  Ref D  \nfault  0x00 \n0x0A0C  A, C Incremental  \nphase offset  Unused  Reset  \nphase \noffset  Decrement  \nphase offset  Increment \nphase \noffset  0x00 \n0x0A0D  A, C Reference  \nprofile detect  Detect DD  Detect D  Detect CC  Detect C  Detect BB  Detect B  Detect AA  Detect A  0x00 \n0x0A0E  A, C Force \nvalidation \ntimeout  Force Timeout DD Force \nTimeout D Force Timeout CC  Force Timeout C  Force  \nTimeout BB  Force \nTimeout B  Force Timeout AA  Force Timeout A  0x00 \n0x0A0F  C Reference \nmonitor \noverride  Ref Mon \nOverride DD Ref Mon \nOverride \nD Ref Mon \nOverride \nCC Ref Mon \nOverride C  Ref Mon Override \nBB Ref Mon \nOverride B  Ref Mon Override \nAA Ref Mon \nOverride  A 0x00 \n0x0A10  C Reference  \nmonitor \nbypass  Ref Mon \nBypass DD Ref Mon Bypass D  Ref Mon \nBypass CC Ref Mon Bypass C Ref Mon Bypass BB  Ref Mon \nBypass B  Ref Mon Bypass AA Ref Mon Bypass A 0x00 \nUser Scratch Pad (E ight Bytes)  \n0x0C00  L Clock part serial ID Write  user scratch pad[63:0]  \n 0x00 \n0x0C01  L 0x00 \n0x0C02  S 0x00 \n0x0C03  S 0x00 \n0x0C04  C 0x00 \n0x0C05  C 0x00 \n0x0C06  C 0x00 \n0x0C07  C 0x00 \nStatus ( These registers are r ead only  and are accessible during EEPROM transactions .) \n0x0D00 R, L EEPROM  Unused  Fault  \ndetected  Load in  \nprogress  Save in  \nprogress    \n0x0D01 R, L System clock  Unused  Stable  Unused   Unused   Cal in \nprogress  Lock  \ndetected    \n0x0D02 R, L IRQ monitor  Unused  SYSCLK  \nunlocked  SYSCLK  \nlocked  Unused   Unused   SYSCLK Cal  \ncomplete  SYSCLK Cal  \nstarted    \n0x0D03 R, L Unused  Distribu tion \nsync   Watchdog  \ntimer  EEPROM  \nfault  EEPROM  \ncomplete    \n0x0D04 R, L Switching  Closed  Free -run Holdover  Freq  \nunlocked  Freq  \nlocked  Phase  \nunlocked  Phase  \nlocked    \n0x0D05 R, L Unused  History  \nupdated  Freq un -\nclamped  Freq \nclamped  Phase slew  \nunlimited  Phase slew  \nlimited    \n0x0D06 R, L Ref AA  \nnew profile  Ref AA  \nvalidated  Ref AA  \nfault cleared  Ref AA  \nfault  Ref A  \nnew profile  Ref A  \nvalidated  Ref A  \nfault cleared  Ref A  \nfault    \n0x0D07 R, L Ref BB new profile  Ref BB \nvalidated  Ref BB \nfault \ncleared  Ref BB fault  Ref B  \nnew profile  Ref B  \nvalidated  Ref B  \nfault cleared  Ref B  \nfault    \n0x0D08 R, L Ref CC  \nnew profile  Ref CC  \nvalidated  Ref CC  \nfault \ncleared  Ref CC  \nfault  Ref C new \nprofile  Ref C  \nvalidated  Ref C  \nfault \ncleared  Ref C  \nfault    \n0x0D09  R, L Ref DD  \nnew profile  Ref DD  \nvalidated  Ref DD  \nfault cleared  Ref DD  \nfault  Ref D new \nprofile  Ref D  \nvalidated  Ref D  \nfault \ncleared  Ref D  \nfault    \n0x0D0A  R, C DPLL status  Offset slew  \nlimiting  Phase \nbuild -out Freq lock  Phase lock  Loop  \nswitching  Holdover  Active  Free running    \n0x0D0B  R, C Frequency  \nclamped  History  \navailable  Active reference priority [3:0]  Active reference [3:0]    \nRev. G | Page 67 of 111 \nAD9548 Data Sheet \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0D0C  R, C Ref A  Profile  \nselected  Selected profile [2:0]  Valid  Fault  Fast  Slow    \n0x0D0D  R, C Ref AA  Profile  \nselected  Selected  profile [2:0]  Valid  Fault  Fast  Slow    \n0x0D0E  R, C Ref B  Profile  \nselected  Selected profile [2:0]  Valid  Fault  Fast  Slow    \n0x0D0F  R, C Ref BB Profile  \nselected  Selected profile [2:0]  Valid  Fault  Fast  Slow    \n0x0D10 R, C Ref C  Profile  \nselected  Selected profi le [2:0]  Valid  Fault  Fast  Slow    \n0x0D11 R, C Ref CC  Profile  \nselected  Selected profile [2:0]  Valid  Fault  Fast  Slow    \n0x0D12 R. C Ref D  Profile  \nselected  Selected profile [2:0]  Valid  Fault  Fast  Slow    \n0x0D13 R, C Ref DD  Profile  \nselected  Selected profile [2 :0] Valid  Fault  Fast  Slow    \n0x0D14 R, C Holdover \nhistory  Tuning word readback [47:0]    \n0x0D15 R, C   \n0x0D16 R, C   \n0x0D17 R, C   \n0x0D18 R, C   \n0x0D19 R, C   \nNonvolatile Memory (EEPROM) C ontrol  \n0x0E00  L Write protect  Unused  Half rate  \nmode  Write  \nenable  0x00 \n0x0E01  L, E Condition Unused  Condition value [4:0] 0x00 \n0x0E02  L, A, \nE Save  Unused  Save to  \nEEPROM  0x00 \n0x0E03  L, A, \nE Load  Unused  Load from  \nEEPROM  Unused   0x00 \n     EEPROM storage sequence    \n0x0E10  L, E System  \nclock  Data: 9 bytes  0x08 \n0x0E11  L, E Address: 0x0100 0x01 \n0x0E12  L, E 0x00 \n0x0E13  L, E I/O update  Action: IO_Update  0x80 \n0x0E14  L, E SYSCLK  \ncalibrate  Action: calibrate system clock  0xA0 \n0x0E15  L, E General  Data: 21 bytes  0x14 \n0x0E16  L, E Address: 0x0200 0x02 \n0x0E17  L, E 0x00 \n0x0E18  L, E DPLL  Data: 28 bytes  0xB \n0x0E19  L, E Address: 0x0300 0x03 \n0x0E1A  L, E 0x00 \n0x0E1B  L, E Clock  \ndistribution  Data: 26 bytes  0x19 \n0x0E1C  L, E Address: 0x0400 0x04 \n0x0E1D  L, E 0x00 \n0x0E1E  L, E I/O update  Action: IO_Update  0x80 \n0x0E1F  L, E Reference  \ninputs  Data: 8 bytes  0x07 \n0x0E20  L, E Address: 0x0500 0x05 \n0x0E21  L, E 0x00 \n0x0E22  L,E Profile 0 and \nProfile 1  Data: 100 bytes  0x63 \n0x0E23  L, E Address: 0x0600 0x06 \n0x0E24  L, E 0x00 \n0x0E25  L, E Profile 2 and Profile 3  Data: 100 bytes  0x63 \n0x0E26  L, E Address: 0x0680 0x06 \n0x0E27  L, E 0x80 \n0x0E28  L, E Profile 4 and Profile 5  Data: 100 bytes  0x63 \n0x0E29  L, E Address: 0x0700 0x07 \n0x0E2A  L, E 0x00 \n0x0E2B  L, E Profile 6 and Profile 7  Data: 100 bytes  0x63 \n0x0E2C  L, E Address: 0x0780 0x07 \n0x0E2D  L, E 0x80 \nRev. G | Page 68 of 111 \nData Sheet AD9548 \n \nAddr Opt1 Name  D7 D6 D5 D4 D3 D2 D1 D0 Def  \n0x0E2E  L, E I/O update  Action: I /O u pdate  0x80 \n0x0E2F  L, E Operational \ncontrols  Data: 17 bytes  0x10 \n0x0E30  L, E Address: 0x0A00  0x0A \n0x0E31  L, E 0x00 \n0x0E32  L, E I/O update  Action: I /O update  0x80 \n0x0E33  L, E End of data  Action: end of data  0xFF \n0x0E34  \nto \n0x0E3F  L, E   Continuation of scratch pad area    \n1 For details regarding the options in the Opt column, see the I nput/O utput  Programming Registers  section.  \n \n \nRev. G | Page 69 of 111  \nAD9548 Data Sheet \n \nREGISTER MAP BIT DESCRIPTIONS  \nSERIAL PORT CONFIGUR ATION ( REG ISTER  0x0000 TO REG ISTER  0x0005)  \nTable 37. Serial Configuration  \nAddress  Bits Bit Name  Description  \n0x0000 [7] Unidirectional  Select SPI port SDO pin  operating mode . \n0 (default) = 3 -wire.  \n1 = 4 -wire (SDO pin enabled ). \n[6] LSB f irst Bit order for SPI port.  \n0 (default) = most significant bit and byte first . \n1 = least sig nificant bit and byte first . \n[5] Soft r eset  Device reset  (invokes  an EEPROM download if M[ 7:3] ≠ 0). \n0 (default) = normal operation.  \n1 = reset . \n[4] Long  instruction  16-bit mode (the only mode supported by the device). This bit is read only and reads back as L ogic  1. \n[0] Unused   \nTable 38. Reserved  Register  \nAddress  Bits Bit Name  Description  \n0x0001 [7:0] Unused   \nTable 39. Silicon Revision Level (R ead Only)  \nAddress  Bits Bit Name  Description  \n0x0002 [7:0]  Reserved  Default = 0xC6 = 0b11000110 \nTable 40. Device ID ( Read Only)  \nAdd ress  Bits Bit Name  Description  \n0x0003 [7:0] Reserved  Default = 0x48  = 0b01001000 \nTable 41. Register Read back Control \nAddress  Bits Bit Name  Description  \n0x0004 [7:1] Unused   \n0 Read buffer \nregister  For buffered registers, serial p ort re adback r eads from actual (active) registers instead of from the \nbuffer.  \n0 (default) = reads values currently applied to the internal logic  of the device.  \n1 = reads buffered values that take effect on the next assertion of the I/O update . \nTable 42. Soft I nput /Output  Update  \nAddress  Bits Bit Name  Description  \n0x0005 [7:1] Unused   \n0 I/O \nupdate  Writing a 1 to this bit transfers the data in the seri al I/O buffer registers to the internal control registers  of the \ndevice . This is an  auto clearing bit.  \nRev. G | Page 70 of 111 \nData Sheet AD9548 \n \nSYSTEM CLOCK (REGISTER  0x0100 TO REG ISTER  0x0108)  \nTable 43. Charge Pump and Lock Detect Control  \nAddress  Bits Bit Name  Description  \n0x0100  [7] External l oop filter e nable  Enables use of an external SYSCLK PLL loo p filter  \n0 (default) = internal loop filter  \n1 = external loop filter  \n[6] Charge p ump mode  Charge pump current control  \n0 (default) = automatic  \n1 = manual  \n[5:3] Charge p ump current  Selects  charge pump current when Bit 6 = 1 \n000 = 125 μA  \n001 = 250 μA  \n010 = 375 μA  \n011 (default) = 500 μA  \n100 = 625 μA  \n101 = 750 μA  \n110 = 875 μA  \n111 = 1000 μA  \n[2] Lock d etect timer dis able  Enable the SYSCLK  PLL lock detect timer  \n0 (default) = en able  \n1 = disable  \n[1:0] Lock d etect timer  Select loc k detect timer dep th \n00 (default) = 128 \n01 = 256 \n10 = 512 \n11 = 1024 \nTable 44. N Divider  \nAddress  Bits Bit Name  Description  \n0x0101  [7:0] N-divider  System clock PLL feedback divider valu e: 6 ≤ N ≤ 255 (default  = 0x28 = 40) \nTable 45. SYSCLK  Input Options  \nAddress  Bits Bit Name  Description  \n0x0102 [7] Unused   \n[6] M-divider reset  Reset  the M -divider  \n0 = normal operation  \n1 (default) = reset  \nWhen not using the M -divider, program this bit to L ogic 1.  \n[5:4] M-divider  System clock input divider  \n00 (default) = 1 \n01 = 2 \n10 = 4 \n11 = 8 \n[3] 2× frequency multiplier enable  Enable the 2× frequency multiplier  \n0 (default) = disable  \n1 = enable  \n[2] PLL e nable  Enable the SYSCLK  PLL \n0 = disable  \n1 (default)  = enable  \n[1:0] System clock source  Input mode select for SYSCLK x pins  \n00 = crystal resonator  \n01 (default) = low frequency clock source  \n10 = high frequency (direct) clock source  \n11 = input receiver power -down  \n \nRev. G | Page 71 of 111 \nAD9548 Data Sheet \n \nTable 46. Nomin al System Clock  (SYSCLK ) Period1 \nAddress  Bits Bit Name  Description  \n0x0103 [7:0] System c lock period  (expressed in femtoseconds)  System clock period , Bits[7:0] \n0x0104 [7:0] System clock period , Bits[15:8]  \n0x0105 [7:5] Unused   \n[4:0] System c lock period  System clock period , Bits[20:16]  \n1 Units are femtoseconds. The defa ult value is 0x0F424 = 1,000,000 (1 ns) and implies a system clock frequency of 1 GHz.  \nTable 47. System Clock Stability Period1 \nAddress  Bits Bit Name  Description  \n0x0106 [7:0] System c lock stability p eriod  System clock  stability  perio d, Bits[7:0] (default = 0x01)  \n0x0107 [7:0] System clock stability perio d, Bits[15:8]  (default = 0x00)  \n0x0108 [7:4] Unused   \n[3:0] System c lock stability p eriod  System clock stability period , Bits[19:16]  (default = 0x0)  \n(default period = 0x00001, or 1 ms)  \n1 Units are milliseconds. The default value is 0x000001 = 1 (1 ms).  \nGENERAL CONFIGURATION (REG ISTER  0x0200 TO REG ISTER  0x0214)  \nRegister 0x0200 to Register 0x0207—Multifunction Pin Control  (M0  to M7)  \nTable 48. Multifunction Pin (M 0 to M7)  Control1 \nAddress  Bits Bit Name  Description  \n0x0200 [7] M0 in/o ut In/out control for the M0 pin \n0 (default) = input (control pin)  \n1 = output ( status  pin)  \n[6:0] M0 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n0x0201 [7] M1 in/o ut In/o ut control for the M1 pin (same as M0)  \n[6:0] M1 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n0x0202 [7] M2 in/out In/o ut control for the M2 pin (same as M0)  \n[6:0] M2 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n0x0203 [7] M3 in/out In/o ut control for the M3 pin (same as M0)  \n[6:0] M3 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n0x0204  [7] M4 in/out In/o ut control for the M4 pin  (same as M0)  \n[6:0] M4 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n0x0205 [7] M5 in/out In/o ut control for the M5 pin (same as M0)  \n[6:0] M5 f unction  See Table 25 and Table 26 (default = 0xb0000000)  \n0x0206 [7] M6 in/out In/o ut control for the M6 pin (same as M0)  \n[6:0] M6 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n0x0207  [7] M7 in/out In/o ut control for the M7 pin  (same as M0)  \n[6:0] M7 f unction See Table 25 and Table 26 (default = 0xb0000000)  \n1 The default setting for all the multifunction pins is as an unused control input pin.  \nTable 49. IRQ Pin Output Mode  \nAddress  Bits  Bit Name  Description  \n0x0208 [7:2] Unused   \n[1:0] IRQ pin output mode  Select the output mode of the IRQ pin  \n00 (default) = NMOS, open drain (requires an external pull -up resistor)  \n01 = PMOS, open drain (requires an external pull -down resistor)  \n10 = CMOS, active high  \n11 = CMOS, active low  \nRev. G | Page 72 of 111  \n \n \nData Sheet AD9548 \n \nRegister 0x020 9 to Register 0x0210—IRQ  Mask \nThe IRQ m ask register bits form a one -to-one correspon dence with the bits of the IRQ m onitor register ( Address 0x0D02 to \nAddress  0x0D09).  When set to Logic 1, the IRQ m ask bits enable the correspon ding IRQ monitor bits to indicate an IRQ event.  The \ndefault for all IRQ mask bits is Logic 0, which prevents the IRQ m onitor from detecting any internal interrupts.  \nTable 50. IRQ Mask  for SYSCLK  \nAddress  Bits Bit Name  Description  \n0x0209 [7:6] Unused   \n[5] SYSCLK u nlocked  Enables IRQ for indicating a SYSCLK  PLL state transition from locked to unlocked  \n[4] SYSCLK l ocked  Enables IRQ for indicating a SYSCLK  PLL state transition from unlocked to locked  \n[3:2] Unused   \n[1] SYSCLK Cal c omplete  Enables IRQ for indicating that SYSCLK  calibration has completed  \n[0] SYSCLK Cal s tarted  Enables IRQ for indicating that SYSCLK  calibration has begun  \nTable 51. IRQ Mask for Distribution Sync, Watchdog Timer , and EEPROM  \nAddress  Bits Bit Name  Description  \n0x020A  [7:4] Unused   \n[3] Distribution s ync Enables IRQ for indicating a distribution sync event  \n[2] Watchdog t imer  Enables IRQ for indicatin g expiration of the watchdog timer  \n[1] EEPROM fault  Enables IRQ for indicating a fault during an EEPROM load or save operation  \n[0] EEPROM c omplete  Enables IRQ for indicating successful completion of an EEPROM load or save operation  \nTable 52. IRQ Mask for the Digital PLL  \nAddress  Bits Bit Name  Description  \n0x020B  [7] Switching  Enables IRQ for indicating that the DPLL is switching to a new reference  \n[6] Closed  Enables IRQ for indicating that the DPLL has entered closed -loop opera tion  \n[5] Freerun  Enables IRQ for indicating that the DPLL has entered free -run mode  \n[4] Holdover  Enables IRQ for indicating that the DPLL has entered holdover mode  \n[3] Freq u nlocked  Enables IRQ for indicating that the DPLL lost frequency lock  \n[2] Freq l ocked  Enables IRQ for indicating that the DPLL has acquired frequency lock  \n[1] Phase unlocked  Enables IRQ for indicating that the DPLL lost phase lock  \n[0] Phase l ocked  Enables IRQ for indicating that the DPLL has acquired phase lock  \nTable 53. IRQ Mask for History Update, Frequency Limit,  and Phase Slew Limit  \nAddress  Bits Bit Name  Description  \n0x020C [7:5] Unused   \n[4] History u pdated  Enables IRQ for indicating the occurrence of a tuning word history update  \n[3] Frequency \nunclamped  Enables IRQ for indicating a state transition f requency limit er from clamped to unclamped  \n[2] Frequency clamped  Enables IRQ for indica ting a state transition of the f requency limiter from unclamped to clamped  \n[1] Phase s lew unlimited  Enables IRQ for indica ting a state transition of the phase slew limiter from slew limiting to not \nslew limiting  \n[0] Phase s lew limited  Enables IRQ for indica ting a state transition of the phase slew limiter from not slew limiting to \nslew limiting  \nRev. G | Page 73 of 111 \nAD9548 Data Sheet \n \nTable 54. IRQ Mask for Reference Inputs  \nAddress  Bits Bit Name  Description  \n0x020D  [7] Ref AA new p rofile  Enables IRQ for indicating that Ref AA has switched to a new profile  \n[6] Ref AA v alidated  Enables IRQ for indicating that Ref AA has been v alidated  \n[5] Ref AA fault c leared  Enables IRQ for indicating that Ref AA has been cleared of a previous fault  \n[4] Ref AA fault  Enables IRQ for indicating that Ref AA has been faulted  \n[3] Ref A new p rofile  Enables IRQ for indicating that Ref A has swi tched to a new profile  \n[2] Ref A v alidated  Enables IRQ for indicating that Ref A has been validated  \n[1] Ref A fault c leared  Enables IRQ for indicating that Ref A has been cleared of a previous fault  \n[0] Ref A fault  Enables IRQ for indicating that Ref  A has been faulted  \n0x020E  [7] Ref BB new profile  Enables IRQ for indicating that Ref BB has switched to a new profile  \n[6] Ref BB v alidated  Enables IRQ for indicating that Ref BB has been validated  \n[5] Ref BB fault c leared  Enables IRQ for indicating t hat Ref BB has been cleared of a previous fault  \n[4] Ref BB f ault  Enables IRQ for indicating that Ref BB has been faulted  \n[3] Ref B new profile  Enables IRQ for indicating that Ref B has switched to a new profile  \n[2] Ref B v alidated  Enables IRQ for ind icating that Ref B has been validated  \n[1] Ref B fault c leared  Enables IRQ for indicating that Ref B has been cleared of a previous fault  \n[0] Ref B f ault  Enables IRQ for indicating that Ref B has been faulted  \n0x020F [7] Ref CC n ew profile  Enables IRQ f or indicating that Ref CC has switched to a new profile  \n[6] Ref CC v alidated  Enables IRQ for indicating that Ref CC has been validated  \n[5] Ref CC fault c leared  Enables IRQ for indicating that Ref CC has been cleared of a previous fault  \n[4] Ref CC fault Enables IRQ for indicating that Ref CC has been faulted  \n[3] Ref C new p rofile  Enables IRQ for indicating that Ref C has switched to a new profile  \n[2] Ref C v alidated  Enables IRQ for indicating that Ref C has been validated  \n[1] Ref C fault c leared  Enables IRQ for indicating that Ref C has been cleared of a previous fault  \n[0] Ref C f ault  Enables IRQ for indicating that Ref C has been faulted  \n0x0210 [7] Ref DD n ew profile  Enables IRQ for indicating that Ref DD has switched to a new profile  \n[6] Ref DD v alidated  Enables IRQ for indicating that Ref DD has been validated  \n[5] Ref DD fault c leared  Enables IRQ for indicating that Ref DD has been cleared of a previous fault  \n[4] Ref DD fault  Enables IRQ for indicating that Ref DD has been faulted  \n[3] Ref D new p rofile  Enables IRQ for indicating that Ref D has switched to a new profile  \n[2] Ref D v alidated  Enables IRQ for indicating that Ref D has been validated  \n[1] Ref D fault c leared  Enables IRQ for indicating that Ref D has been cleared of a prev ious fault  \n[0] Ref D fault  Enables IRQ for indicating that Ref D has been faulted  \nTable 55. Wat chdog Timer1 \nAddress  Bits Bit Name  Description  \n0x0211 [7:0] Watchdog t imer  Watchdog timer , Bits [7:0] (default = 0x00)  \n0x0212 [7:0] Watchdog timer , Bits [15:8]  (default = 0x00)  \n1 The watchdo g timer is expressed in milliseconds. The default value is 0 (disabled).  \nTable 56. Auxiliary DAC1 \nAddress  Bits Bit Name  Description  \n0x0213 [7:0] Full-scale current  Full scale current , Bits [7:0] (default = 0xFF)  \n0x0214 [7] DAC shut down  Shut down the  DAC curr ent sources . \n0 (default) = normal operation  \n1 = shut down  \n[6:2] Unused   \n[1:0] Full-scale  current  Full-scale current , Bits [9:8] (default = 0b01)  \n(default current = 0x1FF, or 20.1 mA)  \n1 The default DAC full- scale current value is 0x01FF = 511, which equates to 20.1375 mA.  \n \nRev. G | Page 74 of 111  \n \nData Sheet AD9548 \n \nDPLL CONFIGURATION (REG ISTER  0x0300 TO REG ISTER  0x031B)  \nTable 57. Free Running Frequ ency Tuning Word1 \nAddress  Bits Bit Name  Description  \n0x0300  [7:0] Frequency  (expressed as a 48 -bit frequency tuning word)  Free  running frequency tuning word , Bits [7:0] \n0x0301 [7:0] Free running frequency tuning wo rd, Bits[ 15:8]  \n0x0302 [7:0] Free runn ing frequency tuning word , Bits [23:9]  \n0x0303  [7:0] Free running frequency tuning word , Bits [31:24 ] \n0x0304 [7:0] Free runn ing frequency tuning word , Bits [39:32 ] \n0x0305 [7:0] Free runn ing frequency tuning word , Bits[47:40 ] \n1 The default free running tuning word is 0x000000 = 0, which equates to 0 Hz.  \nTable 58. Update TW  \nAddress  Bits Bit Name  Description  \n0x0306 [7:1] Unused   \n[0] Update \nTW A Logic 1 written to this bit transfers the free running frequency tuning word (Register 0300  to Register \n0305) to the register imbedded in the tuning word processing logic.  Note that it is not necessary to write \nthe u pdate TW bit when the device is in free -run mode. This is an autoclearing bit.  \nTable 59. Pull -In Range Lower Limit1 \nAddress  Bits Bit Name  Des cription  \n0x0307 [7:0] Pull-in r ange lower l imit  (expressed as a 24 -bit frequency tuning word)  Lower limit pull -in range , Bits [7:0] \n0x0308 [7:0] Lower limit pull -in range , Bits [15:8]  \n0x0309 [7:0] Lower limit pull -in range , Bits [23:9]  \n0x030A  [7:0] Pull-in range upper l imit  (expressed as a 24 -bit frequency tuning word)  Upper limit pull -in range , Bits [7:0] \n0x030B  [7:0] Upper limit pull -in range , Bits [15:8]  \n0x030C [7:0] Upper limit pull -in range , Bits [23:9]  \n1 The default p ull-in range lower limit is 0, and the upper range limit is 0xFFFFFF, which effectively spans the full output frequency range of the DDS.  \nTable 60. DDS  Phase  Offset1 \nAddress  Bits Bit Name  Description  \n0x030D  [7:0] Open-l oop phase offset  (expressed in π/215 radians)  DDS phase offset , Bits [7:0] \n0x030E  [7:0] DDS phase offset , Bits [15:8]  \n1 The default DDS phase offset is 0.  \nTable 61. Fixed Closed -Loop Phase Lock Offset1 \nAddress  Bits Bit Name  Description  \n0x030F [7:0] Fixed p hase lock offset  (expressed in picoseconds)  Fixed phase lock offset , Bits [7:0] \n0x0310 [7:0] Fixed phase lock offset , Bits [15:8]  \n0x0311 [7:0] Fixed phase lock offset , Bits [23:16]  \n0x0312 [7:0] Fixed phase lock offset , Bits [31:24]  \n0x0313 [7:0] Fixed phase lock offset , Bits [39:32]  \n1 The default fixed closed loop phase lock offset is 0.  \n \nRev. G | Page 75 of 111  \n \n \n \nAD9548 Data Sheet \n \nTable 62. Incremental Closed -Loop Phase Lock Offset Step Size1 \nAddress  Bits Bit Name  Description  \n0x0314 [7:0] Incremental phase lock offset step size (expressed in picoseconds per \nstep)  Incremental phase lock offset step size , \nBits[7:0] \n0x0315 [7:0] Incremental phase lock offset step size , \nBits[15:8]  \n1 The default incremental  closed -loop phase lock offset step size value is 0x03E8 = 1000 (1 ns).  \nTable 63. Phase  Slew Rate Limit1 \nAddress  Bits Bit Name  Description  \n0x0316 [7:0] Phase s lew limit  \n(expressed in nanoseconds per second)  Phase slew rate limit , Bits [7:0] \n0x0317 [7:0] Phase slew rate limit , Bits [15:8]  \n1 The default phase slew rate limit is 0 (or disabled).  \nTable 64. History Ac cumulation Timer1 \nAddress  Bits Bit Name  Description  \n0x0318 [7:0] History  accumulation t imer  (expressed in milliseconds)  History accumulation timer , Bits [7:0] \n0x0319 [7:0] History accumulation timer , Bits [15:8]  \n0x031A  [7:0] History accumulation timer , Bits [23:16]  \n1 Do not program a timer value of 0. The history accumulation timer default value is 0x007530 = 30,000 (30 sec).  \nTable 65. History Mode  \nAddress  Bits Bit Name  Description  \n0x031B  [7:5] Unused   \n[4] Single -sample \nfallback  Controls the holdover history.  If tuning word history is not available for the reference that was \nactive  just prior to holdover, then \n0 (default) = use the f ree running frequency tuning word register value.  \n1 = use t he last tuning word from the DPL L. \n[3] Persistent h istory  Controls the holdover history initialization. When switching to a new reference  \n0 (default) = clear the tuning word history . \n1 = retain the previous tuni ng word history . \n[2:0] Incremental \naverage  History mode value from 0 to 7 (default = 0 ). See the Frequency Tuning Word History  section for \ndetails on this register.  \nRev. G | Page 76 of 111  \n \n \nData Sheet AD9548 \n \nCLOCK DISTRIBUTION O UTPUT CON FIGURATION (REG ISTER  0x0400 TO REG ISTER  0x0419)  \nTable 66. Distribution Settings1 \nAddress  Bits Bit Name  Description  \n0x0400  [7:6] Unused   \n[5] External distribution resistor  Output current control for the clock distribution outputs  \n0 (default) = int ernal current setting resistor  \n1 = external current setting resistor  \n[4] Receiver mode  Clock distribution receiver mode  \n0 (default) = normal operation  \n1 = high frequency mode  (super -Nyquist)  \n[3] OUT3 power -down  Power -down clock distribution output OUT3  \n0 (default) = normal operation  \n1 = power -down  \n[2] OUT2 power -down  Power -down clock distribution output OUT2  \n0 (default) = normal operation  \n1 = power -down  \n[1] OUT1 p ower -down  Power -down clock distribution output OUT1  \n0 (default) = normal operation  \n1 = power -down  \n[0] OUT0 p ower -down  Power -down clock distribution output OUT0  \n0 (default) = normal operation  \n1 = power -down  \n1 When Bits[3:0 ] = 1111, the clock distribution output enters a deep sleep mode.  \nTable 67. Distribution Enable  \nAddress  Bits Bit Name  Description  \n0x0401 [7:4] Unused   \n[3] OUT3 e nable  Enabl e the OUT3 driver . \n0 (default) = disable . \n1 = enable . \n[2] OUT2 enable  Enable the OUT2 driver.  \n0 (default) = disable . \n1 = enable . \n[1] OUT1 enable  Enable the OUT1 driver.  \n0 (default) = disable . \n1 = enable . \n[0] OUT0 enable  Enable the OUT0 driver.  \n0 (def ault) = disable . \n1 = enable . \nRev. G | Page 77 of 111  \nAD9548 Data Sheet \n \nTable 68. Distribution Synchronization  \nAddress  Bits Bit Name  Description  \n0x0402 [7:6] Unused   \n[5:4] Sync s ource  Select the sync source for the clock distribution output channels . \n00 (default) = direc t. \n01 = active reference . \n10 = DPLL feedback edge . \n11 = reserved . \n[3] OUT3 sync m ask Mask the synchronous reset to the OUT3 divider . \n0 (default) = unmasked . \n1 = masked . \n[2] OUT2 sync mask  Mask the synchronous reset to the OUT2 divider.  \n0 (default) = un masked . \n1 = masked . \n[1] OUT1 sync mask  Mask the synchronous reset to the OUT1 divider.  \n0 (default) = unmasked . \n1 = masked . \n[0] OUT0 sync mask  Mask the synchronous reset to the OUT0 divider.  \n0 (default) = unmasked . \n1 = masked . \nTable 69. Automatic Synchronization  \nAddress  Bits Bit Name  Description  \n0x0403  [7:2] Unused   \n[1:0] Automatic sync mode  Auto sync mode  \n00 (default) = disabled  \n01 = sync on DPLL frequency lock \n10 = sync on DPLL phase lock  \n11 = reserved  \nTable 70. Distribution Channel  Modes  \nAddress  Bits Bit Name  Description  \n0x0404 [7:6] Unused   \n[5] OUT0 CMOS phase \ninvert  When the output mode is CMOS, the bit inverts the relative phase between the two CMOS output \npins . Otherwise, this bit is nonfunctio nal. \n0 (default) = not inverted . \n1 = inverted . \n[4] OUT0 p olarity \ninvert  Invert the polarity of OUT0 . \n0 (default) = not inverted . \n1 = inverted . \n[3] OUT0 d rive \nstrength  OUT0 output drive capability control . \n0 (default) = CMOS: low drive strength ; LVDS: 3.5  mA nominal . \n1 = CMOS: normal  drive strength ; LVDS: 7 mA nominal . \n[2:0] OUT0 m ode  OUT0 operating mode select.  \n000 = CMOS (both pins) . \n001 = CMOS (positive pin), tri state  (negative pin) . \n010 = tri state (positive pin), CMOS (negative pin) . \n011 (default) = tristate  (both pins) . \n100 = LVDS.  \n101 = LVPECL . \n110 = reserved . \n111 = reserved . \nRev. G | Page 78 of 111 \nData Sheet AD9548 \n \nAddress  Bits Bit Name  Description  \n0x0405 [7:6] Unused   \n[5] OUT1 CMOS phase \ninvert  When the output mode is CMOS, the bit inverts the relative phase between the two CMOS output \npins. Otherwise, this bit is n onfunctional.  \n0 (default) = not inverted . \n1 = inverted . \n[4] OUT1 polarity \ninvert  Invert the polarity of OUT1.  \n0 (default) = not inverted . \n1 = inverted . \n[3] OUT1 drive \nstrength  OUT1 output drive capability control.  \n0 (default) = CMOS: low drive strength ; LVDS: 3.5 mA nominal . \n1 = CMOS: normal drive strength; LVDS: 7 mA nominal . \n[2:0]  OUT1 mode  OUT1 operating mode select.  \n000 = CMOS (both pins) . \n001 = CMOS (positive pin), tri state (negative pin) . \n010 = trist ate (positive pin), CMOS (negative pin) . \n011 ( default) = tri state (both pins) . \n100 = LVDS.  \n101 = LVPECL . \n110 = reserved . \n111 = reserved . \n0x0406 [7:6]  Unused   \n[5] OUT2 CMOS phase \ninvert  When the output mode is CMOS, the bit inverts the relative phase between the two CMOS output \npins. Otherwise, this bit is nonfunctional.  \n0 (default) = not inverted . \n1 = inverted . \n[4] OUT2 polarity invert  Invert the polarity of OUT2.  \n0 (default) = not inverted . \n1 = inverted . \n[3] OUT2 drive \nstrength  OUT2 output drive capability control.  \n0 (default) = CMOS: low drive  strength; LVDS: 3.5 mA nominal . \n1 = CMOS: normal drive strength; LVDS: 7 mA nominal . \n[2:0]  OUT2 mode  OUT2 operating mode select.  \n000 = CMOS (both pins) . \n001 = CMOS (positive pin), tri state (negative pin) . \n010 = tri state (positive pin), CMOS (negative pi n). \n011 (default) = tri state (both pins) . \n100 = LVDS.  \n101 = LVPECL . \n110 = reserved . \n111 = reserved . \nRev. G | Page 79 of 111 \nAD9548 Data Sheet \n \nAddress  Bits Bit Name  Description  \n0x0407 [7:6]  Unused   \n[5] OUT3 CMOS phase \ninvert  When the output mode is CMOS, the bit inverts the relative phase between the two CMOS output \npins. Otherw ise, this bit is nonfunctional.  \n0 (default) = not inverted . \n1 = inverted . \n[4] OUT3 polarity \ninvert  Invert the polarity of OUT3.  \n0 (default) = not inverted . \n1 = inverted . \n[3] OUT3 drive \nstrength  OUT3 output drive capability control.  \n0 (default) = CMOS: low drive strength; LVDS: 3.5 mA nominal . \n1 = CMOS: normal drive strength; LVDS: 7 mA nominal . \n[2:0]  OUT3 mode  OUT3 operating mode select.  \n000 = CMOS (both pins) . \n001 = CMOS (positive pin), tristate (negative pin) . \n010 = tri state (positive pin), CMOS (ne gative pin) . \n011 (default) = tri state (both pins) . \n100 = LVDS.  \n101 = LVPECL . \n110 = reserved . \n111 = reserved . \nRegister 0x040 8 to Register 0x0417—Distribution Channel Dividers  \nTable 71. Q0 Divider1 \nAddress  Bits Bit Name  Description  \n0x0408 [7:0] Q0 Q0 divider , Bits [7:0] \n0x0409 [7:0] Q0 divider , Bits [15:8]  \n0x040A  [7:0] Q0 divider , Bits [23:16]  \n0x040B  [7:6] Unused   \n[5:0] Q0 Q0 divider , Bits [29:24]  \n1 The default value is 0 (or divide by 1).  \nTable 72. Q1 Divider1 \nAddress  Bits Bit Name  Description  \n0x040C [7:0] Q1 Q1 divider , Bits [7:0] \n0x040D  [7:0] Q1 divider , Bits [15:8]  \n0x040E  [7:0] Q1 divider , Bits [23:16]  \n0x040F  [7:6] Unused   \n[5:0] Q1 Q1 divider , Bits [29:24]  \n1 The default value is 0 (or divide by 1).  \nTable 73. Q2 Divider1 \nAddress  Bits Bit Name  Description  \n0x0410 [7:0] Q2 Q2 divider , Bits [7:0] \n0x0411 [7:0] Q2 divider , Bits [15:8]  \n0x0412 [7:0] Q2 divider , Bits [23:16]  \n0x0413 [7:6] Unused   \n[5:0] Q2 Q2 divider , Bits [29:24]  \n1 The default value is 0 (or divide by 1).  \n \nRev. G | Page 80 of 111  \n \n \nData Sheet AD9548 \n \nTable 74. Q3 Divider1 \nAddress  Bits Bit Name  Description  \n0x0414 [7:0] Q3 Q3 divider , Bits [7:0] \n0x0415  [7:0] Q3 divider , Bits [15:8] \n0x0416 [7:0] Q3 divider , Bits [23:16]  \n0x0417 [7:6] Unused   \n[5:0] Q3 Q3 divider , Bits [29:24]  \n1 The default value is 0 (or divide by 1).  \nREFERENCE INPUT CONF IGURATION (REG ISTER  0x0500 TO REG ISTER  0x0507)  \nTable 75. Reference Power -Down  \nWhen all bits are set, the reference receiver section enters a deep sleep mode.  \nAddress  Bits Bit Name  Description  \n0x0500 [7] Ref DD power -down  REF DD input receiver  power -down  \n0 (default) = normal operation  \n1 = power -down  \n[6] Ref D power -down  REF D input receiver power -down  \n0 (default) = normal operation  \n1 = power -down  \n[5] Ref CC power -down  REF CC input receiver power -down  \n0 (default) = normal operation  \n1 = power -down  \n[4] Ref C power -down  REF C input receiver pow er-down  \n0 (default) = normal operation  \n1 = power -down  \n[3] Ref BB power -down  REF B B input receiver power -down  \n0 (default) = normal operation  \n1 = power -down  \n[2] Ref B power -down  REF B input receiver power -down  \n0 (default) = normal operation  \n1 = power -dow n \n[1] Ref AA power -down  REF AA input receiver power -down  \n0 (default) = normal operation  \n1 = power -down  \n[0] Ref A power -down  REF A input receiver power -down  \n0 (default) = normal operation  \n1 = power -down  \nRev. G | Page 81 of 111  \nAD9548 Data Sheet \n \nTable 76. Reference Logic  Family  \nAddress  Bits Bit Name  Description  \n0x0501 [7:6] Ref BB l ogic family  Select the logic family for the REF BB input receiver (ignored if Bits[ 5:4] = 00). \n00 (default) = disabled . \n01 = 1.2 V to 1.5 V CMOS.  \n10 = 1.8 V to 2.5 V CMOS.  \n11 = 3.0 V to 3.3 V CMOS . \n[5:4] Ref B logic family  Select logic family for REF B input receiver.  \n00 (default) = differential (REFB /BB is  positive /negative input) . \n01 = 1.2 V to 1.5 V CMOS.  \n10 = 1.8 V to 2.5 V CMOS.  \n11 = 3.0 V to 3.3 V CMOS.  \n[3:2] Ref AA logic family  The s ame as Register 0501, Bits[ 7:6] but for REF AA . \n[1:0] Ref A logic family  The same as Register 0501, Bits[ 5:4] but for REF A . \n0x0502 [7:6] Ref DD logic family  The same as Register 0501, Bits[ 7:6] but for REF DD . \n[5:4] Ref D logic family  The same as Reg ister 0501, Bits[ 5:4] but for REF D . \n[3:2] Ref CC logic family  The same as Register 0501, Bits[ 7:6] but for REF CC . \n[1:0] Ref C logic family  The same as Register 0501, Bits[ 5:4] but for REF C . \nTable 77. Manual Reference Profile Selection  \nAddress  Bits Bit Name  Description  \n0x0503 [7] Enable Ref AA manual profile  Select manual or automatic referenc e profile assignment for REF AA  \n0 (default) = automatic  \n1 = manual  \n[6:4] Ref AA manual profile  Manual profile assignment  \n000 (default ) = Profile 0  \n001 = Profile 1  \n010 = Profile 2 \n011 = Profile 3 \n100 = Profile 4 \n101 = Profile 5 \n110 = Profile 6 \n111 = Profile 7  \n[3] Enable Ref A manual profile  Same as Register 0503, Bit 7 but for REF A  \n[2:0] Ref A manual profile  Same as Register 0503, B its[6:4] but for REF A  \n0x0504 [7] Enable Ref BB manual profile  Same as Register 0503, Bit 7 but for REF B  \n[6:4] Ref BB manual profile  Same as Register 0503, Bits[ 6:4] but for REF BB  \n[3] Enable Ref B manual profile  Same as Register 0503, Bit 7 but for REF B  \n[2:0] Ref B manual profile  Same as Register 0503, Bits[ 6:4] but for REF B  \n0x0505 [7] Enable Ref CC manual profile  Same as Register 0503, Bit 7 but for REF CC  \n[6:4] Ref CC manual profile  Same as Register 0503, Bits[ 6:4] but for REF CC  \n[3] Enabl e Ref C manual profile  Same as Register 050, Bit 7 but for REF C \n[2:0] Ref C manual profile  Same as Register 0503, Bits[ 6:4] but for REF C  \n0x0506 [7] Enable Ref DD M  manual profile  Same as Register 0503, Bit 7 but for REF DD  \n[6:4] Ref DD manual profil e Same as Register 0503, Bits[ 6:4] but for REF DD  \n[3] Enable Ref D manual profile  Same as Register 0503 , Bit 7 but for REF D  \n[2:0] Ref D manual profile  Same as Register 0503, Bits[ 6:4] but for REF D  \nRev. G | Page 82 of 111 \nData Sheet AD9548 \n \nTable 78. Phase Build -Out Sw itching  \nAddress  Bits Bit Name  Description  \n0x0507 [7:3] Unused   \n[2:0] Phase master \nthreshold \npriority  Threshold priority level ( a value of 0 to 7, with 0 (default) being the highest priority level).  References \nwith a s election priority value lower than t his value are treated as phase masters (see the Profile \nRegisters (Register 0 X0600 to Register 0X07FF)  section for the selection priority value ). \nPROFILE REGISTERS (REG ISTER 0 x0600 TO REG ISTER  0x07FF ) \nNote that t he default value  of every bit is 0 for Profile 0  to Profile 7. \nRegister 0x0600 to Register 0x0631—Profile 0 \nTable 79. Priorities— Profile 0  \nAddress  Bits Bit Name  Description  \n0x0600 [7] Phase lock \nscale  Controls the phase lock threshold unit scaling . \n0 = picoseconds . \n1 = nanoseconds . \n[6] Unused   \n[5:3] Promoted \npriority  User assigned p riority level (0  to 7) of the reference associated with  Profile 0 while that  reference is the \nactive reference.  The numeric value of the promoted priority must be less than or equal to the numeric \nvalue of the selection priority.  \n[2:0] Selectio n \npriority  User assigned priority level (0  to 7) of the reference associated with Profile 0 , which  ranks that reference \nrelative to the others . \nTable 80. Reference Period —Profile 0  \nAddress  Bits Bit Name  Description  \n0x0601 [7:0] Reference p eriod  (in femtoseconds ) Nominal reference period , Bits [7:0] \n0x0602 [7:0] Nominal reference period , Bits [15:8]  \n0x0603 [7:0] Nominal reference period , Bits [23:16]  \n0x0604 [7:0] Nominal reference period , Bits [31:24]  \n0x0605 [7:0] Nominal reference period , Bits [39:32]  \n0x0606 [7:0] Nominal reference period , Bits [47:40]  \n0x0607 [7:2] Unused   \n[1:0] Reference p eriod  Nominal reference period , Bits [49:48]  \nTable 81. Tolerance— Profile 0  \nAddress  Bits Bit Name  Description  \n0x0608 [7:0] Inner t olerance  Inner tolerance , Bits [7:0] \n0x0609 [7:0] Inner tolerance , Bits [15:8]  \n0x060A  [7:4] Unused   \n[3:0] Inner t olerance  Inner tolerance , Bits [19:16]  \n0x060B  [7:0] Outer t olerance  Outer tolerance , Bits [7:0] \n0x060C  [7:0] Outer tolerance , Bits [5:8] \n0x060D  [7:4] Unused   \n[3:0] Outer t olerance  Outer tolerance , Bits [19:16]  \nTable 82. Validation Timer —Profile 0  \nAddress  Bits Bit Name  Des cription  \n0x060E  [7:0] Validation t imer  (in milliseconds ) Validation timer , Bits [7:0] \n0x060F [7:0] Validation timer , Bits [15:8]  \nTable 83. Redetect Timer —Profile 0  \nAddress  Bits Bit Name  Description  \n0x0610 [7:0] Redetect t imer  (in milliseconds)  Redetect timer , Bits [7:0] \n0x0611  [7:0] Redetect timer , Bits [15:8 ] \nRev. G | Page 83 of 111 \nAD9548 Data Sheet \n \nTable 84. Digital Loop Filter Coefficients —Profile 01 \nAddress  Bits Bit Name  Description  \n0x0612 [7:0] Alpha -0 linear  Alpha -0 coefficient linear , Bits[7:0] \n0x0613  [7:0] Alpha -0 coefficient linear , Bits [15:8 ] \n0x0614 [7:6] Alpha -2 exponent  Alpha -2 coefficient exponent , Bits [1:0] \n[5:0] Alpha -1 exponent  Alpha -1 coefficient exponent , Bits [5:0] \n0x0615 [7:1] Beta -0 linear  Beta -0 coefficient linear , Bits [6:0] \n[0] Alpha -2 exponent  Alpha -2 coefficient exponent , Bit 2 \n0x0616 [7:0] Beta -0 linear  Beta -0 coefficie nt linear, B its[14:7]  \n0x617 [7] Unused   \n[6:2] Beta -1 exponent  Beta -1 coefficient exponent , Bits[4:0] \n[1:0] Beta -0 linear  Beta -0 coefficient linear , Bits[16:15]  \n0x0618 [7:0] Gamma -0 linear  Gamma -0 coefficient linear , Bits[7:0] \n0x0619 [7:0] Gamma -0 coefficient linear , Bits[15:8]  \n0x061A  [7:6] Unused   \n[5:1] Gamma -1 exponent  Gamma -1 coefficient exponent , Bits[4:0] \n[0] Gamma -0 linear  Gamma -0 coefficient linear , Bit 16  \n0x061B  [7:0] Delta -0 linear  Delta -0 coefficient linear , Bits[7:0] \n0x061C [7] Delta-1 exponent  Delta -1 coefficient exponent , Bit 0 \n[6:0] Delta -0 linear  Delta -0 coefficient linear , Bits[14:8]  \n0x061D  [7:4] Alpha -3 exponent  Alph a-3 coefficient exponent , Bits[3:0] \n[3:0] Delta -1 exponent  Delta -1 coefficient exponent , Bits[4:1] \n1 The digital loop  filter c oefficients (α, β, γ, and δ) have the general form: x(2y), where x is the linear component and y is the exponential component of the coefficient. \nThe value of the linear component (x) constitutes a fraction, where 0 ≤ x < 1. The exponential component (y) i s an integer. See the Calculating Digital Filter Coefficients  \nsection for details.  \nTable 85. R-Divider —Profile 01 \nAddress  Bits Bit Name  Description  \n0x061E  [7:0] R R, Bits[7:0] \n0x061F  [7:0] R, Bits[15:8 ] \n0x0620 [7:0] R, Bits[23:16]  \n0x0621 [7:6] Unused   \n[5:0] R R, Bits[29:24 ] \n1 The value stored in the R -divider register yields an actual divide ratio of one more than the programmed value.  \nTable 86. S -Divider —Profile 01 \nAddress  Bits Bit Name  Description  \n0x0622 [7:0] S S, Bits[7:0] \n0x0623 [7:0] S, Bits[15:8]  \n0x0624 [7:0] S, Bits[23:16]  \n0x0625 [7:6] Unused   \n[5:0] S S, Bits[29:24]  \n1 The value stored in the S -divid er register yields an actual divide ratio of one more than the programmed value. Furthermore, the value of S must be at least  7. \n \nRev. G | Page 84 of 111  \n \n \nData Sheet AD9548 \n \nTable 87. Fractional Feedback Divider —Profile 0 \nAddress  Bits Bit Name  Description  \n0x0626 [7:0] V V, Bits[7:0] \n0x0627  [7:4] U U, Bits[3:0] \n[3:2] Unused   \n[1:0] V V, Bits[9:8] \n0x0628 [7:6] Unused   \n[5:0] U U, Bits[9:4] \nTable 88. Lock Detectors —Profile 0  \nAddress  Bits Bit Name  Description  \n0x0629 [7:0] Phase l ock threshold  (units determined by Register 0x 0600[7] ) Phase lock threshold , Bits[7:0] \n0x062A  [7:0] Phase lock threshold, Bits[ 15:8]  \n0x062B  [7:0] Phase l ock fill rate Phase lock fill rate , Bits[7:0] \n0x062C [7:0] Phase l ock drain rate Phase lock drain rate , Bits[7:0] \n0x062D  [7:0] Frequency lock t hresh -old (in picoseconds ) Frequency lock threshold , Bits[7:0] \n0x062E  [7:0] Frequency lock threshold , Bits[15:8]  \n0x062F  [7:0] Frequency lock threshold , Bits[23:16 ] \n0x0630 [7:0] Frequency lock f ill rate  Frequency lock fill rate , Bits[7:0] \n0x0631 [7:0] Frequency lock drain r ate Frequency lock drain rate , Bits[7:0] \nRegister 0x0632 to Register 0x067F—Profile 1 \nTable 89. Priorities— Profile 1  \nAddress  Bits Bit Name  Description  \n0x0632 [7] Phase lock \nscale  Controls the phase lock threshold unit scaling.  \n0 = picoseconds . \n1 = nanoseconds . \n[6] Unused   \n[5:3]  Promoted priority  User assigned priority level (0 to 7) of the reference associated with Profile 1 while that reference is the \nactive reference. The numeric value of the promoted priority must be less than or equal to the numeric \nvalue of t he selection priority.  \n[2:0]  Selection priority  User assigned priority level (0 to 7) of the reference associated with Profile 1, which ranks that reference \nrelative to the others.  \nTable 90. Reference Period —Profile 1  \nAddress  Bits Bit Name  Description  \n0x0633 [7:0] Reference p eriod  (in femtoseconds)  Nominal reference period , Bits[7:0] \n0x634 [7:0] Nominal reference period , Bits[15:8]  \n0x0635 [7:0] Nominal reference period , Bits[23:16]  \n0x0636 [7:0] Nominal reference period , Bits[31:24]  \n0x0637 [7:0] Nominal reference period , Bits[39:32]  \n0x0638 [7:0] Nominal reference period , Bits[47:40]  \n0x0639  [7:2] Unused   \n[1:0] Reference period  Nominal reference period , Bits[49:48]  \nRev. G | Page 85 of 111 \nAD9548 Data Sheet \n \nTable 91. Tolerance— Profile 1  \nAddress  Bits Bit Name  Description  \n0x063A  [7:0] Inner t olerance  Inner tolerance , Bits[7:0] \n0x063B  [7:0] Inner tolerance , Bits[ 15:8 ] \n0x063C [7:4] Unused   \n[3:0] Inner t olerance  Inner tolerance , Bits[19:16]  \n0x063D  [7:0] Outer tolerance  Outer tolerance , Bits[7:0] \n0x063E  [7:0] Outer tolerance , Bits[ 15:8]  \n0x063F [7:4] Unused   \n[3:0] Outer t olerance  Outer tolerance , Bits[19:16]  \nTable 92. Validation Timer —Profile 1  \nAddress  Bits Bit Name  Description  \n0x0640 [7:0] Validation t imer  (in milliseconds ) Validation timer , Bits[7:0] \n0x0641 [7:0] Validation timer , Bits[15:8]  \nTable 93. Redetect Timer —Profile 1  \nAddress  Bits Bit Name  Description  \n0x0642 [7:0] Redetect t imer  (in milliseconds)  Redetect timer , Bits[7:0] \n0x0643 [7:0] Redetect timer , Bits[15:8]  \nTable 94. Digital Loop Filter  Coefficients —Profile 11 \nAddress  Bits Bit Name  Description  \n0x0644 [7:0] Alpha -0 linear  Alpha -0 coefficient linear , Bits[7:0] \n0x0645 [7:0] Alpha -0 coefficient linear , Bits[15:8]  \n0x0646 [7:6] Alpha -2 exponent  Alpha -2 coefficient exponent , Bits[1:0] \n[5:0] Alpha -1 exponent  Alpha -1 coefficient exponent , Bits[5:0] \n0x0647 [7:1] Beta -0 linear  Beta -0 coefficient linear , Bits[6:0] \n[0] Alpha -2 exponent  Alpha -2 coef ficient exponent , Bit 2 \n0x0648  [7:0] Beta -0 linear  Beta -0 coefficient linear , Bits[14:7 ] \n0x0649 [7] Unused   \n[6:2] Beta -1 exponent  Beta -1 coefficient exponent , Bits[4:0] \n[1:0] Beta -0 linear  Beta -0 coefficient linear , Bits[16:15 ] \n0x064A  [7:0] Gamma -0 linear  Gamma -0 coefficient linear , Bits[7:0] \n0x064B  [7:0] Gamma -0 coefficient linear , Bits[15:8] \n0x064C  [7:6] Unused   \n[5:1] Gamma -1 exponent  Gamma -1 coefficient exponent , Bits[4:0] \n[0] Gamma -0 linear  Gamma -0 coefficient linear , Bit 16  \n0x064D  [7:0] Delta -0 linear  Delta -0 coefficient linear , Bits[7:0] \n0x064E  [7] Delta -1 exponent  Delta -1 coefficient exponent , Bit 0 \n[6:0] Delta -0 linear  Delta -0 coefficient linear , Bits[14:8]  \n0x064F [7:4] Alpha -3 exponent  Alpha -3 coefficient exponent , Bits[3:0] \n[3:0] Delta -1 exponent  Delta -1 coefficient exponent , Bits[4:1] \n1 The digital loop filter coefficients (α, β, γ, and δ) have the general form: x(2y), where x is the linear component and y is the exponential component of the coefficient. \nThe value of the linear component (x) constitutes a fraction, where 0 ≤ x < 1. The e xponential component (y) is an integer. See the Calculating Digital Filter Coefficients  \nsection for details.  \n \nRev. G | Page 86 of 111  \nData Sheet AD9548 \n \nTable 95. R-Divider —Profile 11 \nAddress  Bits Bit Name  Description  \n0x0650 [7:0] R R, Bits[7:0] \n0x0651  [7:0] R, Bits[15:8 ] \n0x0652 [7:0] R, Bits[23:16]  \n0x0653 [7:6] Unused   \n[5:0] R R, Bits[29:24]  \n1 The value stored in the R -divider register yields an actual divide ratio of one more than the programmed value.  \nTable 96. S-Divider —Profile 11 \nAddress  Bits Bit Name  Description  \n0x0654 [7:0] S S, Bits[7:0] \n0x0655 [7:0] S, Bits[15:8]  \n0x0656 [7:0] S, Bits[23:16]  \n0x0657 [7:6] Unused   \n[5:0] S S, Bits[29:24]  \n1 The v alue stored in the S -divider register yields an actual divide ratio of one more than the programmed value. Furthermore, the value of S must be at least 7.  \nTable 97. Fractional Feedback Divider —Profile 1 \nAddress  Bits Bit Name  Description  \n0x0658 [7:0] V V, Bits[7:0] \n0x0659 [7:4] U U, Bits[3:0] \n[3:2] Unused   \n[1:0] V V, Bits[9:8] \n0x065A  [7:6] Unused   \n[5:0] U U, Bits[9:4] \nTabl e 98. Lock Detectors —Profile 1  \nAddress  Bits Bit Name  Description  \n0x065B  [7:0] Phase lock threshold  (units determined by Register 0x0632[7])  Phase lock threshold , Bits[7:0] \n0x065C [7:0] Phase lock threshold , Bits[15:8]  \n0x065D  [7:0] Phase l ock fill rate Phase lock fill rate , Bits[7:0] \n0x065E  [7:0] Phase l ock drain rate Phase lock drain rate , Bits[7:0] \n0x065F [7:0] Frequency lock t hreshold  (in picoseconds ) Frequency lock threshold , Bits[7:0] \n0x0660 [7:0] Frequency lock threshold , Bits[15:8]  \n0x0661 [7:0] Frequency lock threshold , Bits[23:16]  \n0x0662 [7:0] Frequency lock fill rate  Frequency lock fill rate , Bits[7:0] \n0x0663 [7:0] Frequency l ock drain r ate Frequency lock drain rate , Bits[7:0] \n0x0664 to 0x 067F  [7:0] Unused   \nRev. G | Page 87 of 111  \n \nAD9548 Data Sheet \n \nRegis ter 0x0680 to Register 0x06B1—Profile 2 \nTable 99. Priorities— Profile 2  \nAddress  Bits Bit Name  Description  \n0x0680 [7] Phase lock \nscale  Controls the phase lock threshold unit scaling.  \n0 = picoseconds . \n1 = nanoseconds . \n[6] Unused   \n[5:3]  Promoted \npriority  User assigned priority level (0 to 7) of the reference associated with Profile 2 while that reference is the \nactive reference. The numeric value of the promoted priority must be less than or equal to the numeric \nvalue of the selecti on priority.  \n[2:0]  Selection \npriority  User assigned priority level (0 to 7) of the reference associated with Profile 2, which ranks that reference \nrelative to the others.  \nTable 100.  Reference Period —Profile 2  \nAddress  Bits Bit Nam e Description  \n0x0681 [7:0] Reference p erio d (in femtoseconds)  Nominal reference period , Bits[7:0] \n0x0682 [7:0] Nominal reference period , Bits[15:8]  \n0x0683 [7:0] Nominal reference period , Bits[23:16]  \n0x0684 [7:0] Nominal reference period , Bits[31:24]  \n0x0685 [7:0] Nominal reference period , Bits[39:32]  \n0x0686 [7:0] Nominal reference period , Bits[47:40]  \n0x0687 [7:2] Unused   \n[1:0] Reference p eriod  Nominal reference period , Bits[49:48]  \nTable 101.  Tolerance —Profile 2 \nAddress  Bits Bit Name  Description  \n0x0688 [7:0] Inner t olerance  Inner tolerance , Bits[7:0] \n0x0689 [7:0] Inner tolerance, Bits[ 15:8]  \n0x068A  [7:4] Unused   \n[3:0] Inner t olerance  Inner tolerance , Bits[19:16]  \n0x068B  [7:0] Outer t olerance  Outer tolerance , Bits[7:0] \n0x068C [7:0] Outer tolerance , Bits[ 15:8]  \n0x068D  [7:4] Unused   \n[3:0] Outer t olerance  Outer tolerance , Bits[19:16]  \nTable 102.  Validation Timer —Profile 2  \nAddress  Bits Bit Name  Description  \n0x068E  [7:0] Validation t imer  (in milliseconds ) Validation timer , Bits[7:0] \n0x068F [7:0] Validation timer , Bits[15:8]  \nTable 103.  Redetect Timer —Profile 2  \nAddress  Bits Bit Name  Description  \n0x0690 [7:0] Redetect t imer  (in milliseconds)  Redetect timer , Bits[7:0] \n0x0691 [7:0] Redetect timer , Bits[15:8]  \nRev. G | Page 88 of 111 \nData Sheet AD9548 \n \nTable 104.  Digital Loop Filter  Coefficients —Profile 21 \nAddress  Bits Bit Name  Description  \n0x0692 [7:0] Alpha -0 linear  Alpha -0 coefficient linear , Bits[7:0] \n0x0693  [7:0] Alpha -0 coefficient line ar, Bits[15:8 ] \n0x0694 [7:6] Alpha -2 exponent  Alpha -2 coefficient exponent , Bits[1:0]  \n[5:0] Alpha -1 exponent  Alpha -1 coefficient exponent , Bits[5:0]  \n0x0695  [7:1] Beta -0 linear  Beta -0 coefficient linear , Bits[ 6:0] \n[0] Alpha-2 exponent  Alpha -2 coefficient exponent , Bit 2  \n0x0696 [7:0] Beta 0-linear  Beta -0 coefficient linear , Bits[14:7]  \n0x0697 [7] Unused   \n[6:2] Beta -1 exponent  Beta -1 coefficient exponent , Bits[4:0]  \n[1:0] Beta -0 linear  Beta -0 coefficient linear , Bits[ 16:15]  \n0x0698 [7:0] Gamma -0 linear  Gamma -0 coefficient linear , Bits[ 7:0] \n0x0699 [7:0] Gamma -0 coefficient linear , Bits[ 15:8]  \n0x069A  [7:6] Unused   \n[5:1] Gamma -1 exponent  Gamma -1 coefficient exponent , Bits[4:0]  \n[0] Gamma -0 linear  Gamma -0 coefficient linear , Bit 6 \n0x069B  [7:0] Delta -0 linear  Delta -0 coefficient linear , Bits[7:0]  \n0x069C [7] Delta -1 exponent  Delta -1 coefficient exponent , Bit 0 \n[6:0] Delta -0 linear  Delta -0 coefficient linear , Bits[ 14:8]  \n0x069D  [7:4] Alpha -3 exponent  Alpha -3 coefficient exponent , Bits[3:0]  \n[3:0] Delta-1 exponent  Delta -1 coefficient exponent , Bits[ 4:1] \n1 The digital loop filter coefficients (α, β, γ, and δ) have the general form: x(2y), where x is the linear component and y is the exponential component of the coefficient. \nThe value of the linear component (x) constitutes a fraction, where 0 ≤ x < 1. The e xponential component (y) is an integer. See the Calculating Digital Filter Coefficients  \nsection for details.  \nTable 105.  R-Divider —Profile 21 \nAddress  Bits Bit Name  Description  \n0x069E  [7:0] R R, Bits[7:0] \n0x069F  [7:0] R, Bits[15:8 ] \n0x06A0  [7:0] R, Bits[23:16]  \n0x06A1  [7:6] Unused   \n[5:0] R R, Bits[29:24 ] \n1 The value stored in the R -divider register yields an actual divide ratio of one more than the programmed value.  \nTable 106. S -Divider —Profile 21 \nAddress  Bits Bit Name  Description  \n0x06A2  [7:0] S S, Bits[7:0] \n0x06A3  [7:0] S, Bits[15:8]  \n0x06A4  [7:0] S, Bits[23:16]  \n0x06A5  [7:6] Unused   \n[5:0] S S, Bits[29:24]  \n1 The v alue stored in the S -divider register yields an actual divide ratio of one more than the programmed value. Furthermore, the value of S must be at least 7.  \nTable 107.  Fractional Feedback Divider —Profile 2  \nAddress  Bits Bit Name  Description  \n0x06A6  [7:0] V V, Bits[7:0] \n0x06A7  [7:4] U U, Bits[3:0] \n[3:2] Unused   \n[1:0] V V, Bits[9:8] \n0x06A8  [7:6] Unused   \n[5:0] U U, Bits[9:4] \nRev. G | Page 89 of 111  \n \n \nAD9548 Data Sheet \n \nTable 108.  Lock Detectors —Profile 2  \nAddress  Bits Bit Name  Description  \n0x06A9  [7:0] Phase lock threshold  (units determined by Register 0x0680[7])  Phase lock threshold , Bits[ 7:0] \n0x06AA  [7:0] Phase lock threshold , Bits[ 15:8 ] \n0x06AB  [7:0] Phase l ock fill rate Phase lock fill rate , Bits[ 7:0] \n0x06AC  [7:0] Phase l ock drain rate Phase lock drain rate , Bits[ 7:0] \n0x06AD  [7:0] Frequency lock t hresh -old (in picosecon ds) Frequency lock threshold , Bits[ 7:0] \n0x06AE  [7:0] Frequency lock threshold , Bits[ 15:8]  \n0x06AF  [7:0] Frequency lock threshold , Bits[ 23:16]  \n0x06B0 [7:0] Frequency l ock fill rate  Frequency lock fill rate , Bits[ 7:0] \n0x06B1 [7:0] Frequency l ock drain r ate Frequency lock drain rate , Bits[ 7:0] \nRegister 0x06B2  to Register 0x07FF—Prof ile 3  \nTable 109.  Priorities— Profile 3 \nAddress  Bits Bit Name  Description  \n0x06B2 [7] Phase lock \nscale  Controls the phase lock threshold unit scaling.  \n0 = picoseconds . \n1 = nanoseconds . \n[6] Unused   \n[5:3]  Promoted priority  User assigned priority level (0 to 7) of the reference associated with Profile 3 while that reference is the \nactive reference. The numeric value of the promoted priority must be less than or equal to the numeric \nvalue of the selection priority.  \n[2:0]  Selection \npriority  User assigned priority level (0 to 7) of the reference associated with Profile 3, which ranks that reference \nrelative to the others.  \nTable 110.  Reference Period —Profile 3  \nAddress  Bits Bit Name  Description  \n0x06B3 [7:0] Refer ence p eriod  (in femtoseconds)  Nominal reference period , Bits[7:0] \n0x06B4 [7:0] Nominal reference period , Bits[15:8]  \n0x06B5 [7:0] Nominal reference period , Bits[ 23:16]  \n0x06B6 [7:0] Nominal reference period , Bits[31:24]  \n0x06B7 [7:0] Nominal reference period , Bits[39:32]  \n0x06B8 [7:0] Nominal reference period , Bits[47:40]  \n0x06B9 [7:2] Unused   \n[1:0] Reference p eriod  Nominal reference period , Bits[49:48]  \nTable 111.  Tolerance —Profile 3 \nAddress  Bits Bit Name  Description  \n0x06BA  [7:0] Inner t olerance  Inner tolerance , Bits[ 7:0] \n0x06BB  [7:0] Inner tolerance , Bits[ 15:8 ] \n0x06BC [7:4] Unused   \n[3:0] Inner tolerance  Inner tolerance , Bits[ 19:16]  \n0x06BD  [7:0] Outer tolerance  Outer tolerance , Bits[ 7:0] \n0x06BE  [7:0] Outer tolerance , Bits[ 15:8]  \n0x06BF [7:4] Unused   \n[3:0] Outer tolerance  Outer tolerance , Bits[ 19:16 ] \nTable 112.  Validation Timer —Profile 3  \nAddress  Bits Bit Name  Description  \n0x06C0 [7:0] Validation t imer  (in milliseconds ) Validation timer , Bits[7:0] \n0x06C1 [7:0] Validation timer , Bits[15:8]  \nRev. G | Page 90 of 111 \nData Sheet AD9548 \n \nTable 113.  Redetect Timer —Profile 3  \nAddress  Bits Bit Name  Description  \n0x06C2 [7:0] Redetect timer  (in milliseconds)  Redetect timer , Bits[7:0] \n0x06C3  [7:0] Redetect timer , Bits[15:8] \nTable 114.  Digital Loop Filter  Coefficients —Profile 31 \nAddress  Bits Bit Name  Description  \n0x06C4 [7:0] Alpha -0 linear  Alpha -0 coefficient linear , Bits[ 7:0] \n0x06C5 [7:0] Alpha -0 coefficient linear , Bits[ 15:8]  \n0x06C6 [7:6] Alph a-2 exponent  Alpha -2 coefficient exponent , Bits[ 1:0] \n[5:0] Alpha -1 exponent  Alpha -1 coefficient exponent , Bits[ 5:0] \n0x06C7 [7:1] Beta -0 linear  Beta -0 coefficient linear , Bits[ 6:0] \n[0] Alpha -2 exponent  Alpha -2 coefficient exponent , Bit 2 \n0x06C8 [7:0] Beta -0 linear  Beta -0 coefficient linear , Bits[ 14:7]  \n0x06C9 [7] Unused   \n[6:2] Beta -1 exponent  Beta -1 coefficient exponent , Bits[ 4:0] \n[1:0] Beta -0 linear  Beta -0 coefficient linear , Bits[ 16:15]  \n0x06CA  [7:0] Gamma -0 linear  Gamma -0 coefficient linear , Bits[7:0] \n0x06CB  [7:0] Gamma -0 coefficient linear , Bits[ 15:8]  \n0x06CC  [7:6] Unused   \n[5:1] Gamma -1 exponent  Gamma -1 coefficient exponent , Bits[ 4:0] \n[0] Gamma -0 linear  Gamma -0 coefficient linear , Bit 16 \n0x06CD  [7:0] Delta -0 linear  Delta -0 coefficient lin ear, Bits[7:0]  \n0x06CE  [7] Delta-1 exponent  Delta -1 coefficient exponent , Bit 0 \n[6:0] Delta -0 linear  Delta -0 coefficient linear , Bits[14:8]  \n0x06CF [7:4] Alpha -3 exponent  Alpha -3 coefficient exponent , Bits[3:0]  \n[3:0] Delta -1 exponent  Delta -1 coefficien t exponent , Bits[4:1]  \n1 The digital loop filter coefficients (α, β, γ, and δ) have the general form: x(2y), where x is the linear component and y is the exponential component of the coefficient. \nThe value of the linear component (x) constitutes a fraction, where 0 ≤ x < 1. The e xponential component (y) is an integer. See the Calculating Digital Filter Coefficients  \nsection for details.  \nTable 115.  R Divider —Profile 31 \nAddress  Bits Bit Name  Description  \n0x06D0  [7:0] R R, Bits[7:0] \n0x06D1  [7:0] R, Bits[15:8]  \n0x06D2  [7:0] R, Bits[23:16]  \n0x06D3  [7:6] Unused   \n[5:0] R R, Bits[29:24]  \n1 The value stored in the R -divider register yields an actual divide ratio of one more than the programmed value.  \nTable  116.  S Divider —Profile 31 \nAddress  Bits Bit Name  Description  \n0x06D4  [7:0] S S, Bits[7:0] \n0x06D5  [7:0] S, Bits[15:8]  \n0x06D6  [7:0] S, Bits[23:16]  \n0x06D7  [7:6] Unused   \n[5:0] S S, Bits[29:24]  \n1 The v alue stored in the S -divider register yields an actual divide ratio of one more than the programmed value. Furthermore, the value of S must be at least 7.  \n \nRev. G | Page 91 of 111  \n \n \nAD9548 Data Sheet \n \nTable 117.  Fractional Feedback Divider —Profile 3  \nAddress  Bits Bit Name  Description  \n0x06D8  [7:0] V V, Bits[7:0] \n0x06D9  [7:4] U U, Bits[3:0] \n[3:2] Unused   \n[1:0] V V, Bits[9:8] \n0x06DA  [7:6] Unused   \n[5:0] U U, Bits[9:4] \nTable 118.  Lock Detectors —Profile 3  \nAddress  Bits Bit Name  Description  \n0x06DB  [7:0] Phase lock threshold  (units determined by Register 0x06B2[7])  Phase lock threshold , Bits[ 7:0] \n0x06DC [7:0] Phase lock threshold , Bits[ 15:8]  \n0x06DD  [7:0] Phase l ock fill rate Phase lock fill rate , Bits[ 7:0] \n0x06DE  [7:0] Phase l ock drain rate Phase lock drain rate , Bits[ 7:0] \n0x06DF [7:0] Frequency lock t hresh -old (in picosecond s) Frequency lock threshold , Bits[ 7:0] \n0x06E0  [7:0] Frequency lock threshold , Bits[ 15:8]  \n0x06E1  [7:0] Frequ ency lock threshold , Bits[ 23:16]  \n0x06E2  [7:0] Frequency l ock fill rate  Frequency lock fill rate , Bits[ 7:0] \n0x06E3  [7:0] Frequency l ock drain r ate Frequency lock drain rate , Bits[ 7:0] \n0x06E4  to 0x06FF  [7:0] Unused   \nRegister 0x0700 to Register 0x07FF—Profile  4 to Profile 7 \nProfile 4 (Register 0x 0700 to Register 0x 0731) is i dentical t o Profile 0 (Register 0x 0600 to Register  0x0631).  \nProfile 5 (Register 0x 0732 to Register  0x077F) is identical to Profile 1 (Register 0x 0632 to Register 0x 067F).  \nProfile 6 (Reg ister 0x0780 to Register 0x 07B1) is identical to Profile 2 (Register 0x 0680 to Register 0x 06B1).  \nProfile 7 (Register 0x 07B2 to Register 0x 07FF) is i dentical to Profile 3 (Register  0x06B2 to Register 0x 06FF). \nOPERATIONAL CONTROLS  (REG ISTER  0x0A00 TO REG ISTE R 0x0A10)  \nTable 119.  General Power -Down  \nAddress  Bits Bit Name  Description  \n0x0A00  [7] Reset s ans reg map  Reset internal hardware  but retain programmed register values . \n0 (default) = normal operation.  \n1 = reset . \n[6] Unused   \n[5] SYSCLK  power -down  Place  SYSCLK  input and PLL in deep sleep mode . \n0 (default) = normal operation.  \n1 = power -down . \n[4] Reference power -down  Place  reference clock inputs in deep sleep mode . \n0 (default) = normal operation.  \n1 = power -down . \n[3] TDC power -down  Place  the time -to-digital converter in deep sleep mode . \n0 (default) = normal operation.  \n1 = power -down . \n[2] DAC power -down  Place  the DAC in deep sleep mode . \n0 (default) = normal operation.  \n1 = power -down . \n[1] Dist power -down  Place  the clock distribution outputs in deep sleep mode.  \n0 (default) = normal operation.  \n1 = power -down . \n[0] Full power -down  Place  the entire device in deep sleep mode.  \n0 (default) = normal operation.  \n1 = power -down . \nRev. G | Page 92 of 111 \nData Sheet AD9548 \n \nTable 120.  Loop Mode  \nAddress  Bits Bit Name  Description  \n0x0A01  [7] Unused   \n[6] User \nholdover  Force the device into holdover mode . \n0 (default) = normal operation.  \n1 = force device into holdover mode . \nThe de vice behaves as though all input references are faulted . \n[5] User f ree-run  Force the device into free -run mode.  \n0 (default) = normal operation.  \n1 = f orce device into free -run mode . \nThe f ree running frequency tuning word register specifies the DDS output frequency.  Note that, w hen \nthe user free-run  bit is set, it overrides the user holdover  bit. \n[4:3] User \nselection \nmode  Select the operating mode of the reference switching state machine . \n00 (default) = automatic mode . The fully automatic priority -based algorithm  selects the active reference \n(Bits[2 :0] are ignored).  \n01 = f allback mode . The active reference is the user r eference ( Bits[2:0]) as long as it is valid.  Otherwise, \nuse the fully automatic priority -based algorithm to select the active reference.  \n10 = h oldover mode . The active reference is the u ser reference ( Bits[2:0]) as long as it is valid.  Otherwise, \nenter holdover mode . \n11 = m anual mode . The active reference is always the u ser reference ( Bits[2:0]). When using manual  \nmode, be sure that the reference declared as the user reference (Bits[2:0]) is programmed for manual reference -to-profile assignment in the appropriate manual reference profile selection register  (Address \n0503 to Address 0506) . \n[2:0] User reference \nselection  Input reference when u ser selection mode = 01, 10, or 11. \n000 (default) = Input R eference A . \n001 = Input R eference AA . \n010 = Input R eference B . \n011 = Input R eference BB . \n100 = Input R eference C . \n101 = Input R eference CC . \n110 = Input R eference D . \n111 = Inp ut R eference DD . \nTable 121.  Cal/Sync  \nAddress  Bits Bit Name  Description  \n0x0A02  [7:2] Unused   \n[1] Sync \ndistribution  Setting this bit (default  = 0) initiates synchronization of the c lock distribution output.  While this bit = 1, \nthe c lock distribution output stalls . Synchronization occurs on the 1  to 0 transition of this bit . \n[0] Calibrate  \nsystem c lock  A 0 to 1 transition on this bit (default = 0), followed by an IO_UPDATE, initiates an internal calibration of \nthe SYSCLK PLL (assuming it is enabled). The calibration routine automatically selects the proper VCO \nfrequency band and signal ampl itude. The internal system clock stalls during the calibration procedure, \ndisabling the device until the calibration is complete (a few milliseconds). If the user wishes to \nrecalibrate the SYSCLK PLL and this bit is already set to 1, the user must first wr ite a 0 to this bit, issue an \nIO_UPDATE, write a 1 to this bit, and issue another IO_UPDATE.  \n \nRev. G | Page 93 of 111 \nAD9548 Data Sheet \n \nRegister 0x0A03 —ResetFunc  \nTable 122.  Reset Functions1 \nAddress  Bits Bit Name  Description  \n0x0A03  [7] Unused   \n[6] Clear LF  Setting this b it (default = 0) clears the digital loop filter (intended as a debug tool).  \n[5] Clear CCI  Setting this bit (default = 0) clears the CCI filter (intended as a debug tool).  \n[4] Clear phase \naccumulator  Setting this bit (default = 0) clears DDS phase accumulator (not a recommended action).  \n[3] Reset a uto \nsync Setting this bit (default = 0) resets the automatic synchronization logic (see Register  0x0403).  \n[2] Reset TW history  Setting this bit (default = 0) resets the tuning word history logic (part of holdover functionality).  \n[1] Reset a ll IRQs  Setting this bit (default = 0) clears the entire IRQ monitor register (Register 0x 0D02 to Register 0x 0D09). \nIt is the equivalent of s etting all the bits of the IRQ c learing register (Register 0x 0A04 to Register \n0x0A0B). \n[0] Reset watchdog  Setting this bit (default = 0) resets the watchdog timer (see Register 0x 0211 to Register 0x 0212). If the \ntimer had timed out, it simply starts a new timing cycle.  If the timer has not yet timed out, it restarts at \ntime zero without causing a timeout event.  Continuously resetting the watchdog timer at intervals le ss \nthan its timeout period prevent s the watchdog timer from generating a timeout event.  \n1 All bits in this register are autoclearing.  \nRegister 0x0A04 to Register 0x0A0B —IRQ Clearing  \nThe IRQ c learing registers are  identical in format to the IRQ m onitor registers ( Address 0x 0D02  to Address  0x0D09).  When set to Logic \n1, an IRQ c learing bit resets the corresponding IRQ m onitor bit, thereby canceling the interrupt request for the indicated event.  The IRQ \nclearing regis ter is an auto clearing register.  \nTable 123.  IRQ Clearing for SYSCLK  \nAddress  Bits Bit Name  Description  \n0x0A04  [7:6] Unused   \n[5] SYSCLK  unlocked  Clears SYSCLK  unlocked IRQ \n[4] SYSCLK  locked  Clears SYSCLK  locked IRQ \n[3:2]  Unused   \n[1] SYSCLK  Cal c omplete  Clears SYSCLK  calibration complete IRQ  \n[0] SYSCLK  Cal s tarted  Clears SYSCLK  calibration started IRQ  \nTable 124.  IRQ Clearing for Distribution Sync, Watchdog Timer , and EEPROM  \nAddress  Bits Bit Name  Descr iption  \n0x0A05  [7:4] Unused   \n[3] Distribution s ync Clears distribution s ync IRQ  \n[2] Watchdog t imer  Clears watchdog timer IRQ  \n[1] EEPROM fault  Clears EEPROM fault IRQ  \n[0] EEPROM c omplete  Clears EEPROM c omplete IRQ  \nTable 125.  IRQ Clearing for the Digital PLL  \nAddress  Bits Bit Name  Description  \n0x0A06  [7] Switching  Clears s witching IRQ  \n[6] Closed  Clears closed IRQ  \n[5] Free -run  Clears f ree-run IRQ  \n[4] Holdover  Clears h oldover IRQ \n[3] Freq u nlocked  Clears f requency unlocke d IRQ  \n[2] Freq l ocked  Clears f requency locked IRQ \n[1] Phase unlocked  Clears p hase unlocked IRQ \n[0] Phase l ocked  Clears phase locked IRQ \nRev. G | Page 94 of 111  \nData Sheet AD9548 \n \nTable 126.  IRQ Clearing for History Update, Frequency Limit , and Phase Slew Limit  \nAddress  Bits Bit Name  Description  \n0x0A07  [7:5] Unused   \n[4] History u pdated  Clears h istory updated IRQ  \n[3] Frequency u nclamped  Clears  frequency u nclamped IRQ \n[2] Frequency clamped  Clears frequency c lamped IRQ \n[1] Phase s lew unlimited  Clears p hase slew u nlimited IRQ  \n[0] Phase slew l imited  Clears p hase slew limited IRQ  \nTable 127.  IRQ Clearing for Reference Inputs  \nAddress  Bits Bit Name  Description  \n0x0A08  [7] Ref AA n ew profile  Clears Ref AA n ew profile IRQ  \n[6] Ref AA v alidated  Clears Ref AA v alidated IRQ  \n[5] Ref AA fault cleared  Clears Ref AA fault cleared IRQ  \n[4] Ref AA fault  Clears Ref AA f ault IRQ  \n[3] Ref A n ew profile  Clears Ref A new p rofile IRQ  \n[2] Ref A v alidated  Clears Ref A v alidated IRQ  \n[1] Ref A fault cleared  Clears Ref A f ault cleared IRQ  \n[0] Ref A fault  Clears Ref A f ault IRQ  \n0x0A09  [7] Ref BB n ew profile  Clears Ref BB n ew profile IRQ  \n[6] Ref BB v alidated  Clears Ref BB validated IRQ  \n[5] Ref BB f ault cleared  Clears Ref BB f ault cleared IRQ  \n[4] Ref BB f ault  Clears Ref BB f ault IRQ  \n[3] Ref B new profile  Clears Ref B new profile IRQ  \n[2] Ref B v alidated  Clears Ref B v alidated IRQ  \n[1] Ref B f ault cleared  Clears Ref B f ault cleared IRQ  \n[0] Ref B f ault  Clears Ref B f ault IRQ  \n0x0A0A  [7] Ref CC n ew profile Clears Ref CC n ew profile IRQ  \n[6] Ref CC v alidated  Clears Ref CC v alidated IRQ  \n[5] Ref CC f ault cleared  Clears Ref CC f ault cleared IRQ  \n[4] Ref CC f ault  Clears Ref CC f ault IRQ  \n[3] Ref C n ew profile  Clears Ref C n ew profile IRQ  \n[2] Ref C v alidated  Clears Ref C v alidated IRQ  \n[1] Ref C f ault cleared  Clears Ref C f ault cleared IRQ  \n[0] Ref C f ault  Clears Ref C f ault IRQ  \n0x0A0B  [7] Ref DD n ew profile  Clears Ref DD n ew profile IRQ  \n[6] Ref DD v alidated  Clears Ref DD v alidated IRQ  \n[5] Ref DD fault cleared  Clears Ref DD fault cleared IRQ  \n[4] Ref DD fault  Clears Ref DD f ault I RQ \n[3] Ref D n ew profile  Clears Ref D n ew profile IRQ  \n[2] Ref D v alidated  Clears Ref D v alidated IRQ  \n[1] Ref D fault c leared  Clears Ref D f ault cleared IRQ  \n[0] Ref D fault  Clears Ref D f ault IRQ  \nRev. G | Page 95 of 111 \nAD9548 Data Sheet \n \nTable 128.  Incremental Phase Offset Control \nAddress  Bits Bit Name  Description  \n0x0A0C  [7:3] Unused   \n[2] Reset p hase \noffset  Resets the incremental phase offset to 0.  \nThis is an autoclearing bit.  \n[1] Decr p hase \noffset  Decrements the incremental phase offset by the amoun t specified in the incremental p hase lock offset \nstep size register (Register 0x 0314 to Register 0x 0315).  \nThis is an autoclearing bit.  \n[0] Incr phase \noffset  Increments the increme ntal phase offset by the amount specified in the incremental p hase lock offset \nstep size register (Register 0x 0314 to Register 0x 0315).  \nThis is an autoclearing bit.  \nTable 129.  Reference Profile Selection State Machine Startup1 \nAddr ess Bits Bit Name  Description  \n0x0A0D  [7] Detect DD  Setting this bit starts the profile selection state machin e for I nput Reference DD.  \n[6] Detect D  Setting this bit starts the profile selection state machine for Input Reference D. \n[5] Detect CC  Settin g this bit starts the profile selection state machine for Input Reference CC. \n[4] Detect C  Setting this bit starts the profile selection state machine for Input Reference C. \n[3] Detect BB  Setting this bit starts the p rofile selection state machine for Input Reference BB. \n[2] Detect B  Setting this bit starts the profile selection state machine for Input Reference B. \n[1] Detect AA  Setting this bit starts the profile selection state machine for Input Reference AA. \n[0] Detect A  Setting this bit starts  the profile selection state machine for Input Reference A. \n1 All bits in this register are autoclearing.  \nTable 130.  Reference Validation Override Control s1 \nAddress  Bits Bit Name  Description  \n0x0A0E  [7] Force Timeout DD  Setting this bit emulates a timeout of the validation timer for R eference DD.  \nThis is an autoclearing bit.  \n[6] Force Timeout D  Setting this bit emulates a timeout of the validation timer for Reference D. \nThis is an autoclearing bit.  \n[5] Force Timeout CC  Setting this bit emulates a timeout of the validation timer for Reference  CC. \nThis is an autoclearing bit.  \n[4] Force Timeout C  Setting this bit emulates a timeout of the validation timer for Reference C. \nThis is an autoclearing bit.  \n[3] Force Timeout BB  Setting this bit emulates a timeout of the validatio n timer for Reference BB. \nThis is an autoclearing bit.  \n[2] Force Timeout B  Setting this bit emulates a timeout of the validation timer for Reference B. \nThis is an autoclearing bit.  \n[1] Force Timeout AA  Setting this bit emulates a timeout of the validat ion timer for Reference AA. \nThis is an autoclearing bit.  \n[0] Force Timeout A  Setting this bit emulates a timeout of the validation timer for Reference A. \nThis is an autoclearing bit.  \nRev. G | Page 96 of 111  \nData Sheet AD9548 \n \nAddress  Bits Bit Name  Description  \n0x0A0F  [7] Ref Mon Override DD  Overrides the reference monitor REF fau lt signal for Reference DD (default  = 0, not overridden ). \n[6] Ref Mon Override D  Overrides the reference monitor REF fault  signal for Reference D (default  = 0, not overridden ). \n[5] Ref Mon Override CC  Overrides the reference monitor REF fault  signal fo r Reference CC (default  = 0, not overridden ). \n[4] Ref Mon Override C  Overrides the reference monitor REF fault signal for Reference C (default  = 0, not overridden ). \n[3] Ref Mon Override BB  Overrides the reference monitor REF fault  signal for Reference BB (default  = 0, not overridden ). \n[2] Ref Mon Override B  Overrides the reference monitor REF fault signal for Reference B (default  = 0, not overridden ). \n[1] Ref Mon Override AA  Overrides the reference monitor REF fault  signal for Reference AA (default  = 0, not overridden ). \n[0] Ref Mon Override A  Overrides the reference monitor REF fault signal for Reference  A (default  = 0, not overridden ). \n0x0A10  [7] Ref Mon Bypass DD  Bypasses the reference monitor for R eference DD  (default  = 0, not bypassed ). \n[6] Ref Mon Bypass D  Bypasses the reference monitor for R eference D  (default  = 0, not bypassed ). \n[5] Ref Mon Bypass CC  Bypasses the reference monitor for Reference CC  (default  = 0, not bypassed ). \n[4] Ref Mon Bypass C  Bypasses the reference monitor for R eference C  (default  = 0, not bypassed ). \n[3] Ref Mon Bypass BB  Bypasses the reference monitor for R eference BB  (default  = 0, not bypassed ). \n[2] Ref Mon Bypass B  Bypasses the reference monitor for Reference B  (default  = 0, not bypassed ). \n[1] Ref Mon Bypas s AA  Bypasses the reference monitor for R eference AA  (default  = 0, not bypassed ). \n[0] Ref Mon Bypass A  Bypasses the reference monitor for R eference A  (default  = 0, not bypassed ). \n1 See Figure 36 for details . \n \nCLOCK PART SERIAL ID  (REGISTER 0 x0C00 TO REGISTER 0 x0C07)  \nUser programma ble EEPROM ID registers.  \nTable 131. User Defined Identification Registers  \nAddress  Bits Bit Name  Description  \n0x0C00 [7:0]  User scratch \npad[7:0]  User programmable EEPROM ID registers. These registers enable users to write a unique co de of their \nchoosing to keep track of revisions to the EEPROM register loading. It has no effect on part operation.  \nThe default EEPROM storage sequence must be altered to include these registers. See the Programming \nthe EEPROM to Include a Clock Part ID  section . \n0 = default.  0x0C01 [7:0]  User scratch pad [15:8]  \n0x0C02 [7:0]  User scratch \npad[23:16]  \n0x0C03 [7:0]  User scratch pad[31:24]  \n0x0C04 [7:0]  User scratch pad [39:32]  \n0x0C05 [7:0]  User scratch pad [47:40]  \n0x0C06 [7:0]  User scratch \npad [55:48]  \n0x0C07 [7:0]  User scratch \npad [63:56]  \n \nSTATUS READBACK (REGISTER 0 x0D00 TO REGISTER 0 x0D19)  \nAll bits in Register 0x0D00 to Register 0x 0D19 are read only.  Register 0x0D00 and Register 0x0D01 require an IO_UPDATE  \n(Register 0x0005 = 0x01) in order to reflect their latest status.  \nTable 132.  EEPROM Status  \nAddress  Bits Bit Name  Description  \n0x0D00  [7:3] Unused   \n[2] Fault d etected  An error occurred while saving data to or loading data from the EEPROM.  \n[1] Load  in progress  The control logic sets this bit while data is being read from the EEPROM.  \n[0] Save i n progress  The control logic sets this bit while data is being written to the EEPROM.  \nRev. G | Page 97 of 111  \nAD9548 Data Sheet \n \nTable 133.  SYSCLK  Status  \nAddress  Bits Bit Name  Description  \n0x0D01  [7:5] Unused   \n[4] Stable  The control logic sets this bit when the device considers the system clock to be stable (see the System \nClock Stability Timer  section ). \n[3:2]  Unused   \n[1] Cal i n \nprogress  The con trol logic holds this bit set while the system clock calibration is in progress.  \n[0] Lock \ndetected  Indicates the status of the system clock PLL.  \n0 = unlocked . \n1 = locked (or the PLL is disabled) . \nRegister 0x0D02 to Register 0x0D09—IRQ Monitor  \nIf not mas ked via the IRQ m ask register ( Address 0x0209 to Address 0x 0210), then the appropria te IRQ monitor bit is set to a L ogic 1 \nwhen the indicated event occurs.  These bits c an only be cleared via the IRQ c learing register ( Address 0x0A04 to Address 0x 0A0B), the  \nreset all IRQs bit (Register 0x 0A03, Bit 1), or a device reset.  \nTable 134.  IRQ Monitor for SYSCLK  \nAddress  Bits Bit Name  Description  \n0x0D02  [7:6] Unused   \n[5] SYSCLK  unlocked  Indicates a SYSCLK  PLL state transition from locked to unlocked  \n[4] SYSCLK  locked  Indicates a SYSCLK  PLL state transition from unlocked to locked  \n[3:2]  Unused   \n[1] SYSCLK  Cal c omplete  Indicates that SYSCLK  calibration has completed  \n[0] SYSCLK  Cal s tarted  Indicates that SYSCLK  calibration has begun  \nTable 135.  IRQ Monitor for Distribution Sync, Watchdog Timer , and EEPROM  \nAddress  Bits Bit Name  Description  \n0x0D03  [7:4] Unused   \n[3] Distribution s ync Indicates a distribution sync event  \n[2] Watchdog timer  Indicates expiration of t he watchdog timer  \n[1] EEPROM fault  Indicates a fault during an EEPROM load or save operation  \n[0] EEPROM c omplete  Indicates successful completion of an EEPROM load or save operation  \nTable 136.  IRQ Monitor for the Digital PLL  \nAdd ress  Bits Bit Name  Description  \n0x0D04  [7] Switching  Indicates that the DPLL is switching to a new reference  \n[6] Closed  Indicates that the DPLL has entered closed -loop operation  \n[5] Free -run  Indicates that the DPLL has entered free -run mode  \n[4] Holdo ver Indicates that the DPLL has entered holdover mode  \n[3] Freq u nlocked  Indicates that the DPLL lost frequency lock  \n[2] Freq l ocked  Indicates that the DPLL has acquired frequency lock  \n[1] Phase unlocked  Indicates that the DPLL lost phase lock  \n[0] Phase l ocked  Indicates that the DPLL has acquired phase lock  \nTable 137.  IRQ Monitor for History Update, Frequency Limit,  and Phase Slew Limit  \nAddress  Bits Bit Name  Description  \n0x0D05  [7:5] Unused   \n[4] History u pdated  Indicates th e occurrence of a tuning word history update  \n[3] Freq u nclamped  Indicates a f requency limit er state transition from clamped to unclamped  \n[2] Freq c lamped  Indicates a frequency limiter state transition from unclamped to clamped  \n[1] Phase slew unlimited  Indicates a p hase slew limiter state transition from slew limiting to not slew limiting  \n[0] Phase slew limited  Indicates a p hase slew limiter state transition from not slew limiting to slew limiting  \nRev. G | Page 98 of 111 \nData Sheet AD9548 \n \nTable 138.  IRQ Monitor  for R eference Inputs  \nAddress  Bits Bit Name  Description  \n0x0D06  [7] Ref AA n ew profile  Indicates that Ref AA has switched to a new profile  \n[6] Ref AA validated  Indicates that Ref AA has been validated  \n[5] Ref AA f ault cleared  Indicates that Ref AA has been c leared of a previous fault  \n[4] Ref AA f ault  Indicates that Ref AA has been faulted  \n[3] Ref A new profile  Indicates that Ref A has switched to a new profile  \n[2] Ref A v alidated  Indicates that Ref A has been validated  \n[1] Ref A fault cleared  Indicates that Ref A has been cleared of a previous fault  \n[0] Ref A fault  Indicates that Ref A has been faulted  \n0x0D07  [7] Ref BB n ew profile  Indicates that Ref BB has switched to a new profile  \n[6] Ref BB v alidated  Indicates that Ref BB has been validated  \n[5] Ref BB f ault cleared  Indicates that Ref BB has been cleared of a previous fault  \n[4] Ref BB f ault  Indicates that Ref BB has been faulted  \n[3] Ref B n ew profile  Indicates that Ref B has switched to a new profile  \n[2] Ref B v alidated  Indicates that Ref  B has been validated  \n[1] Ref B f ault cleared  Indicates that Ref B has been cleared of a previous fault  \n[0] Ref B f ault  Indicates that Ref B has been faulted  \n0x0D08  [7] Ref CC n ew profile  Indicates that Ref CC has switched to a new profile  \n[6] Ref C C validated  Indicates that Ref CC has been validated  \n[5] Ref CC fault cleared  Indicates that Ref CC has been cleared of a previous fault  \n[4] Ref CC fault  Indicates that Ref CC has been faulted  \n[3] Ref C n ew profile  Indicates that Ref C has switched t o a new profile  \n[2] Ref C v alidated  Indicates that Ref C has been validated  \n[1] Ref C f ault cleared  Indicates that Ref C has been cleared of a previous fault  \n[0] Ref C fault  Indicates that Ref C has been faulted  \n0x0D09  [7] Ref DD n ew profile  Indicat es that Ref DD has switched to a new profile  \n[6] Ref DD v alidated  Indicates that Ref DD has been validated  \n[5] Ref DD fault cleared  Indicates that Ref DD has been cleared of a previous fault  \n[4] Ref DD fault  Indicates that Ref DD has been faulted  \n[3] Ref D n ew profile  Indicates that Ref D has switched to a new profile  \n[2] Ref D validated  Indicates that Ref D has been validated  \n[1] Ref D f ault cleared  Indicates that Ref D has been cleared of a previous fault  \n[0] Ref D f ault  Indicates that Ref D  has been faulted  \nTable 139.  DPLL Status  \nAddress  Bits Bit Name  Description  \n0x0D0A  [7] Offset s lew limiting  The current closed -loop phase offset is rate limited.  \n[6] Phase build -out A phase build -out transition was made to the cu rrently active reference.  \n[5] Freq lock The DPLL has achieved frequency lock.  \n[4] Phase lock The DPLL has achieved phase lock.  \n[3] Loop s witching  The DPLL is in the process of a reference switchover.  \n[2] Holdover  The DPLL is in holdover mode.  \n[1] Active  The DPLL is active ( that is, operating in a closed -loop condition) . \n[0] Free r unning  The DPLL is free running ( that is, operating in an open- loop condition) . \nRev. G | Page 99 of 111 \nAD9548 Data Sheet \n \n0x0D0B  [7] Frequency clamped  The upper or lower frequency tuning word clamp is in effec t. \n[6] History available  There is sufficient tuning word history available for holdover operation.  \n[5:3] Active reference p riority  Priority value of the currently active reference.  \n000 = highest priority . \n111 = lowest priority . \n[2:0] Active  reference  Index of the currently active reference.  \n000 = Reference A . \n001 = Reference AA . \n010 = Reference B . \n011 = Reference BB . \n100 = Reference C . \n101 = Reference CC . \n110 = Reference D . \n111 = Reference DD . \nTable 140.  Input Reference  Status  \nAddress  Bits Bit Name  Description  \n0x0D0C [7] Profile \nselected  The control logic sets this bit when it assigns Ref A to one of the eight profiles.  \n[6:4] Selected \nprofile  The index (0  to 7) of the profile assigned to Ref A.  \nNote that these bits are meani ngless unless B it 7 = 1. \n[3] Valid  Ref A is valid for use (it is non faulted and its validation timer has expired).  \n[2] Fault  Ref A is not valid for use.  \n[1] Fast  If Bit 7 = 1, then this bit indicates that the frequency of Ref A is higher than allowed  by its profile \nsettings.  \nIf Bit 7 = 0, then this bit indicates that the frequency of Ref A is above the maximum input reference \nfrequency supported by the device.  \n[0] Slow  If Bit 7 = 1, then this bit indicates that the frequency of Ref A is lower than a llowed by its profile settings.  \nIf Bit 7 = 0, then this bit indicates that the frequency of Ref A is below the minimum input reference \nfrequency supported by the device.  \n0x0D0D  [7:0]  Same as 0D0 C but for REF AA instead of REF A.  \n0x0D0E  [7:0]  Same as 0D 0C but for REF B instead of REF A.  \n0x0D0F [7:0]  Same as 0D0 C but for REF BB instead of REF A.  \n0x0D10  [7:0]  Same as 0D0 C but for REF C instead of REF A.  \n0x0D11  [7:0]  Same as 0D0C but for REF CC instead of REF A.  \n0x0D12  [7:0]  Same as 0D0C but for REF  D instead of REF A.  \n0x0D13  [7:0]  Same as 0D0C but for REF DD instead of REF A.  \nTable 141.  Holdover History1 \nAddress  Bits Bit Name  Description  \n0x0D14  [7:0] Holdover h istory  Tuning word read back , Bits[7:0] \n0x0D15  [7:0] Tuning w ord read back , Bits[15:8]  \n0x0D16  [7:0] Tuning word read back, Bits[23:9]  \n0x0D17  [7:0] Tuning word readback , Bits[31:24 ] \n0x0D18  [7:0] Tuning word readback , Bits[39:32]  \n0x0D19  [7:0] Tuning word readback , Bits[47:40]  \n1 These registers contain the current 48 -bit DDS frequency tuning word generated by the tuning word history logic.  \n \nRev. G | Page 100 of 111  \nData Sheet AD9548 \n \nNONV OLATILE MEMORY (EEPR OM) CONTR OL (REG ISTER  0x0E00 TO REG ISTER  0x0E03)  \nTable 142.  EEPROM Control  \nAddress  Bits Bit Name  Description  \n0x0E00  [7:2] Unused   \n[1] Half r ate \nmode  EEPROM serial communication rate.  \n0 (default) = 400  kHz (normal) . \n1 = 200 kHz. \n[0] Writ e enable  EEPROM write enable/protect.  \n0 (default) = EEPROM write protected . \n1 = EEPROM write enabled . \n0x0E01  [7:5] Unused   \n[4:0] Condition  \nvalue  When set to a nonzero value (default = 0), these bits  establish the condition for EEPROM downloads . \n0x0E02  [7:1] Unused   \n[0] Save to \nEEPROM  Upload data to the EEPROM based on the EEPROM storage sequence.  This is an autoclearing bit.  When  \nan EEPROM save/load transfer is complete , wait a minimum of 10  μs before starting the next EEPROM \nsave/load transfer.  \n0x0E03  [7:2] Unused   \n[1] Load f rom \nEEPROM  Download data from the EEPROM.  This is an autoclearing bit.  When an EEPROM save/load transfer is \ncomplete, wait a minimum of 10  μs before starting the next EEPROM save/load transfer.  \n[0] Unused   \nEEPROM STORAGE SEQUENCE (REG ISTER  0x0E10 TO REG ISTER  0x0E3F)  \nThe default settings of Register 0x0E10 to Register 0x 0E33 embody a sample scratch pad instruction sequence.  The f ollowing is a \ndescription of the regist er defaults under the assumption  that the controller has been instructed to carry  out an EEPROM storage \nsequence.  \nTable 143.  EEPROM Storage Sequence for System Clock Settings \nAddress  Bits Bit \nName  Description  \n0x0E10  [7:0] System \nclock The default value of this register is 0x08, which the controller interprets as a d ata instruction.  Its decimal value \nis 8, which  tells the controller to transfer nine  bytes of data (8  + 1) beginning at the address specified by the \nnext two bytes.  The c ontroller stores 0x08 in the EEPROM and increments the EEPROM address pointer.  \n0x0E11  [7:0] System \nclock  The default value of these two registers is 0x0100.  Note that R egister 0x0E11 and Register 0x0E12 are the \nmost significant and least significant bytes  of the target address, respectively.  Because the previous register \ncontains a d ata instruction, these two registers define a starting address (in this case, 0x0100).  The controller \nstores 0x0100 in the EEPROM and increments the EEPROM pointer by 2.  It the n transfers nine b ytes from the \nregister map (beginning at A ddress 0x0100) to the EEPROM and increments the EEPROM address pointer by \n10 (nine  data bytes and one checksum byte).  The nine  bytes  transferred correspond to the s ystem clock \nparameters in the re gister map.  0x0E12  [7:0] \n0x0E13  [7:0] I/O \nupdate  The default value of this register is 0x80, which the controller interprets as an I/O u pdate instruction.  The \ncontroller stores 0x80 in the EEPROM and increments the EEPROM a ddress pointer.  \nTable 144.  EEPROM Storage Sequence for System Clock Calibration  \nAddress  Bits Bit Name  Description  \n0x0E14  [7:0] SYSCLK  \ncalibrate  The default value of this register is 0xA0, which t he controller interprets as a c alibrate instruction.  The \ncontrol ler stores 0xA0 in the EE PROM and increments the EEPROM address pointer.  \nRev. G | Page 101 of 111 \nAD9548 Data Sheet \n \nTable 145.  EEPROM Storage Sequence for General Configuration Settings  \nAddress  Bits Bit \nName  Description  \n0x0E15  [7:0] General  The default value of this regist er is 0x14, which the controller interprets as a d ata instruction.  Its decimal value \nis 20, which  tells the controller to transfer 21 bytes of data (20  + 1) beginning at the address specified by the \nnext two bytes.  The controller stores 0x14 in the EEPROM and increments the EEPROM address pointer.  \n0x0E16  [7:0] General  The default value of these two registers is 0x0200.  Note that R egister 0x0E16 and Register 0x0E17 are the \nmost significant and least significant bytes of the target address, respectively.  Because  the previous register \ncontains a d ata instruction, these two registers define a starting address (in this case, 0x0200).  The controller \nstores 0x0200 in the EEPROM and increments the EEPROM pointer by 2.  It then transfers 21 bytes from the \nregister ma p (beginning at A ddress 0x0200) to the EEPROM and increments the EEPROM address pointer by \n22 (21 data bytes and one  checksum byte).  The 21 bytes transferred correspond to t he g eneral configuration \nparameters in the register map.  0x0E17  [7:0] \nTable 146.  EEPROM Storage Sequence for DPLL Settings  \nAddress  Bits Bit \nName  Description  \n0x0E18  [7:0] DPLL  The default value of this register is 0x1B, which the controller interprets as a d ata instruction.  Its decimal value \nis 27, which tells  the controller to transfer 28 bytes of data (27  + 1) beginning at the address specified by the \nnext two bytes.  The controller stores 0x1B in the EEPROM and increments the EEPROM address pointer.  \n0x0E19  [7:0] DPLL  The default value of these two registers is 0x0300. Note that R egister 0x0E19 and Register 0x0E1A are the most \nsignificant and least significant bytes of the target address, respectively.  Because the previous register contains \na data instruction, these two registers define a starting address (in this case, 0x0300). The controller stores \n0x0300 in the EEPROM and increments the EEPROM pointer by 2.  It then transfers 28 bytes from the register \nmap (beginning at A ddress 0x0300) to the EEPROM and increments the EEPROM address pointer by 29 (28 \ndata byt es and one  checksum byte).  The 28 bytes transferred correspond to the DPLL parameters in the \nregister map.  0x0E1A  [7:0] \nTable 147.  EEPROM Storage Sequence for Clock Distribution Settings  \nAddress  Bits Bit Name  Description  \n0x0E1B  [7:0] Clock \ndistribution  The default value of this register is 0x19, which t he controller interprets as a d ata instruction.  Its decimal \nvalue is 25 , which  tells the controller to transfer 26 bytes of data (25  + 1) beginning at the address \nspecified by the next two bytes.  The controller stores 0x19 in the EEPROM and increments the EEPROM \naddress pointer.  \n0x0E1C  [7:0] Clock \ndistribution  The default value of these two registers is 0x0400.  Note that R egister 0x0E1C and Register 0x0x 0E1D are \nthe most significa nt and least significant bytes of the target address, respectively.  Because the previous \nregister contains a d ata instruction, these two registers define a starting address (in this case, 0x0400).  \nThe controller stores 0x0400 in the EEPROM and increments t he EEPROM pointer by 2.  It then transfers \n26 bytes from the register map (beginning at A ddress 0x0400) to the EEPROM and increments the \nEEPROM address pointer by 27 (26 data bytes and one  checksum byte).  The 26 bytes  transferred \ncorrespond to the c lock distribution parameters in the register map.  0x0E1D  [7:0] \n0x0E1E  [7:0] I/O update  The default value of this register is 0x80, which the contr oller interprets as an I/O u pdate instruction.  The \ncontroller stores 0x80 in the EE PROM and increments the EEPROM a ddress pointer.  \nRev. G | Page 102 of 111 \nData Sheet AD9548 \n \nTable 148.  EEPROM Storage Sequence for Reference Input Settings  \nAddress  Bits Bit Name  Description  \n0x0E1F  [7:0] Reference \ninputs  The default value of this register is 0x07, which the controller interprets as a d ata instruction.  Its decimal \nvalue is 7, which  tells the controller to transfer eight  bytes of data (7  + 1) beginning at the address \nspecified by the next two bytes.  The controller stores 0x07 in the EEPROM and increments the EEPROM \naddress pointer.  \n0x0E20  [7:0] Reference \ninputs  The default value of these two registers is 0x0500.  Note that R egister 0x0E20 and Register 0x0E21 are the \nmost significant and least significant bytes of the target address, respectively.  Because the pre vious \nregister contains a d ata instruction, these two registers define a starting address (in this case, 0x0500).  The \ncontroller stores 0x0500 in the EEPROM and increments the EEPROM pointer by 2.  It then transfers eight  \nbytes from the register map (beginnin g at A ddress 0x0500) to the E EPROM and increments the EEPROM \naddress pointer by nine  (eight  data bytes and one  checksum byte).  The eight  bytes  transferred correspond \nto the r eference inputs parameters in the register map.  0x0E21  [7:0] \nTable 149.  EEPROM Storage Sequence for Profile 0 and Profile 1 Settings  \nAddress  Bits Bit Name  Description  \n0x0E22  [7:0] Profile 0 \nand \nProfile 1 The default value of this register is 0x63, which the controller interprets as a d ata instruction.  Its decimal \nvalue is 99, which  this tells the controller to transfer 100 bytes of data (99  + 1) beginning at the address \nspecified by the next two bytes.  The controller stores 0x63 in the EEPROM and increments the EEPROM \naddress pointer.  \n0x0E23  [7:0] Profile 0 and \nProfile 1 The default val ue of these two registers is 0x0600.  Note that R egister 0x0E23 and Register 0x0E24 are the \nmost significant and least significant bytes of the target address, respectively.  Because the previous register \ncontains a d ata instruction, these two registers define a starting address (in this case, 0x0600).  The controller \nstores 0x0600 in the EEPROM and increments the EEPROM pointer by 2.  It then transfers 100 bytes from the \nregister map (beginning at A ddress 0x0600) to the EEPROM and increments the EEPROM address  pointer by \n101 (100 data bytes and  one  checksum byte).  The 99 bytes transferred correspond to the Profile 0 and Profile \n1 parameters in the register map.  0x0E24  [7:0] \nTable 150.  EEPROM Storage Sequence for Profile 2 and Profile 3 Settings \nAddress  Bits Bit Name  Description  \n0x0E25  [7:0] Profile 2 \nand \nProfile 3 The default value of this register is 0x63, which the controller interprets as a d ata instruction.  Its decimal \nvalue is 99, which  tells the controller to transfer 100 bytes of data (99  + 1) beginning at the address specified \nby the next two bytes.  The controller stores 0x63 in the EEPROM and increments the EEPROM address \npointer.  \n0x0E26  [7:0] Profile 2 \nand \nProfile 3 The default value of these two registers is 0x0680.  Note t hat R egister 0x0E26 and Register 0x0E27 are the \nmost significant and least significant bytes of the target address, respectively.  Because the previous register \ncontains a d ata instruction, these two registers define a starting address (in this case, 0x0680 ). The controller \nstores 0x0680 in the EEPROM and increments the EEPROM pointer by 2.  It then transfers 100 bytes from the \nregister map (beginning at A ddress 0x0680) to the EEPROM and increments the EEPROM address pointer by \n101 (100 data bytes and one checksum byte).  The 99 bytes transferred correspond to the Profile 2 and Profile \n3 parameters in the register map.  0x0E27  [7:0] \nRev. G | Page 103 of 111 \nAD9548 Data Sheet \n \nTable 151.  EEPROM Storage Sequence for Profile 4 and Profile 5 Settings  \nAddress  Bits Bit Name  Description  \n0x0E28  [7:0] Profile 4 \nand \nProfile 5 The default value of this register is 0x63, which the controller interprets as a d ata instruction.  Its decimal \nvalue is 99, which  tells the controller to transfer 100 bytes of data (99  + 1) beginning at the address specified \nby the next two bytes.  The controller stores 0x63 in the EEPROM and increments the EEPROM address \npointer.  \n0x0E29  [7:0] Profile 4 \nand \nProfile 5 The default value of these two registers is 0x0700.  Note that R egister 0x0E29 and Register 0x0E2A are  the \nmost significant and least significant bytes of the target address, respectively.  Because the previous register \ncontains a d ata instruction, these two registers define a starting address (in this case, 0x0700).  The controller \nstores 0x0700 in the EEPR OM and increments the EEPROM pointer by 2.  It then transfers 100 bytes from the \nregister map (beginning at A ddress 0x0700) to the EEPROM and increments the EEPROM address pointer by \n101 (100 data bytes and one checksum byte).  The 99 bytes transferred corre spond to the Profile 4 and Profile \n5 parameters in the register map.  0x0E2A  [7:0] \nTable 152.  EEPROM Storage Sequence for Profile 6 and Profile 7 Settings  \nAddress  Bits Bit Name  Description  \n0x0E2B  [7:0] Profile 6 \nand \nProfile 7 The default value of this register is 0x63, which the controller interprets as a d ata instruction.  Its decimal \nvalue is 99, which  tells the controller to transfer 100 bytes of data (99  + 1) beginning at the address \nspecified by the next two bytes.  The contro ller stores 0x63 in the EEPROM and increments the EEPROM \naddress pointer.  \n0x0E2C  [7:0] Profile 6 \nand \nProfile 7 The default value of these two registers is 0x0780.  Note that R egister 0x0E2C and Register 0x0E2C are the \nmost significant and least significant  bytes of the target address, respectively.  Because the previous register \ncontains a d ata instruction, these two registers define a starting address (in this case, 0x0780).  The \ncontroller stores 0x0780 in the EEPROM and increments the EEPROM pointer by 2.  It then transfers 100 \nbytes from the reg ister map (beginning at A ddress 0x0780) to the EEPROM and increments the EEPROM \naddress pointer by 101 (100 data bytes and  \none  checksum byte).  The 99 bytes transferred correspond to the Profile 6 and Profile 7 param eters in the \nregister map.  0x0E2D  [7:0] \n0x0E2E  [7:0] I/O \nupdate  The default value of this register is 0x80, which the controller interprets as an I/O u pdate instruction.  The \ncontroller stores 0x80 in the EEPROM and increments the EEPROM a ddress pointer . \nTable 153.  EEPROM Storage Sequence for Operational Control Settings  \nAddress  Bits Bit Name  Description  \n0x0E2F  [7:0] Operational \ncontrols  The default value of this register is 0x10, which the controller interprets as a data instru ction. Its decimal \nvalue is 16, which  tells the controller to transfer 17 bytes of data (16 + 1) beginning at the address \nspecified by the next two bytes. The controller stores 0x10 in the EEPROM and increments the EEPROM \naddress pointer.  \n0x0E30  [7:0] Ope rational \ncontrols  The default value of these two registers is 0x0A00. Note that Register 0x0E30 and Register 0x0E31  are the \nmost significant and least significant bytes of the target address, respectively. Because the previous \nregister contains a data inst ruction, these two registers define a starting address (in this case, 0x0A00). \nThe controller stores 0x0A00 in the EEPROM and increments the EEPROM pointer by 2. It then transfers \n17 bytes from the register map (beginning at Address 0x0A00) to the EEPROM a nd increments the \nEEPROM address pointer by 18 (17 data bytes and one checksum  byte). The 17 bytes transferred \ncorrespond to the operational controls  parameters in the register map . 0x0E31  [7:0] \n0x0E32  [7:0]  I/O update  The default value of this register is 0x80, which the controller interprets as an I/O update instruction. The \ncontroller stores 0x80 in the EEPROM and increments the EEPROM address pointer.  \nRev. G | Page 104 of 111 \nData Sheet AD9548 \n \nTable 154.  EEPROM Storage Sequence for End of Data  \nAddress  Bits Bit Name  Description  \n0x0E33  [7:0]  End of data The default value of this register is 0xFF, which the controller int erprets as an end instruction. \nThe controller store s this instruction in the EEPROM, resets the EEPROM address pointer, and \nenters an idle state.  \n0x0E34 to \n0x0E3F   Continuation of user \nscratch pad area  This area is unused in the default configuration and is available for additional EEP ROM \nstorage sequence commands. Note that the EEPROM storage sequence must  always end \nwith either an end of data or paus e command.  \n \n \nRev. G | Page 105 of 111 \nAD9548 Data Sheet \n \nPOWER SUPPLY PARTITI ONS \nThe AD9548 features multiple power supplies, and their power \nconsumption varies with the AD9548 configuration. This \nsection provides information about which power supplies can \nbe grouped together and how the power consumption of each block varies with frequency.  \nThe numbers quoted here a re for comparison only. Please refer \nto the Specifications  section fo r exact numbers. With each group , \nbypass cap acitor s of 1 μF in parallel with 10 μF should be used.  \nUpon applying power to the device, internal circuitry monitors  \nthe 1.8 V digital cor e supply and the 3.3 V digital input/output  \nsupply. When these supplies cross the desired threshold level , \nthe device generates an internal 10 μs reset pulse. This pulse does \nnot appear on the RESET pin.  \n3.3 V SUPPLIES  \nThe 3.3 V supply domain consists of two main partitions, digit al \n(DVDD3) and analog (AVDD3). Take care to keep these two \nsupply domains separate.  Furthermore , the AVDD3 consists of two subdomains: the c lock \ndistribution output domain ( Pin 31, Pin 37, Pin 38, and Pin 44) \nand the rest of  the AVDD3 supply connections. Generally, these \nsupply domains can be joined together. However, if an application  \nrequires 1.8 V CMOS driver operation in the clock d istribution \noutput block, then provide one 1.8 V supply domain to power \nthe clock distribution o utput block. Each output driver has a \ndedicated supply pin, as shown in  Table 155. \nTable 155.  Output Driver Supply Pins \nOutput Driver  Supply Pin  \nOUT0  31 \nOUT1  37 \nOUT2  38 \nOUT3  44 \n1.8 V SU PPLIES  \nThe 1.8 V supply domain consists of two main partitions, dig ital \n(DVDD) and analog (AVDD). T hese two supply domains must \nbe kept separate.  \n \nRev. G | Page 106 of 111 \nData Sheet AD9548 \n \nTHERMAL PERFORMANCE  \nTable 156. Thermal Parameters for the AD9548 88-Lead LFCSP Package  \nSymbol  Thermal Characteristic Using a JEDEC51 -7 Plus JEDEC51 -5 2S2P Test Board1 Value2 Unit  \nθJA Junction-to -ambient thermal resistance, 0.0 m/s air flow per JEDE C JESD51-2 (still air)  18 °C/W  \nθJMA Junction-to -ambient thermal resistance, 1.0 m/s airflow per JEDEC JESD51 -6 (moving air)  16 °C/W  \nθJMA Junction-to -ambient thermal resistance, 2.5 m/s airflow per JEDEC JESD51 -6 (moving air)  14 °C/W  \nθJB Junction-to -boar d thermal resistance, 1.0 m/sec air flow per JEDEC JESD51 -8 (moving air)  9 °C/W  \nθJC Junction-to -case thermal resistance (die -to-heat sink) per MIL -Std 883, Method 1012.1  1.0 °C/W  \nΨJT Junction-to -top -of-package characterization parameter, 0 m/s ec airflow p er JEDEC JESD51-2 (still air)  0.1 °C/W  \n1 The exposed pad on the bottom of the package must be soldered to ground to achieve the speci fied thermal performance.  \n2 Results are from simulations. The PCB is a JEDEC multilayer type. Thermal performance for actual applications requires carefu l inspection of the conditions in the \napplication to determine if they are similar to those assumed in these calculations.  \n \nThe AD9548 is specified for a case temperature (T CASE). To \nensure that T CASE is not exceeded, an airflow source can be us ed. \nUse the following equation to determine the junction tempera -\nture on the application PCB:  \nTJ = TCASE + (Ψ JT × PD) \nwhere:  \nTJ is the  junction temperature (°C).  \nTCASE is the  case temperature (°C) measured by the customer at \nthe top center of the package.  \nΨJT is the  value as indicated in Table 156. \nPD is the  power dissipation (see the Power Dissipation  section).  Values of θ JA are provided for package comparison and PCB \ndesign considerations. θ JA can be used for a first order \napproximation of T J by the equation  \nTJ = TA + (θ JA × PD) \nwhere TA is the ambient temper ature (°C).  \nValues of θ JC are provided for package comparison and PCB \ndesign considerations when an external heat sink is required.  \nValues of θ JB are provided for package comparison and PCB \ndesign considerations.  \n \nRev. G | Page 107 of 111  \nAD9548 Data Sheet\n \nRev. G | Page 108 of 111 CALCULATING DIGITAL FILTER COEFFICIENTS \nThe digital loop filter coefficients ( \uf061, \uf062, \uf067, and \uf064 (see Figure 42)) \nrelate to the time constants (T 1, T 2, and T 3) associated with the \nequivalent analog circuit for a third order loop filter (see Figure 69). \nNote that AD9548  evaluation software contains a profile \ndesigner that will compute these coefficients for you. The user \nshould not normally need to use these formulas. \nR2FROM\nCHARGE\nPUMPTO\nVCOR3\nC3 C1\nC2\n08022-042 \nFigure 69. Third Order Analog Loop Filter \nThe design process begins by deciding on two design \nparameters related to the second order loop filter shown in Figure 70—the desired open-loop bandwidth (f\nP) and phase \nmargin (\uf071\uf029. \nR2FROM\nCHARGE\nPUMPTO\nVCO\nC1\nC2\n08022-043 \nFigure 70. Second Order Analog Loop Filter \nAn analysis of the second order loop filter leads to its primary \ntime constant, T 1. It can be shown that T 1 is expressible in terms \nof fP and \uf071  as \n) cos() sin( 1\n\uf071 \uf077\uf071\nP1T\uf02d\uf03d \nwhere P Pf\uf070\uf077 2\uf03d . \nAn analysis of the third order loop filter leads to the definition \nof another time constant, T 3. It can be shown that T 3 is \nexpressible in terms of the desired amount of additional \nattenuation introduced by R 3 and C 3 at some specified \nfrequency offset ( fOFFSET ) from the PLL output frequency. \nOFFSETATTEN\n3T\uf0771 1010\uf02d\uf03d \nwhere OFFSET OFFSET f\uf070 \uf077 2\uf03d . \nNote that ATTEN is the desired excess attenuation in decibels. \nFurthermore, ATTEN and ω OFFSET  should be chosen so that \nPfT51\n3\uf0a3  With an expression for T 1 and T 3, it is possible to define an \nadjusted open-loop bandwidth ( fC) that is slightly less than fP. It \ncan be shown that ω C (fC expressed as a radian frequency) is \nexpressible in terms of T 1, T 3, and θ (phase margin) as \n\uf028\uf029\n\uf028\uf029\uf028\uf029\n\uf028\uf029\uf05b\uf05d \uf0fa\uf0fa\n\uf0fb\uf0f9\n\uf0ea\uf0ea\n\uf0eb\uf0e9\n\uf02d\n\uf02b\uf02b \uf02b\uf02b\n\uf02b \uf02b\uf02b\uf03d 1\n) tan(1) tan(\n22\n2\uf071\uf071\uf077\n3 13 1 3 1\n3 1 3 13 1\nCT TT T T T\nT T T TT T  \nIt can also be shown that the adjusted open-loop bandwidth \nleads to T 2 (the secondary time constant of the second order \nloop filter) expressed as \n\uf028\uf0293 1 C2T TT\n\uf02b\uf03d21\n\uf077 \nCalculation of the digital loop filter coefficients requires a scaling constant, K (related to the system clock frequency, f\nS), \nand the PLL feedback divide ratio, D. \nSf K332125 , 578 , 517 , 30\uf03d  \n1\uf02b \uf02b \uf03dVUS D  \nwhere S, U, and V  are the integer and fractional feedback \ndivider values that reside in the profile registers. Keep in mind that the desired integer feedback divide ratio is one more than the stored value of S (hence, the +1 term in the equation for D in this equation). This leads to the digital filter coefficients \ngiven by \n\uf028\uf029\uf028\uf029\uf028\uf029\uf028\uf029\n\uf028\uf02922 2 2\n11 1\n2 C3 C 1 C\n12 C\nTT T\nK TD T\n\uf077\uf077 \uf077 \uf077\uf061\n\uf02b\uf02b \uf02b\uf03d \n\uf0f7\uf0f7\n\uf0f8\uf0f6\n\uf0e7\uf0e7\n\uf0e8\uf0e6\uf02d\uf02d\uf03d\n2 1 ST T f1 1 32\uf062 \n1 ST f32\uf02d\uf03d\uf067 \n3 ST f32\uf03d\uf064 \nCalculation of the coefficient register values requires the \napplication of some special functions described as follows: \nThe if() function \ny = if(test_statement , true_value , false_value ) \nwhere test_statement  is a conditional expression (for example, x \n< 3), true_value  is what y equals if the conditional expression is \ntrue, and false_value  is what y equals if the conditional \nexpression is false. The round() function \ny = round( x) \nData Sheet AD9548 \n \nIf x is an integer, then y  = x. Otherwise, y is the nearest integer to x. \nFor example, round(2.1)  = 2, round(2.5)  = 3, and round( −3.1) = −3. \nThe ceil() function  \ny = ceil(x) \nIf x is an integer, then y  = x. Otherwise, y is the ne xt integer to \nthe right on the number line. For example, ceil(2.8)  = 3, \nwhereas ceil( −2.8) = −2. \nThe min() function  \ny = min( x0, x1, ... x n) \nwhere x0 through xn is a list of real numbers , and the value of y  \nis the number in the list that is the farthest to the left on the \nnumber line.  \nThe max() function  \ny = max( x0, x1, ... x n) \nwhere x0 through xn is a list of real numbers , and the value of y \nis the number in the list that is the farthest to the right on the number line.  \nThe log\n2() function  \n)2(ln)(ln)( log2xx= \nwhere ln() is the natural log function  and x is a positive, \nnonzero number.  \nAssume that the coefficient calculations for α , β, γ, and δ yield \nthe following results:  \n012735446.0=α  \n510 98672.6−× −=β  \n510 50373.7−× −=γ  \n002015399.0=δ  \nThese values are floating point numbers that must be quantized \naccording to the bit widths of the linear and exponen tial \ncomponents of the coefficients as they appear in the register \nmap. Note that the calculations that follow indicate a positive \nvalue for the register entries of β  and γ. The reason is that β  and \nγ, which are supposed to be negative values, are stored i n the \nAD9548 registers as positive values. The AD9548 converts the \nstore d values to negative numbers within its signal processing core. \nA detailed description of the register value computations for α , β, γ, \nand δ is contained in the Calculation of the α  Register Values  \nsection to the Calculation of the δ  Register Values  section . \nCALCULATION OF THE α REGISTER VALUES \nThe quantized α coefficient consists of four components, α 0, α1, \nα2, and α 3 according to  \n3 2 1\n0 quantizedαααα αα++−−× = ≈162  \nwhere α0, α1, α2, and α3 are the register values. α2 provides \nfront -end gain, α3 provides back- end gain , and α1 shifts the binary decimal point o f α0 to the left to accommodate small \nvalues of α . Calculation of α 1 is a two -step process, as follows: \n)0)),( (logceil,1 (if2α α −< =w  \n[ ])0,),0 max(,63 min,1 (if1 w < =α α  \nIf gain is necessary (that is, α  > 1), then it is beneficial to apply \nmost or all of it to the front -end gain ( α2) implying  that the \ncalculation of α 2 is to be done before α 3. Calculation of α 2 is a \nthree -step process that leads directly to the calculation of α 3. \n)0)),( (logceil,1 (if2α α> =x  \n[ ])0,),0 max(,22 min,1 (if x y > =α  \n),7,8 (if2 y y≥ =α  \n)0,7 ,8 (if3 − ≥ = y y α  \nCalculation of α 0 is a two -step process, as follows: \n) 2 ( round163 2 1zαααα−−+× =  \n[ ]),1 max(,535,65 min z0=α  \nUsing the example value of α  = 0.012735446 yields  \nw = 6, so  α1 = 6 \nx = 0 and y  = 0, so  α2 = 0 and α3 = 0 \nz = 53,416.332099584, so α0 = 53,416 \nThis leads to  the following quantized value, which is very close \nto the desired value of 0.012735446:  \n1 0127356682.0 2 5341622≈ × =−\nquantizedα  \nCALCULATION OF THE β REGISTER VALUES  \nThe quantized β coefficient consists of two components, β 0 and \nβ1 according to  \n) 17(12ββ ββ+ −× = ≈−0 quantized \nwhere β0 and β1 are the register values. Calculation of β 1 is a \ntwo-step process that leads to the calculation of β 0, which is also \na two -step process.  \n))( (logceil2β −=x  \n[ ]),0 max(,31 min x1=β  \n) 2 ( round171yββ+× =  \n[ ]),1 max(, 071,131 min y0=β  \nUsing the e xample value of − β = 6.98672 × 10−5 yields  \nx = 13, so β 1 = 13  \ny = 75,019.3347657728, so β 0 = 75,019 \nThis leads to the following quantized value, which is very close \nto the desired value of 6.98672x10−5: \n5 3010 986688823.6 2 019,75− −× ≈ × =quantizedβ  \nRev. G | Page 109 of 111 \nAD9548 Data Sheet \n \nCALCULATION OF THE γ REGISTER  VALUES  \nThe quantized γ  coefficient consists of two components, γ 0 and \nγ1 according to  \n) 17(21\n0 quantizedγγ γγ+ −× = ≈−  \nwhere γ0 and γ1 are the register values. Calculation of γ 1 is a two -\nstep process that leads to the calculation of γ 0, which is also a \ntwo-step process. \n))( (logceil2γ −=x  \n[ ]),0 max(,31 min x1=γ  \n) 2 ( round171yγγ+× =  \n[ ]),1 max(, 071,131 min y0=γ  \nUsing the example value of − γ = 7.50373 × 10−5 yields  \nx = 13, so  γ1 = 13  \ny = 80,570.6873700352, so  γ1 = 80,571 \nThis leads to the following quantized valu e, which is very close \nto the desired value of 7.50373x10−5: \n5 3010 503759116.7 2 80571− −× ≈ × =quantizedγ  CALCULATION OF THE δ REGISTER VALUES  \nThe quantized δ coefficient consists of two components, δ0 and \nδ1, according to  \n) 15(21\n0 quantizedδδ δδ+ −× = ≈  \nwhere δ0 and δ1 are the regist er values.  \nCalculation of δ 1 is a two -step process that leads to the \ncalculation of δ0, which is also a two -step process . \n))( (logceil2δ −=x  \n[ ]),0 max(,31 min x1=δ  \n) 2 ( round151yδδ+× =  \n[ ]),1 max(,767,32 min y0=δ  \nGiven the example value of δ = 0.002015399, t he preceding \nformulas yield  \nx = 8, δ 1 = 8 \ny = 16,906.392174592, δ0 = 16,906 \nThis leads to the following quantized value , which is very close \nto the desired value of 0.002015399:  \n49 0020153522.0 2 1690623≈ × =−\nquantizedδ  \n \n \nRev. G | Page 110 of 111 \nData Sheet AD9548 \n \nOUTLINE DIMENSIONS \n \n*COMPLIANT TO JEDEC S TANDARDS MO-220-VRRD\nEXCEPT FOR MINIMUM THICKNESS AND LEAD COUN T.1\n2266\n45\n23 4488 67\n0.50\n0.400.300.300.230.18\n10.50\nREF0.60 MAX\n0.60\nMAX\n6.15\n6.00 SQ\n5.850.50\nBSC\n0.20 REF12° MAX\nSEATING\nPLANETOP VIEWPIN 1\nINDIC ATOR\nEXPOSED PAD\nBOTTOM VIEW\n*0.90\n0.850.750.70\n0.65\n0.60\n0.05 MAX0.01 NOMPIN 1\nINDIC ATOR\nFOR PROPER CONNECTION OF\nTHE EXPOSED PAD, REFER TO\nTHE PIN CONFIGURATION AND\nFUNCTION DESCRIPTIONSSECTION OF THIS DATA SHEET.\n07-02-2012-BCOPLANARIT Y\n0.0812.10\n12.00 SQ\n11.90\n11.85\n11.75 SQ\n11.65\n \nFigure 71. 88-Lead Lead Frame Chip Sc ale Package [LFCSP_VQ]  \n12 mm × 12 mm Body, Very Thin Quad  \n(CP-88-2) \nDimensions shown in millimeters  \n \nORDERING GUIDE  \nModel1 Temperature Range Package Description  Package Option  \nAD9548BCPZ  −40°C  to +85°C 88-L ead Lead Frame Chip Scale Package [ LFCSP _VQ ] CP-88-2 \nAD9548BCPZ -REEL7  −40°C to +85°C 88-Lead Lead Frame Chip Scale Package [LFCSP _VQ ] CP-88-2 \nAD9548/PCBZ  −40°C to +85°C Evaluation Board  CP-88-2 \n1 Z = RoHS Compliant Part.  \n \n \n©2009 –2014  Analog Devices, Inc . All rights reserved. Trademarks and   \n registered trademarks are the property of their respective owners.  \n  D08022- 0-12/14(G)  \n \nRev. G | Page 111 of 111  \n"}]
!==============================================================================!
### Component Summary: AD9548BCPZ-REEL7

#### Key Characteristics and Specifications:
- **Voltage Ratings:**
  - DVDD3: 3.135V to 3.465V
  - DVDD: 1.71V to 1.89V
  - AVDD3: 3.135V to 3.465V
  - AVDD: 1.71V to 1.89V

- **Current Ratings:**
  - IDVDD3: 1.5mA to 3mA
  - IDVDD: 190mA to 215mA
  - IAVDD3: 52mA to 75mA
  - IAVDD: 135mA to 163mA

- **Power Consumption:**
  - Typical Configuration: 800mW to 1100mW
  - All Blocks Running: 900mW to 1400mW
  - Full Power-Down: 13mW

- **Operating Temperature Range:**
  - -40°C to +85°C

- **Package Type:**
  - 88-lead LFCSP (Lead Frame Chip Scale Package)

- **Special Features:**
  - Supports Stratum 2 stability in holdover mode.
  - Hitless reference switchover capability.
  - Programmable digital loop filter with bandwidths from 0.001 Hz to 100 kHz.
  - On-chip EEPROM for storing multiple power-up profiles.
  - Software-controlled power-down.

- **Moisture Sensitive Level (MSL):**
  - MSL Level 3 per JEDEC J-STD-020E.

#### Description:
The **AD9548** is a quad/octal input network clock generator/synchronizer designed for high-performance clock management in various applications. It provides synchronization for systems such as synchronous optical networks (SONET/SDH) by generating output clocks that are phase-locked to selected external reference inputs. The device features a digital phase-locked loop (DPLL) that minimizes jitter and phase noise, ensuring stable clock outputs even during reference failures through holdover functionality.

#### Typical Applications:
- **Network Synchronization:** Ensures accurate timing across network devices.
- **Cleanup of Reference Clock Jitter:** Improves signal integrity by reducing jitter in clock signals.
- **GPS 1 Pulse Per Second Synchronization:** Provides precise timing for GPS applications.
- **SONET/SDH Clocks:** Supports high-speed telecommunications standards.
- **Stratum 2 Holdover and Jitter Cleanup:** Maintains clock stability during reference loss.
- **Wireless Base Station Controllers:** Used in telecommunications infrastructure.
- **Cable Infrastructure and Data Communications:** Enhances performance in data transmission systems.

The AD9548 is ideal for applications requiring precise clock generation and synchronization, making it a versatile component in modern electronic systems.