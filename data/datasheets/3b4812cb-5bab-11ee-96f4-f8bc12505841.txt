[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of 5M160ZE64I5N production of ALTERA from the text:101 Innovation Drive\nSan Jose, CA 95134\nwww.altera.com\n  \n  MAX V Device Handbook\nSubscribeMAX V Device Handbook  \nMAX V Device Handbook  June 2017 Altera Corporation© 2017 Altera Corporation. All rights reserved. ALTERA, ARRIA, CYCLONE, HARDCOPY, MAX, MEGACO RE, NIOS, QUARTUS and STRATIX are Reg. U.S. Pat.\n& Tm. Off. and/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the property of their respective\nholders as described at www.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to current specifications in accordance\nwith Altera’s standard warranty, but reserv es the right to make changes to any products and services at any time without notice . Altera assumes no responsibility or\nliability arising out of the application or us e of any information, product, or servic e described herein except as expressly ag reed to in writing by Altera. Altera\ncustomers are advised to obtain the latest version of device spec ifications before re lying on any published information and bef ore placing orders for products or\nservices.\nJune 2017 Altera Corporation MAX V Device HandbookContents\nSection I. MAX V Device Core\nChapter 1. MAX V Device Family Overview\nFeature Summary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1–1\nIntegrated Software Platform  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . 1–3\nDevice Pin-Outs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . 1–3\nOrdering Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1–4\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1–4\nChapter 2. MAX V Architecture\nFunctional Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–1\nLogic Array Blocks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . 2–4\nLAB Interconnects  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–6\nLAB Control Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 2–6\nLogic Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–8\nLUT Chain and Register Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–9\naddnsub Signal  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . 2–9\nLE Operating Modes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . 2–9\nNormal Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 2–10\nDynamic Arithmetic Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . 2–10\nCarry-Select Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–11\nClear and Preset Logic Control  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . 2–13\nLE RAM  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . 2–13\nMultiTrack Interconnect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 2–14\nGlobal Signals  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . 2–19\nUser Flash Memory Block  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–21\nUFM Storage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–22\nInternal Oscillator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . 2–22\nProgram, Erase, and Busy Signals  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . 2–23\nAuto-Increment Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . 2–23\nSerial Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–23\nUFM Block to Logic Array Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . 2–24\nCore Voltage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–25\nI/O Structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–26\nFast I/O Connection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . 2–27\nI/O Blocks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . 2–28\nI/O Standards and Banks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–29\nPCI Compliance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–32\nLVDS and RSDS Channels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–32\nSchmitt Trigger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . 2–32\nOutput Enable Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 2–33\nProgrammable Drive Strength  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–33\nSlew-Rate Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 2–34\nOpen-Drain Output  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–34\nProgrammable Ground Pins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–34\nBus-Hold  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . 2–34\nProgrammable Pull-Up Resistor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . 2–35\nProgrammable Input Delay . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–35\niv Contents\nMAX V Device Handbook June 2017 Altera CorporationMultiVolt I/O Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 2–35\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2–36\nChapter 3. DC and Switching Characteristics for MAX V Devices\nOperating Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–1\nAbsolute Maximum Ratings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–1\nRecommended Operating Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–2\nProgramming/Erasure Specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–3\nDC Electrical Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 3–3\nOutput Drive Characteristics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . 3–5\nI/O Standard Specifications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–5\nBus Hold Specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . 3–8\nPower-Up Timing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 3–9\nPower Consumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 3–10\nTiming Model and Specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 3–10\nPreliminary and Final Timing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . 3–11\nPerformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . 3–11\nInternal Timing Parameters  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 3–12\nExternal Timing Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–19\nExternal Timing I/O Delay Adders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–23\nMaximum Input and Output Clock Ra tes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . 3–26\nLVDS and RSDS Output Timing Specificatio ns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–27\nJTAG Timing Specifications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 3–29\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3–30\nSection II. System Integration in MAX V Devices\nChapter 4. Hot Socketing and Power-On Reset in MAX V Devices\nMAX V Hot-Socketing Specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . 4–1\nDevices Can Be Driven Before Power Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . 4–2\nI/O Pins Remain Tri-Stated During Power Up  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . 4–2\nSignal Pins Do Not Drive the VCCIO  or VCCINT  Power Supplies  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4–2\nAC and DC Specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4–2\nHot-Socketing Feature Implementation in MA X V Devices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4– 3\nPower-On Reset Circuitry  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 4–5\nPower-Up Characteristics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 4–5\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4–6\nChapter 5. Using MAX V Device s in Multi-Voltage Systems\nI/O Standards  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5–1\nMultiVolt I/O Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5–3\n5.0-V Device Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 5–3\nRecommended Operating Conditions for 5.0-V Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5–7\nPower-Up Sequencing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5–8\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5–8\nChapter 6. JTAG and In -System Programmabilit y in MAX V Devices\nIEEE Std. 1149.1 Boundary-Scan Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . 6–1\nJTAG Block  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . 6–4\nParallel Flash Loader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 6–4\nIn-System Programmability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . 6–5\nIEEE 1532 Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6–6\nJam Standard Test and Programming Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6–6\nContents v\nJune 2017 Altera Corporation MAX V Device HandbookProgramming Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6–6\nUser Flash Memory Programming  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6–7\nIn-System Programming Clamp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . 6–7\nReal-Time ISP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6–8\nDesign Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . 6–8\nProgramming with External Hardware  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . 6–8\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6–9\nChapter 7. User Flash Memory in MAX V Devices\nUFM Array Description  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–1\nMemory Organization Map  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–2\nUsing and Accessing UFM Storage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–2\nUFM Functional Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–3\nUFM Address Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–5\nUFM Data Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 7–6\nUFM Program/Erase Control Block  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–6\nOscillator  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . 7–7\nInstantiating the Oscillator without the UFM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–7\nUFM Operating Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 7–8\nRead/Stream Read . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–9\nProgram  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–10\nErase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . 7–11\nProgramming and Reading the UFM with JTAG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 7–12\nJam Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–12\nJam Players . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . 7–12\nSoftware Support for UFM Block  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 7–13\nInter-Integrated Circuit  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . 7–13\nI2C Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–13\nDevice Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . 7–15\nByte Write Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 7–16\nPage Write Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 7–17\nAcknowledge Polling  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–17\nWrite Protection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–17\nErase Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–17\nRead Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 7–20\nALTUFM_I2C Interface Timing Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 –22\nInstantiating the I2C Interface Using the Quartus II ALTUFM_I2C  Megafunction . . . . . . . . . . . 7–23\nSerial Peripheral Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . 7–23\nOpcodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . 7–25\nALTUFM SPI Timing Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . 7–35\nInstantiating SPI Using Quartus II ALTU FM_SPI Megafunction  . . . . . . . . . . . . . . . . . . . . . . . . . 7–35\nParallel Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–36\nALTUFM Parallel Interface Timing Specific ation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7– 37\nInstantiating Parallel Interface Using Quartus II  ALTUFM_PARALLEL Megafunction . . . . . . 7–37\nNone (Altera Serial Interface) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–38\nInstantiating None Using Quartus II ALTUFM_NONE Megafunction  . . . . . . . . . . . . . . . . . . . . 7–38\nCreating Memory Content File  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . 7–39\nMemory Initialization for the ALTUFM_PARALLEL Megafuncti on  . . . . . . . . . . . . . . . . . . . . . . 7–39\nMemory Initialization for the ALTUFM_SPI Megafunction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–39Memory Initialization for the ALTUFM_I2C Megafunction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–40\nSimulation Parameters  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–43\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7–43\nvi Contents\nMAX V Device Handbook June 2017 Altera CorporationChapter 8. JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 BST Architecture  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8–2\nIEEE Std. 1149.1 Boundary-Scan Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8–3\nBoundary-Scan Cells of a MAX V Device I/O Pin  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8–4\nJTAG Pins and Power Pins  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . 8–5\nIEEE Std. 1149.1 BST Operation Control  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . 8–6\nSAMPLE/PRELOAD Instruction Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . 8–8\nEXTEST Instruction Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 8–10\nBYPASS Instruction Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8–12\nIDCODE Instruction Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . 8–12\nUSERCODE Instruction Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . 8–13\nCLAMP Instruction Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8–13\nHIGHZ Instruction Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . 8–13\nI/O Voltage Support in the JTAG Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . 8–13\nBoundary-Scan Test for Programmed Devices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . 8–14\nDisabling IEEE Std. 1149.1 BST Circuitry  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . 8–15\nGuidelines for IEEE Std. 1149.1 Boundary-Sca n Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 8–15\nBoundary-Scan Description Language Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8–15\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8–16\nAdditional Information\nDocument Revision History  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  Info–1\nHow to Contact Altera  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  Info–1\nTypographic Conventions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  Info–1\nJune 2017 Altera Corporation MAX V Device HandbookSection I. MAX V Device Core\nThis section provides a complete overview of all features relating to the MAX®V \ndevice family.\nThis section includes the following chapters:\n■Chapter 1, MAX V Device Family Overview\n■Chapter 2, MAX V Architecture\n■Chapter 3, DC and Switching Characteristics for MAX V Devices\nI–2 Section I: MAX V Device Core\nMAX V Device Handbook June 2017 Altera Corporation\nMAX V Device Handbook\nMay 2011MV51001-1.2\nSubscribe© 2011 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.1. MAX V Device Family Overview\nThe MAX®V family of low cost and low power CPLDs offer more density and I/Os \nper footprint versus other CPLDs. Ranging in density from 40 to 2,210 logic elements \n(LEs) (32 to 1,700 equivalent macrocells) and up to 271 I/Os, MAX V devices provide \nprogrammable solutions for applications su ch as I/O expansion, bus and protocol \nbridging, power monitoring and control,  FPGA configuration, and analog IC \ninterface.\nMAX V devices feature on-chip flash stor age, internal oscillator, and memory \nfunctionality. With up to 50% lower total power versus other CPLDs and requiring as \nfew as one power supply, MAX V CPLDs can help you meet your low power design \nrequirement.\nThis chapter contains the following sections:\n■“Feature Summary” on page 1–1\n■“Integrated Software Platform” on page 1–3\n■“Device Pin-Outs” on page 1–3\n■“Ordering Information” on page 1–4\nFeature Summary\nThe following list summarizes the MAX V device family features:\n■Low-cost, low-power, and non-volatile CPLD architecture\n■Instant-on (0.5 ms or less) configuration time\n■Standby current as low as 25 µA an d fast power-down/reset operation\n■Fast propagation delay and clock-to-output times\n■Internal oscillator\n■Emulated RSDS output support with a data rate of up to 200 Mbps\n■Emulated LVDS output support with  a data rate of up to 304 Mbps\n■Four global clocks with two clocks available per logic array block (LAB)\n■User flash memory block up to 8 Kbits fo r non-volatile storag e with up to 1000 \nread/write cycles\n■Single 1.8-V external supply for device core\n■MultiVolt I/O interface supporting 3.3-V, 2. 5-V, 1.8-V, 1.5-V, and 1.2-V logic levels\n■Bus-friendly architecture including programmable slew rate, drive strength, \nbus-hold, and programma ble pull-up resistors\n■Schmitt triggers enabling noise tolerant inputs (programmable per pin)\n1–2 Chapter 1: MAX V Device Family Overview\nFeature Summary\nMAX V Device Handbook June 2017 Altera Corporation■I/Os are fully compliant with the PCI-SIG® PCI Local Bus Specification, revision \n2.2 for 3.3-V operation\n■Hot-socket compliant\n■Built-in JTAG BST circuitry comp liant with IEEE Std. 1149.1-1990\nTable 1–1  lists the MAX V family features.\nMAX V devices accept 1.8 V on their VCCINT  pins. The 1.8-V V CCINT  external supply \npowers the device core directly. MAX V devices operate internally at 1.8 V. The \nsupported MultiVolt I/O interface voltage levels (V CCIO)  a r e  1 . 2V ,  1 . 5V ,  1 . 8V ,  2 . 5V ,  \nand 3.3 V.\nMAX V devices are available in two speed gr ades: –4 and –5, with –4 being the fastest. \nFor commercial applications, speed grades –C4 and –C5 are available. For industrial \nand automotive applications, speed grade –I5 and –A5 are availa ble, respectively. \nThese speed grades represent the overall relative performance, not any specific timing \nparameter.\nf For propagation delay timing numbers within each speed grade and density, refer to \nthe DC and Switching Charact eristics for MAX V Devices  chapter.\nMAX V devices are available in space-saving FineLine BGA (FBGA), Micro FineLine \nBGA (MBGA), plastic enhanced quad flat pack (EQFP), and thin quad flat pack \n(TQFP) packages (refer to Table 1–2  and Table 1–3 ). MAX V devices support vertical \nmigration within the same package (for  example, you can migrate between the \n5M570Z, 5M1270Z, and 5M2210Z devices in  the 256-pin FineLine BGA package). \nVertical migration means that you can migrate to devices whose dedicated pins and \nJTAG pins are the same and power pins ar e subsets or supersets for a given package \nacross device densities. The largest density in any package has the highest number of \npower pins; you must lay out for the larges t planned density in a package to provide Table 1–1. MAX V Family Features\nFeature 5M40Z 5M80Z 5M160Z 5M240Z 5M570Z 5M1270Z 5M2210Z\nLEs 40 80 160 240 570 1,270 2,210\nTypical Equivalent Macrocells 32 64 128 192 440 980 1,700\nUser Flash Memory Size (bits) 8,192 8,192 8,192 8,192 8,192 8,192 8,192G l o b a l  C l o c k s 4444444\nInternal Oscillator 1 1 1 1 1 1 1\nMaximum User I/O pins 54 79 79 114 159 271 271t\nPD1 (ns) (1) 7.5 7.5 7.5 7.5 9.0 6.2 7.0\nfCNT (MHz) (2) 152 152 152 152 152 304 304\ntSU (ns) 2.3 2.3 2.3 2.3 2.2 1.2 1.2\ntCO (ns) 6.5 6.5 6.5 6.5 6.7 4.6 4.6\nNotes to Table 1–1 :\n(1) t PD1 represents a pin-to-p in delay for the worst case I/O pla cement with a full diagon al path across the devi ce and combinational l ogic \nimplemented in a single LUT and LAB th at is adjacent to the output pin.\n(2) The maximum global  clock frequency, f CNT, is limited by the I/O standard on the clock input pin. The 16-bit counter critical delay will run faster \nthan this number.\nChapter 1: MAX V Device Family Overview 1–3\nIntegrated Software Platform\nJune 2017 Altera Corporation MAX V Device Handbookthe necessary power pins for migration. For I/O pin migration across densities, cross \nreference the available I/O pins using the de vice pin-outs for all planned densities of \na given package type to identify which I/O pins can be migrated. The Quartus® II \nsoftware can automatically cr oss-reference and place all pins for you when given a \ndevice migration list.\nIntegrated Software Platform\nThe Quartus II software provides an integrated environment for HDL and schematic \ndesign entry, compilation and logic synthesis, full simulation and advanced timing \nanalysis, and programming of MAX V devices.\nf For more information about the Quartus II software features, refer to the Quartus II \nHandbook .\nYou can debug your MAX V designs using In-System Sources and Probes Editor in \nthe Quartus II software. This feature allows you to easily control any internal signal \nand provides you with a completely dynamic debugging environment.\nf For more information about the In-System Sources and Probes Editor, refer to the \nDesign Debugging Using In -System Sources and Probes  chapter of the Quartus II \nHandbook .\nDevice Pin-Outs\nf For more information, refer to the MAX V Device Pin-Out Files  page.Table 1–2. MAX V Packages and User I/O Pins (Note 1)\nDevice64-Pin \nMBGA64-Pin \nEQFP68-Pin \nMBGA100-Pin \nTQFP100-Pin \nMBGA144-Pin \nTQFP256-Pin \nFBGA324-Pin \nFBGA\n5M40Z 30 54 — — — — — —\n5M80Z 30 54 52 79 — — — —\n5M160Z — 54 52 79 79 — — —5M240Z — — 52 79 79 114 — —\n5M570Z — — — 74 74 114 159 —\n5M1270Z — — — — — 114 211 2715M2210Z — — — — — — 203 271\nNote to Table 1–2 :\n(1) Device packages under the same arrow si gn have vertical migration capability.\nTable 1–3. MAX V Package Sizes\nPackage64-Pin \nMBGA64-Pin \nEQFP68-Pin \nMBGA100-Pin \nTQFP100-Pin \nMBGA144-Pin \nTQFP256-Pin \nFBGA324-Pin \nFBGA\nPitch (mm) 0.5 0.4 0.5 0.5 0.5 0.5 1 1\nArea (mm2) 20.25 81 25 256 36 484 289 361\nLength × width\n(mm × mm)4.5 × 4.5 9 × 9 5 × 5 16 × 16 6 × 6 22 × 22 17 × 17 19 × 19\n1–4 Chapter 1: MAX V Device Family Overview\nOrdering Information\nMAX V Device Handbook June 2017 Altera CorporationOrdering Information\nFigure 1–1  shows the ordering codes for MAX V devices.\nDocument Revision History\nTable 1–4  lists the revision history for this chapter.Figure 1–1. MAX V Device Packaging Ordering Information\nPackage Type\n T: Thin quad flat pack (TQFP)\n F: FineLine BGA (FBGA) M: Micro FineLine BGA (MBGA)\n E: Plastic Enhanced Quad Flat Pack (EQFP)Speed GradeFamily Signature\n 5M: MAX V\nOperating Temperature\nPin CountDevice Type\n 40Z: 40 Logic Elements\n 80Z: 80 Logic Elements 160Z: 160 Logic Elements 240Z: 240 Logic Elements 570Z: 570 Logic Elements 1270Z: 1,270 Logic Elements\n 2210Z: 2,210 Logic ElementsOptional Suffix\n4 or 5, with 4 being the fastest\nNumber of pins for a particular package C: Commercial temperature (TJ = 0° C to 85 ° C)\n I: Industrial temperature (TJ = -40 ° C to 100 ° C)\nA:  Automotive temperature (TJ = -40 ° C to 125 ° C)5M 40Z E 64 C 4 N\nIndicates specific device \noptions or shipment method\n N: Lead-free packaging\nTable 1–4. Document Revision History\nDate Version Changes\nMay 2011 1.2■Updated Figure 1–1 .\n■Updated Table 1–3 .\nJanuary 2011 1.1 Updated “Feature Summary” section.\nDecember 2010 1.0 Initial release.\nMAX V Device Handbook\nDecember 2010MV51002-1.0\nSubscribe© 2010 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.2. MAX V Architecture\nThis chapter describes the architecture of the MAX® V device and contains the \nfollowing sections:\n■“Functional Description” on page 2–1\n■“Logic Array Blocks” on page 2–4\n■“Logic Elements” on page 2–8\n■“MultiTrack Interconnect” on page 2–14\n■“Global Signals” on page 2–19\n■“User Flash Memory Block” on page 2–21\n■“Internal Oscillator” on page 2–22\n■“Core Voltage” on page 2–25\n■“I/O Structure” on page 2–26\nFunctional Description\nMAX V devices contain a two-dimensional ro w- and column-based architecture to \nimplement custom logic. Row and column in terconnects provide signal interconnects \nbetween the logic array blocks (LABs).\nEach LAB in the logic array contains 10 logic elements (LEs). An LE is a small unit of \nlogic that provides efficient implementation of user logic functions. LABs are grouped \ninto rows and columns across the device. Th e MultiTrack interconnect provides fast \ngranular timing delays between LABs. The fast routing between LEs provides \nminimum timing delay for added levels of logic versus globally routed interconnect structures.\nThe I/O elements (IOEs) located after the LAB rows and columns around the \nperiphery of the MAX V device feeds the I/ O pins. Each IOE contains a bidirectional \nI/O buffer with several adva nced features. I/O pins suppo rt Schmitt trigger inputs \nand various single-ended standards, su ch as 33-MHz, 32-bit PCI™, and LVTTL.\nMAX V devices provide a global clock networ k. The global clock network consists of \nfour global clock lines that drive throughout the entire device, providing clocks for all \nresources within the device. You can also use the global clock lines for control signals such as clear, preset, or output enable.\n2–2 Chapter 2: MAX V Architecture\nFunctional Description\nMAX V Device Handbook June 2017 Altera CorporationFigure 2–1  shows a functional block di agram of the MAX V device.\nEach MAX V device contains a flash memory block within its floorplan. This block is \nlocated on the left side of the 5M40Z, 5M80Z, 5M160Z, and 5M240Z devices. On the \n5M240Z (T144 package), 5M570Z, 5M1270Z, and 5M2210Z devices,  the flash memory \nblock is located on the bottom-left area of  the device. The majority of this flash \nmemory storage is partitioned as the de dicated configuration flash memory (CFM) \nblock. The CFM block provides the non- volatile storage for all of the SRAM \nconfiguration information. The CFM automatically downloads and configures the \nlogic and I/O at power-up, providing instant-on operation.\nf For more information about configuration upon power-up, refer to the Hot Socketing \nand Power-On Reset for MAX V Devices  chapter.\nA portion of the flash memory within the MAX V device is partitioned into a small \nblock for user data. This user flash memo ry (UFM) block provides 8,192 bits of \ngeneral-purpose user storage. The UFM prov ides programmable port connections to \nthe logic array for reading and writing. Th ere are three LAB rows adjacent to this \nblock, with column numbers varying by device. Figure 2–1. Device Block Diagram\nLogic Array\nBLock (LAB )\nMultiTrackInterconnect\nMultiTrack\nInterconnectLogic\nElement\nLogic\nElementIOE\nIOEIOE IOE\nLogic\nElement\nLogic\nElementIOE\nIOELogic\nElement\nLogic\nElementIOE IOE\nLogic\nElement\nLogic\nElementLogic\nElement\nLogic\nElementIOE IOE\nLogic\nElement\nLogic\nElement\nChapter 2: MAX V Architecture 2–3\nFunctional Description\nJune 2017 Altera Corporation MAX V Device HandbookTable 2–1  lists the number of LAB rows and columns in each device, as well as the \nnumber of LAB rows and columns adjacent to the flash memory area. The long LAB \nrows are full LAB rows that extend from on e side of row I/O blocks to the other. The \nshort LAB rows are adjacent to the UFM bloc k; their length is shown as width in LAB \ncolumns.\nTable 2–1. Device Resources for MAX V Devices\nDevice UFM Blocks LAB ColumnsLAB Rows\nTotal LABs\nLong LAB Rows Short LAB Rows (Width) (1)\n5M40Z 1 6 4 — 24\n5M80Z 1 6 4 — 24\n5M160Z 1 6 4 — 245M240Z (2) 164 — 2 4\n5M240Z (3) 11 24 3  ( 3 ) 5 7\n5M570Z 1 12 4 3 (3) 575M1270Z (4) 1 16 7 3 (5) 127\n5M1270Z (5) 1 20 10 3 (7) 221\n5M2210Z 1 20 10 3 (7) 221\nNotes to Table 2–1 :\n(1) The width is the number of LAB columns in length.\n(2) Not applicable to T144 package of the 5M240Z device.(3) Only applicable to T144 package of the 5M240Z device.\n(4) Not applicable to F324 package of the 5M1270Z device.\n(5) Only applicable to  F324 package of the 5M1270Z device.\n2–4 Chapter 2: MAX V Architecture\nLogic Array Blocks\nMAX V Device Handbook June 2017 Altera CorporationFigure 2–2  shows a floorplan of a MAX V device. \nLogic Array Blocks\nEach LAB consists of 10 LEs, LE carry chains , LAB control signals, a local interconnect, \na look-up table (LUT) chain, and register ch ain connection lines. There are 26 possible \nunique inputs into an LAB, with an additional 10 local feedback input lines fed by LE \noutputs in the same LAB. The local interconnect transfers signals between LEs in the same LAB. LUT chain connections transfer the LUT output from one LE to the Figure 2–2. Device Floorplan for MAX V Devices (Note 1)\nNote to Figure 2–2 :\n(1) The device shown is a 5M 570Z device. 5M1270Z and 5M2210Z devices have a simi lar floorplan with more LABs. For 5M40Z, 5M80Z, 5M160Z, \nand 5M240Z devices, the CFM and UFM blocks are located on the left side of the device.UFM Block\nCFM BlockI/O Blocks\nLogic Array\nBlocksI/O Blocks\nLogic ArrayBlocks\n2 GCLKInputs2 GCLK\nInputs\nI/O Blocks\nChapter 2: MAX V Architecture 2–5\nLogic Array Blocks\nJune 2017 Altera Corporation MAX V Device Handbookadjacent LE for fast sequential LUT connect ions within the same LAB. Register chain \nconnections transfer the output of one LE’ s register to the adjacent LE’s register \nwithin an LAB. The Quartus® II software places associated logic within an LAB or \nadjacent LABs, allowing the use of local, LUT chain, and register chain connections \nfor performance and area efficiency. Figure 2–3  shows the MAX V LAB.\nFigure 2–3. LAB Structure for MAX V Devices\nNote to Figure 2–3 :\n(1) Only from LABs adjacent to IOEs.DirectLink\ninterconnect fromadjacent  LAB or IOE\nDirectLinkinterconnect toadjacent  LAB or IOERow Interconnect\nColumn Interconnect\nLocal Interconnect LABDirectLink\ninterconnect from adjacent LAB or IOE\nDirectLink\ninterconnect toadjacent  LAB or IOEFast I/O connectionto IOE (1)Fast I/O connection\nto IOE (1)LE0\nLE1\nLE2\nLE3\nLE4\nLE6\nLE7\nLE8\nLE9LE5\nLogic Element\n2–6 Chapter 2: MAX V Architecture\nLogic Array Blocks\nMAX V Device Handbook June 2017 Altera CorporationLAB Interconnects\nColumn and row interconnects and LE outputs within the same LAB drive the LAB \nlocal interconnect. Adjacent LABs, from the left and right, can also drive an LAB’s \nlocal interconnect through the DirectLink  connection. The DirectLink connection \nfeature minimizes the use of row and column interconnects, providing higher performance and flexibility. Each LE can drive 30 other LEs through fast local and \nDirectLink interconnects. Figure 2–4  shows the DirectLink connection.\nLAB Control Signals\nEach LAB contains dedicated logic for driving control signals to its LEs. The control \nsignals include two clocks, two clock enables, two asynchronous clears, a \nsynchronous clear, an asynchronous preset/load, a synchronous load, and add/subtract control signals, providing a maximum of 10 control signals at a time. \nSynchronous load and clear signals are generally used when implementing counters \nbut they can also be used with other functions.\nEach LAB can use two clocks and two clock enable signals. Each LAB’s clock and \nclock enable signals are linked. For example, any LE in a particular LAB using the \nlabclk1  signal also uses labclkena1 . If the LAB uses both the rising and falling edges \nof a clock, it also uses both LAB-wide clock signals. Deasserting the clock enable \nsignal turns off the LAB-wide clock.\nEach LAB can use two asynchronous clear signals and an asynchronous load/preset \nsignal. By default, the Quartus II software uses a NOT gate push-back technique to \nachieve preset. If you disable the NOT gate push-back option or assign a given register \nto power-up high using the Quartus II software, the preset is then achieved using the asynchronous load signal with asynchronous load data input tied high.Figure 2–4. DirectLink Connection\nLABDirectLink\ninterconnectto rightDirectLink interconnect from\nright LAB or IOE o utputDirectLink interconnect from\nleft LAB or IOE o utput\nLocal\nInterconnectDirectLink\ninterconnect\nto leftLE0\nLE1\nLE2\nLE3LE4\nLE6\nLE7LE8\nLE9LE5\nLogic Element\nChapter 2: MAX V Architecture 2–7\nLogic Array Blocks\nJune 2017 Altera Corporation MAX V Device HandbookWith the LAB-wide addnsub  control signal, a single LE can implement a one-bit adder \nand subtractor. This signal saves LE resources and improves performance for logic \nfunctions such as correlators and signed mu ltipliers that alternate between addition \nand subtraction depending on data. \nThe LAB column clocks [3..0] , driven by the global clock network, and LAB local \ninterconnect generate the LAB-wide control signals. The MultiTrack interconnect \nstructure drives the LAB local interconnect for non-global control signal generation. \nThe MultiTrack interconnect’s  inherent low skew allows clock and control signal \ndistribution in addition to data signals. Figure 2–5  shows the LAB control signal \ngeneration circuit.\nFigure 2–5. LAB-Wide Control Signals\nlabclkena1\nlabclk2 labclk1labclkena2\nasyncload\nor labpresyncloadDedicated\nLAB Col umn\nClocks\nLocalInterconnect\nLocal\nInterconnectLocalInterconnect\nLocal\nInterconnect\nLocal\nInterconnect\nLocal\nInterconnectlabclr1labclr2\nsynclraddns ub4\n2–8 Chapter 2: MAX V Architecture\nLogic Elements\nMAX V Device Handbook June 2017 Altera CorporationLogic Elements\nThe smallest unit of logic in the MAX V ar chitecture, the LE, is compact and provides \nadvanced features with efficient logic utili zation. Each LE contains a four-input LUT, \nwhich is a function generator that can implement any function of four variables. In addition, each LE contains a programmable re gister and carry chai n with carry-select \ncapability. A single LE also supports dynami c single-bit addition or subtraction mode \nthat is selected by an LAB-wide cont rol signal. Each LE drives all types of \ninterconnects: local, row, column, LUT chain, register chain, and DirectLink \ninterconnects as shown in Figure 2–6 .\nYou can configure each LE’s prog rammable register for D, T, JK, or SR operation. Each \nregister has data, true asynchronous load  data, clock, clock enable, clear, and \nasynchronous load/preset inputs. Global si gnals, general purpose I/O (GPIO) pins, \nor any LE can drive the register’s clock and clear control signals. Either GPIO pins or \nLEs can drive the clock enable, preset, asynchronous load, and asynchronous data. \nThe asynchronous load data input comes from the \ndata3  input of the LE. For \ncombinational functions, the LUT output bypa sses the register and drives directly to \nthe LE outputs.\nEach LE has three outputs that drive the local, row, and column routing resources. The \nLUT or register output can drive these th ree outputs independently. Two LE outputs \ndrive either a column or row and DirectLi nk routing connections while one output \ndrives the local interconnect resources. This configuration allows the LUT to drive one output while the register drives another output. This register packing feature Figure 2–6. LE for MAX V Devices\nlabclk1\nlabclk2labclr2\nlabpre/aloadCarry-In1\nCarry-In0LAB Carry-In\nClock and\nClock Enable\nSelect\nLAB Carry-OutCarry-Out1Carry-Out0Look-Up\nTable\n(LUT)Carry\nChainRow, column,\nand DirectLink \nrouting\nRow, column,\nand DirectLink \nroutingProgrammable\nRegi ster\nPRN/ALD\nCLRNDQ\nENARegi ster Bypa ss\nPacked\nRegi ster Select\nChip-Wide\nReset (DEV_CLRn)\nlabclkena1\nlabclkena2Synchronous\nLoad and\nClear LogicLAB-wide\nSynchronous\nLoad\nLAB-wide\nSynchronous\nClear\nAsynchronous\nClear/Preset/\nLoad Logicdata1\ndata2\ndata3\ndata4LUT chain\nrouting to next LE\nlabclr1\nLocal routing\nRegister chain\noutputADATAaddnsub\nRegi ster\nFeedbackRegister chainrouting fromprevious LE\nChapter 2: MAX V Architecture 2–9\nLogic Elements\nJune 2017 Altera Corporation MAX V Device Handbookimproves device utilization because the device can use the register and the LUT for \nunrelated functions. Another special packing mode allows the register output to feed \nback into the LUT of the same LE so that the register is packed with its own fan-out \nLUT. This mode provides another mechanis m for improved fitting. The LE can also \ndrive out registered and unregistered versions of the LUT output.\nLUT Chain and Register Chain\nIn addition to the three general routing outputs, the LEs within a LAB have LUT chain and register chain outputs. LUT chain conn ections allow LUTs within the same LAB \nto cascade together for wide input function s. Register chain outputs allow registers \nwithin the same LAB to cascade together. Th e register chain output allows a LAB to \nuse LUTs for a single combinational function  and the registers for an unrelated shift \nregister implementation. These resources speed up connections between LABs while \nsaving local interconnect resources. Fo r more information about LUT chain and \nregister chain connections, refer to “MultiTrack Interconnect” on page 2–14 .\naddnsub Signal\nThe LE’s dynamic adder/subtractor feature sa ves logic resources by using one set of \nLEs to implement both an adder and a subtra ctor. This feature is  controlled by the \nLAB-wide control signal addnsub . The addnsub  signal sets the LAB to perform either \nA + B or A – B. The LUT computes addition; subtraction is computed by adding the two’s complement of the intended subtractor . The LAB-wide signal converts to two’s \ncomplement by inverting the B bits within the LAB and setting carry-in to 1, which \nadds one to the LSB. The LSB of an adder/subtractor must be placed in the first LE of the LAB, where the LAB-wide \naddnsub  signal automatically sets the carry-in to 1. The \nQuartus II Compiler automatically places  and uses the adder/subtractor feature \nwhen using adder/subtractor  parameterized functions.\nLE Operating Modes\nThe MAX V LE can operate in one of the following modes:\n■“Normal Mode”\n■“Dynamic Arithmetic Mode”\nEach mode uses LE resources differently. In  each mode, eight available inputs to the \nLE, the four data inputs from the LAB local interconnect, carry-in0 and carry-in1  \nfrom the previous LE, the LAB carry-in from the previous carry-chain LAB, and the \nregister chain connection are directed to different destinations to implement the desired logic function. LAB-wide signal s provide clock, asynchronous clear, \nasynchronous preset/load, synchronous cl ear, synchronous load, and clock enable \ncontrol for the register. These LAB-wide si gnals are available in all LE modes. The \naddnsub  control signal is allowed in arithmetic mode. \nThe Quartus II software, along with parameterized functions such as the library of \nparameterized modules (LPM) functions, automatically chooses the appropriate \nmode for common functions such as counte rs, adders, subtractors, and arithmetic \nfunctions. \n2–10 Chapter 2: MAX V Architecture\nLogic Elements\nMAX V Device Handbook June 2017 Altera CorporationNormal Mode\nThe normal mode is suitable for genera l logic applications and combinational \nfunctions. In normal mode, four data inputs from the LAB local interconnect are \ninputs to a four-input LUT as shown in Figure 2–7 . The Quartus II Compiler \nautomatically selects the carry-in or the data3  signal as one of the inputs to the LUT. \nEach LE can use LUT chain connections to dr ive its combinational output directly to \nthe next LE in the LAB. Asynchronous load data for the register comes from the data3  \ninput of the LE. LEs in normal mode support packed registers.\nDynamic Arithmetic Mode\nThe dynamic arithmetic mode is ideal for implementing adders, counters, \naccumulators, wide parity functions, and comparators. A LE in dynamic arithmetic \nmode uses four 2-input LUTs configurable as a dynamic adder/subtractor. The first \ntwo 2-input LUTs compute two summations base d on a possible carry-in of 1 or 0; the \nother two LUTs generate carry outputs for the two chains of the carry-select circuitry. \nAs shown in Figure 2–8 , the LAB carry-in signal selects either the carry-in0  or \ncarry-in1  chain. The selected chain’s logic level in turn determines which parallel \nsum is generated as a combinational or registered output. For example, when \nimplementing an adder, the sum output is  the selection of two possible calculated \nsums:\ndata1 + data2 + carry-in0\nor\ndata1 + data2 + carry-in1Figure 2–7. LE in Normal Mode\nNote to Figure 2–7 :\n(1) This signal is only allowed in normal mode if the LE is after an adder/subtractor chain.data1\n4-Inp ut\nLUTdata2\ndata3\ncin (from co ut\nof pre vious LE)\ndata4addns ub (LAB Wide)\nclock (LAB Wide)\nena (LAB Wide)\naclr (LAB Wide)aload\n(LAB Wide)\nALD/PRE\nCLRNDQ\nENAADATAsclear\n(LAB Wide)sload\n(LAB Wide)\nRegister chain\nconnection\nLUT chainconnection\nRegister\nchain o utputRow, column, and\nDirectLink ro utingRow, column, and\nDirectLink ro uting\nLocal ro uting\nRegister Feedback(1)\nChapter 2: MAX V Architecture 2–11\nLogic Elements\nJune 2017 Altera Corporation MAX V Device HandbookThe other two LUTs use the data1  and data2  signals to generate two possible \ncarry-out signals: one for a carry of 1 and the other for a carry of 0. The carry-in0 \nsignal acts as the carry-select for the carry-out0  output and carry-in1  acts as the \ncarry-select for the carry-out1  output. LEs in arithmetic mode can drive out \nregistered and unregistered ve rsions of the LUT output.\nThe dynamic arithmetic mode also offers clock enable, counter enable, synchronous \nup/down control, synchronous clea r, synchronous load, and dynamic \nadder/subtractor options. The LAB local interconnect data inputs generate the \ncounter enable and synchronous up/down control signals. The synchronous clear \nand synchronous load options are LAB-wide signals that affect all registers in the \nLAB. The Quartus II software automatically places any registers that are not used by \nthe counter into other LABs. The addnsub  LAB-wide signal controls whether the LE \nacts as an adder or subtractor.\nCarry-Select Chain\nThe carry-select chain provides a very fa st carry-select function between LEs in \ndynamic arithmetic mode. The carry-select ch ain uses the redundant carry calculation \nto increase the speed of carry functions. Th e LE is configured to calculate outputs for a \npossible carry-in of 0 and carry-in of 1 in parallel. The carry-in0  and carry-in1  \nsignals from a lower-order bit feed forward into the higher-order bit via the parallel carry chain and feed into both the LUT an d the next portion of the carry chain. \nCarry-select chains can begin in any LE within an LAB. Figure 2–8. LE in Dynamic Arithmetic Mode\nNote to Figure 2–8 :\n(1) The  addnsub  signal is tied to the ca rry input for the first LE of a carry chain only.data1LUT\ndata2\ndata3addns ub\n(LAB Wide)\nclock (LAB Wide)\nena (LAB Wide)\naclr (LAB Wide)ALD/PRE\nCLRNDQ\nENAADATARegister chain\nconnection\nLUT\nLUT\nLUT\nCarry-O ut1 Carry-O ut0LAB Carry-In\nCarry-In0\nCarry-In1\n(1)sclear\n(LAB Wide)sload\n(LAB Wide)\nLUT chain\nconnection\nRegisterchain o utputRow, column, and\ndirect link ro utingRow, column, and\ndirect link ro uting\nLocal ro utingaload\n(LAB Wide)\nRegister Feedback\n2–12 Chapter 2: MAX V Architecture\nLogic Elements\nMAX V Device Handbook June 2017 Altera CorporationThe speed advantage of the carry-select chai n is in the parallel pre-computation of \ncarry chains. Because the LAB carry-in selects the precomputed carry chain, not every \nLE is in the critical path. Only the propagation delays between LAB carry-in \ngeneration ( LE5 and LE10 ) are now part of the critical path. This feature allows the \nMAX V architecture to implement high-sp eed counters, adders, multipliers, parity \nfunctions, and comparator s of arbitrary width. \nFigure 2–9  shows the carry-select circuitry in an LAB for a 10-bit full adder. One \nportion of the LUT generates the sum of two bits using the input signals and the \nappropriate carry-in bit; the sum is routed to  the output of the LE. The register can be \nbypassed for simple adders or used for accumulator functions. Another portion of the LUT generates carry-out bits. An LAB-wide ca rry-in bit selects whic h chain is used for \nthe addition of given inputs. The carry-in signal for each chain, \ncarry-in0  or \ncarry-in1 , selects the carry-out to carry forw ard to the carry-in signal of the \nnext-higher-order bit. The final carry-out signal  is routed to an LE, where it is fed to \nlocal, row, or column interconnects. \nFigure 2–9. Carry-Select Chain\nLE3LE2LE1LE0A1\nB1\nA2\nB2\nA3\nB3\nA4\nB4Sum1\nSum2\nSum3\nSum4\nLE9LE8LE7LE6A7\nB7\nA8\nB8\nA9\nB9\nA10\nB10Sum7LE5A6\nB6Sum6LE4A5\nB5Sum5\nSum8\nSum9\nSum100101LAB Carry-In\nLAB Carry-O utLUT\nLUT\nLUTLUTdata1LAB Carry-In\ndata2Carry-In0\nCarry-In1\nCarry-O ut0 Carry-O ut1Sum\nTo top of adjacent LAB\nChapter 2: MAX V Architecture 2–13\nLogic Elements\nJune 2017 Altera Corporation MAX V Device HandbookThe Quartus II software automatically cr eates carry chain logic during design \nprocessing, or you can create it manual ly during design en try. Parameterized \nfunctions such as LPM functions automaticall y take advantage of carry chains for the \nappropriate functions. The Quartus II software  creates carry chains longer than 10 LEs \nby linking adjacent LABs within the same row together automatically. A carry chain \ncan extend horizontally up to one full LAB row, but does not extend between LAB \nrows.\nClear and Preset Logic Control\nLAB-wide signals control the logic for the re gister’s clear and preset signals. The LE \ndirectly supports an asynchro nous clear and preset function. The register preset is \nachieved through the asynchronous load of a logic high. MAX V devices support \nsimultaneous preset/asynchronous load an d clear signals. An asynchronous clear \nsignal takes precedence if both signals are asserted simultaneously. Each LAB supports up to two clears and one preset signal.\nIn addition to the clear and preset ports,  MAX V devices provide a chip-wide reset pin \n(\nDEV_CLRn ) that resets all registers in the device . An option set before compilation in \nthe Quartus II software controls this pin. This chip-wide reset overrides all other \ncontrol signals and uses its own dedicated routing resources without using any of the \nfour global resources. Driving this signal low before or during power-up prevents user mode from releasing clears within the design. This allows you to control when \nclear is released on a device that has just been powered-up. If not set for its chip-wide \nreset function, the \nDEV_CLRn  pin is a regular I/O pin.\nBy default, all registers in MAX V devices are set to power-up low. However, this \npower-up state can be set to high on individual registers during design entry using \nthe Quartus II software.\nLE RAM\nThe Quartus II memory compiler can configure the unused LEs as LE RAM. \nMAX V devices support the following memory types:\n■FIFO synchronous R/W\n■FIFO asynchronous R/W\n■1 port SRAM\n■2 port SRAM\n■3 port SRAM\n■shift registers\nf For more information about memory, refer to the Internal Memory (RAM and ROM) \nUser Guide .\n2–14 Chapter 2: MAX V Architecture\nMultiTrack Interconnect\nMAX V Device Handbook June 2017 Altera CorporationMultiTrack Interconnect\nIn the MAX V architecture, connections between LEs, the UFM, and device I/O pins \nare provided by the MultiTrack interconnect  structure. The MultiTrack interconnect \nconsists of continuo us, performance-optimized routin g lines used for inter- and \nintra-design block connectivity. The Quartus II Compiler automatically places critical \ndesign paths on faster interconnects to improve design performance.\nThe MultiTrack interconnect consists of ro w and column interconnects that span fixed \ndistances. A routing structure with fixed length resources for all devices allows \npredictable and short delays between logic levels instead of large delays associated \nwith global or long routing lines. Dedica ted row interconnects route signals to and \nfrom LABs within the same row. These row resources include:\n■DirectLink interconnects between LABs \n■R4 interconnects traversing fo ur LABs to the right or left\nThe DirectLink interconnect allows an LAB to  drive into the local interconnect of its \nleft and right neighbors. The DirectLink interconnect provides  fast communication \nbetween adjacent LABs and blocks with out using row interconnect resources.\nThe R4 interconnects span four LABs and are used for fast row connections in a \nfour-LAB region. Every LAB has its own set of R4 interconnects to drive either left or \nright. Figure 2–10  shows R4 interconnect connections from an LAB. R4 interconnects \ncan drive and be driven by row IOEs. For LAB interfacing, a primary LAB or \nhorizontal LAB neighbor can drive a given R4  interconnect. For R4 interconnects that \ndrive to the right, the primary LAB and right neighbor can drive on to the interconnect. For R4 interconnects that drive to the left, the primary LAB and its left \nneighbor can drive on to the interconnect. R4 interconnects can drive other R4 \ninterconnects to extend the range of LABs they can drive. R4 interconnects can also \ndrive C4 interconnects for connections from one row to another. \nChapter 2: MAX V Architecture 2–15\nMultiTrack Interconnect\nJune 2017 Altera Corporation MAX V Device HandbookThe column interconnect operates similarly to the row interconnect. Each column of \nLABs is served by a dedicated column interconnect, which vertically routes signals to and from LABs and row and column IOEs. These column resources include:\n■LUT chain interconnects within an LAB\n■Register chain interconnects within an LAB\n■C4 interconnects traversing a distance of four LABs in an up and down direction\nMAX V devices include an enhanced interco nnect structure within LABs for routing \nLE output to LE input connections faster using LUT chain connections and register \nchain connections. The LUT chain connection allows the combinational output of an \nLE to directly drive the fast input of the LE right below it, bypassing the local \ninterconnect. These resources can be used as a high-speed  connection for wide fan-in \nfunctions from LE 1  to LE 10  in the same LAB. The regi ster chain connection allows \nthe register output of one LE to connect direct ly to the register input of the next LE in \nthe LAB for fast shift registers. The Quartus II Compiler automatically takes \nadvantage of these resources to im prove utilization and performance. Figure 2–11  \nshows the LUT chain and register chain interconnects.Figure 2–10. R4 Interconnect Connections\nNotes to Figure 2–10 :\n(1) C4 interconnects can drive R4 interconnects.\n(2) This pattern is repeated for every LAB in the LAB row.Primary\nLAB (2)R4 Interconnect\nDriving LeftAdjace nt LAB ca n\ndrive onto another\nLAB’s R4 InterconnectC4 Col umn Interconnects (1)R4 Interconnect\nDriving Right\nLAB\nNeighbo rLAB\nNeighbo r\n2–16 Chapter 2: MAX V Architecture\nMultiTrack Interconnect\nMAX V Device Handbook June 2017 Altera CorporationThe C4 interconnects span four LABs up or down from a source LAB. Every LAB has \nits own set of C4 interconnects to drive either up or down. Figure 2–12  shows the C4 \ninterconnect connections from an LAB in a column. The C4 interconnects can drive \nand be driven by column and row IOEs. For LAB interconnection, a primary LAB or its vertical LAB neighbor ca n drive a given C4 interconnect. C4 interconnects can \ndrive each other to extend their range as well as drive row interconnects for \ncolumn-to-column connections. Figure 2–11. LUT Chain and Register Chain Interconnects\nLE0\nLE1\nLE2\nLE3\nLE4\nLE5\nLE6\nLE7\nLE8\nLE9LUT Chain\nRouting to\nAdjacent LE\nLocal\nInterconnectRegister ChainRouting to Adjacen\nt\nLE\'s Register InputLocal Interconnect\nRouting Among LEsin the LAB\nChapter 2: MAX V Architecture 2–17\nMultiTrack Interconnect\nJune 2017 Altera Corporation MAX V Device HandbookFigure 2–12. C4 Interconnect Connections (Note 1)\nNote to Figure 2–12 :\n(1) Each C4 interconnect can drive either up or down four rows.C4 Interconnect\nDrives Local and R 4\nInterconnectsUp to Four Rows\nAdjacent LAB can\ndrive onto neigh boring\nLAB\'s C4 interconnectC4 InterconnectDriving Up\nC4 InterconnectDriving DownLAB\nRow\nInterconnect\nLocal\nInterconnect\n2–18 Chapter 2: MAX V Architecture\nMultiTrack Interconnect\nMAX V Device Handbook June 2017 Altera CorporationThe UFM block communicates with the logic array similar to LAB-to-LAB interfaces. \nThe UFM block connects to row and column interconnects and has local interconnect \nregions driven by row and column interconnects. This block also has DirectLink \ninterconnects for fast connections to and from a neighboring LAB. For more \ninformation about the UFM interface to the logic array, refer too “User Flash Memory \nBlock” on page 2–21 .\nTable 2–2  lists the MAX V device routing scheme.\nTable 2–2. Routing Scheme for MAX V Devices\nSourceDestination\nLUT \nChainRegister \nChainLocal \n(1)DirectLink \n(1)R4 (1) C4 (1) LEUFM \nBlockColumn \nIOERow \nIOEFast I/O \n(1)\nLUT Chain — — — — — — v —— — —\nRegister Chain — — — — — — v —— — —\nLocal \nInterconnect——— — — — vv vv —\nDirectLink \nInterconnect—— v —— — — — — — —\nR4 Interconnect — — v — vv —— — — —\nC4 Interconnect — — v — vv —— — — —\nLE vvv v vv —— vvv\nUFM Block — — vvv v —— — — —\nColumn IOE — — — — — v —— — — —\nRow IOE — — — vv v —— — — —\nNote to Table 2–2 :\n(1) These categories are interconnects.\nChapter 2: MAX V Architecture 2–19\nGlobal Signals\nJune 2017 Altera Corporation MAX V Device HandbookGlobal Signals\nEach MAX V device has four dual-purpose dedicated clock pins ( GCLK[3..0] , two \npins on the left side and two pins on the ri ght side) that drive the global clock network \nfor clocking, as shown in Figure 2–13 . These four pins can also be used as GPIOs if \nthey are not used to drive the global clock network. \nThe four global clock lines in the global clock network drive throughout the entire \ndevice. The global clock network can provide clocks for all resources within the device including LEs, LAB local interconnect, IOEs, and the UFM block. The global \nclock lines can also be used for global control signals, such as clock enables, \nsynchronous or asynchronous clears, preset s, output enables, or protocol control \nsignals such as \nTRDY  and IRDY  for the PCI I/O standard. Internal logic can drive the \nglobal clock network for internally-generated global clocks and control signals. \nFigure 2–13  shows the various sources that drive the global clock network.\nThe global clock network drives to individual LAB column signals, LAB column \nclocks [3..0] , that span an entire LAB column from the top to the bottom of the \ndevice. Unused global clocks or control signal s in an LAB column are turned off at the \nLAB column clock buffers shown in Figure 2–14 . The LAB column clocks [3..0]  are \nmultiplexed down to two LAB clock signal s and one LAB clear signal. Other control \nsignal types route from the global clock network into the LAB local interconnect. For \nmore information, refer to “LAB Control Signals” on page 2–6 .Figure 2–13. Global Clock Generation\nNote to  Figure 2–13 :\n(1) Any I/O pin can use a Mu ltiTrack interconnect to route as a logi c array-generated global clock signal.4\n4GCLK0\nGlobal Clock\nNetworkGCLK1\nGCLK2\nGCLK3\nLogic Array (1)\n2–20 Chapter 2: MAX V Architecture\nGlobal Signals\nMAX V Device Handbook June 2017 Altera CorporationFigure 2–14. Global Clock Network (Note 1)\nNotes to Figure 2–14 :\n(1) LAB column clocks in  I/O block regions provide high fan-out output enable signals.\n(2) LAB column clocks dr ive to the UFM block.UFM Block (2)\nCFM BlockI/O Block Regio nI/O Block Regio n\nI/O Block Regio nLAB Column  \nclock[3..0]\nLAB Column\nclock[3..0]4 4 4 4 4 4 4 4\nChapter 2: MAX V Architecture 2–21\nUser Flash Memory Block\nJune 2017 Altera Corporation MAX V Device HandbookUser Flash Memory Block\nMAX V devices feature a single UFM block, which can be used like a serial EEPROM \nfor storing non-volatile information up to  8,192 bits. The UFM block connects to the \nlogic array through the MultiTrack interco nnect, allowing any LE to interface to the \nUFM block. Figure 2–15  shows the UFM block and interface signals. The logic array is \nused to create customer interface or prot ocol logic to interface the UFM block data \noutside of the device. The UFM bloc k offers the following features:\n■Non-volatile storage up to 16-bit wide and 8,192 total bits\n■Two sectors for partitioned sector erase\n■Built-in internal oscillator that optionally drives logic array\n■Program, erase, and busy signals\n■Auto-increment addressing\n■Serial interface to logic array with programmable interface\nFigure 2–15. UFM Block and Interface Signals\nOSC 4Program\nErase\nControl\nUFM Sector 1\nUFM Sector 0:_\nAddress\nRegisterPROGRAM\nERASE\nOSC_E NARTP_BUSY\nBUSY\nOSC\nData RegisterUFM Block\nDRDin DRDo utARCLK\nARSHFT\nARDin\nDRCLK\nDRSHFT16 16 9\n2–22 Chapter 2: MAX V Architecture\nUser Flash Memory Block\nMAX V Device Handbook June 2017 Altera CorporationUFM Storage\nEach device stores up to 8,192 bits of data in the UFM block. Table 2–3  lists the data \nsize, sector, and address sizes for the UFM block.\nThere are 512 locations with 9- bit addressing ranging from 000h  to 1FFh . The sector 0 \naddress space is 000h  to 0FFh  and the sector 1 address space is from 100h  to 1FFh . The \ndata width is up to 16 bits of data. The Qu artus II software automatically creates logic \nto accommodate smaller read or program data widths. Erasure of the UFM involves \nindividual sector erasing (that is, one erase of sector 0 and one erase of sector 1 is \nrequired to erase the entire UFM block). Be cause sector erase is required before a \nprogram or write operation, having two sectors enables a sector size of data to be left \nuntouched while the other sector is erased and programmed with new data. \nInternal Oscillator\nAs shown in Figure 2–15 , the dedicated circuitry within the UFM block contains an \noscillator. The dedicated circuitry uses this  oscillator internally for its read and \nprogram operations. This osci llator\'s divide by 4 output  can drive out of the UFM \nblock as a logic interface clock source or for general-purpose logic clocking. The \ntypical OSC output signal frequency ranges fr om 3.9 to 5.3 MHz, and its exact \nfrequency of operation is not programmable.\nThe UFM internal oscillator can be instantiated using the MegaWizard™ Plug-In \nManager. You can also use the MAX II/MAX V Oscillator megafunc tion to instantiate \nthe UFM oscillator without using the UFM memory block.Table 2–3. UFM Array Size\nDevice Total Bits Sectors Address Bits Data Width\n5M40Z 8,192 2 (4,096 bits per sector) 9 16\n5M80Z 8,192 2 (4,096 bits per sector) 9 16\n5M160Z 8,192 2 (4,096 bits per sector) 9 165M240Z 8,192 2 (4,096 bits per sector) 9 16\n5M570Z 8,192 2 (4,096 bits per sector) 9 16\n5M1270Z 8,192 2 (4,096 bits per sector) 9 165M2210Z 8,192 2 (4,096 bits per sector) 9 16\nChapter 2: MAX V Architecture 2–23\nUser Flash Memory Block\nJune 2017 Altera Corporation MAX V Device HandbookProgram, Erase, and Busy Signals\nThe UFM block’s dedicated circuitry automatically generates the necessary internal \nprogram and erase algorithm after the PROGRAM  or ERASE  input signals have been \nasserted. The PROGRAM  or ERASE  signal must be asserted until the busy signal deasserts, \nindicating the UFM internal program or erase operation has completed. The UFM \nblock also supports JTAG as the inte rface for programming and reading. \nf For more information about programming and erasing the UFM block, refer to the \nUser Flash Memory in MAX V Devices  chapter.\nAuto-Increment Addressing\nThe UFM block supports standard read or stre am read operations. The stream read is \nsupported with an auto-increment address feature. Deasserting the ARSHIFT  signal \nwhile clocking the ARCLK  signal increments the address register value to read \nconsecutive locations from the UFM array.\nSerial Interface\nThe UFM block supports a serial interface wi th serial address and data signals. The \ninternal shift registers within the UFM block for address and data are 9 bits and 16 bits \nwide, respectively. The Quartus II software automatically generates interface logic in \nLEs for a parallel address and data interface to the UFM block. Other standard protocol interfaces such as SPI are also automatically generated in LE logic by the \nQuartus II software.\nf For more information about the UFM inte rface signals and the Quartus II LE-based \nalternate interfaces, refer to the User Flash Memory in MAX V Devices  chapter.\n2–24 Chapter 2: MAX V Architecture\nUser Flash Memory Block\nMAX V Device Handbook June 2017 Altera CorporationUFM Block to Logic Array Interface\nThe UFM block is a small partition of the fl ash memory that contains the CFM block, \nas shown in Figure 2–1  and Figure 2–2 . The UFM block for the 5M40Z, 5M80Z, \n5M160Z, and 5M240Z devices is located on the left side of the device adjacent to the \nleft most LAB column. The UFM blocks  for the 5M570Z, 5M1270Z, and 5M2210Z \ndevices are located at the bottom left of the device. The UFM input and output signals \ninterface to all types of interconnects (R4 interconnect, C4 interconnect, and \nDirectLink interconnect to/from adjacent LAB rows). The UFM signals can also be \ndriven from global clocks, GCLK[3..0] . The interface regions for the 5M40Z, 5M80Z, \n5M160Z, and 5M240Z devices are shown in Figure 2–16 . The interface regions for \n5M570Z, 5M1270Z, and 5M2210Z devices are shown in Figure 2–17 .\nFigure 2–16. 5M40Z, 5M80Z, 5M160Z, and 5M240Z UFM Block LAB Row Interface (Note 1) ,(2)\nNotes to Figure 2–16 :\n(1) The UFM block inputs and outputs can dr ive to and from all types of interconn ects, not only DirectLink interconnects \nfrom adjacent row LABs.\n(2) Not applicable to the T144  package of th e 5M240Z device.UFM BlockCFM Block\nPROGRAM\nERASE\nOSC_ENA\nDRDin\nDRCLK\nDRSHFT\nARin\nARCLK\nARSHFT\nDRDout\nOSC\nBUSYRTP_BUSYLAB\nLAB\nLAB\nChapter 2: MAX V Architecture 2–25\nCore Voltage\nJune 2017 Altera Corporation MAX V Device HandbookCore Voltage\nThe MAX V architecture supports a 1.8-V core voltage on the V CCINT  supply. You must \nuse a 1.8-V V CC external supply to power the VCCINT  pins.Figure 2–17. 5M240Z, 5M570Z, 5M1270Z, and 5M2210Z UFM Block LAB Row Interface (Note 1)\nNote to Figure 2–17 :\n(1) Only applicable to the T14 4 package of the 5M240Z device.RTP_BUSY\nBUSY\nOSC\nDRDo ut\nDRDin\nPROGRAM\nERASE\nOSC_E NA\nARCLK\nARSHFTDRDCLK\nDRDSHFT\nARDin\nUFM BlockCFM Block\nLAB\nLAB\nLAB\nFigure 2–18. Core Voltage Feature in MAX V Devices\nMAX V Device1.8-V on\nVCCINT Pins1.8-V Core\nVoltage\n2–26 Chapter 2: MAX V Architecture\nI/O Structure\nMAX V Device Handbook June 2017 Altera CorporationI/O Structure\nIOEs support many features, including:\n■LVTTL, LVCMOS, LVDS, and RSDS I/O standards\n■3.3-V, 32-bit, 33-MHz PCI compliance\n■JTAG boundary-scan test (BST) support\n■Programmable drive strength control\n■Weak pull-up resistors during po wer-up and in system programming\n■Slew-rate control\n■Tri-state buffers with indivi dual output enable control\n■Bus-hold circuitry\n■Programmable pull-up resistors in user mode\n■Unique output enable per pin\n■Open-drain outputs\n■Schmitt trigger inputs\n■Fast I/O connection\n■Programmable input delay\nMAX V device IOEs contain a bidirectional I/O buffer. Figure 2–19  shows the MAX V \nIOE structure. Registers from adjacent LABs can drive to or be driven from the IOE’s \nbidirectional I/O buffers. Th e Quartus II software automatically attempts to place \nregisters in the adjacent LAB with fast I/ O connection to achieve the fastest possible \nclock-to-output and registered output enab le timing. When the fast input registers \noption is enabled, the Quartus II software  automatically routes the register to \nguarantee zero hold time. You can set timi ng assignments in the Quartus II software \nto achieve desired I/O timing. \nChapter 2: MAX V Architecture 2–27\nI/O Structure\nJune 2017 Altera Corporation MAX V Device HandbookFast I/O Connection\nA dedicated fast I/O connection from the ad jacent LAB to the IOEs within an I/O \nblock provides faster output de lays for clock-to-output and t PD propagation delays. \nThis connection exists for data output si gnals, not output enable signals or input \nsignals. Figure 2–20 , Figure 2–21 , and Figure 2–22  illustrate the fast I/O connection.\nFigure 2–19. IOE Structure for MAX V Devices\nNotes to Figure 2–19 :\n(1) Available only in I/O bank 3 of 5M1270Z and 5M2210Z devices.\n(2) The programmable pull-up resi stor is active during power-up, in-system progra mming (ISP), and if the device is unprogrammed.Data_in\nOptio nal Schmitt\nTrigger InputDrive St rength Co ntrol\nOpen-Drain Output\nSlew Co ntrolFast_out\nData_out OE\nOptio nal\nPCI Clamp (1)\nProgrammable\nPull-Up (2)VCCIO VCCIO\nI/O Pin\nOptio nal Bus-Hold  \nCircuitDEV_OE\nProgrammable\nInput Delay\n2–28 Chapter 2: MAX V Architecture\nI/O Structure\nMAX V Device Handbook June 2017 Altera CorporationI/O Blocks\nThe IOEs are located in I/O blocks around the periphery of the MAX V device. There \nare up to seven IOEs per row I/O block and up to four IOEs per column I/O block. \nEach column or row I/O block interfaces  with its adjacent LAB and MultiTrack \ninterconnect to distribute signals throug hout the device. The row I/O blocks drive \nrow, column, or DirectLink  interconnects. The column  I/O blocks drive column \ninterconnects. \n1 5M40Z, 5M80Z, 5M160Z, and 5M240Z devices have a maximum of five IOEs per row \nI/O block.\nFigure 2–20  shows how a row I/O block connects to the logic array. \nFigure 2–20. Row I/O Block Connection to the Interconnect (Note 1)\nNote to Figure 2–20 :\n(1) Each of the seven IOEs in th e row I/O block can have one data_out  or fast_out  output, one OE output, and \none data_in  input.7R4 Interconnects C4 Interconnects\nI/O Block Local \nInterconnect\ndata_in[6..0]data_o ut\n[6..0]\n7OE\n[6..0]\n7\n7fast_o ut\n[6..0]\nRow I/O Block\nContains up to\nSeven IOEsDirect Link\nInterconnect\nto Adjacent LABDirect Link\nInterconnect\nfrom Adjacent LAB\nLAB Col umn\nclock [3..0]LAB Local\nInterconnectLABRow\nI/O Block\nChapter 2: MAX V Architecture 2–29\nI/O Structure\nJune 2017 Altera Corporation MAX V Device HandbookFigure 2–21  shows how a column I/O block connects to the logic array.\nI/O Standards and Banks\nTable 2–4  lists the I/O standards supported by MAX V devices.Figure 2–21. Column I/O Block Connection to the Interconnect (Note 1)\nNote to Figure 2–21 :\n(1) Each of the four IOEs in th e column I/O bl ock can have one data_out  or fast_out  output, one OE output, and \none data_in  input.Column I/O \nBlock ContainsUp To 4 IOEs\nI/O Block\nLocal Interconnect\nR4 Interconnects\nLAB Local\nInterconnect\nC4 InterconnectsLAB Local\nInterconnect\nC4 Interconnects4\nLAB LAB LABdata_o ut\n[3..0]\n4OE\n[3..0]\n4fast_o ut\n[3..0]\nFast I/O\nInterconnect\nPath4data_in\n[3..0]Column I/O Block\nLAB Local\nInterconnectLAB Col umn\nClock [3..0]\nTable 2–4. MAX V I/O Standards (Part 1 of 2)\nI/O Standard TypeOutput Supply Voltage (V CCIO) \n(V)\n3.3-V LVTTL/LVCMOS Single-ended 3.3\n2.5-V LVTTL/LVCMOS Single-ended 2.5\n1.8-V LVTTL/LVCMOS Single-ended 1.8\n1.5-V LVCMOS Single-ended 1.51.2-V LVCMOS Single-ended 1.2\n2–30 Chapter 2: MAX V Architecture\nI/O Structure\nMAX V Device Handbook June 2017 Altera CorporationThe 5M40Z, 5M80Z, 5M160Z, 5M240Z, and 5M570Z devices support two I/O banks, \nas shown in Figure 2–22 . Each of these banks support  all the LVTTL, LVCMOS, LVDS, \nand RSDS standards shown in Table 2–4 . PCI compliant I/O is not supported in these \ndevices and banks.3.3-V PCI (1) Single-ended 3.3\nLVDS (2) Differential 2.5\nRSDS (3) Differential 2.5\nNotes to Table 2–4 :\n(1) The 3.3-V PCI compliant I/O is supported in Bank 3 of the 5M1270Z and 5M2210Z devices.\n(2) MAX V devices only support emulated LVDS output using a three resistor network (LVDS_E_3R).(3) MAX V devices only support emul ated RSDS output using a three resistor network (RSDS_E_3R).\nFigure 2–22. I/O Banks for 5M40Z, 5M80Z, 5M160Z, 5M240Z, and 5M570Z Devices (Note 1) , (2)\nNotes to Figure 2–22 :\n(1) Figure 2–22  is a top view of the silicon die.\n(2) Figure 2–22  is a graphical representation only. Refer to the pin list and the Quartus II software for exact pin locations.\n(3) This I/O standard is not supported in Bank 1.\n(4) Emulated LVDS output using a th ree resistor network (LVDS_E_3R).\n(5) Emulated RSDS output using a three resistor network (RSDS_E_3R).Table 2–4. MAX V I/O Standards (Part 2 of 2)\nI/O Standard TypeOutput Supply Voltage (V CCIO) \n(V)\nAll I/O Ba nks Support\n3.3-V LVTTL/LVCMO S,\n2.5-V LVTTL/LVCMO S,\n1.8-V LVTTL/LVCMO S,\n1.5-V LVCMO S,\n1.2-V \nLVDS (4)\nRSDS (5), LVCMO S (3),I/O Ba nk 2 I/O Ba nk 1\nChapter 2: MAX V Architecture 2–31\nI/O Structure\nJune 2017 Altera Corporation MAX V Device HandbookThe 5M1270Z and 5M2210Z devices support four I/O banks, as shown in Figure 2–23 . \nEach of these banks support all of the LVTTL, LVCMOS, LVDS, and RSDS standards \nshown in Table 2–4 . PCI compliant I/O is supported in Bank 3. Bank 3 supports the \nPCI clamping diode on inputs and PCI driv e compliance on outputs. You must use \nBank 3 for designs requiring PCI compliant I/O pins. The Quartus II software \nautomatically places I/O pins in this bank  if assigned with the PCI I/O standard. \nEach I/O bank has dedicated V CCIO pins that determine the voltage standard support \nin that bank. A single device can support 1.2- V, 1.5-V, 1.8-V, 2.5-V,  and 3.3-V interfaces; \neach individual bank can support a differ ent standard. Each I/O bank can support \nmultiple standards with the same V CCIO for input and output pins. For example, when \nVCCIO is 3.3 V, Bank 3 can support LVTTL, LVCMOS, and 3.3-V PCI. V CCIO powers \nboth the input and output buffers in MAX V devices. \nThe JTAG pins for MAX V devices are dedica ted pins that cannot be used as regular \nI/O pins. The pins TMS, TDI, TDO, and TCK support all the I/O standards shown in \nTable 2–4 on page 2–29  except for PCI and 1.2-V LVCMOS . These pins reside in Bank 1 \nfor all MAX V devices and their I/O standard support is controlled by the V CCIO \nsetting for Bank 1.Figure 2–23. I/O Banks for 5M1270Z and 5M2210Z Devices (Note 1) , (2)\nNotes to Figure 2–23 :\n(1) Figure 2–23  is a top view of the silicon die.\n(2) Figure 2–23  is a graphical representation only. Refer to the pin list and the Quartu s II software for exact pin locations.\n(3) This I/O standard is not supported in Bank 1.(4) Emulated LVDS output using a th ree resistor network (LVDS_E_3R).\n(5) Emulated RSDS output using a three resistor network (RSDS_E_3R).I/O Ba nk 2\nI/O Ba nk 3\nI/O Ba nk 4I/O Ba nk 1Also Supports\nthe 3.3-V PCI\nI/O Sta ndard All I/O Ba nks Support\n3.3-V LVTTL/LVCMO S,\n2.5-V LVTTL/LVCMO S,\n1.8-V LVTTL/LVCMO S,\n1.5-V LVCMO S,\n1.2-V LVCMO S (3),\nLVDS (4),\nRSDS(5)\n2–32 Chapter 2: MAX V Architecture\nI/O Structure\nMAX V Device Handbook June 2017 Altera CorporationPCI Compliance\nThe MAX V 5M1270Z and 5M2210Z devices are compliant with PCI applications as \nwell as all 3.3-V electric al specifications in the PCI Local Bus Specification Revision 2.2 . \nThese devices are also large enough to supp ort PCI intellectual property (IP) cores. \nTable 2–5  shows the MAX V device speed gr ades that meet the PCI timing \nspecifications.\nLVDS and RSDS Channels\nThe MAX V device supports emulated LVDS  and RSDS outputs on both row and \ncolumn I/O banks. You can configure the rows and columns as emulated LVDS or \nRSDS output buffers that us e two single-ended output buffers with three external \nresistor networks.\nSchmitt Trigger\nThe input buffer for each MAX V device I/O pin has an optional Schmitt trigger \nsetting for the 3.3-V and 2.5-V standards. Th e Schmitt trigger allows input buffers to \nrespond to slow input edge rates with a fa st output edge rate. Most importantly, \nSchmitt triggers provide hysteresis on the input buffer, preventing slow-rising noisy \ninput signals from ringing or oscillating on the input signal driven into the logic array. \nThis provides system noise tolerance on MAX V inputs, but adds a small, nominal input delay.\nThe JTAG input pins (\nTMS, TCK, and TDI) have Schmitt trigger buffers that are always \nenabled.\n1 The TCK input is susceptible to high pulse glitches when the input signal fall time is \ngreater than 200 ns for all I/O standards.Table 2–5. 3.3-V PCI Electrical Specifications and PCI Timing Support for MAX V Devices\nDevice 33-MHz PCI\n5M1270Z All Speed Grades\n5M2210Z All Speed Grades\nTable 2–6. LVDS and RSDS Channels supported in MAX V Devices (Note 1)\nDevice 64 MBGA 64 EQFP 68 MBGA 100 TQFP 100 MBGA 144 TQFP 256 FBGA 324 FBGA \n5 M 4 0 Z 1 0  e T x 2 0  e T x ——————\n5 M 8 0 Z 1 0  e T x 2 0  e T x 2 0  e T x 3 3  e T x ————5M160Z — 20 eTx 20 eTx 33 eTx 33 eTx — — —\n5M240Z — — 20 eTx 33 eTx 33 eTx 49 eTx — —\n5M570Z — — — 28 eTx 28 eTx 49 eTx 75 eTx —5M1270Z — — — — — 42 eTx 90 eTx 115 eTx\n5M2210Z — — ———— 8 3  e T x 115 eTx\nNote to Table 2–6 :\n(1) eTx = emulated LVDS output buffers (LVDS_E_3R ) or emulated RSDS output buffers (RSDS_E_3R).\nChapter 2: MAX V Architecture 2–33\nI/O Structure\nJune 2017 Altera Corporation MAX V Device HandbookOutput Enable Signals\nEach MAX V IOE output buffer supports outp ut enable signals for tri-state control. \nThe output enable signal can originate from the GCLK[3..0]  global signals or from the \nMultiTrack interconnect. The MultiTrack in terconnect routes output enable signals \nand allows for a unique output enable for each output or bidirectional pin.\nMAX V devices also provide a ch ip-wide output enable pin ( DEV_OE ) to control the \noutput enable for every output pin in the design. An option set before compilation in \nthe Quartus II software controls this pin. This chip-wide output enable uses its own routing resources and does not use any of the four global resources. If this option is \nturned on, all outputs on the chip operate normally when \nDEV_OE  is asserted. When \nthe pin is deasserted, all outputs are tri-stated. If this option is turned off, the DEV_OE \npin is disabled when the device operates in user mode and is available as a user I/O \npin.\nProgrammable Drive Strength\nThe output buffer for each MAX V device  I/O pin has two levels of programmable \ndrive strength control for each of the LVTTL and LVCMOS I/O standards. \nProgrammable drive strength provides sy stem noise reduction control for high \nperformance I/O designs. Although a separate slew-rate control feature exists, using \nthe lower drive strength setting provides signal slew-rate control to reduce system \nnoise and signal overshoot without the large delay adder associated with the \nslew-rate control feature. Table 2–7  lists the possible settings for the I/O standards \nwith drive strength control. The Quartu s II software uses the maximum current \nstrength as the default setting. The PCI I/O st andard is always set at 20 mA with no \nalternate setting.\n1 The programmable drive strength feature can be used simultaneously with the \nslew-rate control feature.Table 2–7. Programmable Drive Strength (Note 1)\nI/O Standard IOH/IOL Current Strength Setting (mA)\n3.3-V LVTTL16\n8\n3.3-V LVCMOS8\n4\n2.5-V LVTTL/LVCMOS14\n7\n1.8-V LVTTL/LVCMOS6\n3\n1.5-V LVCMOS4\n2\n1.2-V LVCMOS 3\nNote to Table 2–7 :\n(1) The I OH current strength numbers show n are for a condition of a V OUT = V OH minimum, where the V OH \nminimum is specified by the I/O standard. The I OL current strength numbers shown are for a condition of a \nVOUT = V OL maximum, where the V OL maximum is specified by the I/O standard. For 2.5-V LVTTL/LVCMOS, \nthe I OH condition is V OUT = 1.7 V and the I OL condition is V OUT= 0.7 V.\n2–34 Chapter 2: MAX V Architecture\nI/O Structure\nMAX V Device Handbook June 2017 Altera CorporationSlew-Rate Control\nThe output buffer for each MAX V devi ce I/O pin has a programmable output \nslew-rate control that can be configured fo r low noise or high-speed performance. A \nfaster slew rate provides high-speed tr ansitions for high-performance systems. \nHowever, these fast transitions may introduc e noise transients into the system. A slow \nslew rate reduces system noise, but adds a nominal output delay to rising and falling \nedges. The lower the voltage standard (f or example, 1.8-V LVTTL) the larger the \noutput delay when slow slew is enabled. Each I/O pin has an individual slew-rate control, allowing you to specify the slew rate on a pin-by-pin basis. The slew-rate \ncontrol affects both the rising and falling edges. If no slew-rate control is specified, the \nQuartus II software defaults to a fast slew rate.\n1 The slew-rate control feature can be used  simultaneously wi th the programmable \ndrive strength feature.\nOpen-Drain Output\nMAX V devices provide an optional open-dra in (equivalent to open-collector) output \nfor each I/O pin. This open-drain output enables the device to provide system-level \ncontrol signals (for example, interrupt and wr ite enable signals) that can be asserted \nby any of several devices. This output can also provide an additional wired-OR plane. \nProgrammable Ground Pins\nEach unused I/O pin on MAX V devices can be used as an additional ground pin. \nThis programmable ground feature does not require the use of the associated LEs in \nthe device. In the Quartus II software, un used pins can be se t as programmable GND \non a global default basis or they can be individually assigned. Unused pins also have \nthe option of being set as tri-stated input pins.\nBus-Hold\nEach MAX V device I/O pin provides an op tional bus-hold feature. The bus-hold \ncircuitry can hold the signal on an I/O pin at its last-driven state. Because the bus-\nhold feature holds the last-driven state of the pin until the next input signal is present, \nan external pull-up or pull-down resistor is not necessary to hold a signal level when the bus is tri-stated. \nThe bus-hold circuitry also pulls un-dri ven pins away from the input threshold \nvoltage where noise can cause unintended hi gh-frequency switching. You can select \nthis feature individually for each I/O pin. The bus-hold output will drive no higher \nthan V\nCCIO to prevent overdriving signals. If the bus-hold feature is enabled, the \ndevice cannot use the prog rammable pull-up option. \nThe bus-hold circuitry is only active after th e device has fully initialized. The bus-hold \ncircuit captures the value on the pin pres ent at the moment user mode is entered.\nChapter 2: MAX V Architecture 2–35\nI/O Structure\nJune 2017 Altera Corporation MAX V Device HandbookProgrammable Pull-Up Resistor\nEach MAX V device I/O pin provides an optional programmable pull-up resistor \nduring user mode. If you enable this feature for an I/O pin, the pull-up resistor holds \nthe output to the V CCIO level of the output pin’s bank.\n1 The programmable pull-up resistor feature shou ld not be used at the same time as the \nbus-hold feature on a given I/O pin.\n1 The programmable pull-u p resistor is active during power-up, ISP, and if the device is \nunprogrammed.\nProgrammable Input Delay\nThe MAX V IOE includes a programmable input delay that is activated to ensure zero hold times. A path where a pin directly drives a register, with minimal routing \nbetween the two, may require the delay to ensure zero hold time. However, a path \nwhere a pin drives a register through long  routing or through combinational logic \nmay not require the delay to achieve a zero  hold time. The Quartus II software uses \nthis delay to ensure zero hold times when needed.\nMultiVolt I/O Interface\nThe MAX V architecture supports the MultiV olt I/O interface feature, which allows \nMAX V devices in all packages to interface with systems of different supply voltages. \nThe devices have one set of VCC pins for internal operation (V CCINT ), and up to four \nsets for input buffers and I/O output driver buffers (V CCIO), depending on the \nnumber of I/O banks available in the devices where each set of VCCIO  pins powers one \nI/O bank. The 5M40Z, 5M80Z, 5M160Z, 5M240Z, and 5M570Z devices each have two I/O banks while the 5M1270Z and 5M2210Z devices each have four I/O banks.\nConnect \nVCCIO  pins to either a 1.2-, 1.5-, 1.8-, 2.5-, or 3.3-V powe r supply, depending \non the output requirements. The output le vels are compatible with systems of the \nsame voltage as the power supply (that is, when VCCIO  pins are connected to a 1.5-V \npower supply, the output levels are compatible with 1.5-V systems). When VCCIO  pins \nare connected to a 3.3-V power supply, the outp ut high is 3.3 V and is compatible with \n3.3-V or 5.0-V systems. Table 2–8  summarizes MAX V MultiVolt I/O support.\nTable 2–8. MultiVolt I/O Support in MAX V Devices (Part 1 of 2) (Note 1)\nVCCIO (V)Input Signal Output Signal\n1 . 2  V1 . 5  V1 . 8  V2 . 5  V3 . 3  V5 . 0  V1 . 2  V1 . 5  V1 . 8  V2 . 5  V3 . 3  V5 . 0  V\n1.2 v ————— v —————\n1.5 —vvvv —vv ————\n1.8 —vvvv —v (2)v (2)v ———\n2.5 ——— vv —v (3)v (3)v (3)v ——\n2–36 Chapter 2: MAX V Architecture\nDocument Revision History\nMAX V Device Handbook June 2017 Altera CorporationDocument Revision History\nTable 2–9  lists the revision history for this chapter.3.3 ——— v (4)vv  (5)v (6)v (6)v (6)v (6)vv  (7)\nNotes to Table 2–8 :\n(1) To drive inputs higher than V CCIO but less than 4.0 V including the over shoot, disable the I/O clamp diode. However, to drive 5.0-V signals to \nthe device, enable the I/O clamp diode to prevent V I from rising above 4.0 V. Use an external diode if the I/O pin does not support the clamp \ndiode.\n(2) When V CCIO = 1.8 V, a MAX V device can drive a 1.2-V or 1.5-V device with 1.8-V tolerant inputs.\n(3) When V CCIO = 2.5 V, a MAX V device can drive a 1.2-V, 1. 5-V, or 1.8-V device with 2.5-V tolerant inputs.\n(4) When V CCIO = 3.3 V and a 2.5-V input signal feeds an input pin, the VCCIO supp ly current will be slightly  larger than expected.\n(5) MAX V devices can be 5.0-V tolerant with the use of an external resistor and the in ternal I/O clamp diode  on the 5M1270Z and  5M2210Z devices. \nUse an external cl amp diode if the in ternal clamp diode is not available.\n(6) When V CCIO = 3.3 V, a MAX V device can drive a 1.2-V, 1.5-V, 1.8-V, or 2.5-V device with 3.3-V tolerant inputs.\n(7) When V CCIO = 3.3 V, a MAX V device can drive a device with 5.0-V TTL inputs but not 5.0-V CMOS inputs. For 5.0-V CMOS, open-drain setting \nwith internal I/O clamp diode (a vailable only on 5M1270Z and 5M22 10Z devices) and external resistor  is required. Use an externa l clamp diode \nif the internal clamp diode is not available.Table 2–8. MultiVolt I/O Support in MAX V Devices (Part 2 of 2) (Note 1)\nVCCIO (V)Input Signal Output Signal\n1 . 2  V1 . 5  V1 . 8  V2 . 5  V3 . 3  V5 . 0  V1 . 2  V1 . 5  V1 . 8  V2 . 5  V3 . 3  V5 . 0  V\nTable 2–9. Document Revision History\nDate Version Changes\nDecember 2010 1.0 Initial release.\nMAX V Device Handbook\nMay 2011MV51003-1.2\nSubscribe© 2011 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.3. DC and Switching Characteristics for\nMAX V Devices\nThis chapter covers the electrical and switching characteristics for MAX®V devices. \nElectrical characteristics include operating conditions and power consumptions. This \nchapter also describes the timing model and specifications.\nYou must consider the recommended DC and switching conditions described in this \nchapter to maintain the highest possible performance and reliability of the MAX V \ndevices.\nThis chapter contains the following sections:\n■“Operating Conditions” on page 3–1\n■“Power Consumption” on page 3–10\n■“Timing Model and Specifications” on page 3–10\nOperating Conditions\nTable 3–1  through Table 3–15 on page 3–9  list information about absolute maximum \nratings, recommended operating conditions, DC electrical characteristics, and other \nspecifications for MAX V devices.\nAbsolute Maximum Ratings\nTable 3–1  lists the absolute maximum ratings for the MAX V device family.\nTable 3–1. Absolute Maximum Ratings for MAX V Devices (Note 1) , (2)\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCINT Internal supply voltage With respect to ground –0.5 2.4 V\nVCCIO I/O supply voltage — –0.5 4.6 V\nVI DC input voltage — –0.5 4.6 V\nIOUT DC output current, per pin — –25 25 mA\nTSTG Storage temperature No bias –65 150 °C\nTAMB Ambient temperature Under bias (3) –65 135 °C\nTJ Junction temperatureTQFP and BGA packages \nunder bias— 135 °C\nNotes to Table 3–1 :\n(1) For more informat ion, refer to the Operating Requirements for Altera Devices Data Sheet.\n(2) Conditions beyond those listed in Table 3–1  may cause permanent damage to a device. Additionally,  device operation at the absolute maximum \nratings for extended periods of time may have adverse affects on the device.\n(3) For more information about “under bias” conditions, refer to Table 3–2 .May 2011\nMV51003-1.2\n3–2 Chapter 3: DC and Switching Characteristics for MAX V Devices\nOperating Conditions\nMAX V Device Handbook May 2011 Altera CorporationRecommended Operating Conditions\nTable 3–2  lists recommended operating conditions for the MAX V device family. \nTable 3–2. Recommended Operating Conditions for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCINT (1)1.8-V supply voltage for internal logic and \nin-system programming (ISP)MAX V devices 1.71 1.89 V\nVCCIO (1)Supply voltage for I/O buffers, 3.3-V \noperation—3 . 0 0 3 . 6 0 V\nSupply voltage for I/O buffers, 2.5-V \noperation— 2.375 2.625 V\nSupply voltage for I/O buffers, 1.8-V \noperation—1 . 7 1 1 . 8 9 V\nSupply voltage for I/O buffers, 1.5-V \noperation— 1.425 1.575 V\nSupply voltage for I/O buffers, 1.2-V \noperation—1 . 1 4 1 . 2 6 V\nVI Input voltage (2), (3), (4) –0.5 4.0 V\nVO Output voltage — 0 V CCIO V\nTJ Operating junction temperatureCommercial range 0 85 °C\nIndustrial range –40 100 °CExtended range (5) –40 125 °C\nNotes to Table 3–2 :\n(1) MAX V device ISP and/or user flash memory  (UFM) programming using JTAG or logic a rray is not guaranteed outside the recommend ed \noperating conditi ons (for example, if brown-out occu rs in the system during a potential wr ite/program sequence to the UFM, Alte ra recommends \nthat you read back the UFM contents and ver ify it against the intended write data).\n(2) The minimum DC input is –0.5 V. During transitions, the input s may undershoot to –2.0 V for input currents less than 100 mA and periods \nshorter than 20 ns.\n(3) During transitions, the inputs may overshoot to the volt ages shown below based on the input duty cycle. The DC case is equiv alent to 100% \nduty cycle. For more information ab out 5.0-V tolerance, refer to the  Using MAX V Devices in Multi-Voltage Systems chapter.\nVIN Max. Duty Cycle\n4.0 V 100% (DC)4.1 V 90%4.2 V 50%4.3 V 30%4.4 V 17%4.5 V 10%\n(4) All pins, including the clock, I/O, and JTAG pins, may be driven before V\nCCINT and V CCIO are powered.\n(5) For the extended temperature range of 100 to 125°C, MAX V UFM programmi ng (erase/write) is only su pported using the JTAG inte rface. UFM \nprogramming using the logic array interf ace is not guaranteed in this range.\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–3\nOperating Conditions\nMay 2011 Altera Corporation MAX V Device HandbookProgramming/Erasure Specifications\nTable 3–3  lists the programming/erasure specifications for the MAX V device family. \nDC Electrical Characteristics\nTable 3–4  lists DC electrical characteristics for the MAX V device family. Table 3–3. Programming/Erasure Specifications for MAX V Devices\nParameter Block Minimum Typical Maximum Unit\nErase and reprogram cyclesUFM — — 1000 (1) Cycles\nConfiguration flash memory (CFM) — — 100 Cycles\nNote to Table 3–3 :\n(1) This value applies to the commercial grade devices. For the industria l grade devices, the value is 100 cycles.\nTable 3–4. DC Electrical Characteristics for MAX V Devices (Note 1) (Part 1 of 2)\nSymbol Parameter Conditions Minimum Typical Maximum Unit\nII Input pin leakage current V I = V CCIO max to 0 V (2) –10 — 10  µA\nIOZTri-stated I/O pin leakage \ncurrentVO = V CCIO max to 0 V (2) –10 — 10  µA\nICCSTANDBYVCCINT supply current \n(standby) (3)5M40Z, 5M80Z, 5M160Z, and \n5M240Z (Commercial grade) \n(4), (5)—2 59 0 µ A\n5M240Z (Commercial grade) \n(6)—2 79 6 µ A\n5M40Z, 5M80Z, 5M160Z, and \n5M240Z (Industrial grade) \n(5), (7)—2 5 1 3 9 µ A\n5M240Z (Industrial grade) (6) —2 7 1 5 2 µ A\n5M570Z (Commercial grade) \n(4)—2 79 6 µ A\n5M570Z (Industrial grade) (7) —2 7 1 5 2 µ A\n5M1270Z and 5M2210Z — 2 — mA\nVSCHMITT  (8)Hysteresis for Schmitt \ntrigger input (9)VCCIO = 3.3 V — 400 — mV\nVCCIO = 2.5 V — 190 — mV\nICCPOWERUPVCCINT supply current \nduring power-up (10)MAX V devices — — 40 mA\nRPULLUPValue of I/O pin pull-up \nresistor during user \nmode and ISPVCCIO = 3.3 V (11) 5 — 25 k \uf057\nVCCIO = 2.5 V (11) 1 0—4 0 k \uf057\nVCCIO = 1.8 V (11) 2 5—6 0 k \uf057\nVCCIO = 1.5 V (11) 4 5—9 5 k \uf057\nVCCIO = 1.2 V (11) 80 — 130 k \uf057\n3–4 Chapter 3: DC and Switching Characteristics for MAX V Devices\nOperating Conditions\nMAX V Device Handbook May 2011 Altera CorporationIPULLUPI/O pin pull-up resistor \ncurrent when I/O is \nunprogrammed—— — 3 0 0 µ A\nCIOInput capacitance for \nuser I/O pin—— — 8 p F\nCGCLKInput capacitance for \ndual-purpose GCLK/user I/O pin—— — 8 p F\nNotes to Table 3–4 :\n(1) Typical values are for T A = 25°C, V CCINT = 1.8 V and V CCIO = 1.2, 1.5, 1.8, 2.5, or 3.3 V.\n(2) This value is specified for normal device operation. Th e value may vary during power- up. This applies to all V CCIO settings (3.3, 2.5, 1.8, 1.5, \nand 1.2 V).\n(3) V I = ground, no load, and no toggling inputs.\n(4) Commercial temperature ranges from 0°C to 85°C with the maximum current at 85°C.\n(5) Not applicable to the T14 4 package of the 5M240Z device.\n(6) Only applicable to the T144 package of the 5M240Z device.\n(7) Industrial temperature ranges from –40°C to 100°C with the maximum current at 100°C.(8) This value applies to co mmercial and industrial range devices. For extended temperature range devices, the V\nSCHMITT  typical value is 300 mV \nfor V CCIO = 3.3 V and 120 mV for V CCIO = 2.5 V.\n(9) The TCK input is susceptible to high pulse glitches when th e input signal fall time is greater than 200 ns for all I/O standards. \n(10) This is a peak current value with a maximum duration of t CONFIG  time.\n(11) Pin pull-up resistance values will lower if an ex ternal source drives the pin higher than V CCIO.Table 3–4. DC Electrical Characteristics for MAX V Devices (Note 1) (Part 2 of 2)\nSymbol Parameter Conditions Minimum Typical Maximum Unit\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–5\nOperating Conditions\nMay 2011 Altera Corporation MAX V Device HandbookOutput Drive Characteristics\nFigure 3–1  shows the typical drive strength characteristics of MAX V devices.\nI/O Standard Specifications\nTable 3–5  through Table 3–13 on page 3–8  list the I/O standard specifications for the \nMAX V device family.Figure 3–1. Output Drive Characteristics of MAX V Devices (Note 1)\nNotes to Figure 3–1 :\n(1) The DC output current per pin is s ubject to the absolute maximum rating of Table 3–1 on page 3–1 .\n(2) 1.2-V V CCIO is only applicable to the maximum drive strength.05101520253035\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5Voltage (V)Typical IOOutput Current (mA)3.3-V VCCIO\n2.5-V VCCIO\n1.8-V VCCIO\n1.5-V VCCIO(Minimum Drive Strength)MAX V Output Drive IOH Characteristics \n051015202530\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5Voltage (V)Typical IOOutput Current (mA)3.3-V VCCIO\n2.5-V VCCIO\n1.8-V VCCIO\n1.5-V VCCIO(Minimum Drive Strength)MAX V Output Drive IOL Characteristics0102030405060\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5\nVoltage (V)Typical IOOutput Current (mA)3.3-V VCCIO\n2.5-V VCCIO\n1.8-V VCCIO\n1.5-V VCCIO(Maximum Drive Strength)MAX V Output Drive IOL Characteristics \n1.2-V VCCIO (2)MAX V Output Drive IOH Characteristics\n(Maximum Drive Strength)\n010203040506070\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5\nVoltage (V)Typical IOOutput Current (mA)3.3-V VCCIO\n2.5-V VCCIO\n1.8-V VCCIO\n1.5-V VCCIO\n1.2-V VCCIO (2)\nTable 3–5. 3.3-V LVTTL Specifications for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCIO I/O supply voltage — 3.0 3.6 V\nVIH High-level input voltage — 1.7 4.0 V\nVIL Low-level input voltage — –0.5 0.8 V\nVOH High-level output voltage IOH = –4 mA (1) 2.4 — V\nVOL Low-level output voltage IOL = 4 mA (1) —0 . 4 5 V\nNote to Table 3–5 :\n(1) This specification is supported across all the programmable drive strength setting s available for this I/O standard, as show n in the\nMAX V Device Architecture  chapter.\n3–6 Chapter 3: DC and Switching Characteristics for MAX V Devices\nOperating Conditions\nMAX V Device Handbook May 2011 Altera CorporationTable 3–6. 3.3-V LVCMOS Specifications for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCIO I/O supply voltage — 3.0 3.6 V\nVIH High-level input voltage — 1.7 4.0 V\nVIL Low-level input voltage — –0.5 0.8 V\nVOH High-level output voltageVCCIO = 3.0, \nIOH = –0.1 mA (1)VCCIO – 0.2 — V\nVOL Low-level output voltageVCCIO = 3.0,\nIOL = 0.1 mA (1)—0 . 2 V\nNote to Table 3–6 :\n(1) This specification is supported across all the programmable drive strength setting s available for this I/O standard, as show n in the\nMAX V Device Architecture  chapter.\nTable 3–7. 2.5-V I/O Specifications for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCIO I/O supply voltage — 2.375 2.625 V\nVIH High-level input voltage — 1.7 4.0 V\nVIL Low-level input voltage — –0.5 0.7 V\nVOH High-level output voltageIOH = –0.1 mA (1) 2.1 — V\nIOH = –1 mA (1) 2.0 — V\nIOH = –2 mA (1) 1.7 — V\nVOL Low-level output voltageIOL = 0.1 mA (1) —0 . 2 V\nIOL = 1 mA (1) —0 . 4 V\nIOL = 2 mA (1) —0 . 7 V\nNote to Table 3–7 :\n(1) This specification is supported across all the programmable drive strength setting s available for this I/O standard, as show n in the\nMAX V Device Architecture  chapter.\nTable 3–8. 1.8-V I/O Specifications for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCIO I/O supply voltage — 1.71 1.89 V\nVIH High-level input voltage — 0.65 × V CCIO 2.25 (2) V\nVIL Low-level input voltage — –0.3 0.35 × V CCIO V\nVOH High-level output voltage IOH = –2 mA (1) VCCIO – 0.45 — V\nVOL Low-level output voltage IOL = 2 mA (1) —0 . 4 5 V\nNotes to Table 3–8 :\n(1) This specification is supported across all the programmable drive strength setting s available for this I/O standard, as show n in the\nMAX V Device Architecture  chapter.\n(2) This maximum V IH reflects the JEDEC specification. The MAX V input buffer can tolerate a V IH maximum of 4.0, as specified by the V I parameter \nin Table 3–2 on page 3–2 .\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–7\nOperating Conditions\nMay 2011 Altera Corporation MAX V Device HandbookTable 3–9. 1.5-V I/O Specifications for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCIO I/O supply voltage — 1.425 1.575 V\nVIH High-level input voltage — 0.65 × V CCIO VCCIO + 0.3 (2) V\nVIL Low-level input voltage — –0.3 0.35 × V CCIO V\nVOH High-level output voltage IOH = –2 mA (1) 0.75 × V CCIO —V\nVOL Low-level output voltage IOL = 2 mA (1) — 0.25 × V CCIO V\nNotes to Table 3–9 :\n(1) This specification is supported across all the programmable drive strength setting s available for this I/O standard, as show n in the\nMAX V Device Architecture  chapter.\n(2) This maximum V IH reflects the JEDEC specifi cation. The MAX V input bu ffer can tolerate a V IH maximum of 4.0, as specified by the V I parameter \nin Table 3–2 on page 3–2 .\nTable 3–10. 1.2-V I/O Specifications for MAX V Devices\nSymbol Parameter Conditions Minimum Maximum Unit\nVCCIO I/O supply voltage — 1.14 1.26 V\nVIH High-level input voltage — 0.8 × V CCIO VCCIO+0 . 3 V\nVIL Low-level input voltage — –0.3 0.25 × V CCIO V\nVOH High-level output voltage IOH = –2 mA (1) 0.75 × V CCIO —V\nVOL Low-level output voltage IOL = 2 mA (1) — 0 . 2 5×V CCIO V\nNote to Table 3–10 :\n(1) This specification is supported across all the programmable drive strength setting s available for this I/O standard, as show n in the\nMAX V Device Architecture  chapter.\nTable 3–11. 3.3-V PCI Specifications for MAX V Devices (Note 1)\nSymbol Parameter Conditions Minimum Typical Maximum Unit\nVCCIO I/O supply voltage — 3.0 3.3 3.6 V\nVIH High-level input voltage — 0.5 × V CCIO —V CCIO + 0.5 V\nVIL Low-level input voltage — –0.5 — 0.3 × V CCIO V\nVOH High-level output voltage IOH = –500 µA 0.9 × V CCIO —— V\nVOL Low-level output voltage IOL = 1.5 mA — — 0.1 × V CCIO V\nNote to Table 3–11 :\n(1) 3.3-V PCI I/O standard is only supported in Bank 3 of the 5M12 70Z and 5M2210Z devices.\nTable 3–12. LVDS Specifications for MAX V Devices (Note 1)\nSymbol Parameter Conditions Minimum Typical Maximum Unit\nVCCIO I/O supply voltage — 2.375 2.5 2.625 V\nVOD Differential output voltage swing — 247 — 600 mV\nVOS Output offset voltage — 1.125 1.25 1.375 V\nNote to Table 3–12 :\n(1) Supports emulated LVDS output using a three-resistor network (LVDS_E_3R).\n3–8 Chapter 3: DC and Switching Characteristics for MAX V Devices\nOperating Conditions\nMAX V Device Handbook May 2011 Altera CorporationBus Hold Specifications\nTable 3–14  lists the bus hold specifications for the MAX V device family. Table 3–13. RSDS Specifications for MAX V Devices (Note 1)\nSymbol Parameter Conditions Minimum Typical Maximum Unit\nVCCIO I/O supply voltage — 2.375 2.5 2.625 V\nVOD Differential output voltage swing — 247 — 600 mV\nVOS Output offset voltage — 1.125 1.25 1.375 V\nNote to Table 3–13 :\n(1) Supports emulated RSDS output using a three-resistor network (RSDS_E_3R).\nTable 3–14. Bus Hold Specifications for MAX V Devices\nParameter ConditionsVCCIO Level\nUnit 1 . 2  V1 . 5  V1 . 8  V2 . 5  V3 . 3  V\nMin Max Min Max Min Max Min Max Min Max\nLow sustaining \ncurrentVIN > V IL ( m a x i m u m ) 1 0—2 0—3 0—5 0—7 0—µ A\nHigh sustaining \ncurrentVIN < V IH (minimum) –10 — –20 — –30 — –50 — –70 — µA\nLow overdrive \ncurrent0 V < V IN < V CCIO — 130 — 160 — 200 — 300 — 500 µA\nHigh overdrive \ncurrent0 V < V IN < V CCIO —– 1 3 0—– 1 6 0—– 2 0 0—– 3 0 0—– 5 0 0µ A\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–9\nOperating Conditions\nMay 2011 Altera Corporation MAX V Device HandbookPower-Up Timing\nTable 3–15  lists the power-up timing characteristics for the MAX V device family.\nTable 3–15. Power-Up Timing for MAX V Devices\nSymbol Parameter Device Temperature Range Min Typ Max Unit\ntCONFIGThe amount of time from \nwhen minimum V CCINT is \nreached until the device \nenters user mode (1)5M40ZCommercial and industrial — — 200 µs\nExtended — — 300 µs\n5M80ZCommercial and industrial — — 200 µs\nExtended — — 300 µs\n5M160ZCommercial and industrial — — 200 µs\nExtended — — 300 µs\n5M240Z (2)Commercial and industrial — — 200 µs\nExtended — — 300 µs\n5M240Z (3)Commercial and industrial — — 300 µs\nExtended — — 400 µs\n5M570ZCommercial and industrial — — 300 µs\nExtended — — 400 µs\n5M1270Z (4)Commercial and industrial — — 300 µs\nExtended — — 400 µs\n5M1270Z (5)Commercial and industrial — — 450 µs\nExtended — — 500 µs\n5M2210ZCommercial and industrial — — 450 µs\nExtended — — 500 µs\nNotes to Table 3–15 :\n(1) For more information abou t power-on reset (POR) trig ger voltage, refer to the  Hot Socketing and Power-On Reset in MAX V Devices  chapter.\n(2) Not applicable to the T14 4 package of the 5M240Z device.\n(3) Only applicable to the T144 package of the 5M240Z device.\n(4) Not applicable to the F324  package of the 5M1270Z device.\n(5) Only applicable to the F324  package of the 5M1270Z device.\n3–10 Chapter 3: DC and Switching Characteristics for MAX V Devices\nPower Consumption\nMAX V Device Handbook May 2011 Altera CorporationPower Consumption\nYou can use the Altera® PowerPlay Early Power Estimator and PowerPlay Power \nAnalyzer to estimate the device power. \nf For more information about these power analysis tools, refer to the PowerPlay Early \nPower Estimator for Altera CPLDs User Guide  and the PowerPlay Power Analysis  chapter \nin volume 3 of the Quartus II Handbook.\nTiming Model and Specifications\nMAX V devices timing can be analyzed with the Altera Quartus®II software, a variety \nof industry-standard EDA simulators and timing analyzers, or with the timing model shown in Figure 3–2 . \nMAX V devices have predictable internal delays that allow you to determine the \nworst-case timing of any design. The software provides timing simulation, point-to-point delay prediction, and detailed timing analysis for device-wide \nperformance evaluation.\nYou can derive the timing characteristics of  any signal path from the timing model \nand parameters of a particular device. You can calculate external timing parameters, \nwhich represent pin-to-pin timing delays, as the sum of the internal parameters.\nf For more information, refer to  AN629: Understanding Timing in Altera CPLDs . Figure 3–2. Timing Model for MAX V Devices\nI/O Pin I/O Input Delay\ntIN\nINPUT\nGlobal Input DelaytC4tR4\nOutput\nDelay\ntOD\ntXZ\ntZXtLOCAL\ntGLOBLogic Element\nI/O PintFASTIOOutput Routing\nDelayUser\nFlash\nMemory\nFrom Adjace nt LE\nTo Adjace nt LEInput Routing\nDelay\ntDLtLUT\ntCLUT Delay\nRegister Control\n Delay\nRegi ster Delay stCO\ntSU\ntH\ntPRE\ntCLRData-I n/LUT Chai n\nData-O uttIODROutput and Output Enable \nData Delay\ntIOE\ntCOMB\nCombi national Path Delay\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–11\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookPreliminary and Final Timing\nThis section describes the performance, internal, external, and UFM timing \nspecifications. All specifications are representative of the worst-case supply voltage \nand junction temperature conditions.\nTiming models can have either preliminar y or final status. The Quartus II software \nissues an informational message during the design compilation if the timing models \nare preliminary. Table 3–16  lists the status of the MAX V device timing models.\nPreliminary status means the timing model is subject to change. Initially, timing \nnumbers are created using simulation results, process data, and other known \nparameters. These tests are used to make the preliminary numbers as close to the \nactual timing parameters as possible.\nFinal timing numbers are based on actual  device operation and testing. These \nnumbers reflect the actual performance of the device under the worst-case voltage \nand junction temperature conditions.\nPerformance\nTable 3–17  lists the MAX V device performance for some common designs. All \nperformance values were obtained with the Quartus II software compilation of \nmegafunctions.Table 3–16. Timing Model Status for MAX V Devices\nDevice Final\n5M40Z v\n5M80Z v\n5M160Z v\n5M240Z v\n5M570Z v\n5M1270Z v\n5M2210Z v\nTable 3–17. Device Performance for MAX V Devices (Part 1 of 2)\nResource \nUsedDesign Size and \nFunctionResources UsedPerformance\nUnit5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nMode LEsUFM \nBlocksC4 C5, I5 C4 C5, I5\nLE16-bit counter (1) — 16 0 184.1 118.3 247.5 201.1 MHz\n64-bit counter (1) — 64 0 83.2 80.5 154.8 125.8 MHz\n16-to-1 multiplexer — 11 0 17.4 20.4 8.0 9.3 ns\n32-to-1 multiplexer — 24 0 12.5 25.3 9.0 11.4 ns\n16-bit XOR function — 5 0 9.0 16.1 6.6 8.2 ns\n16-bit decoder with \nsingle address line— 5 0 9.2 16.1 6.6 8.2 ns\n3–12 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationInternal Timing Parameters\nInternal timing parameters are specified on  a speed grade basis independent of device \ndensity. Table 3–18  through Table 3–25 on page 3–19  list the MAX V device internal \ntiming microparameters for LEs, input/ou tput elements (IOEs), UFM blocks, and \nMultiTrack interconnects.\nf For more information about each internal timing microparameters symbol, refer to \nAN629: Understanding Timi ng in Altera CPLDs .UFM512 × 16 None 3 1 10.0 10.0 10.0 10.0 MHz\n512 × 16 SPI (2) 37 1 9.7 9.7 8.0 8.0 MHz\n512 × 8Parallel \n(3)73 1 ( 4 )( 4 )( 4 )( 4 ) MHz\n512 × 16 I2C (3) 142 1 100 (5) 100 (5) 100 (5) 100 (5) kHz\nNotes to Table 3–17 :\n(1) This design is a bina ry loadable up counter. \n(2) This design is configured for read-onl y operation in Extended mode . Read and write ability incr eases the number of logic ele ments (LEs) used.\n(3) This design is configured for read -only operation. Read a nd write ability increases the number of LEs used.\n(4) This design is asynchronous.(5) The I\n2C megafunction is verified in hardware up to 100-kHz serial  clock line rate.Table 3–17. Device Performance for MAX V Devices (Part 2 of 2)\nResource \nUsedDesign Size and \nFunctionResources UsedPerformance\nUnit5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nMode LEsUFM \nBlocksC4 C5, I5 C4 C5, I5\nTable 3–18. LE Internal Timing Microparameters for MAX V Devices (Part 1 of 2)\nSymbol Parameter5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\ntLUTLE combinational look-up \ntable (LUT) delay — 1,215  — 2,247  — 742  — 914 ps\ntCOMB Combinational path delay  — 243  — 309  — 192  — 236 ps\ntCLR LE register clear delay 401  — 545  — 309  — 381  — ps\ntPRE LE register preset delay 401  — 545  — 309  — 381  — ps\ntSULE register setup time \nbefore clock260  — 321  — 271  — 333  — ps\ntHLE register hold time \nafter clock0 —0 —0   —0   — p s\ntCOLE register \nclock-to-output delay — 380  — 494  — 305  — 376 ps\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–13\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbooktCLKHLMinimum clock high or \nlow time253  — 339  — 216  — 266  — ps\ntC Register control delay  — 1,356 — 1,741  — 1,114  — 1,372 psTable 3–18. LE Internal Timing Microparameters for MAX V Devices (Part 2 of 2)\nSymbol Parameter5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\nTable 3–19. IOE Internal Timing Microparameters for MAX V Devices\nSymbol Parameter5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\ntFASTIO Data output delay from \nadjacent LE to I/O block — 170  — 428  — 207  — 254 ps\ntINI/O input pad and buffer \ndelay — 907  — 986  — 920  — 1,132 ps\ntGLOB (1)I/O input pad and buffer \ndelay used as global \nsignal pin — 2,261  — 3,322  — 1,974  — 2,430 ps\ntIOEInternally generated \noutput enable delay — 530  — 1,410  — 374  — 460 ps\ntDL Input routing delay  — 318  — 509  — 291  — 358 ps\ntOD (2)Output delay buffer and \npad delay — 1,319  — 1,543  — 1,383  — 1,702 ps\ntXZ (3)Output buffer disable \ndelay — 1,045  — 1,276  — 982  — 1,209 ps\ntZX (4)Output buffer enable \ndelay — 1,160  — 1,353  — 1,303  — 1,604 ps\nNotes to Table 3–19 :\n(1) Delay numbers for t GLOB differ for each device density and sp eed grade. The de lay numbers for t GLOB, shown in Table 3–19 , are based on a 5M240Z \ndevice target.\n(2) For more information about delay adders  associated with different I/O standards, drive strengths, and slew rates, refer to Table 3–34 on page 3–\n24 and Table 3–35 on page 3–25 .\n(3) For more information about t XZ delay adders associated with different I/O standa rds, drive strengths, and slew rates, refer to Table 3–22 on page 3–\n15 and Table 3–23 on page 3–15 .\n(4) For more information about t ZX delay adders associated with different I/O standa rds, drive strengths, and slew rates, refer to Table 3–20 on page 3–\n14 and Table 3–21 on page 3–14 .\n3–14 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationTable 3–20  through Table 3–23  list the adder delays for t ZX and t XZ microparameters \nwhen using an I/O standard other than 3.3-V LVTTL with 16 mA drive strength.\nTable 3–20. t ZX IOE Microparameter Adders for Fast Slew Rate for MAX V Devices\nStandard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTL1 6  m A  —0 —0 —0 —0 p s\n8 mA  — 72  — 74  — 101  — 125 ps\n3.3-V LVCMOS8  m A  —0 —0 —0 —0 p s\n4 mA  — 72  — 74  — 101  — 125 ps\n2.5-V LVTTL / \nLVCMOS14 mA  — 126  — 127  — 155  — 191 ps\n7 mA  — 196  — 197  — 545  — 671 ps\n1.8-V LVTTL / \nLVCMOS6 mA  — 608  — 610  — 721  — 888 ps\n3 mA  — 681  — 685  — 2012  — 2477 ps\n1.5-V LVCMOS4 mA  — 1162  — 1157  — 1590  — 1957 ps\n2 mA  — 1245  — 1244  — 3269  — 4024 ps\n1.2-V LVCMOS 3 mA — 1889 — 1856 — 2860 — 3520 ps\n3.3-V PCI 20 mA  — 72  — 74  — –18  — –22 psLVDS — — 126 — 127 — 155 — 191 ps\nRSDS — — 126 — 127 — 155 — 191 ps\nTable 3–21. t ZX IOE Microparameter Adders for Slow Slew Rate for MAX V Devices\nStandard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTL16 mA  — 5,951  — 6,063  — 6,012  — 5,743 ps\n8 mA  — 6,534  — 6,662  — 8,785  — 8,516 ps\n3.3-V LVCMOS8 mA  — 5,951  — 6,063  — 6,012  — 5,743 ps\n4 mA  — 6,534  — 6,662  — 8,785  — 8,516 ps\n2.5-V LVTTL / \nLVCMOS14 mA  — 9,110  — 9,237  — 10,072  — 9,803 ps\n7 mA  — 9,830  — 9,977  — 12,945  — 12,676 ps\n1.8-V LVTTL / \nLVCMOS6 mA  — 21,800  — 21,787  — 21,185  — 20,916 ps\n3 mA  — 23,020  — 23,037  — 24,597  — 24,328 ps\n1.5-V LVCMOS4 mA  — 39,120  — 39,067  — 34,517  — 34,248 ps\n2 mA  — 40,670  — 40,617  — 39,717  — 39,448 ps\n1.2-V LVCMOS 3 mA  — 69,505  — 70,461  — 55,800  — 55,531 ps\n3.3-V PCI 20 mA  — 6,534  — 6,662  — 35  — 44 ps\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–15\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookTable 3–22. t XZ IOE Microparameter Adders for Fast Slew Rate for MAX V Devices\nStandard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTL1 6  m A —0—0—0—0 p s\n8 mA — –69 — –69 — –74 — –91 ps\n3.3-V LVCMOS8  m A —0—0—0—0 p s\n4 mA — –69 — –69 — –74 — –91 ps\n2.5-V LVTTL / \nLVCMOS14 mA — –7 — –10 — –46 — –56 ps\n7 mA — –66 — –69 — –82 — –101 ps\n1.8-V LVTTL / \nLVCMOS6  m A—4 5—3 7—– 7—– 8 p s\n3 mA — 34 — 25 — 119 — 147 ps\n1.5-V LVCMOS4 mA — 166 — 155 — 339 — 418 ps\n2 mA — 190 — 179 — 464 — 571 ps\n1.2-V LVCMOS 3 mA — 300 — 283 — 817 — 1,006 ps\n3.3-V PCI 20 mA — –69 — –69 — 80 — 99 ps\nLVDS — — –7 — –10 — –46 — –56 ps\nRSDS — — –7 — –10 — –46 — –56 ps\nTable 3–23. t XZ IOE Microparameter Adders for Slow Slew Rate for MAX V Devices\nStandard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTL16 mA — 171 — 174 — 73 — –132 ps\n8 mA — 112 — 116 — 758 — 553 ps\n3.3-V LVCMOS8 mA — 171 — 174 — 73 — –132 ps\n4 mA — 112 — 116 — 758 — 553 ps\n2.5-V LVTTL / \nLVCMOS14 mA — 213 — 213 — 32 — –173 ps\n7 mA — 166 — 166 — 714 — 509 ps\n1.8-V LVTTL / \nLVCMOS6 mA — 441 — 438 — 96 — –109 ps\n3 mA — 496 — 494 — 963 — 758 ps\n1.5-V LVCMOS4 mA — 765 — 755 — 238 — 33 ps\n2 mA — 903 — 897 — 1,319 — 1,114 ps\n1.2-V LVCMOS 3 mA — 1,159 — 1,130 — 400 — 195 ps3.3-V PCI 20 mA — 112 — 116 — 303 — 373 ps\n3–16 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera Corporation1 The default slew rate setting for MAX V devi ces in the Quartus II design software is \n“fast”.\nTable 3–24. UFM Block Internal Timing Microparameters for MAX V Devices (Part 1 of 2)\nSymbol Parameter5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\ntACLKAddress register clock \nperiod100 — 100 — 100 — 100 — ns\ntASUAddress register shift \nsignal setup to address \nregister clock2 0—2 0—2 0—2 0— n s\ntAHAddress register shift \nsignal hold to address register clock2 0—2 0—2 0—2 0— n s\nt\nADSAddress register data in \nsetup to address register clock2 0—2 0—2 0—2 0— n s\nt\nADHAddress register data in \nhold from address \nregister clock2 0—2 0—2 0—2 0— n s\ntDCLK Data register clock period 100 — 100 — 100 — 100 — ns\ntDSSData register shift signal \nsetup to data register \nclock6 0—6 0—6 0—6 0— n s\ntDSHData register shift signal \nhold from data register \nclock2 0—2 0—2 0—2 0— n s\ntDDSData register data in \nsetup to data register clock2 0—2 0—2 0—2 0— n s\nt\nDDHData register data in hold \nfrom data register clock2 0—2 0—2 0—2 0— n s\ntDPProgram signal to data \nclock hold time0—0—0—0— n s\ntPBMaximum delay between \nprogram rising edge to \nUFM busy  signal rising \nedge— 960 — 960 — 960 — 960 ns\ntBPMinimum delay allowed \nfrom UFM busy  signal \ngoing low to program \nsignal going low2 0—2 0—2 0—2 0— n s\ntPPMXMaximum length of busy  \npulse during a program— 100 — 100 — 100 — 100 µs\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–17\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbooktAEMinimum erase  signal \nto address clock hold \ntime0—0—0—0  — n s\ntEBMaximum delay between \nthe erase  rising edge to \nthe UFM busy  signal \nrising edge— 960 — 960 — 960 — 960 ns\ntBEMinimum delay allowed \nfrom the UFM busy  \nsignal going low to \nerase  signal going low2 0—2 0—2 0—2 0— n s\ntEPMXMaximum length of busy  \npulse during an erase— 500 — 500 — 500 — 500 ms\ntDCODelay from data register \nclock to data register output—5—5—5—5 n s\nt\nOEDelay from OSC_ENA  \nsignal reaching UFM to \nrising clock of OSC \nleaving the UFM180 — 180 — 180 — 180 — ns\ntRAMaximum read access \ntime—6 5—6 5—6 5—6 5 n s\ntOSCSMaximum delay between \nthe OSC_ENA  rising edge \nto the erase/program  \nsignal rising edge250 — 250 — 250 — 250 — ns\ntOSCHMinimum delay allowed \nfrom the \nerase/program  signal \ngoing low to OSC_ENA  \nsignal going low250 — 250 — 250 — 250 — nsTable 3–24. UFM Block Internal Timing Microparameters for MAX V Devices (Part 2 of 2)\nSymbol Parameter5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3–18 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationFigure 3–3  through Figure 3–5  show the read, program, and erase waveforms for \nUFM block timing parameters listed in Table 3–24 .\nFigure 3–3. UFM Read Waveform\ntDCOtDCLKtDSStDSHtADH\ntADStASUtACLKtAHARShft\nARClk\nARDin\nDRShft\nDRClk\nDRDin\nDRDo ut\nProgram\nErase\nBusy16 Data Bits9 Address Bits\nOSC_E NA\nFigure 3–4. UFM Program Waveform\ntADStASU tACLK\ntADHtAH\ntDDStDCLK tDSStDSH\ntDDH\ntPB tBP\ntPPMXtOSCStOSCHARShft\nARClk\nARDin\nDRShft\nDRClk\nDRDin\nDRDo ut\nProgram\nErase\nBusy16 Data Bits9 Address Bits\nOSC_E NA\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–19\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookExternal Timing Parameters\nExternal timing parameters are specified by device density and speed grade. All \nexternal I/O timing parameters shown are for the 3.3-V LVTTL I/O standard with the \nmaximum drive strength and fast slew rate . For external I/O timing using standards \nother than LVTTL or for different drive strengths, use the I/O standard input and \noutput delay adders in Table 3–32 on page 3–23  through Table 3–36 on page 3–25 .\nf For more information about each external  timing parameters symbol, refer to \nAN629: Understanding Timi ng in Altera CPLDs .Figure 3–5. UFM Erase Waveform\nARShft\nARClk\nARDin\nDRShft\nDRClk\nDRDin\nDRDo ut\nProgram\nErase\nBusy9 Address BitstASUtACLK tAH\ntADH\ntADS\ntEB\ntEPMXtOSCStOSCHOSC_E NA\ntBE\nTable 3–25. Routing Delay Internal Timing Microparameters for MAX V Devices\nRouting5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\ntC4 — 860 — 1,973 — 561 — 690 ps\ntR4 — 655 — 1,479 — 445 — 548 ps\ntLOCAL — 1,143 — 2,947 — 731 — 899 ps\n3–20 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationTable 3–26  lists the external I/O timing parame ters for the 5M40Z, 5M80Z, 5M160Z, \nand 5M240Z devices.\nTable 3–27  lists the external I/O timing para meters for the T144 package of the \n5M240Z device.Table 3–26. Global Clock External I/O Timing Parameters for the 5M40Z, 5M80Z, 5M160Z, and 5M240Z Devices\n(Note 1) , (2)\nSymbol Parameter ConditionC4 C5, I5\nUnit\nMin Max Min Max\ntPD1 Worst case pin-to-pin delay through one LUT 10 pF — 7.9 — 14.0 ns\ntPD2 Best case pin-to-pin delay through one LUT 10 pF — 5.8 — 8.5 ns\ntSU Global clock setup time — 2.4 — 4.6 — ns\ntH Global clock hold time — 0 — 0 — ns\ntCO Global clock to output delay 10 pF 2.0 6.6 2.0 8.6 ns\ntCH Global clock high time — 253 — 339 — ps\ntCL Global clock low time — 253 — 339 — ps\ntCNTMinimum global clock period for \n16-bit counter— 5 . 4—8 . 4— n s\nfCNTMaximum global clock frequency for 16-bit \ncounter— — 184.1 — 118.3 MHz\nNotes to Table 3–26 :\n(1) The maximum frequency is limited by the I/O standard on the clock input pin. The 16 -bit counter critical delay performs fast er than this global \nclock input pin maximum frequency.\n(2) Not applicable to the T14 4 package of the 5M240Z device.\nTable 3–27. Global Clock External I/O Timing Parameters for the 5M240Z Device (Note 1) , (2)\nSymbol Parameter ConditionC4 C5, I5\nUnit\nMin Max Min Max\ntPD1 Worst case pin-to-pin delay through one LUT 10 pF — 9.5 — 17.7 ns\ntPD2 Best case pin-to-pin delay through one LUT 10 pF — 5.7 — 8.5 ns\ntSU Global clock setup time — 2.2 — 4.4 — ns\ntH Global clock hold time — 0 — 0 — ns\ntCO Global clock to output delay 10 pF 2.0 6.7 2.0 8.7 ns\ntCH Global clock high time — 253 — 339 — ps\ntCL Global clock low time — 253 — 339 — ps\ntCNTMinimum global clock period for 16-bit \ncounter— 5 . 4—8 . 4— n s\nfCNTMaximum global clock frequency for 16-bit \ncounter— — 184.1 — 118.3 MHz\nNotes to Table 3–27 :\n(1) The maximum frequency is limited by the I/O standard on the clock input pin. The 16 -bit counter critical delay performs fast er than this global \nclock input pin maximum frequency.\n(2) Only applicable to the T144 package of the 5M240Z device.\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–21\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookTable 3–28  lists the external I/O timing parameters for the 5M570Z device.\nTable 3–29  lists the external I/O timing parameters for the 5M1270Z device.Table 3–28. Global Clock External I/O Timing Parameters for the 5M570Z Device (Note 1)\nSymbol Parameter ConditionC4 C5, I5\nUnit\nMin Max Min Max\ntPD1 Worst case pin-to-pin delay through one LUT 10 pF — 9.5 — 17.7 ns\ntPD2 Best case pin-to-pin delay through one LUT 10 pF — 5.7 — 8.5 ns\ntSU Global clock setup time — 2.2 — 4.4 — ns\ntH Global clock hold time — 0 — 0 — ns\ntCO Global clock to output delay 10 pF 2.0 6.7 2.0 8.7 ns\ntCH Global clock high time — 253 — 339 — ps\ntCL Global clock low time — 253 — 339 — ps\ntCNTMinimum global clock period for 16-bit \ncounter— 5 . 4—8 . 4— n s\nfCNTMaximum global clock frequency for 16-bit \ncounter— — 184.1 — 118.3 MHz\nNote to Table 3–28 :\n(1) The maximum frequency is limited by the I/O standard on the clock input pin. The 16 -bit counter critical delay performs fast er than this global \nclock input pin maximum frequency.\nTable 3–29. Global Clock External I/O Timing Parameters for the 5M1270Z Device (Note 1) , (2)\nSymbol Parameter ConditionC4 C5, I5\nUnit\nMin Max Min Max\ntPD1 Worst case pin-to-pin delay through one LUT 10 pF — 8.1 — 10.0 ns\ntPD2 Best case pin-to-pin delay through one LUT 10 pF — 4.8 — 5.9 ns\ntSU Global clock setup time — 1.5 — 1.9 — ns\ntH G l o b a l  c l o c k  h o l d  t i m e — 0—0— n s\ntCO Global clock to output delay 10 pF 2.0 5.9 2.0 7.3 ns\ntCH Global clock high time — 216 — 266 — ps\ntCL Global clock low time — 216 — 266 — ps\ntCNTMinimum global clock period for 16-bit \ncounter— 4 . 0—5 . 0— n s\nfCNTMaximum global clock frequency for 16-bit \ncounter— — 247.5 — 201.1 MHz\nNotes to Table 3–29 :\n(1) The maximum frequency is limited by the I/O standard on the clock input pin. The 16 -bit counter critical delay performs fast er than this global \nclock input pin maximum frequency.\n(2) Not applicable to the F324  package of the 5M1270Z device.\n3–22 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationTable 3–30  lists the external I/O timing parameters for the F324 package of the \n5M1270Z device.\nTable 3–31  lists the external I/O timing parameters for the 5M2210Z device.Table 3–30. Global Clock External I/O Timing Parameters for the 5M1270Z Device (Note 1) , (2)\nSymbol Parameter ConditionC4 C5, I5\nUnit\nMin Max Min Max\ntPD1 Worst case pin-to-pin delay through one LUT 10 pF — 9.1 — 11.2 ns\ntPD2 Best case pin-to-pin delay through one LUT 10 pF — 4.8 — 5.9 ns\ntSU Global clock setup time — 1.5 — 1.9 — ns\ntH G l o b a l  c l o c k  h o l d  t i m e — 0—0— n s\ntCO Global clock to output delay 10 pF 2.0 6.0 2.0 7.4 ns\ntCH Global clock high time — 216 — 266 — ps\ntCL Global clock low time — 216 — 266 — ps\ntCNTMinimum global clock period for 16-bit \ncounter— 4 . 0—5 . 0— n s\nfCNTMaximum global clock frequency for 16-bit \ncounter— — 247.5 — 201.1 MHz\nNotes to Table 3–30 :\n(1) The maximum frequency is limited by the I/O standard on the clock input pin. The 16 -bit counter critical delay performs fast er than this global \nclock input pin maximum frequency.\n(2) Only applicable to the F324  package of the 5M1270Z device.\nTable 3–31. Global Clock External I/O Timing Parameters for the 5M2210Z Device (Note 1)\nSymbol Parameter ConditionC4 C5, I5\nUnit\nMin Max Min Max\ntPD1 Worst case pin-to-pin delay through one LUT 10 pF — 9.1 — 11.2 ns\ntPD2 Best case pin-to-pin delay through one LUT 10 pF — 4.8 — 5.9 ns\ntSU Global clock setup time — 1.5 — 1.9 — ns\ntH G l o b a l  c l o c k  h o l d  t i m e — 0—0— n s\ntCO Global clock to output delay 10 pF 2.0 6.0 2.0 7.4 ns\ntCH Global clock high time — 216 — 266 — ps\ntCL Global clock low time — 216 — 266 — ps\ntCNTMinimum global clock period for 16-bit \ncounter— 4 . 0—5 . 0— n s\nfCNTMaximum global clock frequency for 16-bit \ncounter— — 247.5 — 201.1 MHz\nNote to Table 3–31 :\n(1) The maximum frequency is limited by the I/O standard on the clock input pin. The 16 -bit counter critical delay performs fast er than this global \nclock input pin maximum frequency.\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–23\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookExternal Timing I/O Delay Adders\nThe I/O delay timing parameters for the I/O standard input and output adders and \nthe input delays are specified by speed grade, independent of device density.\nTable 3–32  through Table 3–36 on page 3–25  list the adder delays associated with I/O \npins for all packages. If you select an I/ O standard other than 3.3-V LVTTL, add the \ninput delay adder to the external t SU timing parameters listed in Table 3–26 on page 3–\n20 through Table 3–31 . If you select an I/O standard  other than 3.3-V LVTTL with \n16 mA drive strength and fast slew rate, add the output delay adder to the external t\nCO and t PD listed in Table 3–26 on page 3–20  through Table 3–31 .\nTable 3–32. External Timing Input Delay Adders for MAX V Devices\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTLWithout Schmitt \nTrigger—0—0—0—0 p s\nWith Schmitt \nTrigger— 387 — 442 — 480 — 591 ps\n3.3-V LVCMOS Without Schmitt \nTrigger—0—0—0—0 p s\nWith Schmitt \nTrigger— 387 — 442 — 480 — 591 ps\n2.5-V LVTTL / \nLVCMOSWithout Schmitt \nTrigger— 42 — 42 — 246 — 303 ps\nWith Schmitt \nTrigger— 429 — 483 — 787 — 968 ps\n1.8-V LVTTL / \nLVCMOS Without Schmitt \nTrigger— 378 — 368 — 695 — 855 ps\n1.5-V LVCMOSWithout Schmitt \nTrigger— 681 — 658 — 1,334 — 1,642 ps\n1.2-V LVCMOSWithout Schmitt \nTrigger— 1,055 — 1,010 — 2,324 — 2,860 ps\n3.3-V PCI Without Schmitt \nTrigger—0—0—0—0 p s\nTable 3–33. External Timing Input Delay t GLOB Adders for GCLK Pins for MAX V Devices (Part 1 of 2)\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTLWithout Schmitt \nTrigger—0—0—0—0 p s\nWith Schmitt \nTrigger— 387 — 442 — 400 — 493 ps\n3–24 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera Corporation3.3-V LVCMOS Without Schmitt \nTrigger—0—0—0—0 p s\nWith Schmitt \nTrigger— 387 — 442 — 400 — 493 ps\n2.5-V LVTTL / \nLVCMOSWithout Schmitt \nTrigger— 242 — 242 — 287 — 353 ps\nWith Schmitt \nTrigger— 429 — 483 — 550 — 677 ps\n1.8-V LVTTL / \nLVCMOSWithout Schmitt \nTrigger— 378 — 368 — 459 — 565 ps\n1.5-V LVCMOSWithout Schmitt \nTrigger— 681 — 658 — 1,111 — 1,368 ps\n1.2-V LVCMOSWithout Schmitt \nTrigger— 1,055 — 1,010 — 2,067 — 2,544 ps\n3.3-V PCI Without Schmitt \nTrigger—0—0—7—9 p sTable 3–33. External Timing Input Delay t GLOB Adders for GCLK Pins for MAX V Devices (Part 2 of 2)\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\nTable 3–34. External Timing Output Delay and t OD Adders for Fast Slew Rate for MAX V Devices\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTL1 6  m A —0—0—0—0 p s\n8  m A —3 9—5 8—8 4— 1 0 4 p s\n3.3-V LVCMOS8  m A —0—0—0—0 p s\n4  m A —3 9—5 8—8 4— 1 0 4 p s\n2.5-V LVTTL / LVCMOS14 mA — 122 — 129 — 158 — 195 ps\n7 mA — 196 — 188 — 251 — 309 ps\n1.8-V LVTTL / LVCMOS6 mA — 624 — 624 — 738 — 909 ps\n3 mA — 686 — 694 — 850 — 1,046 ps\n1.5-V LVCMOS4 mA — 1,188 — 1,184 — 1,376 — 1,694 ps\n2 mA — 1,279 — 1,280 — 1,517 — 1,867 ps\n1.2-V LVCMOS 3 mA — 1,911 — 1,883 — 2,206 — 2,715 ps\n3.3-V PCI 20 mA — 39 — 58 — 4 — 5 psLVDS — — 122 — 129 — 158 — 195 ps\nRSDS — — 122 — 129 — 158 — 195 ps\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–25\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookTable 3–35. External Timing Output Delay and t OD Adders for Slow Slew Rate for MAX V Devices\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\n3.3-V LVTTL16 mA — 5,913 — 6,043 — 6,612 — 6,293 ps\n8 mA — 6,488 — 6,645 — 7,313 — 6,994 ps\n3.3-V LVCMOS8 mA — 5,913 — 6,043 — 6,612 — 6,293 ps\n4 mA — 6,488 — 6,645 — 7,313 — 6,994 ps\n2.5-V LVTTL / LVCMOS14 mA — 9,088 — 9,222 — 10,021 — 9,702 ps\n7 mA — 9,808 — 9,962 — 10,881 — 10,562 ps\n1.8-V LVTTL / LVCMOS6 mA — 21,758 — 21,782 — 21,134 — 20,815 ps\n3 mA — 23,028 — 23,032 — 22,399 — 22,080 ps\n1.5-V LVCMOS4 mA — 39,068 — 39,032 — 34,499 — 34,180 ps\n2 mA — 40,578 — 40,542 — 36,281 — 35,962 ps\n1.2-V LVCMOS 3 mA — 69,332 — 70,257 — 55,796 — 55,477 ps\n3.3-V PCI 20 mA — 6,488 — 6,645 — 339 — 418 ps\nTable 3–36. IOE Programmable Delays for MAX V Devices\nParameter5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z5M1270Z/ 5M2210Z\nUnitC4 C5, I5 C4 C5, I5\nMin Max Min Max Min Max Min Max\nInput Delay from Pin to Internal \nCells = 1— 1,858 — 2,214 — 1,592 — 1,960 ps\nInput Delay from Pin to Internal \nCells = 0— 569 — 616 — 115 — 142 ps\n3–26 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationMaximum Input and Ou tput Clock Rates\nTable 3–37  and Table 3–38  list the maximum input and ou tput clock rates for standard \nI/O pins in MAX V devices.\nTable 3–37. Maximum Input Clock Rate for I/Os for MAX V Devices\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z/5M1270Z/\n5M2210Z Unit\nC4, C5, I5\n3.3-V LVTTLWithout Schmitt Trigger 304 MHz\nWith Schmitt Trigger 304 MHz\n3.3-V LVCMOSWithout Schmitt Trigger 304 MHz\nWith Schmitt Trigger 304 MHz\n2.5-V LVTTLWithout Schmitt Trigger 304 MHz\nWith Schmitt Trigger 304 MHz\n2.5-V LVCMOSWithout Schmitt Trigger 304 MHz\nWith Schmitt Trigger 304 MHz\n1.8-V LVTTL Without Schmitt Trigger 200 MHz\n1.8-V LVCMOS Without Schmitt Trigger 200 MHz\n1.5-V LVCMOS Without Schmitt Trigger 150 MHz\n1.2-V LVCMOS Without Schmitt Trigger 120 MHz3.3-V PCI Without Schmitt Trigger 304 MHz\nTable 3–38. Maximum Output Clock Rate for I/Os for MAX V Devices\nI/O Standard5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z/5M1270Z/\n5M2210Z Unit\nC4, C5, I5\n3.3-V LVTTL 304 MHz\n3.3-V LVCMOS 304 MHz\n2.5-V LVTTL 304 MHz\n2.5-V LVCMOS 304 MHz1.8-V LVTTL 200 MHz\n1.8-V LVCMOS 200 MHz\n1.5-V LVCMOS 150 MHz1.2-V LVCMOS 120 MHz\n3.3-V PCI 304 MHz\nLVDS 304 MHzRSDS 200 MHz\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–27\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookLVDS and RSDS Output  Timing Specifications\nTable 3–39  lists the emulated LVDS output timi ng specifications for MAX V devices.\nTable 3–39. Emulated LVDS Output Timing Specifications for MAX V Devices\nParameter Mode5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z/5M1270Z/\n5M2210Z\nUnit\nC4, C5, I5\nMin Max\nData rate (1), (2)\uf0b410 — 304 Mbps\n\uf0b49 — 304 Mbps\n\uf0b48 — 304 Mbps\n\uf0b47 — 304 Mbps\n\uf0b46 — 304 Mbps\n\uf0b45 — 304 Mbps\n\uf0b44 — 304 Mbps\n\uf0b43 — 304 Mbps\n\uf0b42 — 304 Mbps\n\uf0b41 — 304 Mbps\ntDUTY —4 55 5 %\nTotal jitter (3) — — 0.2 UI\ntRISE — — 450 ps\ntFALL — — 450 ps\nNotes to Table 3–39 :\n(1) The performance of the LVDS_E_3R transmitter system is limite d by the lower of the two—the ma ximum data rate supported by LV DS_E_3R \nI/O buffer or 2x (F MAX of the ALTLVDS_TX instance). The actual performance of yo ur LVDS_E_3R transmitter system  must be attained through \nthe Quartus II timing analysis of the complete design.\n(2) For the input clock pin to achie ve 304 Mbps, use I/O standard with V CCIO of 2.5 V and above.\n(3) This specification is based on external clean  clock source.\n3–28 Chapter 3: DC and Switching Characteristics for MAX V Devices\nTiming Model and Specifications\nMAX V Device Handbook May 2011 Altera CorporationTable 3–40  lists the emulated RSDS output timing specifications for MAX V devices.\nTable 3–40. Emulated RSDS Output Timing Specifications for MAX V Devices\nParameter Mode5M40Z/ 5M80Z/ 5M160Z/\n5M240Z/ 5M570Z/5M1270Z/\n5M2210Z\nUnit\nC4, C5, I5\nMin Max\nData rate (1)\uf0b410 — 200 Mbps\n\uf0b49 — 200 Mbps\n\uf0b48 — 200 Mbps\n\uf0b47 — 200 Mbps\n\uf0b46 — 200 Mbps\n\uf0b45 — 200 Mbps\n\uf0b44 — 200 Mbps\n\uf0b43 — 200 Mbps\n\uf0b42 — 200 Mbps\n\uf0b41 — 200 Mbps\ntDUTY —4 55 5 %\nTotal jitter (2) — — 0.2 UI\ntRISE — — 450 ps\ntFALL — — 450 ps\nNotes to Table 3–40 :\n(1) For the input clock pin to achie ve 200 Mbps, use I/O standard with V CCIO of 1.8 V and above.\n(2) This specification is based on external clean  clock source.\nChapter 3: DC and Switching Characteristics for MAX V Devices 3–29\nTiming Model and Specifications\nMay 2011 Altera Corporation MAX V Device HandbookJTAG Timing Specifications\nFigure 3–6  shows the timing waveform for the JTAG signals for the MAX V device \nfamily.\nTable 3–41  lists the JTAG timing parameters and values for the MAX V device family.Figure 3–6. JTAG Timing Waveform for MAX V Devices\nTDITMS\nTDOTCK\nSignal\nto be\nCaptured\nSignal\nto be\nDriventJCP\ntJCH tJCLtJPSU tJPH\ntJPCO tJPXZ tJPZX\ntJSSU tJSH\ntJSZX tJSCO tJSXZ\nTable 3–41. JTAG Timing Parameters for MAX V Devices (Part 1 of 2)\nSymbol Parameter Min Max Unit\ntJCP (1)TCK clock period for V CCIO1 =3 . 3  V 5 5 . 5 — n s\nTCK clock period for V CCIO1 =2 . 5  V 6 2 . 5 — n s\nTCK clock period for V CCIO1 = 1.8 V 100 — ns\nTCK clock period for V CCIO1 = 1.5 V 143 — ns\ntJCH TCK clock high time 20 — ns\ntJCL TCK clock low time 20 — ns\ntJPSU JTAG port setup time (2) 8— n s\ntJPH JTAG port hold time 10 — ns\ntJPCO JTAG port clock to output (2) —1 5n s\ntJPZX JTAG port high impedance to valid output (2) —1 5n s\ntJPXZ JTAG port valid output to high impedance (2) —1 5n s\ntJSSU Capture register setup time 8 — ns\ntJSH Capture register hold time 10 — ns\ntJSCO Update register clock to output — 25 ns\ntJSZX Update register high impedance to valid output — 25 ns\n3–30 Chapter 3: DC and Switching Characteristics for MAX V Devices\nDocument Revision History\nMAX V Device Handbook May 2011 Altera CorporationDocument Revision History\nTable 3–42  lists the revision history for this chapter.tJSXZ Update register valid output to high impedance — 25 ns\nNotes to Table 3–41 :\n(1) Minimum clock peri od specified for 10  pF load on the TDO pin. Larger loads on TDO degrades the maximum TCK frequency.\n(2) This specification is shown for 3.3-V LVTTL/LVCMOS and 2.5-V LVTTL/LVCMOS operation of the JTAG pins. For 1.8-V LVTTL/LVCMOS  and \n1.5-V LVCMOS operation, the t JPSU minimum is 6 ns and t JPCO, tJPZX, and t JPXZ are maximum values at 35 ns.Table 3–41. JTAG Timing Parameters for MAX V Devices (Part 2 of 2)\nSymbol Parameter Min Max Unit\nTable 3–42. Document Revision History\nDate Version Changes\nMay 2011 1.2 Updated Table 3–2 , Table 3–15 , Table 3–16 , and Table 3–33 .\nJanuary 2011 1.1 Updated Table 3–37, Table 3–38, Table 3–39, and Table 3–40.December 2010 1.0 Initial release.\nJune 2017 Altera Corporation MAX V Device HandbookSection II. System Integration in MAX V\nDevices\nThis section provides information about system integration in MAX®V devices.\nThis section includes the following chapters:\n■Chapter 4, Hot Socketing and Power-On Reset in MAX V Devices\n■Chapter 5, Using MAX V Devices in Multi-Voltage Systems\n■Chapter 6, JTAG and In-System Programmability in MAX V Devices\n■Chapter 7, User Flash Memory in MAX V Devices\n■Chapter 8, JTAG Boundary-Scan Testing in MAX V Devices\nII–2 Section II: System Integration in MAX V Devices\nMAX V Device Handbook June 2017 Altera Corporation\nMAX V Device Handbook\nDecember 2010MV51004-1.0\nSubscribe© 2010 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.4. Hot Socketing and Power-On Reset in\nMAX V Devices\nThis chapter provides information about hot-socketing specifications, power-on reset \n(POR) requirements, and their implementation in MAX\uf0d2V devices.\nMAX V devices offer hot socketing, also known as hot plug-in or hot swap, and \npower sequencing support. You can insert or remove a MAX V device in a system \nduring system operation without causing un desirable effects to the running system \nbus. The hot-socketing feature removes some of the difficulty when using MAX V \ndevices on PCBs that contain a mixture of 3.3-, 2.5-, 1.8- , and 1.5-V devices.\nThe MAX V hot-socketing feature provides the following:\n■Board or device insertion and removal\n■Support for any power-up sequence\n■Non-intrusive I/O buffers to syst em buses during hot insertion\nThis chapter contains the following sections:\n■“MAX V Hot-Socketing Specifications” on page 4–1\n■“Hot-Socketing Feature Implementati on in MAX V Devices” on page 4–3\n■“Power-On Reset Circuitry” on page 4–5\nMAX V Hot-Socketing Specifications\nMAX V devices offer the hot-socketing feature without the need for external \ncomponents or special design requirements . The advantages of hot-socketing support \nin MAX V devices includes the following:\n■The device can be driven before and during power up or power down without \ndamaging the device.\n■I/O pins remain tri-stated during power up. The device does not drive out before \nor during power up, thereby affecting other operating buses.\n■Signal pins do not drive the V CCIO or V CCINT  power supplies. External input signals \nto the device I/O pins do not power the device V CCIO or V CCINT  power supplies \nusing internal paths. Th is is true if the V CCINT  and V CCIO power supplies are held at \nGND.\n1 Altera uses GND as a reference for the hot-socketing and I/O buffers circuitry \ndesigns. To ensure device reliability and compliance to the hot-socketing specifications, you must connect GND between boards before connecting the V\nCCINT  \nand V CCIO power supplies.December 2010\nMV51004-1.0\n4–2 Chapter 4: Hot Socketing and Power-On Reset in MAX V Devices\nMAX V Hot-Socketing Specifications\nMAX V Device Handbook December 2010 Altera CorporationDevices Can Be Driv en Before Power Up\nYou can drive signals into the I/O pins and GCLK[3..0]  pins of MAX V devices before \nor during power up or power down without damaging the device. To simplify the \nsystem-level design, MAX V devices support any power-up or power-down sequence \n(VCCIO1 , VCCIO2 , VCCIO3 , VCCIO4 , and V CCINT ).\nI/O Pins Remain Tri-Stated During Power Up\nA device that does not support hot socketin g may interrupt system operation or cause \ncontention by driving out before or during power up. In a hot-socketing situation, the \nMAX V device’s output buffers are turned off during system power up. MAX V \ndevices do not drive out until the device attains proper operating conditions and is \nfully configured. For more information about turn-on voltages, refer to “Power-On \nReset Circuitry” on page 4–5 .\nSignal Pins Do Not Drive the V CCIO or V CCINT Power Supplies\nMAX V devices do not have a current path from the I/O pins or GCLK[3..0]  pins to \nthe V CCIO or V CCINT  power supplies before or during  power up. A MAX V device may \nbe inserted into (or removed from) a system board that is powered up without \ndamaging or interfering with system-board operation. When hot socketing, MAX V devices may have a minimal effect on the signal integrity of the backplane.\nAC and DC Specifications\nYou can power up or power down the V CCIO and V CCINT  power supplies in any \nsequence. During hot socketing, the I/O pi n capacitance is less than 8 pF. MAX V \ndevices meet the following hot-socketing specifications:\n■DC specification: | I IOPIN  | < 300 \uf06dA.\n■AC specification: | I IOPIN  | < 8 mA for 10 ns or less.\n1 MAX V devices are immune to latch-up when hot socketing. If the TCK JTAG input pin \nis driven high during hot socketing, the current on that pin might exceed the \nspecifications listed above.\nIIOPIN  is the current for any user I/O pin on the device. The AC specification applies \nwhen the device is being powered up or powered down. This specification takes into \naccount the pin capacitance but not the boar d trace and external loading capacitance. \nYou must consider additional  capacitance for trace, connector, and loading separately. \nThe peak current duration due to power-up transients is 10 ns or less.\nThe DC specification applies when all V CC supplies to the device are stable in the \npowered-up or powered-down conditions.\nChapter 4: Hot Socketing and Power-On Reset in MAX V Devices 4–3\nHot-Socketing Feature Implem entation in MAX V Devices\nDecember 2010 Altera Corporation MAX V Device HandbookHot-Socketing Feature Implementation in MAX V Devices\nThe hot-socketing feature tri-states the ou tput buffer during the power-up event \n(either the V CCINT  or V CCIO power supplies) or power-do wn event. The hot-socketing \ncircuitry generates an internal HOTSCKT  signal when either V CCINT  or V CCIO is below \nthe threshold voltage during power up or power down. The HOTSCKT signal cuts off \nthe output buffer to ensure that no DC cu rrent leaks through the pin (except for weak \npull-up leaking). When V CC ramps up very slowly  during power up, V CC may still be \nrelatively low even after the POR signal is released and device configuration is \ncomplete.\n1 Ensure that V CCINT  is within the recommended operating range even though SRAM \ndownload has completed.\nFigure 4–1  shows the circuitry for each I/O and clock pin.\nThe POR circuit monitors the V CCINT  and V CCIO voltage levels and keeps the I/O pins \ntri-stated until the device has completed it s flash memory configuration of the SRAM \nlogic. The weak pull-up resistor (R) from the I/O pin to V CCIO is enabled during \ndownload to keep the I/O pins from floa ting. The 3.3-V tolerance control circuit \npermits the I/O pins to be driven by 3.3 V before V CCIO and/or V CCINT  are powered, \nand it prevents the I/O pins from driving out when the device is not fully powered or \noperational. The hot-socketing circuitry prevents the I/O pins from internally \npowering V CCIO and V CCINT  when driven by external signals before the device is \npowered.\nf For more information about the 5.0-V tolerance, refer to the Using MAX V Devices in \nMulti-Voltage Systems  chapter.Figure 4–1. Hot-Socketing Circuitry for MAX V Devices\nOutput EnableVCCIO\nHot Socket Voltage\nTolerance\nControlPower On\nReset\nMonitor\nWeak\nPull-Up\nResistor\nPAD\nInput Buffer\nto Logic Array\n4–4 Chapter 4: Hot Socketing and Power-On Reset in MAX V Devices\nHot-Socketing Feature Implem entation in MAX V Devices\nMAX V Device Handbook December 2010 Altera CorporationFigure 4–2  shows a transistor-level cross sectio n of the MAX V device I/O buffers. \nThis design ensures that the outp ut buffers do not drive when V CCIO is powered \nbefore V CCINT or if the I/O pad voltage is higher than V CCIO. This also applies for \nsudden voltage spikes during hot insertion. The V PAD leakage current charges the \n3.3-V tolerant circuit capacitance.\nThe CMOS output drivers in the I/O pins in trinsically provide electrostatic discharge \n(ESD) protection. There are two cases to consider for ESD voltage strikes—positive \nvoltage zap and nega tive voltage zap.\nA positive ESD voltage zap occurs when a positive voltage is present on an I/O pin \ndue to an ESD charge event. This can caus e the N+ (Drain)/ P-Substrate junction of \nthe N-channel drain to break down and the N+ (Drain)/P-Substrate/N+ (Source) \nintrinsic bipolar transistor turn on to di scharge ESD current from I/O pin to GND. \nThe dashed line in Figure 4–3  shows the ESD current discharge path during a positive \nESD zap.Figure 4–2. Transistor-Level I/O Buffers for MAX V Devices\np - substrate  p+ p+ \nn - well  n+ VCCIO  \nn+ n+ \np - well  IOE SignalVPAD\nIOE Signal or the\nLarger of VCCIO or VPADThe Larger of\nVCCIO or VPADEnsures 3.3-V\nTolerance andHot-SocketProtection\nFigure 4–3. ESD Protection During Positive Voltage Zap\nI/OI/O\nGate\nGateDrain\nDrainPMOS\nNMOSSource\nSource\nGND GNDN+N+\nP-Substrate G\nSD\nChapter 4: Hot Socketing and Power-On Reset in MAX V Devices 4–5\nPower-On Reset Circuitry\nDecember 2010 Altera Corporation MAX V Device HandbookWhen the I/O pin receives a negative ESD zap at the pin that is less than –0.7 V (0.7 V \nis the voltage drop across a diode), the intrinsic \nP-Substrate/N+ drain diode is forward bias ed. Therefore, the discharge ESD current \npath is from GND to the I/O pin, as shown in Figure 4–4 . \nPower-On Reset Circuitry\nMAX V devices have POR circuits to monitor the V CCINT  and V CCIO voltage levels \nduring power up. The POR circuit monitors these voltages, triggering download from \nthe non-volatile configuration flash memory block to the SRAM logic, maintaining the \ntri-state of the I/O pins (with weak pull-up resistors enabled) before and during this \nprocess. When the MAX V device enters user mode, the POR circuit releases the I/O \npins to user functionality. The POR circui t of the MAX V device does not monitor the \nVCCINT  voltage level after the device enters into user mode.\nPower-Up Characteristics\nWhen power is applied to a MAX V device, the POR circuit monitors V CCINT  and \nbegins SRAM download at 1.55 V for MAX V devices. From this voltage reference, the SRAM download and entry into user mode takes 200 to 450 µs maximum, depending \non your device density. This period of time is specified as t\nCONFIG  in the power-up \ntiming section of the DC and Switching Characteristics for MAX V Devices  chapter.\nEntry into user mode is gated by whether all the V CCIO banks are powered with \nsufficient operating voltage. If V CCINT  and V CCIO are powered simultaneously, the \ndevice enters user mode within the t CONFIG  specifications. If V CCIO is powered more \nthan t CONFIG  after V CCINT , the device does not enter user mode until 2 µs after all V CCIO \nbanks are powered. Figure 4–4. ESD Protection During Negative Voltage Zap\nI/OI/O\nGate\nGateDrain\nDrainPMOS\nNMOSSource\nSource\nGND GNDN+N+\nP-Substrate G\nSD\n4–6 Chapter 4: Hot Socketing and Power-On Reset in MAX V Devices\nDocument Revision History\nMAX V Device Handbook December 2010 Altera CorporationFor MAX V devices, the POR circ uitry does not monitor the V CCINT  and V CCIO voltage \nlevels after the device enters  user mode. If there is a V CCINT  voltage sag below 1.4 V \nduring user mode, the functionality of th e device is not guaranteed and you must \npower down V CCINT  to 250 mV for a minimum of 10 µs before powering V CCINT  and \nVCCIO up again. After V CCINT  rises from 250 mV back to approximately 1.55 V, the \nSRAM download restarts and the devi ce begins to operate after the t CONFIG  time has \npassed.\nFigure 4–5  shows the voltages for POR of MAX V devices during power up into user \nmode and from user mode to power down or brown out.\n1 All V CCINT and V CCIO power supplies of all banks must be powered on before entering \nuser mode.\n1 After SRAM configuration, all registers in the device are cleared and released into \nuser function before the I/O tri-states are re leased. To release clears after the tri-states \nare released, use the DEV_CLRn  pin option. To hold the tri-states beyond the power-up \nconfiguration time, use the DEV_OE pin option.\nDocument Revision History\nTable 4–1  lists the revision history for this chapter.Figure 4–5. Power-Up Characteristics for MAX V Devices (Note 1) , (2)\nNotes to Figure 4–5 :\n(1) Time scale is relative.\n(2) For this figure, all the V CCIO banks are powered up simultaneously with the V CCINT profile shown. If this is not the case, t CONFIG  stretches out until all \nVCCIO banks are powered.3.3 V\n1.55 V\nTri-StateUser Mode\nOperation250 mV1.8 V\nTri-State1.4 VMAX V Device\nApproximate Voltage \nfor SRAM Dow nload Sta rtVCCINT must be powe red dow n\n to 250 mV if the VCCINT \ndips below thi s level \ntCONFIG tCONFIG\nUser Mode\nOperationVCCINT\n minimum 10 µs\nTable 4–1. Document Revision History\nDate Version Changes\nDecember 2010 1.0 Initial release.\nMAX V Device Handbook\nJune 2017MV51005-2017.06.16\nSubscribe© 2017 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.5. Using MAX V Devices in Multi-Voltage\nSystems\nThis chapter describes how to implement Altera® devices in multi-voltage systems \nwithout damaging the device or the system.\nTechnological advancements in deep submicron processes have lowered the supply \nvoltage levels of semiconduc tor devices, creating a design environment where devices \non a system board may potentially use many di fferent supply voltages such as 5.0, 3.3, \n2.5, 1.8, 1.5, and 1.2 V, which can ultimately lead to voltage conflicts.\nTo accommodate interfacing with a vari ety of devices on system boards, MAX®V \ndevices have MultiVolt I/O interfaces that allow devices in a mixed-voltage design \nenvironment to communicate directly with  MAX V devices. The MultiVolt interface \nseparates the power supply voltage (V CCINT ) from the output voltage (V CCIO), \nallowing MAX V devices to interface with ot her devices using a different voltage level \non the same PCB. The 1.8-V input directly powers the core of the MAX V devices. \nf For more information about hot socketing and power-on reset (POR), refer to the Hot \nSocketing and Power-On Reset in MAX V Devices  chapter.\nThis chapter contains the following sections:\n■“I/O Standards” on page 5–1\n■“MultiVolt I/O Operation” on page 5–3\n■“5.0-V Device Compatibility” on page 5–3\n■“Recommended Operating Conditions fo r 5.0-V Compatibility” on page 5–7\n■“Power-Up Sequencing” on page 5–8\nI/O Standards\nThe I/O buffer of MAX V devices is prog rammable and supports a wide range of I/O \nvoltage standards. You can program each I/O bank in a MAX V device to comply \nwith a different I/O standard. You can co nfigure all I/O banks with the following \nstandards:\n■3.3-V LVTTL/LVCMOS\n■2.5-V LVTTL/LVCMOS\n■1.8-V LVTTL/LVCMOS\n■1.5-V LVCMOS\n■1.2-V LVCMOS (Not supported in Bank 1)\n■Emulated LVDS output (LVDS_E_3R)\n■Emulated RSDS output (RSDS_E_3R)June 2017\nMV51005-2017.06.16\n5–2 Chapter 5: Using MAX V Devices  in Multi-Voltage Systems\nI/O Standards\nMAX V Device Handbook June 2017 Altera CorporationThe Schmitt trigger input option is support ed by the 3.3-V and 2.5-V I/O standards. \nThe I/O Bank 3 also includes the 3.3-V PCI I/O standard interface capability on the \n5M1270Z and 5M2210Z devices. Figure 5–1  shows the I/O standards supported by \nMAX V devices.\nFigure 5–1. I/O Standards Supported by MAX V Devices (Note 1) , (2), (3), (4), (5)\nNotes to Figure 5–1 :\n(1) Figure 5–1  is a top view of the silicon die.\n(2) Figure 5–1  is a graphical representation only. For the exact pin locations, refer to the pin list and the Quartus®II software.\n(3) 5M40Z, 5M80Z, 5M160Z, 5M240Z, and 5M570Z devices only have two I/O banks.\n(4) The 3.3-V PCI I/O standard is only supported in 5M1270Z and 5M2210Z devices. \n(5) The Schmitt trigger input option for 3.3-V and 2.5-V I/O standards is supported for all I/O pins.(6) This I/O standard is not supported in Bank 1.I/O Ba nk  1I/O Ba nk  2\nI/O Ba nk  3\nI/O Ba nk  4I/O Ba nk 3 \nalso supports \nthe 3.3-V PCI I/O Sta ndard\nAll I/O Ba nks Support\n■ 3.3-V LVTTL/LVCMOS\n■ 2.5-V LVTTL/LVCMOS\n■ 1.8-V LVTTL/LVCMOS\n■ 1.5-V LVCMOS\n■ 1.2-V LVCMOS (6)\n■ Emulated LVDS o utput\n    (LVDS_E_3R)■ Emulated RSDS o utput\n    (RSDS_E_3R)\nIndivid ual\nPowe r Bus\nChapter 5: Using MAX V Devices  in Multi-Voltage Systems 5–3\nMultiVolt I/O Operation\nJune 2017 Altera Corporation MAX V Device HandbookMultiVolt I/O Operation\nMAX V devices allow the device core and I/O blocks to be powere d-up with separate \nsupply voltages. The VCCINT  pins supply power to the device core and the VCCIO  pins \nsupply power to the de vice I/O buffers. The VCCINT  pins are powered-up with 1.8 V \nfor MAX V devices. All the VCCIO  pins for a given I/O bank that have MultiVolt \ncapability must be supplied from the same volt age level (for example, 5.0, 3.3, 2.5, 1.8, \n1.5, or 1.2 V). Figure 5–2  shows how to implement a multiple-voltage system for \nMAX V devices.\n5.0-V Device Compatibility\nA MAX V device can drive a 5.0-V TTL device by connecting the VCCIO  pins of the \nMAX V device to 3.3 V. This is possible because the output high voltage (V OH) of a \n3.3-V interface meets the minimum high-level  voltage of 2.4 V of a 5.0-V TTL device. \nA MAX V device may not correctly interope rate with a 5.0-V CMOS device if the \noutput of the MAX V device is connected directly to the input of the 5.0-V CMOS \ndevice. If the MAX V device‘s V OUT is greater than V CCIO, the PMOS pull-up transistor \nstill conducts if the pin is driving high, pr eventing an external pull-up resistor from \npulling the signal to 5.0 V. To make MAX V device outputs compatible with 5.0-V \nCMOS devices, configure the output pins as open-drain  pins with the I/O clamp \ndiode enabled and use an external pull-up resistor. Figure 5–2. Implementing a Multi-Voltage System with a MAX V Device (Note 1) , (2)\nNotes to Figure 5–2 :\n(1) MAX V devices can drive a 5.0-V transistor -to-transistor logic (TTL) input when V CCIO = 3.3 V. To drive a 5.0-V \nCMOS, you must have an open-drain setting with an internal I/O clam p diode and external resistor.\n(2) MAX V devices can be 5.0-V tolerant with the use of an external resistor and the internal I/O clamp diode on \n5M1270Z and 5M2210Z devices.MAX V\nDevice3.3-, 2.5-, 1.8-,\n1.5-, 1.2-V\nDevice5.0-V\nDevice1.8-V \nPower Supply\nVCCINT\nVCCIO VCCIO\n5–4 Chapter 5: Using MAX V Devices  in Multi-Voltage Systems\n5.0-V Device Compatibility\nMAX V Device Handbook June 2017 Altera CorporationFigure 5–3  shows MAX V device compatibil ity with 5.0-V CMOS devices.\nThe open-drain pin never drives high, only low or tri-state. When the open-drain pin \nis active, it drives low. When the open-drain pin is inactive, the pin is tri-stated and \nthe trace pulls up to 5.0 V by the external resistor. The purpose of enabling the I/O \nclamp diode is to protect the MAX V  device’s I/O pins. The 3.3-V V CCIO supplied to \nthe I/O clamp diodes causes the voltage at point A to clamp at 4.0 V, which meets the \nMAX V device’s reliability limits when the trace voltage exceeds 4.0 V. The device \noperates successfully because a 5.0-V input is within its input specification.\n1 The I/O clamp diode is only supported in  the 5M1270Z and 5M2210Z devices’ I/O \nBank 3. You must have an external protec tion diode for the other I/O banks in the \n5M1270Z and 5M2210Z devices and all the I/O pins in the 5M40Z, 5M80Z, 5M160Z, \n5M240Z, and 5M570Z devices.\nThe pull-up resistor value must be small enou gh for a sufficient signal rise time, but \nlarge enough so that it does not violate the I OL (output low) specification of the \nMAX V devices. \nThe maximum MAX V device I OL depends on the programmable drive strength of the \nI/O output. Table 5–1  lists the programmable drive streng th settings that are available \nfor the 3.3-V LVTTL/LVCMOS I/O standard for MAX V devices. The Quartus II \nsoftware uses the maximum current streng th as the default setting. The PCI I/O \nstandard is always set to 20 mA  with no alternate setting.Figure 5–3. MAX V Device Compatibility with 5.0-V CMOS Devices\nNote to Figure 5–3 :\n(1) This diode is on ly active after power-up. MAX V devices require an external diode if driven by 5.0 V before \npower-up.VCCIO3.3 V\nVCCIO5.0 V ± 0.5 V\nModel as RINT\nVIN\nVSSVCCIO\nREXT\n5.0-V CMOS\nDeviceAVOUTOpen Drain(1)\nTable 5–1. 3.3-V LVTTL/LVCMOS Programmable Drive Strength (Part 1 of 2)\nI/O Standard I OH/IOL Current Strength Setting (mA)\n3.3-V LVTTL16\n8\nChapter 5: Using MAX V Devices  in Multi-Voltage Systems 5–5\n5.0-V Device Compatibility\nJune 2017 Altera Corporation MAX V Device HandbookTo compute the required value of R EXT, first calculate the model of the open-drain \ntransistors on the MAX V device. You can model this output resistor (R EXT) by \ndividing V OL by I OL (REXT = V OL/IOL). Table 5–2  lists the maximum V OL for the 3.3-V \nLVTTL/LVCMOS I/O standard for MAX V devices. \nf For more information about I/O standard specifications, refer to the DC and Switching \nCharacteristics for MAX V Devices  chapter.\nSelect R EXT so that the MAX V device’s I OL specification is not violated. You can \ncompute the required pull -up resistor value of R EXT by using the equation: \nREXT=( V CC/IOL)–R INT. For example, if an I/O pin is  configured as a 3.3-V LVTTL \nwith a 16 mA drive strength, give n that the maximum power supply (V CC) is 5.5 V, \nyou can calculate the value of R EXT as follows:\nThis resistor value computation assumes wo rst-case conditions. You can adjust the \nREXT value according to the devi ce configuration drive strength. Additionally, if your \nsystem does not see a wide variation in voltage-supply levels, you can adjust these calculations accordingly. \nBecause MAX V devices are 3.3-V, 32-bit, 66 -MHz PCI compliant, the input circuitry \naccepts a maximum high-level input voltage (V\nIH) of 4.0 V. To drive a MAX V device \nwith a 5.0-V device, you must connect a resistor (R 2) between the MAX V device and \nthe 5.0-V device.3.3-V LVCMOS8\n4Table 5–1. 3.3-V LVTTL/LVCMOS Programmable Drive Strength (Part 2 of 2)\nI/O Standard I OH/IOL Current Strength Setting (mA)\nTable 5–2. 3.3-V LVTTL/LVCMOS Maximum V OL \nI/O Standard Voltage (V)\n3.3-V LVTTL 0.45\n3.3-V LVCMOS 0.20\nEquation 5–1.\nREXT5.5 V 0.45 V –\uf028\uf029\n16 mA---------------------------------------- - 315.6\uf057 ==\n5–6 Chapter 5: Using MAX V Devices  in Multi-Voltage Systems\n5.0-V Device Compatibility\nMAX V Device Handbook June 2017 Altera CorporationFigure 5–4  shows how to drive a MAX V PCI-comp liant device with a 5.0-V device.\nIf V CCIO for the MAX V devices is 3.3 V and you enabled the I/O clamp diode, the \nvoltage at point B in Figure 5–4  is 4.0 V, which meets the MAX V devices reliability \nlimits when the trace voltage exceeds 4.0 V. To limit large current draw from the 5.0-V \ndevice, R 2 must be small enough for a fast signal rise time and large enough so that it \ndoes not violate the high-level output current (I OH) specifications of the devices \ndriving the trace. \nTo compute the required value of R 2, first calculate the model of the pull-up \ntransistors on the 5.0-V device. You can model this output resistor (R 1) by dividing the \n5.0-V device supply voltage (V CC) by I OH: R1=V CC/IOH.\nFigure 5–5  shows an example of typical output dr ive characteristics of a 5.0 V device.Figure 5–4. Driving a MAX V PCI-Compliant Device with a 5.0-V Device\nNote to Figure 5–4 :\n(1) This diode is on ly active after power-up. MAX V devices require an external diode if driven by 5.0 V before \npower-up.\nFigure 5–5. Output Drive Characteristics of a 5.0-V DeviceVCC\nR2II5.0 V ± 0.5 V\nModel as R15.0-V Device MAX V Device\nVCCIO\nVCCIO3.3 V\nPCI Clamp\nB(1)\n150\n90\n5 4 3 2 13060120135\nVO Output Voltage ( V)Typical \nOutput \nCurrent (mA)IO\nIOHIOL\nVCCINT = 5.0 V \nVCCIO = 5.0 V\nChapter 5: Using MAX V Devices  in Multi-Voltage Systems 5–7\nRecommended Operating Conditions for 5.0-V Compatibility\nJune 2017 Altera Corporation MAX V Device HandbookAs shown in Figure 5–5 , R1=5 . 0V / 1 3 5m A .\nThe values usually shown in the data sheets reflect typical operating conditions. \nSubtract 20% from the data sheet value for guard band. When you subtract the 20% \nfrom the previous example, the R 1 value is 30.\nSelect R 2 so that the MAX V device’s I OH specification is not violated. For example, if \nthe above device has a maximum I OH of 8 mA, given the I/O clamp diode, \nVIN=V CCIO + 0.7 V = 3.7 V. Given that the maximum supply load of a 5.0-V device \n(VCC) is 5.5 V, calculate value of R 2 as follows:\nThis analysis assumes worst-case conditions. If your system does not see a wide \nvariation in voltage-supply levels, you ca n adjust these calculations accordingly.\nBecause 5.0-V device tolerance in MAX V de vices requires the use of the I/O clamp, \nand this clamp is activated only after powe r-up, 5.0-V signals may not be driven into \nthe device until it is configured. The I/O clamp diode is only supported in the \n5M1270Z and 5M2210Z devices’ I/O Bank 3. You must have an external protection diode for the other I/O banks for the 5M1270Z and 5M2210Z devices and all the I/O \npins in the 5M40Z, 5M80Z, 5M160Z, 5M240Z, and 5M570Z devices.\nRecommended Operating Conditi ons for 5.0-V Compatibility\nAs mentioned earlier, a 5.0-V tolerance ca n be supported with the I/O clamp diode \nenabled with external series/p ull-up resistance. To guarante e long term reliability of \nthe device’s I/O buffer, there are restrictions  on the signal duty cycle that drive the \nMAX V I/O, which is based on the maximum clamp current. Table 5–3  lists the \nmaximum signal duty cycle for the 3.3-V V CCIO given a PCI clamp current-handling \ncapability.Equation 5–2.\nR25.5 V 3.7 V –\uf028\uf029 8 mA 30 \uf057\uf0b4\uf028\uf029–\n8m A--------------------------------------------------------------- --------------------- 194\uf057 ==\nTable 5–3. Maximum Signal Duty Cycle\nVIN (V) (1) ICH (mA) (2) Max Duty Cycle (%)\n4.0 5.00 100\n4.1 11.67 904.2 18.33 50\n4.3 25.00 30\n4.4 31.67 174.5 38.33 10\n4.6 45.00 5\nNotes to Table 5–3 :\n(1) V IN is the voltage at the package pin.\n(2) The I CH is calculated with a 3.3-V V CCIO. A higher V CCIO value will have a lower I CH value with the same V IN.\n5–8 Chapter 5: Using MAX V Devices  in Multi-Voltage Systems\nPower-Up Sequencing\nMAX V Device Handbook June 2017 Altera Corporation1 For signals with a duty cycle greater than 30% on MAX V input pins, Altera \nrecommends using a V CCIO voltage of 3.0 V to guarantee long-term I/O reliability. For \nsignals with a duty cycle less than 30%, the V CCIO voltage can be 3.3 V.\nPower-Up Sequencing\nMAX V devices are designed to operate in multi-voltage environments where it may \nbe difficult to control power sequencing. Therefore, MAX V devices are designed to \ntolerate any possible power-up sequence. Either V CCINT  or V CCIO can initially supply \npower to the device and 3.3- , 2.5-, 1.8-, 1. 5-, or 1.2-V input signals can drive the \ndevices without special precautions before V CCINT  or V CCIO is applied. MAX V devices \ncan operate with a V CCIO voltage level that is higher than the V CCINT  level. \nWhen V CCIO and V CCINT  are supplied from different power sources to a MAX V \ndevice, a delay between V CCIO and V CCINT  may occur. Normal operation does not \noccur until both power supplies are in th eir recommended operating range. When \nVCCINT  is powered-up, the IEEE Std. 1149.1 JTAG circuitry is active. If TMS and TCK are \nconnected to V CCIO and V CCIO is not powered-up, the JTAG signals are left floating. \nThus, any transition on TCK can cause the state machine to transition to an unknown \nJTAG state, leading to incorrect operation when V CCIO is finally powered-up. To \ndisable the JTAG state during the power-up sequence, pull TCK low to ensure that an \ninadvertent rising edge does not occur on TCK.\nDocument Revision History\nTable 5–4  lists the revision history for this chapter.\nTable 5–4. Document Revision History\nDate Version Changes\nJune 2017 2017.06.16 Added note to state that 1.2-V LVCMOS is not supported in Bank 1.\nDecember 2010 1.0 Initial release.\nMAX V Device Handbook\nMay 2011MV51006-1.1\nSubscribe© 2011 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.6. JTAG and In-System Programmability\nin MAX V Devices\nThis chapter describes the IEEE Standard 1149 .1 JTAG BST circuitry that is supported \nin MAX®V devices and how you can enable co ncurrent in-system programming of \nmultiple devices in a minimum time with the IEEE Standard 1532 in-system \nprogrammability (ISP). This chapter also describes the programming sequence, types \nof programming with the Quartus®II software or external hardware, and design \nsecurity. \nThis chapter includes the following sections:\n■“IEEE Std. 1149.1 Boundary-Scan Support” on page 6–1\n■“In-System Programmability” on page 6–5\nIEEE Std. 1149.1 Boundary-Scan Support\nAll MAX V devices provide JTAG BST circuitry that complies with the \nIEEE Std. 1149.1-2001 specification. You can only perform JTAG boundary-scan \ntesting after you have fully powered the V CCINT  and all V CCIO banks and a certain \namount of configuration time (t CONFIG ) have passed. For in-system programming, \nMAX V devices can use the JTAG port wi th either the Quartus II software or \nhardware with Programmer Object File ( .pof) , Jam™ Standard Test and Programming \nLanguage (STAPL) Format File ( .jam ), or Jam Byte Code Files ( .jbc).\nJTAG pins support 1.5-V, 1.8-V, 2. 5-V, and 3.3-V I/O standards. The V CCIO of the bank \nwhere it is located determines the supported voltage level and standard. The \ndedicated JTAG pins reside in Bank 1 of all MAX V devices.\nTable 6–1  lists the JTAG instructions supported in MAX V devices.\nTable 6–1. JTAG Instructions for MAX V Devices (Part 1 of 2)\nJTAG Instruction Instruction Code Description\nSAMPLE/PRELOAD 00 0000 0101Allows you to capture and examine a snapshot of signals at the \ndevice pins if the device is operating in normal mode. Permits an initial data pattern to be an output at the device pins.\nEXTEST  (1) 00 0000 1111Allows you to test the external circuitry and board-level \ninterconnects by forcing a test pattern at the output pins and \ncapturing test results at the input pins.\nBYPASS 11 1111 1111Places the 1-bit bypass register between the TDI and TDO pins, \nwhich allows the boundary-scan test (BST) data to pass \nsynchronously through target devices to adjacent devices during normal device operation.\nUSERCODE 00 0000 0111Selects the 32-bit USERCODE  register and places it between the TDI \nand TDO pins, allowing you to shift the USERCODE  register out of the \nTDO pin serially. If you do not specify the USERCODE  in the Quartus II \nsoftware, the 32-bit USERCODE  register defaults to all 1’s.May 2011\nMV51006-1.1\n6–2 Chapter 6: JTAG and In-System Programmability in MAX V Devices\nIEEE Std. 1149.1 Boundary-Scan Support\nMAX V Device Handbook May 2011 Altera Corporationw You must not issue unsupported JTAG instru ctions to the MAX V device because this \nmay put the device into an unknown state, requiring a power cycle to recover device \noperation.IDCODE 00 0000 0110Selects the IDCODE  register and places it between the TDI and TDO \npins, allowing you to shift the IDCODE  register out of the TDO pin \nserially.\nHIGHZ  (1) 00 0000 1011Places the 1-bit bypass register between the TDI and TDO pins, \nwhich allows the BST data to pass synchronously through target devices to adjacent devices if the device is operating in normal mode \nand tri-stating all the I/O pins.\nCLAMP  (1) 00 0000 1010Places the 1-bit bypass register between the TDI and TDO pins, \nwhich allows the BST data to pass synchronously through target \ndevices to adjacent devices during normal device operation and holding I/O pins to a state defined by the data in the boundary-scan \nregister.\nUSER0 00 0000 1100Allows you to define the scan chain between the TDI and TDO pins in \nthe MAX V logic array. Use this instruction for custom logic and \nJTAG interfaces.\nUSER1 00 0000 1110Allows you to define the scan chain between the TDI and TDO pins in \nthe MAX V logic array. Use this instruction for custom logic and JTAG interfaces.\nIEEE 1532 \ninstructionsFor the instruction codes \nof the IEEE 1532 instructions, refer to the \nIEEE 1532 B SDL Files  \npage of the Altera website.IEEE 1532 in-system concurrent (ISC) instructions used if \nprogramming a MAX V device through the JTAG port.\nNote to Table 6–1 :\n(1)HIGHZ , CLAMP , and EXTEST  instructions do not disable weak pu ll-up resistors or bus hold features.Table 6–1. JTAG Instructions for MAX V Devices (Part 2 of 2)\nJTAG Instruction Instruction Code Description\nChapter 6: JTAG and In-System Progr ammability in MAX V Devices 6–3\nIEEE Std. 1149.1 Boundary-Scan Support\nMay 2011 Altera Corporation MAX V Device HandbookThe MAX V device instruction register length is 10 bits and the USERCODE  register \nlength is 32 bits. Table 6–2  and Table 6–3  list the boundary-scan register length and \ndevice IDCODE  information for MAX V devices.\nf For JTAG direct current (DC) characteristics, refer to the DC and Switching \nCharacteristics for MAX V Devices chapter. Table 6–2. Boundary-Scan Register Length for MAX V Devices\nDevice Boundary-Scan Register Length\n5M40Z 240\n5M80Z 240\n5M160Z 240\n5M240Z (1) 240\n5M240Z (2) 480\n5M570Z 480\n5M1270Z (3) 636\n5M1270Z (4) 816\n5M2210Z 816\nNotes to Table 6–2 :\n(1) Not applicable to T144 package of the 5M240Z device.\n(2) Only applicable to T144 package of the 5M240Z device.\n(3) Not applicable to F324 package of the 5M1270Z device.\n(4) Only applicable to  F324 package of the 5M1270Z device.\nTable 6–3. 32-Bit IDCODE for MAX V Devices\nDeviceBinary IDCODE (32 Bits) (1)\nHEX IDCODEVersion \n(4 Bits)Part NumberManufacturer \nIdentity (11 Bits)LSB \n(1 Bit) (2)\n5M40Z 0000 0010 0000 1010 0101 000 0110 1110 1 0x020A50DD\n5M80Z 0000 0010 0000 1010 0101 000 0110 1110 1 0x020A50DD\n5M160Z 0000 0010 0000 1010 0101 000 0110 1110 1 0x020A50DD\n5M240Z (3) 0000 0010 0000 1010 0101 000 0110 1110 1 0x020A50DD\n5M240Z (4) 0000 0010 0000 1010 0110 000 0110 1110 1 0x020A60DD\n5M570Z 0000 0010 0000 1010 0110 000 0110 1110 1 0x020A60DD\n5M1270Z (5) 0000 0010 0000 1010 0011 000 0110 1110 1 0x020A30DD\n5M1270Z (6) 0000 0010 0000 1010 0100 000 0110 1110 1 0x020A40DD\n5M2210Z 0000 0010 0000 1010 0100 000 0110 1110 1 0x020A40DD\nNotes to Table 6–2 :\n(1) The MSB is on the left.\n(2) The LSB for IDCODE  is always 1.\n(3) Not applicable to T144 package of the 5M240Z device.(4) Only applicable to T144 package of the 5M240Z device.\n(5) Not applicable to F324 package of the 5M1270Z device.\n(6) Only applicable to  F324 package of the 5M1270Z device.\n6–4 Chapter 6: JTAG and In-System Programmability in MAX V Devices\nIEEE Std. 1149.1 Boundary-Scan Support\nMAX V Device Handbook May 2011 Altera Corporationf For more information about JTAG BST, refer to the JTAG Boundary-Scan Testing for \nMAX V Devices  chapter.\nJTAG Block\nIf you issue either the USER0  or USER1  instruction to the JTAG test access port (TAP) \ncontroller, the MAX V JTAG block featur e allows you to access the JTAG TAP \ncontroller and state signals. The USER0  and USER1  instructions bring the JTAG \nboundary-scan chain ( TDI) through the user logic instea d of the boundary-scan cells \n(BSCs) of MAX V devices. Each USER  instruction allows for one unique user-defined \nJTAG chain into the logic array. \nParallel Flash Loader\nMAX V devices have the ability to interface JTAG to non-JTAG devices and are suitable to use with the general flash memory devices that require programming \nduring the in-circuit test. You can use the flash memory devices for FPGA configuration or be part of the system memory. In many cases, you can use the \nMAX V device as a bridge device that controls configuration between FPGA and flash \ndevices. Unlike ISP-capable CPLDs, bulk fl ash devices do not have JTAG TAP pins or \nconnections. For small flash devices, it is co mmon to use the serial JTAG scan chain of \na connected device to program the non-JTAG fl ash device but this is slow, inefficient, \nand impractical for large parallel flash devices. Using the MAX V JTAG block as a parallel flash loader (PFL) with the Quartu s II software to program and verify flash \ncontents provides a fast and cost-effective  means of in-circuit programming during \ntesting.\nf For more information about PFL, refer to the Parallel Flash Loader Megafunction User \nGuide .\nChapter 6: JTAG and In-System Progr ammability in MAX V Devices 6–5\nIn-System Programmability\nMay 2011 Altera Corporation MAX V Device HandbookFigure 6–1  shows how you can use the MAX V JTAG block as a PFL.\nIn-System Programmability\nYou can program MAX V devices in-system through the industry standard 4-pin \nIEEE Std. 1149.1 interface. ISP offers quic k and efficient iterations during design \ndevelopment and debugging cycles. The fl ash-based SRAM conf iguration elements \nconfigure the logic, circuitry, and intercon nects in the MAX V architecture. Each time \nthe device is powered up, the configuration data is loaded into the SRAM elements. \nThe process of loading the SRAM data is called configuration. The on-chip configuration flash memory (CFM) block stor es the configuration data of the SRAM \nelement. The CFM block stores the config uration pattern of your design in a \nreprogrammable flash array. During ISP, th e MAX V JTAG and ISP circuitry programs \nthe design pattern into the non-vola tile flash array of the CFM block. \nThe MAX V JTAG and ISP controller inte rnally generate the high programming \nvoltages required to program the CFM cells, allowing in-system programming with any of the recommended operating external  voltage supplies. You can configure the \nISP anytime after you have fully powered V\nCCINT  and all V CCIO banks, and the device \nhas completed the configuration power-up  time. By default,  during in-system \nprogramming, the I/O pins are tri-stated and weakly pulled-up to V CCIO banks to \neliminate board conflicts. The in-system programming clamp and real-time ISP \nfeature allow user control of the I/O state or behavior during ISP.\nFor more information, refer to “In-System Programming Clamp” on page 6–7  and \n“Real-Time ISP” on page 6–8 . \nThese devices also offer an ISP_DONE  bit that provides safe operation if in-system \nprogramming is interrupted. This ISP_DONE bit, which is the last bit programmed, \nprevents all I/O pins from driving until the bit is programmed.Figure 6–1. PFL for MAX V Devices\nNotes to Figure 6–1 :\n(1) This block is implemente d in logic elements (LEs).\n(2) This function is supported in the Quartus II software.PFL\nConfiguration\nLogicFlash\nMemo ry DeviceMAX V Device\nDQ[7..0]\nRY/BYA[20..0]\nOE\nWE\nCEDQ[7..0]\nRY/BYA[20..0]\nOE\nWE\nCE\nTDI\nTMS\nTCKTDI_UTDO_U\nTMS_U\nTCK_U\nSHIFT_U\nCLKDR_U\nUPDATE_U\nRUNIDLE_U\nUSER1_UTDOAltera FPGA\nCONF_DONE\nnSTATUS\nnCE\nDCLKDATA0\nnCONFIG\n(1), (2)\n6–6 Chapter 6: JTAG and In-System Programmability in MAX V Devices\nIn-System Programmability\nMAX V Device Handbook May 2011 Altera CorporationIEEE 1532 Support\nThe JTAG circuitry and ISP instruction set in MAX V devices are compliant to the \nIEEE-1532-2002 programming specificatio n. This provides industry-standard \nhardware and software for in-system programming among multiple vendor \nprogrammable logic devices (P LDs) in a JTAG chain.   \nf For more information about MAX V 1532 Boundary-Scan Description Language \n(.bsd ) files, refer to the IEEE 1532 BSDL Files  page of the Altera website.\nJam Standard Test an d Programming Language\nYou can use the Jam STAPL  to program MAX V devices with in-circuit testers, PCs, or \nembedded processors. The Jam byte code is also supported for MAX V devices. These \nsoftware programming protocols provid e a compact embedded solution for \nprogramming MAX V devices.\nf For more information, refer to AN 425: Using Command-Line Jam STAPL Solution for \nDevice Programming .\nProgramming Sequence\nDuring in-system programming, 1532 instructions, addresses, and data are shifted \ninto the MAX V device through the TDI input pin. Data is shifted out through the TDO \noutput pin and compared with the expected data. \nTo program a pattern into the device, follow these steps:1.Enter  ISP—The enter ISP stage ensures that th e I/O pins transition smoothly from \nuser mode to ISP mode.\n2.Check ID —The silicon ID is checked before any Program or Verify process. The \ntime required to read this silicon ID is  relatively small compared to the overall \nprogramming time.\n3.Sector Erase —Erasing the device in-system involves shifting in the instruction to \nerase the device and applying an erase pulse or pulses. The erase pulse is \nautomatically generated internally by waitin g in the run, test, or idle state for the \nspecified erase pulse time of 500 ms for the CFM block and 500 ms for each sector \nof the user flash memory (UFM) block.\n4.Program —Programming the device in-system involves shifting in the address, \ndata, and program instruction and genera ting the program pulse to program the \nflash cells. The program pulse is automati cally generated internally by waiting in \nthe run/test/idle state for the specified program pulse time of 75 µs. This process is repeated for each address in the CFM and UFM blocks.\n5.Verify —Verifying a MAX V device in-system involves shifting in addresses, \napplying the verify instruction to generate the read pulse, and shifting out the data \nfor comparison. This process is repeated for each CFM and UFM address.\n6.Exit ISP —An exit ISP stage ensures that the I/ O pins transition smoothly from ISP \nmode to user mode. \nChapter 6: JTAG and In-System Progr ammability in MAX V Devices 6–7\nIn-System Programmability\nMay 2011 Altera Corporation MAX V Device HandbookA stand-alone verification  of a programmed pattern involves only steps 1, 2, 5, and 6. \nThese steps are automatically executed by  third-party programmers, the Quartus II \nsoftware, or the Jam STAPL and Jam Byte-Code Players.   \nTable 6–4  lists the programming times for MAX V devices with in-circuit testers to \nexecute the algorithm vectors in hardware . Because of data processing and data \ntransfer limitations, software-based programming tools used with download cables \nare slightly slower.\nUser Flash Memo ry Programming\nThe Quartus II software (with the use of .pof, .jam , or .jbc files) supports \nprogramming of the UFM block independent of  the logic array design pattern stored \nin the CFM block. This allows updating or  reading UFM contents through ISP without \naltering the current logic array design, or vice versa. By defaul t, these programming \nfiles and methods program the entire flash memory contents, which includes the CFM \nblock and UFM contents. The stand-alon e embedded Jam STAPL Player and Jam \nByte-Code Player provide action commands for programming or reading the entire \nflash memory (UFM and CFM together) or each independently.\nf For more information, refer to AN 425: Using the Command-Line Jam STAPL Solution for \nDevice Programming .\nIn-System Programming Clamp\nBy default, the IEEE 1532 instruction used fo r entering ISP automati cally tri-states all \nI/O pins with weak pull-up resistors for th e duration of the ISP sequence. However, \nsome systems may require certain pins on MAX V devices to maintain a specific DC \nlogic level during an in-field update. For these systems, you can use the optional in-\nsystem programming clamp instruction in the MAX V circuitry to control I/O Table 6–4. Family Programming Times for MAX V Devices\nDescription5M40Z/ \n5M80Z/\n5M160Z/\n5M240Z (1)5M240Z \n(2)5M570Z 5M1270Z (3) 5M1270Z (4) 5M2210Z Unit\nErase + Program (1 MHz) 1.72 2.16 2.16 2.90 3.92 3.92 sec\nErase + Program (10 MHz) 1.65 1.99 1.99 2.58 3.40 3.40 secVerify (1 MHz) 0.09 0.17 0.17 0.30 0.49 0.49 sec\nVerify (10 MHz) 0.01 0.02 0.02 0.03 0.05 0.05 sec\nComplete Program Cycle (1 MHz) 1.81 2.33 2.33 3.20 4.41 4.41 sec\nComplete Program Cycle (10 MHz) 1.66 2.01 2.01 2.61 3.45 3.45 sec\nNotes to Table 6–4 :\n(1) Not applicable to T144 package of the 5M240Z device.\n(2) Only applicable to T144 package of the 5M240Z device.\n(3) Not applicable to F324 package of the 5M1270Z device.\n(4) Only applicable to  F324 package of the 5M1270Z device.\n6–8 Chapter 6: JTAG and In-System Programmability in MAX V Devices\nIn-System Programmability\nMAX V Device Handbook May 2011 Altera Corporationbehavior during the ISP sequence. The in-system programming clamp instruction \nallows the device to sample and sustain the value on an output pin (an input pin \nremains tri-stated if sampled) or to set a logic high, logic low, or tri-state value \nexplicitly on any pin. Setting these options is controlled on an individual pin basis with the Quartus II software. \nf For more information, refer to AN 630: Real-Time ISP and ISP Clamp for Altera CPLDs .\nReal-Time ISP\nFor systems that require more than the DC logic level control of I/O pins, the \nreal-time ISP feature allows you to update the CFM block with a new design image, \nwhile the current design continues to operate in the SRAM logic array and I/O pins. \nA new programming file is updated into  the MAX V device without halting the \noriginal operation of your design, saving down-time costs for remote or field \nupgrades. The updated CFM block configures the new design into the SRAM after the \nnext power cycle. You can execute an immediate SRAM configuration without a \npower cycle with a specific sequence of  ISP commands. The SRAM configuration \nwithout a power cycle takes a specific amount of time (t CONFIG ). During this time, the \nI/O pins are tri-stated and weakly pulled-up to V CCIO.\nDesign Security\nAll MAX V devices contain a programmable secu rity bit that controls access to the \ndata programmed into the CFM block. If th is bit is programmed, you cannot copy or \nretrieve the design programming informatio n stored in the CFM block. This feature \nprovides a high-level design security be cause programmed data within flash memory \ncells is invisible. You can only reset the se curity bit that controls this function and \nother programmed data if the device is eras ed. The SRAM is also invisible and cannot \nbe accessed regardless of the security bit se tting. The security bit does not protect the \nUFM block data, and the UFM is accessible through JTAG or logic array connections.\nProgramming with External Hardware\nYou can program MAX V devices by downloading the information through in-circuit \ntesters, embedded processors, the Altera® ByteBlaster™ II, Et hernetBlaster II, \nEthernetBlaster, and USB-Blaster™ cables. You need to power up these cable’s \nVCC(TRGT)  with V CCIO of Bank 1.\nf For more information about the respective cables, refer to the Cable & Adapter \nDrivers Information  page.\nBP Microsystems, System General, and ot her programming hardware manufacturers \nprovide programming support for Altera de vices. For device support information, \nrefer to their websites.\nChapter 6: JTAG and In-System Progr ammability in MAX V Devices 6–9\nDocument Revision History\nMay 2011 Altera Corporation MAX V Device HandbookDocument Revision History\nTable 6–5  lists the revision history for this chapter.\nTable 6–5. Document Revision History\nDate Version Changes\nMay 2011 1.1 Updated “Programming with External Hardware”  section.\nDecember 2010 1.0 Initial release.\n6–10 Chapter 6: JTAG and In-System Programmabilit y in MAX V Devices\nDocument Revision History\nMAX V Device Handbook May 2011 Altera Corporation\nMAX V Device Handbook\nMay 2014MV51007-1.1\nSubscribe© 2014 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.7. User Flash Memory in MAX V Devices\nThis chapter provides guidelines for us er flash memory (UFM) applications by \ndescribing the features an d functionality of the MAX® V UFM block and the \nQuartus®II ALTUFM megafunction.\nAltera® MAX V devices feature a UFM block that can be used for storing non-volatile \ninformation up to 8 Kbits, similar to a serial EEPROM. The UFM provides an ideal \nstorage solution that supports  all protocols (serial peripher al interface (SPI), parallel, \nand other protocols) for interfacing throug h bridging logic designed into the MAX V \nlogic array.\nThis chapter contains the following sections:\n■“UFM Array Description” on page 7–1\n■“UFM Functional Description” on page 7–3\n■“UFM Operating Modes” on page 7–8\n■“Programming and Reading the UFM with JTAG” on page 7–12\n■“Software Support for UF M Block” on page 7–13\n■“Creating Memory Content File” on page 7–39\n■“Simulation Parameters” on page 7–43\nUFM Array Description\nEach UFM array is organized as two separate  sectors with 4,096 bi ts per sector. Each \nsector can be erased independently. Table 7–1  lists the dimensions of the UFM array. \nTable 7–1. UFM Array Size\nDevice Total Bits Sectors Address Bits Data Width\n5M40Z 8,192 2 (4,096 bits per sector) 9 16\n5M80Z 8,192 2 (4,096 bits per sector) 9 165M160Z 8,192 2 (4,096 bits per sector) 9 16\n5M240Z 8,192 2 (4,096 bits per sector) 9 16\n5M570Z 8,192 2 (4,096 bits per sector) 9 165M1270Z 8,192 2 (4,096 bits per sector) 9 16\n5M2210Z 8,192 2 (4,096 bits per sector) 9 16May 2014\nMV51007-1.1\n7–2 Chapter 7: User Flash Me mory in MAX V Devices\nUFM Array Description\nMAX V Device Handbook May 2014 Altera CorporationMemory Organization Map\nTable 7–2  lists the memory organization for the MAX V UFM block. There are 512 \nlocations with 9 bits addressing a range of 000h  to 1FFh . Each location stores 16-bit \nwide data. The MSB of the address regist er indicates the sector in operation.\nUsing and Accessing UFM Storage\nYou can use the UFM to store data of diff erent memory sizes and data widths. Even \nthough the UFM storage width is 16 bits, yo u can implement different data widths or \na serial interface with the ALTUFM megafunction. Table 7–3  lists the different data \nwidths available for the three types of interf aces supported in the Quartus II software, \nas well as no interface.\nFor more details about the logic array interface options in the ALTUFM megafunction, \nrefer to “Software Support for UFM Block” on page 7–13 .\n1 The UFM block is accessible through the logi c array interface and the JTAG interface. \nHowever, the UFM logic array interface does  not have access to the configuration \nflash memory (CFM) block.Table 7–2. Memory Organization\nSector Address Range\n1 100h 1FFh\n0 000h 0FFh\nTable 7–3. Data Widths for Logic Array Interfaces\nLogic Array Interfaces Data Widths (Bits) Interface Types\nI2C8 S e r i a l\nSPI 8 or 16 Serial\nParallel Options of 3 to 16 Parallel\nNone 16 Serial\nChapter 7: User Flash Memory in MAX V Devices 7–3\nUFM Functional Description\nMay 2014 Altera Corporation MAX V Device HandbookUFM Functional Description\nFigure 7–1  is the block diagram of the MAX V UFM block and the interface signals. \nTable 7–4  lists the MAX V UFM block inpu t and output interface signals.Figure 7–1. UFM Block and Interface Signals\nOSC 4Program\nErase\nControl\nUFM Sector 1\nUFM Sector 0:_\nAddress\nRegisterPROGRAM\nERASE\nOSC_E NARTP_BUSY\nBUSY\nOSC\nData RegisterUFM Block\nDRDin DRDo utARCLK\nARSHFT\nARDin\nDRCLK\nDRSHFT16 16 9\nTable 7–4. UFM Interface Signals (Part 1 of 2)\nPort Name Port Type Description\nDRDin InputSerial input to the data register. It is used to enter a data word when writing to the UFM. The \ndata register is 16 bits wide and data is shi fted serially from the LSB to the MSB with each \nDRCLK . This port is required for writing, but unused if the UFM is in read-only mode.\nDRCLK InputClock input that controls the data register. It is required and takes control when data is \nshifted from DRDin  to DRDout  or loaded in parallel from the flash memory. The maximum \nfrequency for DRCLK  is 10 MHz.\nDRSHFT InputSignal that determines whether to shift the data register or load it on a DRCLK  edge. A high \nvalue shifts the data from DRDin  into the LSB of the data register and from the MSB of the \ndata register out to DRDout . A low value loads the value of the current address in the flash \nmemory to the data register.\nARDin InputSerial input to the address register. It is used to enter the address of a memory location to \nread, program, or erase. The address register is 9 bits wide for the UFM size of 8,192 bits.\nARCLK InputClock input that controls the address register. It is required when shifting the address data \nfrom ARDin  into the address register or during the increment stage. The maximum \nfrequency for ARCLK  is 10 MHz.\nARSHFT InputSignal that determines whether to shift the address register or increment it on an ARCLK  \nedge. A high value shifts the data from ARDin  serially into the address register. A low value \nincrements the current address by 1. The address  register rolls over to 0 when the address \nspace is at the maximum.\n7–4 Chapter 7: User Flash Me mory in MAX V Devices\nUFM Functional Description\nMAX V Device Handbook May 2014 Altera Corporationf For more information about the interact ion between the UFM block and the logic \narray of MAX V devices, refer to the MAX V Device Architecture  chapter.PROGRAM InputSignal that initiates a program sequence. On the rising edge, the data in the data register is \nwritten to the address pointed to by the address register. The BUSY  signal asserts until the \nprogram sequence is completed. \nERASE InputSignal that initiates an erase sequence. On a rising edge, the memory sector indicated by \nthe MSB of the address register is erased. The BUSY  signal asserts until the erase sequence \nis completed. \nOSC_ENA InputThis signal turns on the internal oscillator in the UFM block. It is required when the OSC \noutput is used, but optional otherwise. If OSC_ENA  is driven high, the internal oscillator is \nenabled and the OSC output will toggle. If OSC_ENA  is driven low, the internal oscillator is \ndisabled and the OSC output drives constant high.\nDRDout OutputSerial output of the data register. Each time the DRCLK  signal is applied, a new value is \navailable. The DRDout  data depends on the DRSHFT  signal. When the DRSHFT  signal is high, \nDRDout  contains the new value that is shifted into the MSB of the data register. If DRSHFT  is \nlow, DRDout  contains the MSB of the memory location read into the data register.\nBUSY OutputSignal that indicates when the memory is BUSY  performing a PROGRAM  or ERASE  \ninstruction. When it is high, the address and data register should not be clocked. The new \nPROGRAM  or ERASE  instruction is not executed until the BUSY  signal is deasserted.\nOSC OutputOutput of the internal oscillator. It can be used to generate a clock to control user logic with \nthe UFM. It requires an OSC_ENA  input to produce an output.\nRTP_BUSY OutputThis output signal is optional and only needed if the real-time ISP feature is used. The signal \nis asserted high during real-time ISP and stays in the RUN_STATE  for 500 ms before \ninitiating real-time ISP to allow for the final read/erase/write operati on. No read, write, \nerase, or address and data shift operations are allowed to be issued after the RTP_BUSY  \nsignal goes high. The data and address registers do not retain the contents of the last read \nor write operation for the UFM block during real-time ISP. Table 7–4. UFM Interface Signals (Part 2 of 2)\nPort Name Port Type Description\nChapter 7: User Flash Memory in MAX V Devices 7–5\nUFM Functional Description\nMay 2014 Altera Corporation MAX V Device HandbookUFM Address Register\nThe MAX V UFM block is organized as a 512 × 16 memory. Because the UFM block is \norganized into two sectors, the MSB of the address indicates the sector that is used; 0 \nis for sector 0 (UFM0) while 1 is for sector 1 (UFM1). An ERASE  instruction erases the \ncontent of the specific sector that is in dicated by the MSB of the address register. \nFigure 7–2  shows the selection of the UFM se ctor using the MSB of the address \nregister. \nFor more information about the erase mode, refer to “Erase” on page 7–11 .\nThree control signals exist for the address register: ARSHFT , ARCLK , and ARDin . ARSHFT  is \nused as both a shift-enable control sign al and an auto-increment signal. If the ARSHFT  \nsignal is high, a rising edge on ARCLK  loads address data serially from the ARDin  port \nand moves data serially through th e register. A clock edge with the ARSHFT  signal low \nincrements the address register by 1. This implements an auto-increment of the address to allow data streaming. When a program, read, or erase sequence is \nexecuting, the address that is in the address register becomes the active UFM location.Figure 7–2. Selection of the UFM Sector Using the MSB of the Address Register\n10\nARDin\nARClkAddress RegisterSector 0\nSector 1UFM Block\nUFM BlockA0 A1 A2 A3 A4 A5 A6 A7 A 8\nLSB MSB\n7–6 Chapter 7: User Flash Me mory in MAX V Devices\nUFM Functional Description\nMAX V Device Handbook May 2014 Altera CorporationUFM Data Register\nThe UFM data register is 16 bits wide with four control signals: DRSHFT , DRCLK , DRDin , \nand DRDout . DRSHFT  distinguishes between clock edges that move data serially from \nDRDin  to DRDout  and clock edges that latch parallel data from the UFM sectors. If the \nDRSHFT  signal is high, a clock edge moves da ta serially through the registers from \nDRDin  to DRDout . If the DRSHFT  signal is low, a clock edge captures data from the UFM \nsector pointed by the address register in parall el. The MSB is the first bit that is seen at \nDRDout . The data register DRSHFT  signal is also used to enable the UFM for reading \ndata. When the DRSHFT  signal is low, the UFM latches data into the data register. \nFigure 7–3  shows the UFM data register.\nUFM Program/Erase Control Block\nThe UFM program/erase control block is used to generate all the control signals \nnecessary to program and erase the UFM bloc k independently. This block reduces the \nnumber of logic elements (LEs) necessary to  implement a UFM controller in the logic \narray. It also guarantees corr ect timing of the control signal s to the UFM. A rising edge \non either PROGRAM  or ERASE  signal causes this control signal block to activate and begin \nsequencing through the program or erase cycle. At this point, for a program \ninstruction, the data currently in the data re gister is written to the address pointed to \nby the address register.\nOnly sector erase is supported by the UFM. When an ERASE  command is executed, \nthis control block erases the sector whose address is stored in the address register. \nWhen the PROGRAM  or ERASE  command first activates the program/erase control \nblock, the BUSY  signal will be driven high to indicate an operation in progress in the \nUFM. After the program or eras e algorithm is completed, the BUSY  signal is forced \nlow.Figure 7–3. UFM Data Register\nLSB MSBMAX V UFM Block\nDRDin\nDRCLKDRDoutData Register\nD0 D1 D3 D4 D11 D12 D13 D14 D15 D5 D6 D7 D8 D9 D1016 16\nD2\nChapter 7: User Flash Memory in MAX V Devices 7–7\nUFM Functional Description\nMay 2014 Altera Corporation MAX V Device HandbookOscillator\nOSC_ENA, one of the input signals in the UFM block, is used to enable the oscillator \nsignal to output through the OSC output port. You can use this OSC output port to \nconnect with the interface logic in the logic array. It can be routed through the logic \narray and fed back as an input clock for the address register ( ARCLK ) and the data \nregister (DRCLK ). The output frequency of the OSC port is one-fourth that of the \noscillator frequency. As a result, the frequency range of the OSC port is 3.9 to 5.3 MHz. \nThe maximum clock frequency accepted by ARCLK  and DRCLK  is 10 MHz and the duty \ncycle accepted by the DRCLK  and ARCLK  input ports is approximately 45% to 50%. \nWhen the OSC_ENA input signal is asserted, the oscillator is enabled and the output is \nrouted to the logic array through the OSC output. When the OSC_ENA signal is set low, \nthe OSC output drives constant high. The routing delay from the OSC port of the UFM \nblock to OSC output pin depends on placement. You can analyze this delay using the \nTimeQuest timing analyzer. \nThe undivided internal oscillator, which is  not accessible, operates in a frequency \nrange from 15.6 to 21.2 MHz. The internal  oscillator is enabled during power-up, \nin-system programming, and real-time ISP. At all other times, the oscillator is not running unless the UFM is instantiated in the design and the \nOSC_ENA port is asserted. \nTo see how specific operating modes of the ALTUFM megafunction handle OSC_ENA \nand the oscillator, refer to “Software Support for UFM Block” on page 7–13 . For user-\ngenerated logic interfacing to the UFM, the oscillator must be enabled during \nprogram or erase operations, but not during read operations. The OSC_ENA signal can \nbe tied low if you are not issuing any PROGRAM  or ERASE  commands.\n1 During real-time ISP operation, the intern al oscillator automatically enables and \noutputs through the OSC output port (if this port is instantiated) even though the \nOSC_ENA signal is tied low. You can use the RTP_BUSY  signal to detect the beginning and \nending of the real-time ISP operation for gated control of this self-enabled OSC output \ncondition.\n1 The internal oscillator is not enabled all the time. The internal  oscillator for the \nprogram or erase operation is only activated when the flash memory block is being \nprogrammed or erased. During a read operat ion, the internal oscillator is activated \nwhenever the flash memory block is reading data.\nInstantiating the Oscillator without the UFM\nYou can use the MAX II/MAX V Oscillator megafunction selection in the MegaWizard\n™ Plug-In Manager to instantiate the UF M oscillator if you intend to use \nthis signal without using the UFM memory block. Figure 7–4  shows the \nALTUFM_OSC megafunction instantiation in the Quartus II software. \nFigure 7–4. The Quartus II ALTUFM_OSC Megafunction\n\n7–8 Chapter 7: User Flash Me mory in MAX V Devices\nUFM Operating Modes\nMAX V Device Handbook May 2014 Altera CorporationThis megafunction is in the I/O folder on page 2a of the MegaWizard Plug-In \nManager. On page 3 of the MAX II/MAX V Oscillator megafunction, you have an \noption to choose to simulate the OSC output port at it s maximum or minimum \nfrequency during the design simulation. Th e frequency chosen is only used as a \ntiming parameter simulation and does  not affect the real MAX V device OSC output \nfrequency.\nUFM Operating Modes\nThere are three different modes for the UFM block:\n■Read/Stream Read\n■Program (Write) \n■Erase\nDuring program mode, address and data can be loaded concurrently. You can \nmanipulate the UFM interface controls as necessary to implement the specific \nprotocol provided the UFM timing specifications are met. Figure 7–5  through \nFigure 7–8  show the control waveforms for accessing UFM in three different modes. \nFor program mode ( Figure 7–7 ) and erase mode ( Figure 7–8 ), the PROGRAM  and ERASE  \nsignals can be asserted anytim e after the address register and data register have been \nloaded. Do not assert the READ , PROGRAM , and ERASE  signals or shift data and address \ninto the UFM after entering the re al-time ISP mode. You can use the RTP_BUSY  signal to \ndetect the beginning and end of real-time IS P operation and generate control logic to \nstop all UFM port operations. This user-generated control logic is only necessary for \nthe ALTUFM_NONE megafunction, which pr ovides no auto-generated logic. The \nother interfaces for the ALTUFM megafunction (ALTUFM_PARALLEL, ALTUFM_SPI, ALTUFM_I2C) co ntain control logic to au tomatically monitor the \nRTP_BUSY  signal and will cease operations to the UFM when a real-time ISP operation \nis in progress.\n1 You can program the UFM or CFM block independently without overwriting the \nother block, which is not programmed. The Quartus II programmer provides the \noptions to program the UFM and CFM blocks individually or together (the entire \nMAX V Device).\nf For guidelines about using ISP and real-time ISP while using the UFM block within \nyour design, refer to AN 100: In-System Programmability Guidelines .\nf For a complete description of the device arch itecture, and for the specific values of the \ntiming parameters listed in this chapter, refer to the  MAX V Device Architecture  \nchapter.\nChapter 7: User Flash Memory in MAX V Devices 7–9\nUFM Operating Modes\nMay 2014 Altera Corporation MAX V Device HandbookRead/Stream Read\nThe three control signals, PROGRAM , ERASE , and BUSY  are not required during a read or \nstream read operation. To perform a read operation, the address register must be \nloaded with the reference address where the data is or is going to be located in the \nUFM. The address register can be stopped fr om incrementing or shifting addresses \nfrom ARDin  by stopping the ARCLK  clock pulse. DRSHFT  must be asserted low at the next \nrising edge of DRCLK  to load the data from the UFM to the data register. To shift the bits \nfrom the register, 16 clock pulses must be provided to read 16-bit wide data. You can \nuse DRCLK  to control the read time or disable the data register by discontinuing the \nDRCLK  clock pulse. Figure 7–5  shows the UFM control waveforms during read mode.\nThe UFM block can also perform a stream  read operation, using the address \nincrement feature to read continuously from the UFM. Stream read mode is started by \nloading the base address into the address register. DRSHFT  must then be asserted low at \nthe first rising edge of DRCLK  to load data into the data register from the address \npointed to by the address register. DRSHFT  will then assert high to shift out the 16-bit \nwide data with the MSB out first. Figure 7–6  shows the UFM control waveforms \nduring stream read mode. \nFigure 7–5. UFM Read Waveforms\nFigure 7–6. UFM Stream Read WaveformstDCOtDCLKtDSStDSHtADH\ntADStASUtACLKtAHARSHFT\nARCLK\nARDin\nDRSHFT\nDRCLK\nDRDin\nDRDout\nPROGRAM\nERASE\nBUSY16 Data Bits9 Address Bits\nOSC_ENA\n16 Data BitsIncrement\nAddress\n9 Address BitsIncrement\nAddress\nARSHFT\nARCLK\nARDin\nDRSHFT\nDRCLK\nDRDin\nDRDout\nPROGRAM\nERASE\nBUSYOSC_ENA\n7–10 Chapter 7: User Flash Me mory in MAX V Devices\nUFM Operating Modes\nMAX V Device Handbook May 2014 Altera CorporationProgram\nTo program or write to the UFM, you must  first perform a sequence to load the \nreference address into the address register. DRSHFT  must then be asserted high to load \nthe data serially into the data register star ting with the MSB. Loading an address into \nthe address register and loadin g data into the data register can be done concurrently. \nAfter the 16 bits of data have been succe ssfully shifted into the data register, the \nPROGRAM  signal must be asserted high to start writing to the UFM. On the rising edge, \nthe data currently in the data register is written to the location currently in the address \nregister. The BUSY  signal is asserted until the program sequence is completed. The data \nand address register should not be modified until the BUSY  signal is de-asserted, or the \nflash content will be corrupted. The PROGRAM  signal is ignored if the BUSY  signal is \nasserted. When the PROGRAM  signal is applied at exactly the same time as the ERASE  \nsignal, the behavior is undefined and the flash content is corrupted. Figure 7–7  shows \nthe UFM waveforms during program mode.\nFigure 7–7. UFM Program Waveforms\ntADStASU tACLK\ntADHtAH\ntDDStDCLK tDSStDSH\ntDDH\ntPB tBP\ntPPMXtOSCStOSCH16 Data Bits9 Address Bits ARSHFT\nARCLK\nARDin\nDRSHFT\nDRCLK\nDRDin\nDRDout\nPROGRAM\nERASE\nBUSYOSC_ENA\nChapter 7: User Flash Memory in MAX V Devices 7–11\nUFM Operating Modes\nMay 2014 Altera Corporation MAX V Device HandbookErase\nThe ERASE  signal initiates an erase sequence to erase one sector of the UFM. The data \nregister is not needed to perform an erase sequence. To indicate the sector of the UFM \nto be erased, the MSB of the address register should be loaded with 0 to erase UFM \nsector 0, or 1 to erase UFM sector 1 ( Figure 7–2 on page 7–5 ). On a rising edge of the \nERASE  signal, the memory sector indicated by the MSB of the address register will be \nerased. The BUSY  signal is asserted until the erase sequence is completed. The address \nregister should not be  modified until the BUSY  signal is de-asserted to prevent the flash \ncontent from being corrupted. This ERASE  signal is ignored when the BUSY  signal is \nasserted. Figure 7–8  illustrates the UFM waveforms during erase mode.\n1 When the UFM sector is erased, it ha s 16-bit locations all filled with FFFF . Each UFM \nstorage bit can be programmed only once between erase sequences. You can write to \nany word up to two times providing the seco nd programming attempt at that location \nonly adds 0s. 1s are mask bi ts for your input word that cannot overwrite 0s in the \nflash array. New 1s in the location can only be achieved by an erase. Therefore, it is \npossible for you to perform byte writes because the UFM array is 16 bits for each \nlocation.\nFigure 7–8. UFM Erase Waveforms\n9 Address BitstASUtACLK tAH\ntADH\ntADS\ntEB\ntEPMXtOSCStOSCH\ntBEARSHFT\nARCLK\nARDin\nDRSHFT\nDRCLK\nDRDin\nDRDo ut\nPROGRAM\nERASE\nBUSYOSC_E NA\n7–12 Chapter 7: User Flash Me mory in MAX V Devices\nProgramming and Reading the UFM with JTAG\nMAX V Device Handbook May 2014 Altera CorporationProgramming and Reading the UFM with JTAG\nIn MAX V devices, you can write data to or  read data from the UFM using the IEEE \nStd. 1149.1 JTAG interface. You can use a PC or UNIX workstation, the Quartus II \nProgrammer, or the ByteBlasterMVTM or ByteBlasterTM II parallel port download \ncable to download Programmer Object File ( .pof), JamTM Standard Test and \nProgramming Language (STAPL) Files ( .jam ), or Jam Byte-Code Files ( .jbc) from the \nQuartus II software targeting the MAX V device UFM block. \n1 The .pof, .jam , and .jbc files can be generated using the Quartus II software. \nJam Files\nBoth .jam  STAPL and .jbc files support programmi ng for the UFM block.\nJam Players\nJam Players read the descriptive information in Jam files and translate them into data \nthat programs the target de vice. Jam Players do not pr ogram a particular device \narchitecture or vendor; they only read an d understand the syntax defined by the Jam \nfile specification. In-field changes are confined to the Jam file, not the Jam Player. As a \nresult, you do not need to modify the Jam Player source code for each in-field \nupgrade.\nThere are two types of Jam Players to acco mmodate the two types of Jam files: an \nASCII Jam STAPL Player and a Jam STAPL Byte-Code Player. Both ASCII Jam STAPL \nPlayer and Jam STAPL Byte-Code Player are coded in the C programming language for 16-bit and 32-bit processors.\nf For information about UFM oper ation during ISP, refer to AN 100: In-System \nProgrammability Guidelines .\nChapter 7: User Flash Memory in MAX V Devices 7–13\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookSoftware Support for UFM Block\nThe Altera Quartus II software includes sophisticated tools that fully utilize the \nadvantages of the UFM block in MAX V devices, while maintaining simple, easy-to-\nuse procedures that accelerate the design process. The following section describes how the ALTUFM megafunction supports a simple design methodology for \ninstantiating standard interface prot ocols for the UFM block, such as:\n■I2C\n■SPI\n■Parallel\n■None (Altera Serial Interface)\nThis section includes the megafunction sy mbol, the input and output ports, and a \ndescription of the MegaWizard  Plug-In Manager options. Refer to Quartus II Help for \nthe ALTUFM megafunction Altera Hard ware Description Language (AHDL) \nfunctional prototypes (appl icable to Verilog HDL), VHDL component declarations, \nand parameter descriptions. You can access this megafunction from the Memory \nCompiler directory on page 2a of the MegaWizard Plug-In Manager. \nThe ALTUFM MegaWizard Plug-In Manager ha s separate pages that apply to the \nMAX V UFM block. During compilation, the Quartus II Compiler verifies the \nALTUFM parameters selected against the available logic array interface options, and any specific assignments.\nInter-Integrated Circuit\nInter-Integrated Circuit (I2C) is a bidirectional two-wire interface protocol, requiring \nonly two bus lines: a serial data/address line (SDA), and a serial clock line (SCL). \nEach device connected to the I2C bus is software addressable by a unique address. The \nI2C bus is a multi-master bus where more than  one integrated circuit (IC) capable of \ninitiating a data transfer can be connected to it, which allows masters to function as \ntransmitters or receivers. \nThe ALTUFM_I2C megafunction features a seri al, 8-bit bidirectiona l data transfer up \nto 100 Kbits per second. With the ALTUFM_I2C megafunction, the MAX V UFM and \nlogic can be configured as  a slave device for the I2C bus. The ALTUFM megafunction’s \nI2C interface is designed to function similar to I2C serial EEPROMs. \nThe Quartus II software supports four different memory sizes: \n■(128 × 8) 1 Kbits \n■(256 × 8) 2 Kbits \n■(512 × 8) 4 Kbits \n■(1,024 × 8) 8 Kbits\nI2C Protocol\nThe following defines the characteristics of the I2C bus protocol: \n■Only two bus lines are required: SDA and SCL. Both SDA and SCL are \nbidirectional lines that remain high when the bus is free. \n7–14 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera Corporation■Data transfer can be initiated only when the bus is free. \n■The data on the SDA line must be stable during the high period of the clock. The \nhigh or low state of the data line can only  change when the clock signal on the SCL \nline is low. \n■Any transition on the SDA line while the SCL is high indicates a start or stop \ncondition. \nTable 7–5  lists the ALTUFM_I2C megafunction input and output interface signals. \nSTART and STOP Condition\nThe master always generates start (S) an d stop (P) conditions. After the start \ncondition, the bus is considered busy. Only a stop (P) condition frees the bus. The bus \nstays busy if the repeated start (Sr) conditio n is executed instead of a stop condition. \nIn this occurrence, the start (S) and repeat ed start (Sr) conditio ns are functionally \nidentical. \nA high-to-low transition on the SDA line while the SCL is high indicates a start \ncondition. A low-to-high transition on the SDA line while the SCL is high indicates a \nstop condition. Figure 7–9  shows the start and stop conditions. Table 7–5. ALTUFM_I2C Interface Signals \nPin Description Function \nSDA Serial Data/Address Line The bidirectional SDA port is used to transmit and receive serial data from the \nUFM. The output stage of the SDA port is configured as an open drain pin to \nperform the wired -AND  function. \nSCL Serial Clock Line The bidirectional SCL port is used to synchronize the serial data transfer to and \nfrom the UFM. The output stage of the SCL port is configured as an open drain pin to perform a wired\n-AND  function. \nWP Write Protect Optional active high signal that disables the erase and write function for \nread/write mode. The ALTUFM_I2C megafunction gives you an option to protect the entire UFM memory or only the upper half of memory. \nA2, A1, A0 Slave Address Input These inputs set the UFM slave address. The A 6, A5, A4, A3 slave address bits \nare programmable, set internally to 1010  by default. \nFigure 7–9. Start and Stop Conditions \nSDA\nSCLSDA\nSCL\nS P\nStart Condition Stop Condition\nChapter 7: User Flash Memory in MAX V Devices 7–15\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookAcknowledge\nAcknowledged data transfer is a requirement of I2C. The master must generate a clock \npulse to signify the acknowledge bit. The transmitter releases the SDA line (high) \nduring the acknowledge clock pulse. \nThe receiver (slave) must pull the SDA li ne low during the acknowledge clock pulse \nso that SDA remains a stable low during th e clock high period, indicating positive \nacknowledgement from the receiver. If the re ceiver pulls the SDA line high during the \nacknowledge clock pulse, the receiver sends a not-acknowledge condition indicating \nthat it is unable to process the last byte of data. If the receiver is busy (for example, executing an internally-timed erase or writ e operation), it will not acknowledge any \nnew data transfer. Figure 7–10  shows the acknowledge condition on the I\n2C bus. \nDevice Addressing\nAfter the start condition, the master sends th e address of the particular slave device it \nis requesting. The four most significant bits (MSBs) of the 8-bit slave address are usually fixed while the next three significant bits (A\n2, A1, A0) are device address bits \nthat define which device the master is a ccessing. The last bit of the slave address \nspecifies whether a read or write operation is to be performed. When this bit is set to \n1, a read operation is selected. When this bi t is set to 0, a write operation is selected. \nThe four MSBs of the slave address (A 6, A5, A4, A3) are programmable and can be \ndefined on page 3 of the ALTUFM MegaWizard Plug-In Manager. The default value \nfor these four MSBs is 1010 . The next three significant bits are defined using the three \nA2, A1, A0 input ports of the ALTUFM_I2C megafunction. You can connect these ports \nto input pins in the design file and connect  them to switches on the board. The other \noption is to connect them to V CC and GND primitives in the design file, which \nconserves pins. Figure 7–11  shows the slave address bits. Figure 7–10. Acknowledge on the I2C Bus \nData O utput\nBy Transmitter \nData O utput\nBy Recei ver\nSCL From\nMaster\nS\nStart ConditionClock Pulse For\nAcknowledgement AcknowledgeNot Acknowledge\n7–16 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationAfter the master sends a start condition and the slave address byte, the ALTUFM_I2C \nlogic monitors the bus and responds with an acknowledge (on the SDA line) when its \naddress matches the transmitted slave addr ess. The ALTUFM_I2C megafunction then \nperforms a read or write operation to or fr om the UFM, depending on the state of the \nbit. \nByte Write Operation\nThe master initiates a transfer by generating  a start condition, then sending the correct \nslave address (with the R/W bit set to 0) to the slave. If the slave address matches, the \nALTUFM_I2C slave acknowledges on the nint h clock pulse. The master then transfers \nan 8-bit byte address to the UFM, which ac knowledges the reception of the address. \nThe master transfers the 8-bit data to be written to the UFM. After the ALTUFM_I2C \nlogic acknowledges the reception of the 8-bit data, the master generates a stop \ncondition. The internal write from the MAX V logic array to the UFM begins only after the master generates a stop condition.  While the UFM internal write cycle is in \nprogress, the ALTUFM_I2C logic ignores any attempt made by the master to initiate a \nnew transfer. Figure 7–12  shows the byte write sequence. Figure 7–11. Slave Address Bits \nNotes to Figure 7–11 : \n(1) For the 4-Kbit memory size, the A 0 location in the slave a ddress becomes the MSB (a8) of the memory byte \naddress. \n(2) For the 8-Kbit memory size, the A 0 location in the sla ve address becomes a8 of the memory byte address, while \nthe A 1 location in the slave address becomes th e MSB (a9) of the memory byte address.1 4-Kbit Memory Size (1)MSB LSB\n0 1 0A2A1a8R/W\n1 8-Kbit Memory Size (2)MSB LSB\n0 1 0A2a9 a8R/W1 1- or 2-K bit Memory SizeMSB LSB\n0 1 0A2A1A0R/W\nFigure 7–12. Byte Write Sequence \nS A Byte Address Slave Address A Data A P\nFrom Master to Slave\nFrom Slave to MasterR/W\n"0" (write)S – Start Condition\nP – Stop ConditionA – Acknowledge\nChapter 7: User Flash Memory in MAX V Devices 7–17\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookPage Write Operation\nPage write operation has a similar sequence as the byte write operation, except that \nseveral bytes of data are transmitted in se quence before the master issues a stop \ncondition. The internal write from the MAX V logic array to the UFM begins only \nafter the master generates a stop condition.  While the UFM internal write cycle is in \nprogress, the ALTUFM_I2C logic ignores any attempt made by the master to initiate a \nnew transfer. The ALTUFM_I2C megafunction only allow 16 bytes for the page write \noperation.\nA write operation is only possible to an erased UFM block or word location. The UFM \nblock differs from serial EEPROMs, requiring an erase operation before writing new \ndata in the UFM block. A special erase sequence is required, as discussed in “Erase \nOperation” . \nAcknowledge Polling\nThe master can detect whether the internal write cycle is completed by polling for an \nacknowledgement from the slave. The master  can re-send the start condition together \nwith the slave address as soon as the byte write sequence is finished. The slave does \nnot acknowledge if the internal write cycle is  still in progress. The master can repeat \nthe acknowledge polling and proceed with the next instruction after the slave \nacknowledges. \nWrite Protection\nThe ALTUFM_I2C megafunction includes an  optional Write Protection (WP) port \navailable on page 4 of the ALTUFM MegaWizard Plug-In Manager. In the \nMegaWizard Plug-In Manager, you can choose the WP port to protect either the full or \nupper half memory. \nWhen WP is set to 1, the upper half or the entire memory array (depending on the \nwrite protection level selected) is protected, and the write and erase operations are not allowed. The ALTUFM_I2C megafunction  acknowledges the slave address and \nmemory address. After the master transf ers the first data byte, the ALTUFM_I2C \nmegafunction sends a not-acknowledge condit ion to the master to indicate that the \ninstruction will not execute. When WP is set to \n0, the write and erase operations are \nallowed. \nErase Operation\nCommercial serial EEPROMs automatically erase each byte of memory before writing into that particular memory location duri ng a write operation. However, the MAX V \nUFM block is flash based and only support s sector erase operations. Byte erase \noperations are not supported. When using read/write mode, a sector or full memory \nerase operation is required before writing new data into any location that previously contained data. The block cannot be erased  when the ALTUFM_I2C megafunction is \nin read-only mode. \nData can be initialized into memory for read/write and read-only modes by including \na memory initialization file ( .mif) or hexadecimal file ( .hex) in the ALTUFM \nMegaWizard Plug-In Manager. This data is automatically written into the UFM \nduring device programming by the Quartus II software or third-party programming tool. \n7–18 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationThe ALTUFM_I2C megafunction supports fo ur different erase operation methods \nshown on page 4 of the ALTUFM  MegaWizard Pl ug-In Manager: \n■Full Erase (Device Slave Address Triggered) \n■Sector Erase (Byte Address Triggered) \n■Sector Erase (A 2 Triggered) \n■No Erase \nThese erase options only work as described if that particular option is selected in the \nMegaWizard Plug-In Manager before compiling the design files and programming \nthe device. Only one option can be sele cted for the ALTUFM_I2C megafunction. \nEach erase option is discussed in more detail in the following sections. \nFull Erase (Device Slave Address Triggered)\nThe full erase option uses the A 2, A1, A0 bits of the slave address to distinguish \nbetween an erase or read/write operation. This slave operation decoding occurs when the master transfers the slave address to the slave after generating the start condition. \nIf the A\n2, A1, and A 0 slave address bits transmitted to the UFM slave equals 111 and \nthe four remaining MSBs match the rest of the slave addresses, then the Full Erase operation is selected. If the A\n6, A5, A4, A3 A2, A1, and A 0 slave address bits transmitted \nto the UFM match its unique slave addres s setting, the read/write operation is \nselected and functions as expected. As a re sult, this erase option utilizes two slave \naddresses on the bus reserving A 6, A5, A4, A3, 1, 1, 1 as the erase trigger. Both sectors \nof the UFM block will be erased when th e Full Erase operation is executed. This \noperation requires acknowledge polling. The internal UFM erase function only begins after the master generates a stop condition. Figure 7–13  shows the full erase sequence \ntriggered by using the slave address. \nIf the memory is write-protected (WP = 1) , the slave does not acknowledge the erase \ntrigger slave address (A\n6, A5, A4, A3, 1, 1, 1) sent by the master. The master should \nthen send a stop condition to terminate the transfer. The full erase operation will not \nbe executed. \nFigure 7–13. Full Erase Sequence Triggered Using the Slave Address \nSSlave Address\nA6A5A4A3111A P\nFrom Master to Slave\nFrom Slave to MasterS – Start Condition\nP – Stop ConditionA – AcknowledgeR/W\n\'0\' (write)\nChapter 7: User Flash Memory in MAX V Devices 7–19\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookSector Erase (Byte Address Triggered)\nThis sector erase operation is triggered by defining a 7- to 10-bit byte address for each \nsector depending on the memory size. The trigger address for each sector is entered on page 4 of the ALTUFM MegaWizard Plug -In Manager. When a write operation is \nexecuted targeting this special byte addre ss location, the UFM sector that contains \nthat byte address location is erased. This  sector erase operation is automatically \nfollowed by a write of the intended write byte to that address. The default byte \naddress location for UFM Sector 0 erase is address 0×00. The default byte address \nlocation for UFM Sector 1 eras e is [(selected memory size)/2]. You can specify another \nbyte location as th e trigger-erase addresses for each sector. \nThis sector erase operation supports up to  eight UFM blocks or serial EEPROMs on \nthe I\n2C bus. This sector erase operation requires acknowledge polling. \nSector Erase (A 2 Triggered)\nThis sector erase operation uses the received A 2 slave address bit to distinguish \nbetween an erase or read/write operation. This slave operation decoding occurs when the master transmits the slave address after generating the start condition. If the A\n2 bit \nreceived by the UFM slave is 1, the sect or erase operation is selected. If the A 2 bit \nreceived is 0, the read/write operation is selected. While this reserves the A 2 bit as an \nerase or read/write operation bit, the A 0 and A 1 bits still act as sl ave address bits to \naddress the UFM. With this erase option, there can be up to four UFM slaves cascaded \non the bus for 1-Kbit and 2-Kbit memory si zes. Only two UFM slaves can be cascaded \non the bus for 4-Kbit memory size, because A 0 of the slave address becomes the ninth \nbit (MSB) of the byte address. After the sl ave acknowledges the slave address and its \nerase or read/write operation bit, the master  can transfer any byte address within the \nsector that must be erased. The internal UF M sector erase operation only begins after \nthe master generates a stop condition. Figure 7–14  shows the sector erase sequence \nusing the A 2 bit of the slave address. \nIf the ALTUFM_I2C megafunction is writ e-protected (WP=1), the slave does not \nacknowledge the byte address (that indicates the UFM sector to be erased) sent in by \nthe master. The master should then send a st op condition to terminate the transfer and \nthe sector erase operation will not be executed. Figure 7–14. Sector Erase Sequence Indicated Using the A 2 Bit of the Slave Address \nNote to Figure 7–14 : \n(1) A 2 = 0 indicates a read/write operation is executed in place of an erase. Here, the R/W bit determines whether it is \na read or write operation. SSlave Address\nA2 = \'1\'A Byte Address A P\nFrom Master to Slav e\nFrom Slave to Maste rS – Start Condition\nP – Stop ConditionA – AcknowledgeR/W\n\'0\' (write) (1)\n7–20 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationNo Erase\nThe no erase operation never erases the UFM contents. This method is recommended \nwhen UFM does not require constant re-writing after its initial write of data. For example, if the UFM data is to be initia lized with data during manufacturing using \nI\n2C, you may not require writing to the UFM again. In that case, you should use the no \nerase option and save LE resources from being used to create erase logic. \nRead Operation\nThe read operation is initiated in the same manner as the write operation except that the R/W bit must be set to 1. Three different read operations are supported: \n■Current Address Read (Single Byte) \n■Random Address Read (Single byte) \n■Sequential Read (Multi-Byte) \nAfter each UFM data has been read and tr ansferred to the master, the UFM address \nregister is incremented for all single and multi-byte read operations. \nCurrent Address Read\nThis read operation targets the current byte  location pointed to by the UFM address \nregister. Figure 7–15  shows the current address read sequence. \nFigure 7–15. Current Address Read Sequence \n‘1’ (read)SA Data Slave Address P\nFrom Master to Slave\nFrom Slave to MasterS – Start Condition\nP – Stop ConditionA – AcknowledgeR/W\nChapter 7: User Flash Memory in MAX V Devices 7–21\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookRandom Address Read\nRandom address read operation allows the ma ster to select any byte location for a \nread operation. The master first performs  a “dummy” write operation by sending the \nstart condition, slave address, and byte addres s of the location it wishes to read. After \nthe ALTUFM_I2C megafunction acknowledges the slave and byte address, the master \ngenerates a repeated start cond ition, the slave address, and the R/W bit is set to 1. The \nALTUFM_I2C megafunction then responds  with acknowledge and sends the 8-bit \ndata requested. The master then generates a stop condition. Figure 7–16  shows the \nrandom address read sequence. \nSequential Read\nSequential read operation can be initiated by  either the current address read operation \nor the random address read operation. Inst ead of sending a stop condition after the \nslave has transmitted one byte of data to the master, the master acknowledges that \nbyte and sends additional cloc k pulses (on the SCL line) for the slave to transmit data \nbytes from consecutive byte addresses. The operation is terminated when the master \ngenerates a stop condition instead of responding with an acknowledge. Figure 7–17  \nshows the sequential read sequence. Figure 7–16. Random Address Read Sequence \n‘1’ (read) ‘0’ (write)SSlave\nAddressByte\nAddressSlave\nAddressAA S r Data AP\nFrom Master to Slave\nFrom Slave to MasterS – Start Condition\nSr – Repeated StartP – Stop ConditionA – AcknowledgeR/W R/W\nFigure 7–17. Sequential Read Sequence \n…\n‘0’ (write)SSlave\nAddressByte\nAddressSlave\nAddressAA S r A Data A Data P\nFrom Master to Slave\nFrom Slave to MasterS – Start Condition\nSr – Repeated StartP – Stop ConditionA – AcknowledgeR/W R/W\n‘1’ (read)        Data (n - bytes) + Acknowledgment (n - 1 bytes)\n7–22 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationALTUFM_I2C Interface Timing Specification\nFigure 7–18  shows the timing waveform fo r the ALTUFM_I2C megafunction \nread/write mode. \nTable 7–6  through Table 7–8  list the timing specification needed for the ALTUFM_I2C \nmegafunction read/write mode. Figure 7–18. Timing Waveform for the ALTUFM_I2C Megafunction\nSDA\nSCLtSU:STA tHD:STAtHD:DAT tSU:DAT tSU:STOtBUF\ntLOWtHIGHtSCLSDA\nTable 7–6. I2C Interface Timing Specification \nSymbol Parameter Min Max Unit\nFSCL SCL clock frequency — 100 kHz\ntSCL:SDA  SCL going low to SDA data out — 15 ns\ntBUF Bus free time between a stop and start condition 4.7 — µs\ntHD:STA  (Repeated) start condition hold time 4 — µs\ntSU:STA  (Repeated) start condition setup time 4.7 — µs\ntLOW SCL clock low period 4.7 — µs\ntHIGH SCL clock high period 4 — µs\ntHD:DAT  SDA data in hold time 0 — ns\ntSU:DAT  SDA data in setup time 20 — ns\ntSU:STO  STOP condition setup time 4 — ns\nTable 7–7. UFM Write Cycle Time\nParameter Min Max Unit\nWrite Cycle Time — 110 µs\nTable 7–8. UFM Erase Cycle Time \nParameter Min Max Unit\nSector Erase \nCycle Time — 501 ms \nFull Erase Cycle \nTime — 1,002 ms \nChapter 7: User Flash Memory in MAX V Devices 7–23\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookInstantiating the I2C Interface Using the Quartus II ALTUFM_I2C \nMegafunction\nFigure 7–19  shows the ALTUFM_I2C megafunction symbol for a I2C interface \ninstantiation in the Quartus II software. \nALTUFM_I2C megafunction is under the Memory Compiler  folder on page 2a of the \nMegaWizard Plug-In Manager. On page 3,  you can choose whether to implement the \nRead/Write  or Read Only mode for the UFM. You also have an option to choose the \nmemory size for the ALTUFM_I2C megafunction  as well as defining the four MSBs of \nthe slave address (default 1010). \nYou can select the optional write protection  and erase operation methods on page 4 of \nthe ALTUFM MegaWizard Plug-In Manager. \n1 The UFM block’s internal oscillator is  always running when the ALTUFM_I2C \nmegafunction is instantiated for both  read-only and read/write interfaces. \nSerial Peripheral Interface\nSerial peripheral interfac e (SPI) is a four-pin serial communication subsystem \nincluded on the Motorola 6805 and 68HC11 series microcontrollers. It allows the \nmicrocontroller unit to communicate with pe ripheral devices, and is also capable of \ninter-processor communications in a multiple-master system.\nThe SPI bus consists of masters and slaves. The master device initiates and controls \nthe data transfers and provides the clock signal for synchronization. The slave device \nresponds to the data transfer request from the master device. The master device in an SPI bus initiates a service request with th e slave devices responding to the service \nrequest. \nWith the ALTUFM megafunction, the UFM an d MAX V logic can be configured as a \nslave device for the SPI bus. The \nOSC_ENA is always asserted to enable the internal \noscillator when the SPI megafunction is  instantiated for bo th read only and \nread/write interfaces. Figure 7–19. ALTUFM_I2C Megafunction Symbol for the I2C Interface Instantiation in the Quartus \nII Software \n\n7–24 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationThe Quartus II software supports both the Base mode (uses 8-bit address and data) \nand the Extended mode (uses 16-bit address and data). Base mode uses only UFM \nsector 0 (2,048 bits), while Extended mode us es both UFM sector 0 and sector 1 (8,192 \nbits). There are only four pins in SPI: SI, SO, SCK, and nCS. Table 7–9  describes the SPI \npins and functions.\nData transmitted to the SI port of the slave device is sampled by the slave device at \nthe positive SCK clock. Data transmits from the slave device through SO at the negative \nSCK clock edge. When nCS is asserted, it means the current device is being selected by \nthe master device from the other end of the SPI bus for service. When nCS is not \nasserted, the SI and SCK ports should be blocked from receiving signals from the \nmaster device, and SO should be in High Impedance state to avoid causing contention \non the shared SPI bus. All instructions, addresses, and data are transferred with the \nMSB first and start with high-to-low nCS transition. The circuit diagram is shown in \nFigure 7–20 . Table 7–9. SPI Interface Signals\nPin Description Function\nSI Serial Data Input Receive data serially.\nSO Serial Data Output Transmit data serially.\nSCK Serial Data ClockThe clock signal produced from the master device to \nsynchronize the data transfer. \nnCS Chip SelectActive low signal that enables the slave device to \nreceive or transfer data from the master device.\nFigure 7–20. Circuit Diagram for SPI Interface Read or Write Operations\nRead, Write, and Erase \nState MachineOp-Code Decoder\nEight-Bit Status Shift RegisterAddress and Data Hub UFM BlockSPI Interface\nControl LogicSI SO SCK nCS\nChapter 7: User Flash Memory in MAX V Devices 7–25\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookOpcodes\nTable 7–10  lists the 8-bit instruction opcodes. After nCS is pulled low, the indicated \nopcode must be provided. Otherwise, the interface assumes that the master device \nhas internal logic errors and ignores the rest of the incoming signals. When nCS is \npulled back to high, the interface is back to normal. nCS should be pulled low again \nfor a new service request.\nThe READ  and WRITE  opcodes are instructions for transmission, which means the data \nwill be read from or written to the UFM. \nWREN , WRDI , RDSR , and WRSR  are instructions for the status  register, where they do not \nhave any direct interaction with UFM, but re ad or set the status register within the \ninterface logic. The status register provides status on whether the UFM block is available for any \nREAD  or WRITE  operation, whether the interface is WRITE  enabled, and \nthe state of the UFM WRITE  protection. Table 7–11  lists the status register format. For \nthe read only implementation of ALTUFM  SPI (Base or Extended mode), the status \nregister does not exist, saving LE resources.\nThe following sections describe the instructions for SPI.Table 7–10. Instruction Set for SPI\nName Opcode Operation\nWREN 00000110 Enable Write to UFM\nWRDI 00000100 Disable Write to UFM\nRDSR 00000101 Read Status Register\nWRSR 00000001 Write Status Register\nREAD 00000011 Read data from UFM\nWRITE 00000010 Write data to UFM\nSECTOR-ERASE 00100000 Sector erase\nUFM-ERASE 01100000 Erase the entire UFM block (both sectors)\nTable 7–11. Status Register Format\nPosition Status Default at Power-Up Description\nBit 7 X 0 —\nBit 6 X 0 —\nBit 5 X 0 —Bit 4 X 0 —\nBit 3 BP1 0 Indicate the current level of block write protection (1)\nBit 2 BP0 0 Indicate the current level of block write protection (1)\nBit 1 WEN 01= SPI \nWRITE  enabled state\n0= SPI WRITE disabled state\nBit 0 nRDY 01 = Busy, UFM  WRITE  or ERASE  cycle in progress\n0 = No UFM WRITE  or ERASE  cycle in progress\nNote to Table 7–11 :\n(1) For more information about status register bits BP1 and BP0, refer to Table 7–12  and Table 7–13 on page 7–34 .\n7–26 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationREAD\nREAD  is the instruction for data transmission , where the data is read from the UFM \nblock. When data transfer is taking plac e, the MSB is always the first bit to be \ntransmitted or received. The data output st ream is continuous through all addresses \nuntil it is terminated by a low-to-high transition at the nCS port. The READ  operation is \nalways performed through the followin g sequence in SPI, as shown in Figure 7–21 :\n1.nCS is pulled low to indicate  the start of transmission.\n2. An 8-bit READ  opcode (00000011 ) is received from the master device. (If internal \nprogramming is in progress, READ  is ignored and not accepted).\n3. A 16-bit address is received from the master device. The LSB of the address is \nreceived last. Because the UFM block can take only nine bits of address maximum, \nthe first seven address bits received are discarded. \n4. Data is transmitted for as many words as needed by the slave device through SO \nfor READ  operation. When the end of the UFM storage array is reached, the address \ncounter rolls over to the start of the UFM to continue the READ  operation. \n5.nCS is pulled back to high to indicate the end of transmission.\nFor SPI Base mode, the READ  operation is always performed through the following \nsequence in SPI:\n1.nCS is pulled low to indicate  the start of transmission.\n2. An 8-bit  READ  opcode (00000011 ) is received from the master device, followed by \nan 8-bit address. If internal programming is in progress, the READ  operation is \nignored and not accepted. \n3. Data is transmitted for as many words as needed by the slave device through SO \nfor READ  operation. The internal address poin ter automatically increments until the \nhighest memory address is reached (address 255 only because the UFM sector 0 is \nused). The address counter will not roll over when address 255 is reached. The SO \noutput is set to high-impedance (Z) when all eight data bits from address 255 have \nbeen shifted out through the SO port. \n4.nCS is pulled back to high to indicate the end of transmission.\nFigure 7–21. READ Operation Sequence for Extended Mode\n0123 456 78 9 10 11 20 21 22 23 24 25 26 27 36 37 38 39nCS\nSCK\nSI\nSOHigh Impedance03H\nMSB\nMSB MSBMSB\n16-bit Data Out 1 16-bit Data Out 28-bit\nInstruction16-bit\nAddress\nChapter 7: User Flash Memory in MAX V Devices 7–27\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookFigure 7–22  shows the READ  operation sequence for Base mode.\nWRITE\nWRITE  is the instruction for data transmission , where the data is written to the UFM \nblock. The targeted location in the UFM block that will be written must be in the \nerased state ( FFFFH ) before initiating a WRITE  operation. When data transfer is taking \nplace, the MSB is always the first bit to be transmitted or received. nCS must be driven \nhigh before the instruction is executed internally. You may poll the nRDY  bit in the \nsoftware status register for the comp letion of the internal self-timed WRITE  cycle. For \nSPI Extended mode, the WRITE  operation is always done through the following \nsequence, as shown in Figure 7–23 :\n1.nCS is pulled low to indicate  the start of transmission.\n2. An 8-bit WRITE  opcode (00000010 ) is received from the master device. If internal \nprogramming is in progress, the WRITE  operation is ignored and not accepted.\n3. A 16-bit address is received from the master device. The LSB of the address will be \nreceived last. Because the UFM block can take only nine bits of address maximum, the first seven address bits received are discarded. \n4. A check is carried out on the status register (see Table 7–11 ) to determine if the \nWRITE  operation has been enabled, and the address is outside of the protected \nregion; otherwise, Step 5 is bypassed.\n5. One word (16 bits) of data is tran smitted to the slave device through SI.\n6.nCS is pulled back to high to indicate the end of transmission.\nFor SPI Base mode, the WRITE  operation is always performed through the following \nsequence in SPI:\n1.nCS is pulled low to indicate  the start of transmission.\n2. An 8-bit WRITE  opcode (00000010 ) is received. If the internal programming is in \nprogress, the WRITE  operation is ignored and not accepted.\n3. An 8-bit address is received. A check is carried out on the status register (see \nTable 7–11 ) to determine if the WRITE  operation has been enabled, and the address \nis outside of the protected region; otherwise, Step 4 is skipped.Figure 7–22. READ Operation for Base Mode\n12 3 45 6 7 8 9 10 11 12 13 14 15 16 17 18 19nCS\nSCK\nSI\nSOHigh Impedance03H\nMSB\nMSB MSBMSB\n8-bit Data Out 1 8-bit Data Out 28-bit\nInstruction8-bit20 21 22 23 23\nAddress\n7–28 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera Corporation4. An 8-bit data is transmitted through SI.\n5.nCS is pulled back to high to indicate the end of transmission.\nFigure 7–24  shows the WRITE  operation sequence for Base mode.\nSECTOR-ERASE\nSECTOR-ERASE  (SE)  is the instruction of erasing one sector of the UFM block. Each \nsector contains 256 words. WEN bit and the sector must not be protected for SE \noperation to be successful. nCS must be driven high before the instruction is executed \ninternally. You may poll the nRDY  bit in the software status register for the completion \nof the internal self-timed SECTOR-ERASE  cycle. For SPI Extended mode, the SE \noperation is performed in the following sequence, as shown in Figure 7–25 :\n1.nCS is pulled low.\n2. Opcode  00100000  is transmitted into the interface.\n3. The 16-bit address is sent. The eighth bit (the first seven bits will be discarded) of \nthe address indicates which sector is eras ed; a 0 means sector 0 (UFM0) is erased, \nand a 1 means sector 1 (UFM1) is erased.Figure 7–23. WRITE Operation Sequence for Extended Mode\n0123 456 78 9 10 11 20 21 22 23 24 25 26 27 36 37 38 39nCS\nSCK\nSI\nSOHigh Impedance02H 16-bit Data In\nMSB MSB MSB8-bit\nInstruction16-bit\nAddress\nFigure 7–24. WRITE Operation Sequence for Base Mode\n0123 456 78 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23nCS\nSCK\nSI\nSOHigh Impedance02H\nMSB MSB8-bit Data In8-bit\nInstruction8-bit\nAddress\nChapter 7: User Flash Memory in MAX V Devices 7–29\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device Handbook4.nCS is pulled back to high.\nFor SPI Base mode, the SE instruction erases UFM sector 0. Because there are no \nchoices of UFM sectors to be erased, there is  no address component to this instruction. \nThe SE operation is always done through the following sequence in SPI Base mode:\n1.nCS is pulled low.\n2. Opcode 00100000  is transmitted into the interface.\n3.nCS is pulled back to high.\nFigure 7–26  shows the SECTOR-ERASE  operation sequence for Base mode.Figure 7–25. SECTOR-ERASE Operation Sequence for Extended Mode\nFigure 7–26. SECTOR_ERASE Operation Sequence for Base Mode0123 456 78 9 10 11 20 21 22 23nCS\nSCK\nSI\nSOHigh Impedance20H\nMSB MSB8-bit\nInstruction16-bit\nAddress\n0123 456 7nCS\nSCK\nSI\nSOHigh Impedance20H\nMSB8-bit\nInstruction\n7–30 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationUFM-ERASE\nThe UFM-ERASE  (CE)  instruction erases both UFM sector 0 and sector 1 for SPI \nExtended Mode. While for SPI Base mode, the CE instruction has the same \nfunctionality as the SECTOR-ERASE  (SE)  instruction, which erases UFM sector 0 only. \nWEN bit and the UFM sectors must not be protected for CE operation to be successful. \nnCS must be driven high before the instruct ion is executed internally. You may poll the \nnRDY  bit in the software status register for the completion of the internal self-timed CE \ncycle. For both SPI Extended mode and Base mode, the CE operation is performed in \nthe following sequence as shown in Figure 7–27 :\n1.nCS is pulled low.\n2. Opcode 01100000  is transmitted into the interface.\n3.nCS is pulled back to high.\nFigure 7–27  shows the UFM-ERASE  operation sequence.\nFigure 7–27. UFM-ERASE Operation Sequence\n0123 456 7nCS\nSCK\nSI\nSOHigh Impedance60H\nMSB8-bit\nInstruction\nChapter 7: User Flash Memory in MAX V Devices 7–31\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookWREN (Write Enable)\nThe interface is powered-up in th e write disable state. Therefore, WEN in the status \nregister (refer to Table 7–11 ) is 0 at power-up. Before any write is allowed to take \nplace, WREN  must be issued to set WEN in the status register to 1. If the interface is in \nread-only mode, WREN  does not have any effect on WEN, because the status register does \nnot exist. After WEN is set to 1, it can be reset by the WRDI  instruction; the WRITE  and \nSECTOR-ERASE  instructions will not reset the WEN bit. WREN  is issued through the \nfollowing sequence, as shown in Figure 7–28 :\n1.nCS is pulled low.\n2. Opcode 00000110  is transmitted into the interface to set WEN to 1 in the status \nregister.\n3. After the transmission of the eighth bit of WREN , the interface is in wait state \n(waiting for nCS to be pulled back to high). Any transmission after this is ignored.\n4.nCS is pulled back to high.\nFigure 7–28. WREN Operation Sequence\n0123 456 7nCS\nSCK\nSI\nSOHigh Impedance06H\nMSB8-bit\nInstruction\n7–32 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationWRDI (Write Disable)\nAfter the UFM is programmed, WRDI  can be issued to set WEN back to 0, disabling WRITE  \nand preventing inadvertent writing to the UFM. WRDI  is issued through the following \nsequence, as shown in Figure 7–29 :\n1.nCS is pulled low.\n2. Opcode 00000100  is transmitted to set WEN to 0 in the status register.\n3. After the transmission of the eighth bit of WRDI , the interface is in wait state \n(waiting for nCS to be pulled back to high). Any transmission after this is ignored.\n4.nCS is pulled back to high.\nFigure 7–29. WRDI Operation Sequence\n0123 456 7nCS\nSCK\nSI\nSOHigh Impedance04H\nMSB8-bit\nInstruction\nChapter 7: User Flash Memory in MAX V Devices 7–33\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookRDSR (Read Status Register)\nThe content of the status register can be read by issuing RDSR . After RDSR  is received, \nthe interface outputs the content of  the status register through the SO port. Although \nthe four most significant bits (Bit 7 to Bit 4)  do not hold valuable information, all eight \nbits in the status register will output through the SO port. This allows future \ncompatibility when Bit 7 to Bit 4 have new meaning in the status register. During the internal program cycle in the UFM, \nRDSR  is the only valid opcode recognized by the \ninterface (therefore, the status regist er can be read at any time), and nRDY  is the only \nvalid status bit. Other status bits are froz en and remain unchanged until the internal \nprogram cycle is ended. RDSR  is issued through the following sequence, as shown in \nFigure 7–30 :\n1.nCS is pulled low.\n2. Opcode 00000101  is transmitted into the interface.\n3.SI ignores incoming signals; SO outputs the content of the status register, Bit 7 first \nand Bit 0 last.\n4. If nCS is kept low, repeat step 3.\n5.nCS is pulled back to high to terminate the transmission.\nFigure 7–30. RDSR Operation Sequence\nStatus Register Out0123 456 78 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23nCS\nSCK\nSI\nSOHigh Impedance05H\nMSB MSB\nMSB MSB8-bit\nInstruction\n7–34 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationWRSR (Write Status Register)\nThe block protection bits (BP1  and BP0) are the status bits used to protect certain \nsections of the UFM from inadvertent write. The BP1 and BP0 status are updated by \nWRSR . During WRSR , only BP1 and BP0 in the status register can be written with valid \ninformation. The rest of the bits in the st atus register are ignored and not updated. \nWhen both BP1 and BP0 are 0, there is no protection for the UFM. When both BP1 and \nBP0 are 1, there is full protection for the UFM. BP0 and BP1 are set to 0 upon power-up. \nTable 7–12  lists the Block Write Protect Bits for Extended mode, while Table 7–13  lists \nthe Block Write Protect Bits for Base mode. WRSR  is issued through the following \nsequence, as shown in Figure 7–31 :\n1.nCS is pulled low.\n2. Opcode 00000001  is transmitted into the interface.\n3. An 8-bit status is transmitte d into the interface to update BP1 and BP0 of the status \nregister.\n4. If nCS is pulled high too early (before all the eight bits in Step 2 or Step 3 are \ntransmitted) or too late (the ni nth bit or more is transmitted), WRSR  is not executed.\n5.nCS is pulled back to high to terminate the transmission.\nFigure 7–31. WRSR Operation Sequence\nTable 7–12. Block Write Protect Bits for Extended Mode\nLevelStatus Register BitsUFM Array Address \nProtectedBP1 BP0\n0 (No protection) 0 0 None\n3 (Full protection) 1 1 000 to 1FF\nTable 7–13. Block Write Protect Bits for Base Mode\nLevelStatus Register BitsUFM Array Address \nProtectedBP1 BP0\n0 (No protection) 0 0 None\n3 (Full protection) 1 1 000 to 0FF0123 456 78 9 10 11 12 13 14 15nCS\nSCK\nSI\nSOHigh Impedance01H\nMSB MSBStatus Register In8-bit\nInstruction\nChapter 7: User Flash Memory in MAX V Devices 7–35\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookALTUFM SPI Timing Specification\nFigure 7–32  shows the timing specification needed for the SPI Extended mode \n(read/write). These nCS timing specificat ions do not apply to the SPI Extended \nread-only mode nor to any of the SPI Base modes. However, for the SPI Extended \nmode (read only) and the SPI Base mode (both read only and read/write), the nCS signal and SCK are not allowed to toggle at the same time. Table 7–14  lists the timing \nparameters that only apply to th e SPI Extended mode (read/write).\nInstantiating SPI Using Quartus II ALTUFM_SPI Megafunction\nFigure 7–33  shows the ALTUFM_SPI megafunction symbol for SPI instantiation in the \nQuartus II software.\nALTUFM_SPI megafunction is under the Memory Compiler  folder on page 2a of the \nMegaWizard Plug-In Manager. On page 3,  you can choose whether to implement the \nRead/Write  or Read Only  mode as the access mode for the UFM. You can also select \nthe configuration mode (Base or Extended) for SPI on this page. You can specify the \ninitial content of the UFM block on page of the ALTUFM MegaWizard Plug-In \nManager as discussed in “Creating Memory Content File” on page 7–39 .\n1 The UFM block’s internal oscillator is  always running when the ALTUFM_SPI \nmegafunction is instantiated for read/wri te interface. The UFM block’s internal \noscillator is disabled when the ALTUFM_SPI megafunction is instantiated for read \nonly interface. Figure 7–32. SPI Timing Waveform\nnCS\nSCKtHNCSHIGH\ntNCS2SCK tSCK2 NCS\nTable 7–14. SPI Timing Parameters for Extended Mode\nSymbol Description Minimum (ns) Maximum (ns)\ntSCK2NCS The time required for the SCK signal falling edge to nCS signal rising edge 50 —\ntHNCSHIGH The time that the  nCS  signal must be held high 600 —\ntNCS2SCK The time required for the nCS signal falling edge to SCK signal rising edge 750 —\nFigure 7–33. ALTUFM_SPI Megafunction Symbol for SPI Instantiation\n\n7–36 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationParallel Interface\nThis interface allows for parallel communi cation between the UFM block and outside \nlogic. After the READ  request, WRITE  request, or ERASE  request is asserted (active low \nassertion), the outside logic or device (suc h as a microcontroller) can continue its \noperation while the data in the UFM is retrieved, written, or erased. During this time, the \nnBUSY  signal is driven “low” to indicate that  it is not available to respond to any \nfurther request. After the operation is complete, the nBUSY  signal is brought back to \n“high” to indicate that it is now available to service a new request. If it was the Read \nrequest, the DATA _VALID  is driven “high” to indicate that the data at the DO port is the \nvalid data from the last read address. \nAsserting READ , WRITE , and ERASE  at the same time is not allowed. Multiple requests \nare ignored and nothing is read from, written to, or erased in the UFM block. There is \nno support for sequential read and page writ e in the parallel interface. For both the \nread only and the read/write mo des of the parallel interface, OSC_ENA is always \nasserted, enabling the internal oscillator. Table 7–15  lists the parallel interface pins and \nfunctions.\nEven though the ALTUFM megafunction allows you to select the address widths \nrange from 3 bits to 9 bits, the UFM block al ways expects a full 9 bits for the width of \nthe address register. Therefore, the ALTU FM megafunction will always pad the \nremaining LSBs of the address register with \'0 \'s if the register width selected is less \nthan 9 bits. The address register will point to sector 0 if the address received at the \naddress register starts with a \'0\'. The address register will point to sector 1 if the \naddress received starts with a \'1\'.\nEven though you can select an optional data  register width of 3 to 16 bits using the \nALTUFM megafunction, the UFM block always expects full 16 bits width for the data \nregister. Reading from the data register always proceeds from MSB to LSB. The ALTUFM megafunction always pads the remainin g LSBs of the data re gister with 1s if \nthe user selects a data wi dth of less than 16-bits.Table 7–15. Parallel Interface Signals\nPin Description Function\nDI[15..0] 16-bit data InputReceive 16-bit data in parallel. You can select an optional width of 3 to \n16 bits using the ALTUFM megafunction.\nDO[15..0] 16-bit data OutputTransmit 16-bit data in parallel. You can select an optional width of 3 to \n16 bits using the ALTUFM megafunction.\nADDR[8..0] Address RegisterOperation sequence refers to the data that is pointed to by the address \nregister. You can determine the address bus width using the ALTUFM \nmegafunction.\nnREAD READ  Instruction Signal Initiates a read sequence.\nnWRITE WRITE  Instruction Signal Initiates a write sequence.\nnERASE ERASE  Instruction SignalInitiates a SECTOR-ERASE sequence indicated by the MSB of the \nADDR[]  port.\nnBUSY BUSY  SignalDriven low to notify that it is not available to respond to any further \nrequest.\nDATA_VALID Data ValidDriven high to indicate that the data at the DO port is the valid data from \nthe last read address for read request.\nChapter 7: User Flash Memory in MAX V Devices 7–37\nSoftware Support for UFM Block\nMay 2014 Altera Corporation MAX V Device HandbookALTUFM Parallel Interface Timing Specification\nFigure 7–34  shows the timing specifications for the parallel interface. Table 7–16  lists \nthe parallel interface instruction signals. The nREAD , nWRITE , and nERASE  signals are \nactive low signals.\nInstantiating Parallel Interface Us ing Quartus II ALTUFM_PARALLEL \nMegafunction\nFigure 7–35  shows the ALTUFM_PARALLEL megafunction symbol for a parallel \ninterface instantiation in the Quartus II software.Figure 7–34. Parallel Interface Timing Waveform\nnBusyCommand\nData or Address B ustCOMMA ND\ntHNBUSY\ntHBUS\nTable 7–16. Parallel Interface Timing Parameters\nSymbol Description Minimum (ns) Maximum (ns)\ntCOMMANDThe time required for the command signal ( nREAD /nWRITE /nERASE ) \nto be asserted and held low to initiate a read/write/erase sequence600 3,000\ntHNBUSYMaximum delay between command signal’s falling edge to the \nnBUSY  signal’s falling edge—3 0 0\ntHBUSThe time that the data and address buses must be present at the \ndata input and address register ports after the command signal has \nbeen asserted low600 —\nFigure 7–35. ALTUFM_PARALLEL Megafunction Symbol for Parallel Interface Instantiation\n\n7–38 Chapter 7: User Flash Me mory in MAX V Devices\nSoftware Support for UFM Block\nMAX V Device Handbook May 2014 Altera CorporationALTUFM_PARALLEL megafunction is under the Memory Compiler  folder on page \n2a of the MegaWizard Plug-In Manager. On page 3, you can choose whether to \nimplement the Read/Write  or Read Only  mode for the UFM. You also have an option \nto choose the width for address bus (up to 9 bits) and for the data bus (up to 16 bits). You can specify the initial content of th e UFM block on page  4 of the ALTUFM \nMegaWizard Plug -In Manager as discussed in “Creating Memory Content File” on \npage 7–39 .\n1 The UFM block’s internal oscillator is always running when the \nALTUFM_PARALLEL megafunction is instantiated for read/write interface. The \nUFM block’s internal oscillator is disabled when the ALTUFM_PARALLEL \nmegafunction is instantiated  for a read only interface.\nNone (Altera Serial Interface)\nSelect None  for the interface protocol to use the dedicated UFM serial interface. The \nbuilt-in UFM interface uses 13 pins for the communication. The functional description of the 13 pins are described in Table 7–4 on page 7–3 . You can produce your own \ninterface design to communicate to/from the dedicated UFM interface and \nimplement it in the logic array.\nInstantiating None Using Quartus II ALTUFM_NONE Megafunction\nFigure 7–36  shows the ALTUFM_NONE megafunction  symbol for None instantiation \nin the Quartus II software.\nALTUFM_NONE megafunction is under the Memory Compiler  folder on page 2a of \nthe MegaWizard Plug-In Manager. You can specify the initial content of the UFM block on page 3 of the ALTUFM MegaWizard Plug-In Manager as discussed in \n“Creating Memory Content File” .Figure 7–36. ALTUFM_NONE Megafunction Symbol for None Instantiation\n\nChapter 7: User Flash Memory in MAX V Devices 7–39\nCreating Memory Content File\nMay 2014 Altera Corporation MAX V Device HandbookCreating Memory Content File\nYou can initialize the content of the UFM through a memory content file. The \nQuartus II software supports two types of in itial memory content file format: Memory \nInitialization File ( .mif) and Hexadecimal File ( .hex). A new memory content file for \nthe UFM block can be created by clicking New  on the File menu. Select the .mif or \n.hex file in the Other Files  tab. \nAfter clicking OK, a dialog box appears. In this dialog box, the Number of words  \nrepresents the numbers of address lines while the Word size  represents the data \nwidth. To create a memory content fi le for the ALTUFM megafunction, enter 512 for \nthe number of words and 16 for the word size. \nThe memory content is written into a .hex file. On the Tools menu, click MegaWizard \nPlug-In Manager . The memory content file ( data.hex ) is included on the respective \nALTUFM MegaWizard Plug-In Manager. Click Yes to use this file for the memory \ncontent file. Click Browse  to include the memory content file.\nMemory Initialization for th e ALTUFM_PARALLEL Megafunction\nFor the parallel interface, if a .hex file is used to initialize the memory content for the \nALTUFM megafunction, you must fully specify all 16 bits in each memory address, \nregardless of the data width selected. If your data width is less than 16 bits wide, your \ndata must be placed in the MSBs of the data word and the remaining LSBs must be \npadded with 1’s.\nFor an example, if address _width  = 3 and data _width  = 8 are selected for the \nALTUFM_PARALLEL megafunction, the .hex file should contain eight addresses of \ndata (23 addresses), each word containing 16 bits . If the initial content at the location \n000 is intended to be 10101010 , you should specify  1010101011111111  for address 000 \nin the .hex file.\n1 This specification applies only to .hex files used with the parallel interface. .mifs do \nnot require you to fully specify 16 bits  for each data word. However, both .mif and \n.hex files require you to specify all addresses of data according to the address _width  \nselected in the megafunction.\nMemory Initialization for the ALTUFM_SPI Megafunction\nThe same 16-bit data padding mentione d for ALTUFM_PARALLEL is required for \n.hex files used with the SPI Base (8 bits) an d Extended (16 bits) mode interface. In \naddition, for SPI Base and Extended modes, you must fully specify memory content \nfor all 512 addresses (both sector 0 and sector 1) in the .mif and .hex  files, even if \nsector 1 is not used. You can put valid data for SPI Base mode addresses 0 to 255 \n(sector 0), and initialize sector 1 to all ones.\n7–40 Chapter 7: User Flash Me mory in MAX V Devices\nCreating Memory Content File\nMAX V Device Handbook May 2014 Altera CorporationMemory Initialization for the ALTUFM_I2C Megafunction\nThe MAX V UFM physical memory block cont ains a 16-bit wide and 512 deep (9-bit \naddress) array. The ALTUFM_I2C megafunction uses the following smaller array \nsizes: \n■An 8-bit wide and 128 deep (7-bit addr ess) mapping for 1 Kbit memory size \n■An 8-bit wide and 256 deep (8-bit addr ess) mapping for 2 Kbits memory size \n■An 8-bit wide and 512 deep (9-bit a ddress) mapping for 4 Kbits memory size\n■An 8-bit wide and 1,024 deep (10-bit ad dress) mapping for 8 Kbits memory size\nAltera recommends that you pad the .mif or .hex file for both address and data width \nto fill the physical memory map for the UFM block and ensure the .mif or .hex file \nrepresents a full 16-bit word si ze and a 9-bit address space. \nMemory Map for 1-Kbit Memory Initialization\nFigure 7–37  shows the memory map initialization for the ALTUFM_I2C megafunction \nof 1-Kbit memory size. The ALTUFM_I2C megafunction byte address location of 00h \nto 3Fh is mapped to the UFM bl ock address location of 000h  to 03Fh . The \nALTUFM_I2C megafunction by te address location of 40h to 7Fh is mapped to the \nUFM block address location of 1C0h  to 1FFh . Altera recommends that you pad the \nunused address locations of the UFM block with all 1s. \nFigure 7–37. Memory Map for 1-Kbit Memory Initialization\nUpper Half – Addresses\n40h to 7Fh\nLower Half – Addresses\n00h to 3Fh\n00h\n000h3Fh\n03Fh40h7Fh\n1C0h1FFhAddress 40h in logical memory maps to\n1C0h in the MIF/HEX file. Address 7Fh in logical\nmemory maps to 1FFh in the MIF/HEX file, and all\ndata in between follows the order in the\nlogical memory\nAddress 00h in logical memory maps to\naddress 000h in the MIF/HEX file. Address 3Fh in \nlogical memory maps to 03Fh in the MIF/HEX file, \nand all data in between follows the order in the\nlogical memory040h1BFh\nThis section of the UFM is unused –\nthe MIF/HEX file contents should be set to\nall \'1\' for addresses 040h to 1BFh1-Kbit ALTUFM_I2C Megafunction\nLogical Memory ContentsMIF or HEX File Contents – to represent\nthe actual data and address size for the UFM block\nChapter 7: User Flash Memory in MAX V Devices 7–41\nCreating Memory Content File\nMay 2014 Altera Corporation MAX V Device HandbookMemory Map for 2-Kbit Memory Initialization\nFigure 7–38  shows the memory map initialization for the ALTUFM_I2C megafunction \nof 2 Kbits of memory. The ALTUFM_I2C me gafunction byte address location of 00h to \n7Fh is mapped to the UFM block address location of 000h  to 07Fh . The ALTUFM_I2C \nmegafunction byte address location of 80h to FFh is mapped to the UFM block address \nlocation of 180h  to 1FFh . Altera recommends that you pad the unused address location \nof the UFM block with all 1s. \nFigure 7–38. Memory Map for 2-Kbit Memory Initialization\nUpper Half – Addresses\n80h to FFh\nLower Half – Addresses\n00h to 7Fh\n00h\n000h7Fh\n07Fh80hFFh\n180h1FFh\nAddress 80h in logical memory maps to\naddress 180h in the MIF/HEX file. FFh in logical\nmemory maps to 1FFh in the MIF/HEX file, and all\ndata in between follows the order in the\nlogical memory\nAddress 00h in logical memory maps to\naddress 000h in the MIF/HEX file. Address 7Fh in \nlogical memory maps to 07Fh in the MIF/HEX file, \nand all data in between follows the order in the\nlogical memory080h17Fh\nThis section of the UFM is unused –\nthe MIF/HEX file contents should be set to\nall \'1\' for addresses 080h to 17Fh2-Kbit ALTUFM_I2C Megafunction\nLogical Memory ContentsMIF or HEX File Contents – to represent\nthe actual data and address size for the UFM block\n7–42 Chapter 7: User Flash Me mory in MAX V Devices\nCreating Memory Content File\nMAX V Device Handbook May 2014 Altera CorporationMemory Map for 4-Kbit Memory Initialization\nFigure 7–39  shows the memory map initialization for the ALTUFM_I2C megafunction \nof 4-Kbit memory. The ALTUFM_I2C mega function byte addr ess location of 00h to \nFFh is mapped to the UFM bl ock address location of 000h  to 0FFh . The ALTUFM_I2C \nmegafunction byte ad dress location of 100h  to 1FFh  is mapped to the UFM block \naddress location of 100h  to 1FFh . \nMemory Map for 8-Kbit Memory Initialization\nFigure 7–40  shows the memory map initialization for the ALTUFM_I2C megafunction \nof 8-Kbit memory. The ALTUFM_I2C megafunction of 8-Kbit memory fully utilizes all \nthe memory locations in the UFM block. Figure 7–39. Memory Map for 4-Kbit Memory Initialization\nUpper Half – Addresses\n100h to 1FFh\nLower Half – Addresses\n00h to FFh\n00h 000hFFh 0FFh100h1FFh\n100h1FFh\nAddress 100h in logical memory maps to\n100h in the MIF/HEX file. Address 1FFh in logical\nmemory maps to 1FFh in the MIF/HEX file, and all\ndata in between follows the order in the\nlogical memory\nAddress 00h in logical memory maps to\n000h in the MIF/HEX file. Address FFh in logical\nmemory maps to 0FFh in the MIF/HEX file, and all\ndata in between follows the order in the\nlogical memory4-Kbit ALTUFM_I2C Megafunction\nLogical Memory ContentsMIF or HEX File Contents – to represent\nthe data and address size for the UFM block\nFigure 7–40. Memory Map for 8-Kbit Memory Initialization\n000h0FFh100h1FFh200h2FFh300h3FFh\nUpper 8-bit (byte) Lower 8-bit (byte)\n16-bit data in UFM000h0FFh100h1FFh\n8-Kbit ALTUFM_I2C Megafunction\nLogical Memory Contents\nUpper Quarter Addresses\n300h to 3FFh\nMid-Upper Quarter Addresses\n200h to 2FFh\nMid-Lower Quarter Addresses\n100h to 1FFh\nLower Quarter Addresses\n000h to 0FFhMIF or HEX File Contents - to represent the\nactual data and address size for the UFM Block\nThe upper quarter of\nlogical memory mapsto the upper byte ofsector 1. Address 300hin logical memorymaps to address 100hin physical memoryand all addressesfollow the order inlogical memory.The mid-upper quarter of\nlogical memory mapsto the lower byte ofsector 1. Address 200hin logical memorymaps to address 100hin physical memoryand all addressesfollow the order inlogical memory.\nThe lower quarter of\nlogical memory mapsto the lower byte ofsector 0. Address 000hin logical memorymaps to address 000hin physical memoryand all addressesfollow the order inlogical memory.The mid-lower quarter of\nlogical memory mapsto the lower byte ofsector 0. Address 100hin logical memorymaps to address 000hin physical memoryand all addressesfollow the order inlogical memory.\nChapter 7: User Flash Memory in MAX V Devices 7–43\nSimulation Parameters\nMay 2014 Altera Corporation MAX V Device HandbookPadding Data into Memory Map\nThe ALTUFM_I2C megafunction uses the upper 8 bits of the UFM 16-bit word; \ntherefore, the 8 least significant bits sh ould be padded with 1s, as shown in Figure 7–\n41. \nSimulation Parameters\nIn the ALTUFM megafunction, you have an option to simulate the OSC output port at \nthe maximum or the minimum frequency during the design simulation. The \nfrequency chosen is only used as the timi ng parameter for the Quartus II simulator \nand does not affect the real MAX V device OSC output frequency.\nDocument Revision History\nTable 7–17  lists the revision history for this chapter.Figure 7–41. Padding Data into Memory Map \n8-bit valid data to be placed\nin the upper byte Pad the lo wer byte with eight \'1\'s1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 1\nTable 7–17. Document Revision History\nDate Version Changes\nMay 2014 1.2 Updated “Page Write Operation” on page 7–17\nJanuary 2011 1.1 Updated “Oscillator”  section.\nDecember 2010 1.0 Initial release.\n7–44 Chapter 7: User Flash Me mory in MAX V Devices\nDocument Revision History\nMAX V Device Handbook May 2014 Altera Corporation\nMAX V Device Handbook\nDecember 2010MV51008-1.0\nSubscribe© 2010 Altera Corporation. All rights reserved. ALTERA, ARRIA, CY CLONE, HARDCOPY, MAX, MEGACORE , NIOS, QUARTUS and STRATIX are Reg. U.S. Pat. & Tm. Off. \nand/or trademarks of Altera Corporation in the U.S. and other countries. All other trademarks and service marks are the propert y of their respective holders as described at \nwww.altera.com/common/legal.html . Altera warrants performance of its semiconductor products to cu rrent specifications in accordan ce with Altera’s standard warr anty, but \nreserves the right to make changes to any products and services  at any time without notice. Altera assumes no responsibility or  liability arising out of th e application or use of any \ninformation, product, or service described herein except as expressly agreed to in writing by Altera. Alte ra customers are advi sed to obtain the latest version of device \nspecifications before relying on any published information and before placi ng orders for products or services.8. JTAG Boundary-Scan Testing in MAX V\nDevices\nThis chapter describes the IEEE Std.1149. 1 (JTAG) boundary-scan testing for Altera® \nMAX®V devices. The IEEE Std. 1149.1 BST circuitry available in MAX V devices \nprovides a cost-effective and efficient way to test systems that contain devices with \ntight lead spacing. Circuit boards with Altera and other IEEE Std. 1149.1-compliant \ndevices can use EXTEST , SAMPLE /PRELOAD , and BYPASS  modes to create serial patterns \nthat internally test the pin connections be tween devices and check device operation. \nAs PCBs become more complex, the re quirement for thorough testing becomes \nincreasingly important. Advances in surface-mount packaging and PCB \nmanufacturing have resulted in smaller bo ards, making traditional test methods (for \nexample, external test probes and “bed-of-na ils” test fixtures) harder to implement. \nAs a result, cost savings from PCB space reductions are sometimes offset by cost \nincreases in traditional testing methods.\nIn the 1980s, JTAG developed a specificatio n for boundary-scan testing that was later \nstandardized as the IEEE Std. 1149.1 spec ification. This boundary-scan test (BST) \narchitecture offers the capabi lity to efficiently test comp onents on PCBs with tight \nlead spacing.\nBST architecture can test pin connections without using physical test probes and \ncapture functional data while a device is  operating normally. Boundary-scan cells \n(BSCs) in a device can force signals onto pi ns, or capture data from pin or core logic \nsignals. Forced test data is serially shifted into the BSCs. Captured data is serially \nshifted out and externally comp ared to expected results. \nFigure 8–1  shows the concept of boundary-scan testing.\nThis chapter describes the following topics:\n■“IEEE Std. 1149.1 BST Architecture” on page 8–2\n■“IEEE Std. 1149.1 Boundary-Scan Register” on page 8–3\n■“IEEE Std. 1149.1 BST Operation Control” on page 8–6\n■“I/O Voltage Support in the JTAG Chain” on page 8–13\n■“Boundary-Scan Test  for Programmed Devices” on page 8–14Figure 8–1. IEEE Std. 1149.1 Boundary-Scan Testing\nCore\nLogicSerialData InBoundary-Sca n Cell\nIC\nCore\nLogicSerialData Out\nInterconnectio n\nto Be Te sted\nJTAG Device 1 JTAG Device 2Pin SignalDecember 2010\nMV51008-1.0\n8–2 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 BST Architecture\nMAX V Device Handbook December 2010 Altera Corporation■“Disabling IEEE Std. 1149.1 BST Circuitry” on page 8–15\n■“Guidelines for IEEE Std. 1149.1 Boundary-Scan Testing” on page 8–15\n■“Boundary-Scan Description Language Support” on page 8–15\nIn addition to BST, you can use the IEEE Std. 1149.1 controller for in-system \nprogramming for MAX V devices. MAX V devices support IEEE 1532 programming, \nwhich uses the IEEE Std. 1149.1 test access port (TAP) interface. However, this chapter \nonly describes the BST feature of the IEEE Std. 1149.1 circuitry. \nIEEE Std. 1149.1 BST Architecture\nA MAX V device operating in IEEE Std. 11 49.1 BST mode uses four required pins, TDI, \nTDO, TMS, and TCK. \nTable 8–1  lists the functions of each of thes e pins. MAX V devices do not have a TRST  \npin.\nThe IEEE Std. 1149.1 BST circuitry requires the following registers:\n■The instruction register determines which action to perform and which data \nregister to access.\n■The bypass register (which is a 1- bit long data register) provides a \nminimum-length serial path between the TDI and TDO pins. \n■The boundary-scan register that is a shift register composed of all the BSCs of the \ndevice. Table 8–1. IEEE Std. 1149.1 Pin Descriptions\nPin Description Function\nTDI (1) Test data inputSerial input pin for instructions as well as test and \nprogramming data. Data is shifted in on the rising edge of TCK.\nTDO Test data outputSerial data output pin for instructions as well as test and \nprogramming data. Data is shifted out on the falling edge of \nTCK. The pin is tri-stated if data is not being shifted out of the \ndevice.\nTMS (1) Test mode selectInput pin that provides the control signal to determine the \ntransitions of the TAP controller state machine. Transitions \nwithin the state machine occur at the rising edge of TCK. \nTherefore, you must set up the TMS before the rising edge of \nTCK. TMS is evaluated on the rising edge of TCK.\nTCK (2) Test clock inputThe clock input to the BST circuitry. Some operations occur at \nthe rising edge, while others occur at the falling edge.\nNotes to Table 8–1 :\n(1) The TDI and TMS pins have internal weak pull-up resistors \uf02e\n(2) The TCK pin has an internal weak pull-down resistor \uf02e\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–3\nIEEE Std. 1149.1 Boundary-Scan Register\nDecember 2010 Altera Corporation MAX V Device HandbookFigure 8–2  shows a functional model of the IEEE Std. 1149.1 circuitry.\nThe TAP controller controls the IEEE Std. 1149.1 boundary-scan testing, as described \nin “IEEE Std. 1149.1 BST Operation Control” on page 8–6 . The TMS and TCK pins \noperate the TAP controller and the TDI and TDO pins provide the se rial path for the \ndata registers. The TDI pin also provides data to the instruction register, which then \ngenerates the control logic for the data registers.\nIEEE Std. 1149.1 B oundary-Scan Register\nThe boundary-scan register is a large serial shift register that uses the TDI pin as an \ninput and the TDO pin as an output. The boundary-s can register consists of 3-bit \nperipheral elements that are associated wi th the I/O pins of the MAX V devices. You \ncan use the boundary-scan register to test th e external pin connections or to capture \ninternal data. Figure 8–2. IEEE Std. 1149.1 Circuitry\nNote to Figure 8–2 :\n(1) For the boundary-scan register le ngth in MAX V devices, refer to the JTAG and In- System Programmability in MAX V Devices chapter.aUPDATEIR\nCLOCKIR\nSHIFTIR\nUPDATEDR\nCLOCKDR\nSHIFTDRTDIInstruction Register\nBypass Register\nBoundary-Scan Register (1)Instruction Decode\nTMS\nTCKTAP\nController\nISP RegistersTDO\nData Registers\nDevice ID Register\n8–4 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 Boundary-Scan Register\nMAX V Device Handbook December 2010 Altera CorporationFigure 8–3  shows how test data is serially sh ifted around the periphery of the IEEE \nStd. 1149.1 device. \nBoundary-Scan Cells of a MAX V Device I/O Pin\nExcept for the four JTAG pins and power pins, you can use all the pins of a MAX V \ndevice (including cloc k pins) as user I/O pins and have  a BSC. The 3-bi t BSC consists \nof a set of capture registers and a set of update registers. The capture registers can \nconnect to internal device data through the OUTJ  and OEJ signals, while the update \nregisters connect to external data through the PIN_OUT and PIN_OE signals. The TAP \ncontroller internally generates the SHIFT , CLOCK , and UPDATE  global control signals for \nthe IEEE Std. 1149.1 BST registers; a decode of the instruction register generates the \nMODE  signal. The data signal path for the boun dary-scan register ru ns from the serial \ndata in (SDI) signal to the serial data out ( SDO) signal. The scan register begins at the \nTDI pin and ends at the TDO pin of the device. Figure 8–3. Boundary-Scan Register\nTCK TMSTAP Controller\nTDIInternal Logic\nTDOEach pe ripheral\neleme nt is eithe r an\nI/O pi n, dedicated\ninput pin, or\ndedicated\nconfiguration pin.\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–5\nIEEE Std. 1149.1 Boundary-Scan Register\nDecember 2010 Altera Corporation MAX V Device HandbookFigure 8–4  shows the user I/O BSC for MAX V devices.\nTable 8–2  lists the capture and update register capabilities of all BSC within MAX V \ndevices.\nJTAG Pins and Power Pins\nMAX V devices do not have BSCs for dedicated JTAG pins ( TDI, TDO, TMS, and TCK) \nand power pins ( VCCINT , VCCIO , GNDINT , and GNDIO ).Figure 8–4. User I/O BSC with IEEE Std. 1149.1 BST Circuitry for MAX V Devices\nMODE HIGHZPIN_IN\nPIN_OE\nPIN_OUT\nPin\nOutput\nBufferINJ\nOEJ\nOUTJSDO\nUPDATE CLOCK SHIFT\nSDIDQ\nInput0\n1\nDQ\nOEDQ\nOE0\n1\nDQ\nOutputDQ\nOutput0\n1\n0101\nCapt ure\nRegi stersUpdate\nRegi stersGlobal Sig nals0\n1From o r To Device\nI/O Cell Ci rcuitry\nAnd/Or Logic Co re\nTable 8–2. BSC Description for MAX V Devices (Note 1)\nPin TypeCaptures Drives\nNotes Output \nCapture \nRegisterOE Capture \nRegisterInput Capture \nRegisterOutput \nUpdate \nRegisterOE Update \nRegisterInput Update \nRegister\nUser I/O OUTJ OEJ PIN_IN PIN_OUT PIN_OE —Includes \nuser clocks\nNote to Table 8–2 :\n(1)TDI, TDO, TMS, and TCK pins and all VCC and GND pin types do not have BSCs.\n8–6 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 BST Operation Control\nMAX V Device Handbook December 2010 Altera CorporationIEEE Std. 1149.1 BST Operation Control\nMAX V devices implement the SAMPLE /PRELOAD , EXTEST , BYPASS , IDCODE , USERCODE , \nCLAMP  and HIGHZ  IEEE Std. 1149.1 BST instructions. The length of the BST instructions \nis 10 bits. These instructions are described in detail later in this chapter.\nf For a summary of the BST instructions and their instruction codes, refer to the JTAG \nand In-System Programmab ility in MAX V Devices  chapter.\nThe IEEE Std. 1149.1 TAP controller, a 16-st ate state machine clocked on the rising \nedge of TCK, uses the TMS pin to control IEEE Std. 1149.1 operation in the device. \nFigure 8–5  shows the TAP controller state machine.\nFigure 8–5. IEEE Std. 1149.1 TAP Controller State Machine\nSELECT_DR_SCAN\nCAPTURE_DR\nSHIFT_DR\nEXIT1_DR\nPAUSE_DR\nEXIT2_DR\nUPDATE_DRSHIFT_IR\nEXIT1_IR\nPAUSE_IR\nEXIT2_IR\nUPDATE_IRTMS = 0\nTMS = 0TMS = 0\nTMS = 1TMS = 0TMS = 1\nTMS = 1\nTMS = 0\nTMS = 1\nTMS = 0\nTMS = 1\nTMS = 1\nTMS = 0 TMS = 0TMS = 1TMS = 1TMS = 0TMS = 1TMS = 0\nTMS = 0TMS = 1TMS = 0TMS = 0TMS = 1TMS = 0RUN_TEST/\nIDLE TMS = 0TEST_LOGIC/\nRESET TMS = 1\nTMS = 0\nTMS = 1 TMS = 1\nTMS = 1 TMS = 1CAPTURE_IRSELECT_IR_SCAN\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–7\nIEEE Std. 1149.1 BST Operation Control\nDecember 2010 Altera Corporation MAX V Device HandbookWhen the TAP controller is in the TEST _LOGIC/RESET  state, the BST circuitry is \ndisabled, the device is in normal operation,  and the instruction register is initialized \nwith IDCODE  as the initial instruction. During device power up, the TAP controller \nstarts in this TEST _LOGIC/RESET  state. In addition, the TAP controller may be forced to \nthe TEST _LOGIC/RESET  state by holding TMS high for five TCK clock cycles. After the \nTEST _LOGIC/RESET  state, the TAP controller remains in this state as long as TMS \ncontinues to be held high while TCK is clocked.\nFigure 8–6  shows the timing requirements for the IEEE Std. 1149.1 signals.\nTo start the IEEE Std. 1149.1 operation, select an instruction mode by advancing the \nTAP controller to the shift instruction register ( SHIFT _IR) state and shift in the \nappropriate instruction code on the TDI pin. \nFigure 8–7  shows the entry of the instruction code into the instruction register. From \nthe RESET  state, TMS is clocked with the pattern 01100  to advance the TAP controller to \nSHIFT _IR state.Figure 8–6. IEEE Std. 1149.1 Timing Waveforms (Note 1)\nNote to  Figure 8–6 :\n(1) For timing parameter values, refer to the DC and Switching Characteristics for MAX V Devices chapter.TDITMS\nTDOTCK\nSignal\nto Be\nCaptured\nSignal\nto Be\nDriventJCP tJPSU tJPH\ntJCH tJCL\ntJPZX tJPCO\ntJSSU tJSH\ntJSZX tJSCO tJSXZtJPXZ\nFigure 8–7. Selecting the Instruction Mode\nSELECT_DR_SCAN  SELECT_IR_SCAN\nCAPTURE_IRRUN_TEST/IDLE EXIT1_IRTCK\nTMS\nTDI\nTDO\nTAP_STATE\nTEST_LOGIC/RESETSHIFT_IR\n8–8 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 BST Operation Control\nMAX V Device Handbook December 2010 Altera CorporationThe TDO pin is tri-stated in all states except the SHIFT _IR and SHIFT _DR states. The TDO \npin is activated at the first falling edge of TCK after entering either  of the shift states \nand is tri-stated at the first falling edge of TCK after leaving either of the shift states.\nWhen the SHIFT _IR state is activated, TDO is no longer tri-stated, and the initial state of \nthe instruction register is shifted out on the falling edge of TCK. TDO continues to shift \nout the contents of the instruction register as long as the SHIFT _IR state is active. The \nTAP controller remains in the SHIFT _IR state as long as TMS remains low. \nDuring the SHIFT _IR state, an instruction code is entered by shifting data on the TDI \npin on the rising edge of TCK. You must clock the last bit of the OPCODE  at the same time \nthat the next state, EXIT1 _IR, is activated; EXIT1 _IR is entered by clocking a logic high \non TMS. After in the EXIT1 _IR state, TDO becomes tri-stated again. TDO is always \ntri-stated except in the SHIFT _IR and SHIFT _DR states. After an instruction code is \nentered correctly, the TAP controller advances  to perform the serial shifting of test \ndata in one of three modes ( SAMPLE /PRELOAD , EXTEST , or BYPASS ).\nFor MAX V devices, there are weak pull-up resistors for TDI and TMS, and pull-down \nresistors for TCK. However, in a JTAG chain, there might be some devices that do not \nhave internal pull-up or pull-down resistor s. In this case, Altera recommends pulling \nthe TMS pin high (through  an external 10-k \uf057 resistor), and pulling TCK low (through an \nexternal 1-k \uf057 resistor) during BST or in-system programmability (ISP) to prevent the \nTAP controller from going into an unintended state. Pulling-up the TDI signal \nexternally for the MAX V device is optional.\nf For more information about the pull-u p and pull-down resistors, refer to \nAN 100: In-System Prog rammability Guidelines .\nSAMPLE/PRELOAD Instruction Mode\nSAMPLE/PRELOAD  instruction mode allows you to take a snapshot of device data \nwithout interrupting normal device operation. However, SAMPLE/PRELOAD  instruction \nmode is most often used to preload the te st data into the update registers before \nloading the EXTEST  instruction. \nDuring the capture phase, multiplexers preceding the capture registers select the \nactive device data signals and clocked data into the capture registers. The \nmultiplexers at the outputs of  the update registers also select active device data to \nprevent functional interruptions to the device. \nDuring the shift phase, the boundary-scan sh ift register is formed by clocking data \nthrough capture registers around the device periphery and then out of the TDO pin. \nNew test data can simultaneously be shifted into TDI and replace the contents of the \ncapture registers. During the update phase, data in the capture registers is transferred \nto the update registers.You can then use this data in EXTEST  instruction mode. For \nmore information, refer to “EXTEST Instruction Mode” on page 8–10 .\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–9\nIEEE Std. 1149.1 BST Operation Control\nDecember 2010 Altera Corporation MAX V Device HandbookFigure 8–8  shows the capture, shift,  and update phases of SAMPLE/PRELOAD  mode.\nSAMPLE/PRELOAD  instruction code shifts in through the TDI pin. The TAP controller \nadvances to the CAPTURE _DR state and then to the SHIFT _DR state, where it remains if \nTMS is held low. The data shifted out of the TDO pin consists of the data that was \npresent in the capture registers after the capt ure phase. New test data shifted into the \nTDI pin appears at the TDO pin after being clocked through the entire boundary-scan \nregister. Figure 8–8. IEEE Std. 1149.1 BST SAMPLE/PRELOAD Mode\nMODE HIGHZPIN_IN\nPIN_OE\nPIN_OUT\nPin\nOutput\nBufferINJ\nOEJ\nOUTJSDO\nUPDATE CLOCK SHIFT\nSDIDQ\nInput0\n1\nDQ\nOEDQ\nOE0\n1\nDQ\nOutputDQ\nOutput0\n1\n0\n10\n1\nCapt ure\nRegi stersUpdate\nRegi stersGlobal Sig nals0\n1\nMODE HIGHZPIN_IN\nPIN_OE\nPIN_OUT\nPin\nOutput\nBufferINJ\nOEJ\nOUTJSDO\nUPDATE CLOCK SHIFT\nSDIDQ\nInput0\n1\nDQ\nOEDQ\nOE0\n1\nDQ\nOutputDQ\nOutput0\n1\n0101\nCapt ure\nRegi stersUpdate\nRegi stersGlobal Sig nals0\n1(Cap ture Phase)\n(Shif t and Upda te Phase)\n8–10 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 BST Operation Control\nMAX V Device Handbook December 2010 Altera CorporationFigure 8–9  shows that the test data that shifted into TDI does not appear at the TDO pin \nuntil after the capture register data that is shifted out. If TMS is held high on two \nconsecutive TCK clock cycles, the TAP cont roller advances to the UPDATE _DR state for \nthe update phase. \nIf you enable the device output enable feature but the DEV_OE pin is not asserted \nduring boundary-scan testing, the output en able boundary-scan registers of the BSCs \ncapture data from the core of the device during SAMPLE/PRELOAD . These values are not \nhigh impedance, although th e I/O pins are tri-stated.\nFigure 8–9  shows the SAMPLE/PRELOAD  waveforms. \nEXTEST Instruction Mode\nUse EXTEST  instruction mode to check the extern al pin connections between devices. \nUnlike SAMPLE/PRELOAD  mode, EXTEST  allows test data to be forced onto the pin \nsignals. By forcing known logic high and low levels on output pins, you can detect \nopens and shorts at pins of any device in the scan chain. \nEXTEST  selects data differently than SAMPLE/PRELOAD . EXTEST  chooses data from the \nupdate registers as the source of the output and output enable signals. After the \nEXTEST  instruction code is entered, the multiplexers select the update register data; \nthus, you can force the data stored in these registers from a previous EXTEST  or \nSAMPLE/PRELOAD  test cycle onto the pin signals. In the capture phase, the results of this \ntest data are stored in the capture registers and then shifted out of TDO during the shift \nphase. You can store the new test data in  the update registers during the update \nphase.Figure 8–9. SAMPLE/PRELOAD Shift Data Register Waveforms\nData stored in\nboundary- scan\nregister is shifted\nout of TDO.UPDATE_IRSHIFT_DR\nSELECT_DR_SCAN\nCAPTURE_DREXIT1_IR EXIT1_DR\nUPDATE_DRTCK\nTMS\nTDI\nTDO\nTAP_STATE\nInstruction CodeSHIFT_IR\nAfter boundry-scan\nregister data ha s been\nshifted o ut, data\nentered into TDI will\nshift o ut of TDO.\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–11\nIEEE Std. 1149.1 BST Operation Control\nDecember 2010 Altera Corporation MAX V Device HandbookFigure 8–10  shows the capture, shift, and update phases of EXTEST  mode. \nFigure 8–10. IEEE Std. 1149.1 BST EXTEST Mode\nMODE HIGHZPIN_IN\nPIN_OE\nPIN_OUT\nPin\nOutput\nBufferINJ\nOEJ\nOUTJSDO\nUPDATE CLOCK SHIFT\nSDIDQ\nInput0\n1\nDQ\nOEDQ\nOE0\n1\nDQ\nOutputDQ\nOutput0\n1\n0\n10\n1\nCapt ure\nRegi stersUpdate\nRegi stersGlobal Sig nals0\n1\n(Cap ture Phase)\nMODE HIGHZPIN_IN\nPIN_OE\nPIN_OUT\nPin\nOutput\nBufferINJ\nOEJ\nOUTJSDO\nUPDATE CLOCK SHIFT\nSDIDQ\nInput0\n1\nDQ\nOEDQ\nOE0\n1\nDQ\nOutputDQ\nOutput0\n1\n0101\nCapt ure\nRegi stersUpdate\nRegi stersGlobal Sig nals0\n1\n(Shif t and Upda te Phase)\n8–12 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nIEEE Std. 1149.1 BST Operation Control\nMAX V Device Handbook December 2010 Altera CorporationFigure 8–11  resembles the SAMPLE/PRELOAD  waveform diagram, except that the \ninstruction code for EXTEST  is different. The data shifted out of TDO consists of the data \nthat was present in the capture registers afte r the capture phase. New test data shifted \ninto the TDI pin appears at the TDO pin after being clocked through the entire \nboundary-scan register.\nBYPASS Instruction Mode\nYou can activate BYPASS  instruction mode with an instruction code made up of only \nones. Figure 8–12  shows how scan data passes through a device after the TAP \ncontroller is in the SHIFT _DR state. In this state, data si gnals are clocked into the bypass \nregister from TDI on the rising edge of TCK and out of TDO on the falling edge of the \nsame clock pulse. \nIDCODE Instruction Mode\nUse IDCODE  instruction mode to identify the de vices in an IEEE Std. 1149.1 chain. \nWhen you select IDCODE , the device identification register loads with the 32-bit \nvendor-defined identification code. The devi ce ID register is connected between the \nTDI and TDO ports and the device IDCODE  is shifted out. \nfIDCODE  instruction mode for MAX V devices are listed in the JTAG and In-System \nProgrammability in MAX V Devices  chapter. Figure 8–11. EXTEST Shift Data Register Waveforms\nData stored in\nboundary- scan\nregister is shifted\nout of TDO.UPDATE_IRSHIFT_DR\nSELECT_DR_SCAN\nCAPTURE_DREXIT1_IR EXIT1_DR\nUPDATE_DRTCK\nTMS\nTDI\nTDO\nTAP_STATE\nInstruction CodeSHIFT_IR\nAfter boundry-scan\nregister data ha s been\nshifted o ut, data\nentered into TDI will\nshift o ut of TDO.\nFigure 8–12. BYPASS Shift Data Register Waveforms\nData shifted i nto TDI o n\nthe rising edge of TCK i s\nshifted o ut of TDO o n the\nfalling edge of the same\nTCK p ulse.UPDATE_IRSELECT_DR_SCAN\nCAPTURE_DREXIT1_IR EXIT1_DR\nUPDATE_DRSHIFT_DR\nInstruction CodeTCK\nTMS\nTDI\nTDO\nTAP_STATESHIFT_IRBit 2 Bit 3\nBit 1 Bit 2 Bit nBit 1\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–13\nI/O Voltage Support in the JTAG Chain\nDecember 2010 Altera Corporation MAX V Device HandbookUSERCODE Instruction Mode\nUse USERCODE  instruction mode to examine the user electronic signature (UES) within \nthe devices along an IEEE Std. 1149.1 chain.  When you select this instruction, the \ndevice identificati on register is connected between the TDI and TDO ports. The user-\ndefined UES shifts into the device ID register in parallel from the 32-bit USERCODE  \nregister. The UES then shifts out th rough the device ID register. The USERCODE  \ninformation is only available after the device is successfully configured.\nNon-volatile USERCODE  data is written to the config uration flash memory (CFM) block \nand then written to the SRAM at power up. The USERCODE  instruction reads the data \nvalues from the SRAM. When you use real-time ISP to update the CFM block and \nwrite new USERCODE  data, executing the USERCODE  instruction returns the USERCODE  of \nthe current running design (stored in the SRAM), not the new USERCODE  data. The \nUSERCODE  of the new design (stored in the CFM) can only be read back correctly if a \npower cycle or forced SRAM download has transpired afte r the real-time ISP update. \nIn the Quartus®II software, there is an Auto Usercode feature where you can choose \nto use the checksum value of a programming file as the JTAG user code. If selected, \nthe checksum is automatically loaded to the USERCODE  register. \nTo enable the Auto Usercode feature, follow these steps:\n1. On the Assignments menu, click Device . \n2. In the Device dialog box, click Device and Pin Options  and click the General tab.\n3. Turn on Auto Usercode .\nCLAMP Instruction Mode\nUse CLAMP  instruction mode to allow the state of the signals driven from the pins to be \ndetermined from the boundary-scan register while the bypass register is selected as \nthe serial path between the TDI and Tmv51008.fmDO  ports. Data held in the boundary-\nscan register completely defines the state of  all signals driven from the output pins. \nHowever, CLAMP  instruction mode will not override the I/O weak pull-up resistor or \nthe I/O bus hold if you have any of them selected.\nHIGHZ Instruction Mode\nUse HIGHZ  instruction mode to set all of the user  I/O pins to an inactive drive state. \nThese pins are tri-stated until you execute a new JTAG instruction. When you select \nthis instruction, the bypass register is connected between the TDI and TDO ports. HIGHZ  \ninstruction mode will not override the I/O weak pull-up resistor or I/O bus hold if \nyou have any of them selected.\nI/O Voltage Support in the JTAG Chain\nThere can be several different Altera or non- Altera devices in a JTAG chain. However, \nyou must pay attention to whether or not the chain contains devices with different \nVCCIO levels. The TDO pin of a device drives out at the voltage level according to the \nVCCIO of the device. For MAX V devices, the TDO pin drives out at the voltage level \naccording to the V CCIO of I/O Bank 1. Although the devices may have different V CCIO \n8–14 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nBoundary-Scan Test for Programmed Devices\nMAX V Device Handbook December 2010 Altera Corporationlevels, the devices can interface with each other. For example, a device with 3.3-V \nVCCIO can drive to a device with 5.0-V V CCIO because 3.3 V meets the minimum V IH on \ntransistor-to-transistor logic (TTL)-level input for the 5.0-V V CCIO device. JTAG pins \non MAX V devices can support 1.5-, 1.8-, 2.5-, or 3.3-V input levels, depending on the V\nCCIO voltage of I/O Bank 1. \nf For more information about MultiVolt I/O support, refer to the MAX V Device \nArchitecture  chapter.\nYou can interface the TDI and TDO lines of the JTAG pins of devices that have different \nVCCIO levels by inserting a level shifter betw een the devices. If possible, the JTAG \nchain must be built such that  a device with a higher V CCIO level drives to a device with \nan equal or lower V CCIO level. By building the JTAG chain in this manner, a level \nshifter may be required only to shift the TDO level to a level acceptable to the JTAG \ntester. \nFigure 8–13  shows the JTAG chain of mixed voltages and how a level shifter is \ninserted in the chain.\nBoundary-Scan Test for Programmed Devices\nFor a programmed device, the input buffers ar e turned off by default for I/O pins that \nare set as output only in the design file . You cannot sample on the programmed device \noutput pins with the default boundary-sca n description language (BSDL) file when \nthe input buffers are turned off. \nFor boundary-scan testing, you can set the Quartus II software to always enable the \ninput buffers on a programmed device so it behaves the same as an unprogrammed device, allowing sample function on output pins in the design. This aspect can cause \nslight increase in standby current as the unused input buffer is always on. \nTo enable the unused input buffers on a programmed device, follow these steps:\n1. On the Assignments menu, click Settings.\n2. Under Category , select  Assembler .\n3. Turn on Always Enable Input Buffers .Figure 8–13. JTAG Chain of Mixed Voltages\n2.5-V\nVCCIO\n1.8-V\nVCCIO1.8-V\nVCCIOTDI\nTDOTester\nShift TDO to Level\nAccepted by Te ster\nif Nece ssaryMust be 5.0-V\nTolerantMust be 3.3-V\nTolerant\nMust be 2.5-V\nTolerant1.5-V\nVCCIO\nMust be 1.8-V\nTolerantLevel\nShifter3.3-V\nVCCIO5.0-V\nVCCIO\nChapter 8: JTAG Boundary-Scan Testing in MAX V Devices 8–15\nDisabling IEEE Std. 1149.1 BST Circuitry\nDecember 2010 Altera Corporation MAX V Device HandbookDisabling IEEE Std. 1149.1 BST Circuitry\nYou can enable the IEEE Std. 1149.1 BST circuitry for MAX V devices after device \npowers up. You must enable this circuitry on ly if you use the BST or ISP features. This \nsection describes how to disable the IEEE St d. 1149.1 circuitry to ensure that the \ncircuitry is not inadvertently enabled when it is not required.\nTable 8–3  lists the pin connections necessary for disabling JTAG in MAX V devices \nthat have dedicated IEEE Std. 1149.1 pins. \nGuidelines for IEEE Std.  1149.1 Boundary-Scan Testing\nWhen performing boundary-scan testing with IEEE Std. 1149.1 devices, use the \nfollowing guidelines: \n■If a pattern (for example, a 10-bit 1010101010  pattern) does not shift out of the \ninstruction register through the TDO pin during the first clock cycle of the SHIFT _IR \nstate, the proper TAP controller state has not been reached. To solve this problem, \ntry one of the following procedures: \n■Verify that the TAP controller has reached the SHIFT _IR state correctly. To \nadvance the TAP controller to the SHIFT _IR state, return to the RESET  state and \nclock the code 01100  on the TMS pin.\n■Check the connections to the VCC, GND, and JTAG pins on the device.\n■Perform a SAMPLE/PRELOAD  test cycle before the first EXTEST  test cycle to ensure that \nknown data is present at the device pins when EXTEST  mode is entered. If the OEJ \nupdate register contains a 0, the data in the OUTJ  update register will be driven out. \nThe state must be known and correct to av oid contention with other devices in the \nsystem. \n■Do not perform EXTEST  and SAMPLE/PRELOAD  tests during ISP. These instructions \nare supported before and after ISP but not during ISP.\n1 If problems persist, contact Technical Support .\nBoundary-Scan Description Language Support\nThe BSDL—a subset of VHDL—provides a syntax that allows you to describe the \nfeatures of an IEEE Std. 1149.1 BST-capable device that can be tested. Test software \ndevelopment systems then use the BSDL files for test generation, analysis, failure \ndiagnostics, and in-system programming. Table 8–3. Disabling IEEE Std. 1149.1 Circuitry for MAX V Devices\nJTAG Pins (1)\nTMS TCK TDI TDO\nVCC (2) GND (3) VCC (2) Leave Open\nNotes to Table 8–3 :\n(1) There is no software option to disable JTAG in MAX V devices . The JTAG pins are dedicated.\n(2)VCC refers to V CCIO of Bank 1.\n(3) The TCK signal may also be tied high. If TCK is tied high, power-up conditions must ensure that TMS is pulled high \nbefore TCK. Pulling TCK low avoids this power-up condition.\n8–16 Chapter 8: JTAG Boundary-Scan Testing in MAX V Devices\nDocument Revision History\nMAX V Device Handbook December 2010 Altera Corporationf For more information, or to receive BSDL  files for IEEE Std. 1149.1-compliant MAX V \ndevices, refer to the IEEE 1149.1 BSDL Files  page on the Altera website.\nDocument Revision History\nTable 8–4  shows the revision history for this chapter.\nTable 8–4. Document Revision History\nDate Version Changes\nDecember 2010 1.0 Initial release.\nJune 2017 Altera Corporation MAX V Device HandbookAdditional Information\nThis chapter provides additional info rmation about the document and Altera.\nDocument Revision History\nThe following table shows the revision history for this document.\nHow to Contact Altera\nTo locate the most up-to-date information about Altera® products, refer to the \nfollowing table.\nTypographic Conventions\nThe following table shows the typographic conventions this document uses.Date Version Changes\nJanuary 2011 1.1Updated MAX V Device Family Overview, DC and Switching Characteristics for \nMAX V Devices, and User Flash Memory in MAX V Devices chapters.\nDecember 2010 1.0 Initial release.\nContact (1) Contact Method Address\nTechnical support Website www.altera.com/support\nTechnical trainingWebsite www.altera.com/training\nEmail custrain@altera.com\nProduct literature Website www.altera.com/literature\nNon-technical support (General) Email nacomp@altera.com\n(Software Licensing) Email authorization@altera.com\nNote to Table:\n(1) You can also contact your  local Altera sales office  or sales representative. \nVisual Cue Meaning\nBold Type with Initial Capital \nLettersIndicate command names, dialog box titles, dialog box options, and other GUI \nlabels. For example, Save As  dialog box. For GUI elements, capitalization matches \nthe GUI.\nbold typeIndicates directory names, project names, disk drive names, file names, file name \nextensions, software utility names, and GUI labels. For example, \\qdesigns  \ndirectory, D: drive, and chiptrip.gdf  file.\nItalic Type with Initial Capital Letters Indicate document titles. For example, Stratix IV Design Guidelines .\nitalic typeIndicates variables. For example, n + 1.\nVariable names are enclosed in angle brackets (< >). For example, <file name>  and \n<project name> .pof file. \nInfo–2 Additional Information\nTypographic Conventions\nMAX V Device Handbook June 2017 Altera CorporationInitial Capital LettersIndicate keyboard keys and menu names. For example, the Delete key and the \nOptions menu. \n“Subheading Title”Quotation marks indicate references to sections within a document and titles of \nQuartus II Help topics. For example, “Typographic Conventions.”\nCourier typeIndicates signal, port, register, bit, block, and primitive names. For example, data1 , \ntdi, and input . The suffix n denotes an active-low signal. For example, resetn .\nIndicates command line commands and anything that must be typed exactly as it \nappears. For example, c:\\qdesigns\\tutorial\\chiptrip.gdf . \nAlso indicates sections of an actual file, such as a Report File, references to parts of \nfiles (for example, the AHDL keyword SUBDESIGN ), and logic function names (for \nexample, TRI). \nr An angled arrow instructs you to press the Enter key.\n1., 2., 3., and\na., b., c., and so onNumbered steps indicate a list of items when the sequence of the items is important, \nsuch as the steps listed in a procedure. \n■■■ Bullets indicate a list of items when the sequence of the items is not important. \n1 The hand points to information that requires special attention. \n? A question mark directs you to a software help system with related information. \nf The feet direct you to another document or website with related information. \ncA caution calls attention to a condition or possible situation that can damage or \ndestroy the product or your work.\nw A warning calls attention to a condition or possible situation that can cause you \ninjury.\nThe envelope links to the Email Subscription Management Center  page of the Altera \nwebsite, where you can sign up to receive update notifications for Altera documents.Visual Cue Meaning\n\n'}]
!==============================================================================!
### Component Summary: MAX V Device (5M160ZE64I5N)

**Key Characteristics and Specifications:**

- **Voltage Ratings:**
  - Core Voltage (VCCINT): 1.8 V
  - I/O Voltage (VCCIO): Supports 1.2 V, 1.5 V, 1.8 V, 2.5 V, and 3.3 V

- **Current Ratings:**
  - Maximum output current per pin: 25 mA
  - Standby current: As low as 25 µA

- **Power Consumption:**
  - Total power consumption is significantly lower than other CPLDs, with specific values depending on the operating conditions and configuration.

- **Operating Temperature Range:**
  - Commercial: 0 °C to 85 °C
  - Industrial: -40 °C to 100 °C
  - Automotive: -40 °C to 125 °C

- **Package Type:**
  - Available in various packages including FineLine BGA (FBGA), Micro FineLine BGA (MBGA), and Thin Quad Flat Pack (TQFP).

- **Special Features:**
  - Non-volatile flash memory for configuration storage.
  - Integrated oscillator.
  - MultiVolt I/O interface for compatibility with various voltage levels.
  - Hot-socketing capability.
  - JTAG boundary-scan support for testing and programming.

- **Moisture Sensitive Level (MSL):**
  - MSL is typically classified according to JEDEC J-STD-020E standards, specific to the package type.

**Description:**
The MAX V device (5M160ZE64I5N) is a low-cost, low-power Complex Programmable Logic Device (CPLD) from Altera (now part of Intel). It features a programmable architecture that allows for a wide range of digital logic applications. The device includes a flash memory block for non-volatile storage, enabling quick configuration and reconfiguration of logic functions. The MAX V family is designed to provide high performance with low power consumption, making it suitable for battery-operated and portable applications.

**Typical Applications:**
- **I/O Expansion:** The device can be used to increase the number of I/O pins available in a system.
- **Bus and Protocol Bridging:** It can facilitate communication between different protocols and bus systems.
- **Power Monitoring and Control:** The MAX V device can be employed in systems that require monitoring of power levels and control of power distribution.
- **FPGA Configuration:** It can be used to configure FPGAs in a system.
- **Analog IC Interface:** The device can interface with analog components, providing digital control and monitoring capabilities.

This summary encapsulates the essential specifications and functionalities of the MAX V device, highlighting its versatility and application in various electronic systems.