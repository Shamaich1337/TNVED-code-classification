[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of S25FL512SAGMFMR10 production of CYPRESS SEMICONDUCTORS from the text:Datasheet Please read the Important Notice and Warnings at the end of this document 001-98284 Rev. *S\nwww.infineon.com page 1 of 161  2022-04-11 \nS25FL512S\n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nFeatures\n• CMOS 3.0 V Core with versatile I/O\n•S P I  w i t h  M u l t i - I / O\n•D e n s i t y\n- 512 Mb (64 MB)\n•S P I\n- SPI Clock polarity and phase modes 0 and 3\n- DDR option\n- Extended Addressing: 32-bit address- Serial Command set and footprint compatible with \nS25FL-A, S25FL-K, and S25FL-P SPI families\n- Multi I/O Command set and fo otprint compatible with the\nS25FL-P SPI family\n•R E A D  C o m m a n d s\n- Normal, Fast, Dual, Quad, Fast DDR, Dual DDR, Quad DDR\n- AutoBoot - power up or reset and execute a Normal or Quad read command automatically at a preselected \naddress\n- Common Flash Interface (CFI) data  for configuration information.\n• Programming (1.5 MBps)\n- 512-byte Page Programming buffer\n- Quad-Input Page Programming (QPP) for slow clock systems\n- Automatic ECC -internal hardware Error Correction Code generation with single bit error correction\n• Erase (0.5 to 0.65 MBps)\n- Uniform 256-KB sectors\n•C y c l i n g  E n d u r a n c e\n- 100,000 Program-Erase Cycles, minimum\n•D a t a  R e t e n t i o n\n- 20-Year Data Retention, minimum\n• Security Features\n- OTP array of 1024 bytes-B l o c k  P r o t e c t i o n :\n• Status Register bits to control protection against program or erase of a contiguous range of sectors.\n• Hardware and software control options\n- Advanced Sector Protection (ASP)\n• Individual sector protection controlled by boot code or password\n•I n f i n e o n\n® 65 nm MirrorBit™ Technology with Eclipse™ Architecture\n• Core supply voltage: 2.7 V to 3.6 V\n• I/O supply voltage: 1.65 V to 3.6 V \n- SO16 and FBGA packages\n• Temperature range:\n- Industrial (–40 °C to +85 °C)\nDatasheet 2 of 161 001-98284 Rev. *S\n2022-04-11 \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nFeatures\n- Industrial Plus (–40 °C to +105 °C)\n- Automotive, AEC-Q100 Grade 3 (–40 °C to +85 °C)- Automotive, AEC-Q100 Grade 2 (–40 °C to +105 °C)\n- Automotive, AEC-Q100 Grade 1 (–40 °C to +125 °C)\n• Packages (all Pb-free)\n- 16-pin SOIC (300 mil)\n- 24-BGA (6 × 8 mm)\n• 5 × 5 ball (FAB024) and 4 × 6 ball (FAC024) footprint options \n- Known Good Die and Known Tested Die\nDatasheet 3 of 161 001-98284 Rev. *S\n2022-04-11 \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nLogic block diagram\nLogic block diagram\nPerformance summary\nMaximum read rates with the same core and I/O voltage (VIO = VCC = 2.7 V to 3.6 V)\nCommandClock rate \n(MHz)MBps\nRead 50 6.25\nFast Read 133 16.6Dual Read 104 26Quad Read 104 52\nMaximum read rates with lower I/O voltage (V\nIO = 1.65 V to 2.7 V, VCC = 2.7 V to 3.6 V)\nCommandClock rate \n(MHz)MBps\nRead 50 6.25\nFast Read 66 8.25Dual Read 66 16.5Quad Read 66 33\nMaximum read rates DDR (V\nIO = VCC = 3 V to 3.6 V)\nCommandClock rate \n(MHz)MBps\nFast Read DDR 80 20\nDual Read DDR 80 40\nQuad Read DDR 80 80\nTypical program and erase rates\nOperation KBps\nPage Programming (512-byte page buffer - Uniform Sector Option) 1500256-KB Logical Sector Erase (Uniform Sector Option) 500SRAM\nMirrorBit Array\nControl \nLogic\nData PathX DecodersCS#\nSCK\nSI/IO0\nSO/IO1\nHOLD#/IO3WP#/IO2\nRESET#I/OY Decoders\nData Latch\nDatasheet 4 of 161 001-98284 Rev. *S\n2022-04-11 \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPerformance summary\nCurrent consumption\nOperation Clock rate (MHz)\nSerial Read 50 MHz 16 (max)Serial Read 133 MHz 33 (max)Quad Read 104 MHz 61 (max)Program 100 (max)\nErase 100 (max)\nStandby 0.07 (typ)\nDatasheet 5 of 161 001-98284 Rev. *S\n2022-04-11 \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTable of contents\nTable of contents\nFeatures ....................................................................................................................... ....................1\nLogic block diagram ............................................................................................................ ..............3\nPerformance summary ............................................................................................................ ..........3\nTable of contents .............................................................................................................. .................5\n1 Overview ..................................................................................................................... ..................7\n1.1 General description ........................................................................................................ ........................................7\n1.2 Migration notes ............................................................................................................ ...........................................8\n1.3 Glossary ................................................................................................................... ..............................................10\nHardware interface............................................................................................................. .............11\n2 Signal descriptions .......................................................................................................... .............12\n2.1 Input/Output summary ....................................................................................................... .................................12\n2.2 Address and data configuration............................................................................................. ..............................12\n2.3 RESET#..................................................................................................................... ..............................................13\n2.4 Serial clock (SCK) ......................................................................................................... .........................................13\n2.5 Chip select (CS#) .......................................................................................................... .........................................13\n2.6 Serial input (SI) / I/O0 ................................................................................................... ........................................13\n2.7 Serial output (SO) / I/O1 .................................................................................................. .....................................14\n2.8 Write protect (WP#) / I/O2................................................................................................. ....................................14\n2.9 Hold (HOLD#) / I/O3 ........................................................................................................ ......................................14\n2.10 Core voltage supply (VCC) .............................................................................................................................. .....15\n2.11 Versatile I/O power supply (VIO) .........................................................................................................................15\n2.12 Supply and signal ground (VSS) ..........................................................................................................................15\n2.13 Not connected (NC) ........................................................................................................ ....................................15\n2.14 Reserved for future use (RFU)............................................................................................. ................................15\n2.15 Do not use (DNU).......................................................................................................... .......................................15\n2.16 Block diagrams ............................................................................................................ .......................................16\n3 Signal protocols............................................................................................................. ...............17\n3.1 SPI clock modes ............................................................................................................ ........................................17\n3.2 Command protocol........................................................................................................... ....................................18\n3.3 Interface states ........................................................................................................... ..........................................23\n3.4 Configuration register effects on the interface ...... ...................................................................... .......................28\n3.5 Data protection ............................................................................................................ .........................................28\n4 Electrical specifications.................................................................................................... .............30\n4.1 Absolute maximum ratings ................................................................................................... ...............................30\n4.2 Thermal resistance ......................................................................................................... ......................................30\n4.3 Operating ranges ........................................................................................................... .......................................30\n4.4 Power-up and Power-down .................................................................................................... .............................32\n4.5 DC characteristics ......................................................................................................... ........................................34\n5 Timing specifications ........................................................................................................ ............36\n5.1 Key to switching waveforms................................................................................................. ................................36\n5.2 AC test conditions ......................................................................................................... ........................................36\n5.3 Reset ...................................................................................................................... ................................................37\n5.4 SDR AC characteristics..................................................................................................... .....................................40\n5.5 DDR AC characteristics ..................................................................................................... ....................................44\n6 Physical interface ........................................................................................................... ..............46\n6.1 SOIC 16-lead package ....................................................................................................... ....................................46\n6.2 FAB024 24-ball BGA package............................................................................................................................... ................................. 48\n6.3 FAC024 24-ball BGA package............................................................................................................................... ................................. 50\nSoftware interface............................................................................................................. ..............52\n7 Address space maps ........................................................................................................... ...........53\n7.1 Overview................................................................................................................... .............................................53\nDatasheet 6 of 161 001-98284 Rev. *S\n2022-04-11 \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTable of contents\n7.2 Flash memory array ......................................................................................................... .....................................53\n7.3 ID-CFI address space....................................................................................................... ......................................53\n7.4 JEDEC JESD216 serial flash discoverable parameters (SFDP) space. ..... ............... ............... ............ ............ .....54\n7.5 OTP address space.......................................................................................................... ......................................54\n7.6 Registers .................................................................................................................. ..............................................55\n8 Data protection .............................................................................................................. ..............66\n8.1 Secure silicon region (OTP) ................................................................................................ ..................................66\n8.2 Write enable command ....................................................................................................... .................................66\n8.3 Block protection ........................................................................................................... ........................................67\n8.4 Advanced sector protection ................................................................................................. ................................68\n9 Commands ..................................................................................................................... ..............72\n9.1 Command set summary ........................................................................................................ ...............................73\n9.2 Identification commands .................................................................................................... .................................79\n9.3 Register access commands ................................................................................................... ...............................81\n9.4 Read memory array commands................................................................................................. ..........................90\n9.5 Program flash array commands............................................................................................... ..........................106\n9.6 Erase flash array commands ................................................................................................. .............................109\n9.7 One time program array commands............................................................................................ ......................113\n9.8 Advanced sector protection commands ........................................................................................ ...................114\n9.9 Reset commands ............................................................................................................. ...................................119\n9.10 Embedded algorithm performance tables ..................................................................................... .................120\n10 Data integrity .............................................................................................................. ............. 121\n10.1 Erase endurance ........................................................................................................... ....................................121\n10.2 Data retention ............................................................................................................ .......................................121\n11 Software interface reference ................................................................................................ ..... 122\n11.1 Command summary ........................................................................................................... ..............................122\n11.2 Serial flash discoverable parameters (SFDP) address map ................................................................... .........124\n11.3 Device ID and common flash interface (ID-CFI) addres s map ................................................................. .......128\n11.4 Device ID and common flash interface (ID-CFI) ASO map — Automotive only ..............................................149\n11.5 Registers ................................................................................................................. ...........................................149\n11.6 Initial delivery state .................................................................................................... ......................................154\n12 Ordering information ........................................................................................................ ........ 155\n12.1 Valid combinations — Standard............................................................................................. ..........................156\n12.2 Valid combinations — Automotive Grade / AEC-Q100 .......................................................................... ..........156\nRevision history ............................................................................................................... ............. 157\nDatasheet 7 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nOverview\n1O v e r v i e w\n1.1 General description\nThe Infineon S25FL512S device is a flash non-volatile memory product using: \n•M i r r o r B i t™ technology - that stores two data bits in each memory array transistor\n• Eclipse architecture - that dramatically improves program and erase performance\n• 65 nm process lithography\nThis device connects to a host system via an SPI. Tradit ional SPI single bit serial input and output (Single I/O or \nSIO) is supported as well as optional two bit (Dual I/O or  DIO) and four bit (Quad I/O or QIO) serial commands. \nThis multiple width interface is called  SPI Multi-I/O or MIO. In addition, the FL-S family adds support for Double \nData Rate (DDR) read commands for SIO, DIO, and QIO that transfer address and read data on both edges of the clock.\nThe Eclipse architecture features a Page Programming Bu ffer that allows up to 256 words (512 bytes) to be \nprogrammed in one operation, resulting in faster effe ctive programming and erase than prior generation SPI \nprogram or erase algorithms. \nExecuting code directly from flash memory is often called Execute-In-Place or XIP . By using FL-S devices at the \nhigher clock rates supported, with QIO or DDR-QIO commands, the instruction read transfer rate can match or exceed traditional parallel interfac e, asynchronous, NOR flash memories while reducing signal count dramati-\ncally.\nThe S25FL512S product offers high densities coupled with  the flexibility and fast performance required by a \nvariety of embedded applications. It is idea l for code shadowing, XIP , and data storage.\nDatasheet 8 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nOverview\n1.2 Migration notes\n1.2.1 Features comparison\nThe S25FL512S device is command set and footprint compat ible with prior generation FL-K and FL-P families.\nTable 1 FL generations comparison\nParameter FL-K FL-P FL-S \nTechnology Node 90 nm 90 nm 65 nm Architecture Floating Gate MirrorBit MirrorBit Eclipse Release Date In Production In Production In ProductionDensity 4 Mb–128 Mb 32 Mb–256 Mb 512 MbBus Width x1, x2, x4 x1, x2, x4 x1, x2, x4 Supply Voltage 2.7 V–3.6 V 2.7 V–3.6 V 2.7 V–3.6 V / 1.65 V–3.6 V V\nIO \nNormal Read Speed (SDR) 6 MBps (50 MH z) 5 MBps (40 MHz) 6 MBps (50 MHz) \nFast Read Speed (SDR) 13 MBps (104 MH z) 13 MBps (104 MHz) 17 MBps (133 MHz) \nDual Read Speed (SDR) 26 MBps (104 MH z) 20 MBps (80 MHz) 26 MBps (104 MHz) \nQuad Read Speed (SDR) 52 MBps (104 MH z) 40 MBps (80 MHz) 52 MBps (104 MHz) \nFast Read Speed (DDR) – – 20 MBps (80 MHz) Dual Read Speed (DDR) – – 40 MBps (80 MHz) Quad Read Speed (DDR) – – 80 MBps (80 MHz) Program Buffer Size 256B 256B 512BErase Sector Size 4 KB / 32 KB / 64 KB 64 KB / 256 KB 256 KBParameter Sector Size 4 KB 4 KB –Sector Erase Time (typ.) 30 ms (4 KB), 150 ms (64 \nkB)500 ms (64 kB) 520 ms (256 kB) \nPage Programming Time \n(typ.)700 µs (256B) 1500 µs (256B) 340 µs (512B) \nOTP 768B (3 x 256B) 506B 1024B \nAdvanced Sector \nProtection No No Yes\nAuto Boot Mode No No Yes\nErase Suspend/Resume Yes No YesProgram \nSuspend/ResumeYes No Yes\nOperating Temperature –40 °C to +85 °C –40 °C to +85 °C / +105 °C –40 °C to +85 °C / +105 °C\nNotes\n1. 256B program page option only for 128-Mb and 256-Mb density FL-S devices.2. FL-P column indicates FL129P MIO SPI device (for 128-Mb density).3. 64 kB sector erase option only for 128- Mb/256-Mb density FL-P and FL-S devices.\n4. FL-K family devices can erase 4-kB sectors in groups of 32 kB or 64 kB.5. Refer to individual datasheets for further details.\nDatasheet 9 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nOverview\n1.2.2 Known differences from prior generations\n1.2.2.1 Error reporting\nPrior generation FL memories either do not have error st atus bits or do not set them if program or erase is \nattempted on a protected sector. The FL-S family does have error reporting status bits for program and erase operations. These can be set when there is an internal fail ure to program or erase or when there is an attempt to \nprogram or erase a protected sector. In either case the program or erase operation did not complete as requested by the command.\n1.2.2.2 Secure silicon region (OTP)\nThe size and format (address map) of the One Time Program area is different from prior generations. The method for protecting each portion of the OTP area is different. For additional details see “Secure silicon region (OTP)” \non page 66.\n1.2.2.3 Configuration register Freeze bit\nThe configuration register Freeze bit CR1[0], locks the stat e of the Block Protection bits  as in prior generations. \nIn the FL-S family it also locks the state of the config uration register TBPARM bit CR1[2], TBPROT bit CR1[5], and \nthe Secure Silicon Region (OTP) area. \n1.2.2.4 Sector erase commands\nThe command for erasing an 8-KB area (t wo 4-KB sectors) is not supported. \nThe command for erasing a 4-KB sector is not supported in the 512-Mb density FL-S device.\nThe erase command for 64-KB sectors is not s upported in the 512-Mb density FL-S device.\n1.2.2.5 Deep power-down\nThe Deep Power Down (DPD) function is not supported in FL-S family devices. \nThe legacy DPD (B9h) command code is instead used to en able legacy SPI memory controllers, that can issue the \nformer DPD command, to access a new bank address regi ster. The bank address register allows SPI memory \ncontrollers that do not support more than 24 bits of address, the ability to provide higher order address bits for commands, as needed to access the la rger address space of the 512-Mb density FL-S device. For additional infor-\nmation see “Extended address” on page 53.\n1.2.2.6 New features\nThe FL-S family introduces several new features to SPI category memories:\n• Extended address for access to higher memory density.\n• AutoBoot for simpler access to boot code following power up.\n• Enhanced High Performance read commands using mode bits to eliminate the overhead of SIO instructions \nwhen repeating the same type of read command.\n• Multiple options for initial read latency (number of dummy cycles) for faster initial a ccess time or higher clock \nrate read commands.\n• DDR read commands for SIO, DIO, and QIO.\n• Automatic ECC for enhanced data integrity.• Advanced Sector Protection for individually controlling the protection of each sector. This is very similar to the \nAdvanced Sector Protection feature found in several other Infineon parallel interface NOR memory families.\nDatasheet 10 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nOverview\n1.3 Glossary\nTable 2 Glossary\nItem Description\nCommandAll information transferred between th e host system and memory during one \nperiod while CS# is low. This includes  the instruction (sometimes called an \noperation code or opcode) and any required address, mode bits, latency cycles, or data.\nDDP\n(Dual Die Package)Two die stacked within the same package to increase the memory capacity of a \nsingle package. Often also referred to as a Multi-Chip Package (MCP).\nDDR\n(Double Data Rate)When input and output are latched on every edge of SCK.\nECCECC Unit = 16 byte aligned and length da ta groups in the main Flash array and \nOTP array, each of which has its own hidden ECC syndrome to enable error \ncorrection on each group.\nFlash The name for a type of Electrical Erase Programmable Read Only Memory \n(EEPROM) that erases large blocks of memory bits in parallel, making the erase \noperation much faster than early EEPROM.\nHigh  A signal voltage level ≥ V\nIH or a logic level representing a binary one (1).\nInstructionThe 8 bit code indicating the function to  be performed by a command (sometimes \ncalled an operation code or opcode). The instruction is always the first 8 bits transferred from host system to the memory in any command.\nLow A signal voltage level \n≤ VIL or a logic level representing a binary zero (0).\nLSb\n(Least Significant Bit)Generally the right most bit, with the lo west order of magnitude value, within a \ngroup of bits of a register or data value.\nMSb\n(Most Significant Bit)Generally the left most bit, with the hi ghest order of magnitude value, within a \ngroup of bits of a register or data value.\nLSB\n(Least Significant Byte)The right most byte, within a group of bytes.\nMSB\n(Most Significant Byte)The left most bit, within a group of bytes.\nNon-volatile No power is needed to maintain  data stored in the memory.\nOPN\n(Ordering Part Number)The alphanumeric string sp ecifying the memory device type, density, package, \nfactory non-volatile configuration, etc. used to select the desired device.\nPage 512 bytes aligned and length group of data.\nPCB Printed Circuit Board.\nRegister Bit References Are in the format: Register_name[bit_number] or Regis-\nter_name[bit_range_MSb: bit_range_LSb].\nSDR\n(Single Data Rate)When input is latched on the rising edge  and output on the falling edge of SCK.\nSector Erase unit size 256 KB.\nWriteAn operation that changes data within volatile or non-volatile registers bits or \nnon-volatile flash memory. When changing non-volatile data, an erase and repro-gramming of any unchanged non-volatile da ta is done, as part of the operation, \nsuch that the non-volatile data is modifi ed by the write operation, in the same \nway that volatile data is modified – as a single operation. The non-volatile data appears to the host system to be upda ted by the single write command, without \nthe need for separate commands for erase and reprogram of adjacent, but unaffected data.\nDatasheet 11 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nHardware interface\nHardware interface\nSerial peripheral interface with multiple input / output (SPI-MIO)\nMany memory devices connect to their host system with se parate parallel control, address, and data signals that \nrequire a large number of signal connections and larger package size. The large number of connections increase \npower consumption due to so many signals switching and the larger package increases cost. \nThe S25FL512S device reduces the number of signals for conn ection to the host system by serially transferring \nall control, address, and data information over 4 to 6 signals. This reduces the cost of the memory package, \nreduces signal switching power, and either reduces the ho st connection count or frees host connectors for use \nin providing other features.\nThe S25FL512S device uses the industry standard  single bit Serial Peripheral Interface (SPI) and also supports \noptional extension commands for two bi t (Dual) and four bit (Quad) wide se rial transfers. This multiple width \ninterface is called SPI Multi-I/O or SPI-MIO.\nDatasheet 12 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal descriptions\n2 Signal descriptions\n2.1 Input/Output summary\n2.2 Address and data configuration\nTraditional SPI single bit wide commands (Single or SIO) send information from the host to the memory only on \nthe SI signal. Data may be sent back to the host serially on the Serial Output (SO) signal.\nDual or Quad Output commands send information from the host to the memory only on the SI signal. Data will \nbe returned to the host as a sequence of bit pairs on IO0 and IO1 or four bit (nibble) groups on IO0, IO1, IO2, and IO3. \nDual or Quad Input/Output (I/O) comma nds send information from the host to the memory as bit pairs on IO0 \nand IO1 or four bit (nibble) groups on IO 0, IO1, IO2, and IO3. Data is returned  to the host similarly as bit pairs on \nIO0 and IO1 or four bit (nibble) gr oups on IO0, IO1, IO2, and IO3.Table 3 Signal list\nSignal name Type Description\nRESET# Input Hardware reset:  Low = device resets and returns to standby state, ready to \nreceive a command. The signal has an inte rnal pull-up resistor and may be left \nunconnected in the host system if not used.\nSCK Input Serial clock.\nCS# Input Chip select.\nSI / IO0 I/O Serial input  for single bit data commands or IO0 for Dual or Quad commands.\nSO / IO1 I/O Serial output  for single bit data commands. IO1 for Dual or Quad commands.\nWP# / IO2 I/O Write protect  when not in Quad mode. IO2 in Quad mode. The signal has an \ninternal pull-up resistor and may be left unconnected in the host system if not used for Quad commands.\nHOLD# / IO3 I/O Hold  (pause) serial transfer in single bit or Dual data commands. IO3 in Quad-I/O \nmode. The signal has an internal pull-up resistor and may be left unconnected in the host system if not used for Quad commands.\nV\nCC Supply Core power supply.\nVIO Supply Versatile I/O power supply.\nVSS Supply Ground.\nNC Unused Not connected.  No device internal signal is connected to the package connector \nnor is there any future plan to use the connector for a signal. The connection may \nsafely be used for routing space for a signal on a Printed Circuit Board (PCB). However, any signal connected to an NC must not have voltage levels higher than V\nIO. \nRFU Reserved Reserved for future use.  No device internal signal is currently connected to the \npackage connector but there is potential fu ture use of the connector for a signal. \nIt is recommended to not use RFU connector s for PCB routing channels so that the \nPCB may take advantage of future enhanced features in compatible footprint devices.\nDNU Reserved Do not use.  A device internal signal may be connected to the package connector. \nThe connection may be used by Infineon for test or other purposes and is not intended for connection to any host system signal. Any DNU signal related function will be inactive when the signal is at V\nIL. The signal has an internal \npull-down resistor and may be left unconnect ed in the host system or may be tied \nto VSS. Do not use these connections for PCB signal routing channels. Do not \nconnect any host system signal to this connection. \nDatasheet 13 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal descriptions\n2.3 RESET#\nThe RESET# input provides a hardware method of resett ing the device to standby state, ready for receiving a \ncommand. When RESET# is driven to logic low (VIL) for at least a period of tRP, the device:\n• terminates any operation in progress,• tristates all outputs,\n• resets the volatile bits in the Configuration Register,\n• resets the volatile bits in the Status Registers,• resets the Bank Address Register to zero,• loads the Program Buffer with all ones,\n• reloads all internal configuration information necessary to bring the device to standby mode,\n• and resets the internal Control Unit to standby state.\nRESET# causes the same initialization process as is performed when power comes up and requires t\nPU time.\nRESET# may be asserted low at any time. To ensure da ta integrity any operation that was interrupted by a \nhardware reset should be reinitiated once the device is ready to accept a command sequence.\nWhen RESET# is first asserted Low, the device draws ICC1 (50 MHz value) during tPU. If RESET# continues to be held \nat VSS the device draws CMOS standby current (ISB).\nRESET# has an internal pull-up resi stor and may be left unconnected in the host system if not used.\nThe RESET# input is not available on all packages options.  When not available the RESET# input of the device is \ntied to the inactive state, inside the package.\n2.4 Serial clock (SCK)\nThis input signal provides the synchr onization reference for the SPI interfac e. Instructions, addresses, or data \ninput are latched on the rising edge of the SCK signal. Da ta output changes after the falling edge of SCK, in SDR \ncommands, and after every edge in DDR commands.\n2.5 Chip select (CS#)\nThe chip select signal indicates when a command for the device is in process and the other signals are relevant \nfor the memory device. When the CS# signal is at the logi c high state, the device is not selected and all input \nsignals are ignored and all output signals are high im pedance. Unless an internal Program, Erase or Write \nRegisters (WRR) embedded operation is in progress, the device will be in the Standby Power mode. Driving the \nCS# input to logic low state enables the device, placing it in the Active Power mode. After Power-up, a falling edge \non CS# is required prior to the start of any command.\nCS# toggle with no CLK and Data is considered as non-va lid. The Flash should not be selected (CS# low with no \nCLK and Data) when it’s not being addressed. This is cons idered as a spec violation and can eventually cause the \ndevice to remain in busy state (SR1=0x03) af ter an embedded operation (program/erase/etc.)\n2.6 Serial input (SI) / I/O0\nThis input signal is used to transfer data serially into the device. It receives instructions, addresses, and data to \nbe programmed. Values are latched on the rising edge of serial SCK clock signal.\nSI becomes I/O0 - an input and output during Dual and Quad commands for receiving instructions, addresses, \nand data to be programmed (values latched on rising edge of serial SCK clock signal) as well as shifting out data (on the falling edge of SCK, in  SDR commands, and on every edge of SCK, in DDR commands).\nDatasheet 14 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal descriptions\n2.7 Serial output (SO) / I/O1\nThis output signal is used to transfer data serially out of  the device. Data is shifted out on the falling edge of the \nserial SCK clock signal.\nSO becomes IO1 - an input and output during Dual and Qu ad commands for receiving addresses, and data to be \nprogrammed (values latched on rising edge of serial SCK clock signal) as well as shifting out data (on the falling \nedge of SCK, in SDR commands, and on every edge of SCK, in DDR commands).\n2.8 Write protect (WP#) / I/O2\nWhen WP# is driven Low (VIL), during a WRR command and while the Stat us Register Write Disable (SRWD) bit of \nthe Status Register is set to a 1, it is not possible to wr ite to the Status and Configuration Registers. This prevents \nany alteration of the Block Protect (BP2, BP1, BP0) and TB PROT bits of the Status Register. As a consequence, all \nthe data bytes in the memory area that are protected by the Block Protect and TBPROT bits, are also hardware protected against data modification if WP# is Low during a WRR command.\nThe WP# function is not available when the Quad mode is  enabled (CR[1]=1). The WP# fu nction is replaced by IO2 \nfor input and output during Quad mode for receiving addresses, and data to be programmed (values are latched on rising edge of the SCK signal) as well as shifting out data (on the fallin g edge of SCK, in SDR commands, and \non every edge of SCK, in DDR commands).\nWP# has an internal pull-up resistor; when unconnected, WP# is at V\nIH and may be left unconnected in the host \nsystem if not used for Quad mode.\n2.9 Hold (HOLD#) / I/O3\nThe Hold (HOLD#) signal is used to  pause any serial communications with the device without deselecting the \ndevice or stopping the serial clock.\nTo enter the Hold condition, the device must be selected  by driving the CS# input to the logic low state. It is \nrecommended that the user keep the CS# input low state du ring the entire duration of the Hold condition. This \nis to ensure that the state of the interface logic re mains unchanged from the moment of entering the Hold \ncondition. If the CS# input is driven to the logic high stat e while the device is in the Hold condition, the interface \nlogic of the device will be reset. To restart communication with the device, it is necessary to drive HOLD# to the logic high state while driving the CS# signal into the logic low state. This prevents the device from going back into \nthe Hold condition.\nThe Hold condition starts on the falling  edge of the Hold (HOLD#) signal, pr ovided that this coincides with SCK \nbeing at the logic low state. If the fall ing edge does not coincide with the SCK signal being at the logic low state, \nthe Hold condition starts whenever th e SCK signal reaches the logic low state. Taking the HOLD# signal to the \nlogic low state does not terminate any Write, Progra m or Erase operation that is currently in progress.\nDuring the Hold condition, SO is  in high impedance and both the SI and SCK input are Don\'t Care.\nThe Hold condition ends on the rising edge of the Hold (HOLD#) signal, provid ed that this coincides with the SCK \nsignal being at the logic low state. If the rising edge do es not coincide with the SCK signal being at the logic low \nstate, the Hold condition ends whenever the SCK signal reaches the logic low state.\nThe HOLD# function is not available when the Quad mode is enabled (CR1[1] =1). The Hold function is replaced \nby I/O3 for input and output during Quad mode for rece iving addresses, and data to be programmed (values are \nlatched on rising edge of the SCK signal) as well as shifti ng out data (on the falling edge of SCK, in SDR commands, \nand on every edge of SCK, in DDR commands).\nThe HOLD# signal has an internal pull-up resistor and may be left unconnected in the host system if not used for \nQuad mode.\nDatasheet 15 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal descriptions\nFigure 1 HOLD mode operation\n2.10 Core voltage supply (VCC)\nVCC is the voltage source for all device internal logic. It is  the single voltage used for all device internal functions \nincluding read, program, and erase. The voltage may vary from 2.7V to 3.6V.\n2.11 Versatile I/O power supply (VIO)\nThe Versatile I/O (VIO) supply is the voltage source for all device input receivers and output drivers and allows the \nhost system to set the voltage levels that the device tolerates on all inputs and drives on outputs (address, control, and I/O signals). The V\nIO range is 1.65V to VCC. VIO cannot be greater than VCC.\nFor example, a VIO of 1.65 V - 3.6 V allows for I/O at the 1.8 V, 2.5 V or 3 V levels, driving and receiving signals to and \nfrom other 1.8 V, 2.5 V or 3 V devices on the same data bus. V\nIO may be tied to VCC so that interface signals operate at the same \nvoltage as the core of the device. VIO is not available in all package options, when not available the VIO supply is \ntied to VCC internal to the package.\nDuring the rise of power supplies the VIO supply voltage must remain less than or equal to the VCC supply voltage. \nThis supply is not available in all package options. For a backward compatible with the SO16 package, the VIO \nsupply is tied to VCC inside the package; thus, the I/O will function at VCC level.\n2.12 Supply and signal ground (VSS)\nVSS is the common voltage drain and ground reference for the device core, input signal receivers, and output \ndrivers.\n2.13 Not connected (NC)\nNo device internal signal is connected to the package co nnector nor is there any future plan to use the connector \nfor a signal. The connection may safely be used for routing space for a signal on a Printed Circuit Board (PCB). However, any signal connected to an NC mu st not have voltage levels higher than V\nIO. \n2.14 Reserved for future use (RFU)\nNo device internal signal is currently connected to the package connector but is there potential future use of the \nconnector. It is recommended to not use RFU connector s for PCB routing channels so that the PCB may take \nadvantage of future enhanced features in compatible footprint devices.\n2.15 Do not use (DNU)\nA device internal signal may be connected to the pack age connector. The connection may be used by Infineon \nfor test or other purposes and is not intended for connection to any host system signal. Any DNU signal related function will be inactive when the signal is at V\nIL. The signal has an internal pull- down resistor and may be left \nunconnected in the host system or may be tied to VSS. Do not use these connections for PCB signal routing \nchannels. Do not connect any host system signal to these connections. CS#\nSCK\nHOLD#\nSI_or_IO_(during_input)\nSO_or_IO_(internal)\nSO_or_IO_(external)Valid Input Don\'t Care Valid Input Don\'t Care Valid Input\nAB C D E\nAB B C D EHold Condition \nStandard UseHold Condition \nNon-standard Use\nDatasheet 16 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal descriptions\n2.16 Block diagrams\nFigure 2 Bus master and memory devices on the SPI bus — Single bit data path\nFigure 3 Bus master and memory device s on the SPI bus — Dual bit data path\nFigure 4 Bus master and memory devices on the SPI bus — Quad bit data pathSPI\nBus MasterHOLD#\nWP#\nSO\nSI\nSCK\nCS2#\nCS1#\nFL-S\nFlashFL-S\nFlashHOLD#\nWP#\nSOSI\nSCK\nCS2#\nCS1#\nSPI\nBus MasterHOLD#\nWP#\nIO1\nIO0\nSCK\nCS2#\nCS1#\nFL-S\nFlashFL-S\nFlashHOLD#\nWP#\nIO0IO1\nSCK\nCS2#\nCS1#\nSPI\nBus MasterIO3\nIO2\nIO1\nIO0\nSCK\nCS2#\nCS1#\nFL-S\nFlashFL-S\nFlashIO3\nIO2\nIO0IO1\nSCK\nCS2#\nCS1#\nDatasheet 17 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\n3 Signal protocols\n3.1 SPI clock modes\n3.1.1 Single data rate (SDR)\nThe S25FL512S device can be driven by an embedded microc ontroller (bus master) in ei ther of the two following \nclocking modes.\n•Mode 0  with Clock Polarity (CPOL) = 0 and, Clock Phase (CPHA) = 0\n•Mode 3  with CPOL = 1 and, CPHA = 1\nFor these two modes, input data into the device is always latched in on the rising edge of the SCK signal and the \noutput data is always available from the falling edge of the SCK clock signal.\nThe difference between the two modes is the clock polari ty when the bus master is in standby mode and not \ntransferring any data.\n• SCK will stay at logic low st ate with CPOL = 0, CPHA = 0\n• SCK will stay at logic high state with CPOL = 1, CPHA = 1\nFigure 5 SPI SDR modes supported\nTiming diagrams throughout the remainder of the docu ment are generally shown as both mode 0 and 3 by \nshowing SCK as both high and low at the fall of CS#. In  some cases a timing diagram may show only mode 0 with \nSCK low at the fall of CS#. In such a case, mode 3 timing simply means clock is high at the fall of CS# so no SCK \nrising edge set up or hold time to the falling edge of CS# is needed for mode 3.\nSCK cycles are measured (counted) from one falling edge of  SCK to the next falling edge of SCK. In mode 0 the \nbeginning of the first SCK cycle in a command is measured fr om the falling edge of CS# to the first falling edge of \nSCK because SCK is already low at the beginning of a command.\n3.1.2 Double data rate (DDR)\nMode 0 and Mode 3 are also supported for DDR commands.  In DDR commands, the instruction bits are always \nlatched on the rising edge of clock, the same as in SDR commands. However, the address and input data that \nfollow the instruction are latched on both the rising and fa lling edges of SCK. The first address bit is latched on \nthe first rising edge of SCK following the falling edge at th e end of the last instruction bit. The first bit of output \ndata is driven on the falling edge at the end of the last access latency (dummy) cycle.\nSCK cycles are measured (counted) in the same way as in SDR commands, from one falling edge of SCK to the \nnext falling edge of SCK. In mode 0 the beginning of the first SCK cycle in a command is measured from the falling \nedge of CS# to the first falling edge of SCK becaus e SCK is already low at the beginning of a command.CPOL=0_CPHA=0_SCK\nCPOL=1_CPHA=1_SCK\nCS#\nSI\nSOMSB\nMSB\nDatasheet 18 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nFigure 6 SPI DDR modes supported\n3.2 Command protocol\nAll communication between the host system and S25FL512S  memory device is in the form of units called \ncommands.\nAll commands begin with an instruction that selects the type of information transfer or device operation to be \nperformed. Commands may also have an address, instruct ion modifier, latency period, data transfer to the \nmemory, or data transfer from the memory. All instruction,  address, and data information is transferred serially \nbetween the host system and memory device.\nAll instructions are transferred from  host to memory as a single bit serial sequence on the SI signal.\nSingle bit wide commands may provide an address or data sent only on the SI signal. Data may be sent back to \nthe host serially on the SO signal.\nDual or Quad Output commands provide an address sent to the memory only on the SI signal. Data will be \nreturned to the host as a sequence of bit pairs on I/O0 and I/O1 or four bit (nibble) groups on I/O0, I/O1, I/O2, and I/O3. \nDual or Quad Input/Output (I/O) comma nds provide an address sent from the host as bit pairs on I/O0 and I/O1 \nor, four-bit (nibble) groups on I/O0, I/O1, I/O2, and I/O3. Data is returned to the host similarly as bit pairs on I/O0 and I/O1 or, four bit (nibble) groups on I/O0, I/O1, I/O2, and I/O3.\nCommands are structured as follows:\n• Each command begins with CS# going low and ends with CS# returning high. The memory device is selected by \nthe host driving the Chip Select (CS#) signal low throughout a command. \n• The serial clock (SCK) marks the transfer of each bit or group of bits between the host and memory.\n• Each command begins with an 8-bit (byte) instruction. Th e instruction is always presented only as a single bit \nserial sequence on the Serial Input (SI) signal with one bit transferred to the memory device on each SCK rising \nedge. The instruction selects the type of informatio n transfer or device operation to be performed.\n• The instruction may be stand alone or may be followed by address bits to select a location within one of several \naddress spaces in the device. The instruction determines  the address space used. Th e address may be either a \n24-bit or a 32-bit byte boundary, address. The address transfers occur on SCK rising edge, in SDR commands, \nor on every SCK edge, in DDR commands.\n• The width of all transfers following the instruction are determined by the instructio n sent. Following transfers \nmay continue to be single bit serial on only the SI or Serial Output (SO) signals, they may be done in 2-bit groups per (dual) transfer on the I/O0 and I/O1  signals, or they may be done in 4- bit groups per (quad) transfer on the \nI/O0-I/O3 signals. Within the dual or quad groups the le ast significant bit is on I/O0. More significant bits are \nplaced in significance order on each higher numbered I/O signal. Single bits or parallel bit groups are transferred \nin most to least significant bit order.\n• Some instructions send an instruction modifier called mode bits, following the address, to indicate that the \nnext command will be of the same type with an implied, rather than an explicit, instruction. The next command thus does not provide an instruction byte, only a new address and mode bits. This reduces the time needed to CPOL=0_CPHA=0_SCK\nCPOL=1_CPHA=1_SCK\nCS#\nTransfer_Phase\nSI\nSOInst. 7 Inst. 0 A31 A0\nDLP7D0 D1Dummy / DLP Address Mode Instruction\nA30 M7 M6 M0\nDLP0Read\nData\nDatasheet 19 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nsend each command when the same command type is repeated in a sequence of commands. The mode bit \ntransfers occur on SCK rising edge, in SDR comma nds, or on every SCK edge, in DDR commands.\n• The address or mode bits may be followed by write data to be stored in the memory device or by a read latency \nperiod before read data is returned to the host. \n• Write data bit transfers occur on SCK rising edge, in  SDR commands, or on every SCK edge, in DDR commands.\n• SCK continues to toggle during any read access latency period. The latency may be zero to several SCK cycles \n(also referred to as dummy cycles). At the end of the read latency cycles, the first read data bits are driven from the outputs on SCK falling edge at the end of the last read  latency cycle. The first read data bits are considered \ntransferred to the host on the following SCK rising edge. Each following transfer occurs on the next SCK rising \nedge, in SDR commands, or on every SCK edge, in DDR commands.\n• If the command returns read data to the host, the device  continues sending data transfers until the host takes \nthe CS# signal high. The CS# signal can be driven high after any transfer in the re ad data sequence. This will \nterminate the command.\n• At the end of a command that does not return data, the host drives the CS# input high. The CS# signal must go \nhigh after the eighth bit, of a stand alone instruction or, of  the last write data byte that is transferred. That is, \nthe CS# signal must be driven high wh en the number of clock cycles after CS # signal was driven low is an exact \nmultiple of eight cycles. If the CS# signal does not go high exactly at the eight SCK cycle boundary of the \ninstruction or write data, the command is rejected and not executed. \n• All instruction, address, and mode bits are shifted into th e device with the Most Significant Bits (MSb) first. The \ndata bits are shifted in and out of the device MSb first. All data is transferred in byte units with the lowest address byte sent first. Following bytes of data are sent in lo west to highest byte address order i.e. the byte address \nincrements.\n• All attempts to read the flash memory array during a pr ogram, erase, or a write cycle (embedded operations) \nare ignored. The embedded operation will continue to execute without any affect. A very limited set of \ncommands are accepted during an embedded operatio n. These are discussed in the individual command \ndescriptions.\n• Depending on the command, the time for execution vari es. A command to read status information from an \nexecuting command is available to determine when the command completes execution and whether the command was successful.\n3.2.1 Command sequence examples\nFigure 7 Stand alone instruction command\nFigure 8 Single bit wide input commandCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Data\nDatasheet 20 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nFigure 9 Single bit wide output command\nFigure 10 Single bit wide I/O command without latency\nFigure 11 Single bit wide I/O command with latency\nFigure 12 Dual output commandCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data 2\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n7654321076543210  \nInstruction Address Data 1 Data 2\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n76543210  \nInstruction Dummy Cycles Data 1 Address\nCS#\nSCK\nIO0\nIO1\nPhase765432103028260 64206420\n3129271 75317531\nInstruction 6 Dummy Data 1 Data 2 Address\nDatasheet 21 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nFigure 13 Quad output command without latency\nFigure 14 Dual I/O command\nFigure 15 Quad I/O command\nFigure 16 DDR fast read with EHPLC = 00bCS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                               \n7654321031 1040404040404\n51515151515\n62626262626\n73737373737\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nCS#\nSCK\nIO0\nIO1\nPhase \n                                                     \n7654321030  20 64206420  \n31  31 75317531  \nInstruction Address Dummy Data 1 Data 2\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                     \n7654321028  404 40404040  \n29  515 51515151  \n30  626 62626262  \n31  737 73737373  \nInstruction Address Mode Dummy D1 D2 D3 D4\nCS#\nSCK\nSI\nSO\nPhase \n                                               \n7 6 5 4 3 2 1 03130 076543210  \n7654321076543210\nInstruction Address Mode Dummy Data 1 Data 2\nDatasheet 22 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nFigure 17 DDR dual I/O read with EHPLC = 01b and DLP\nFigure 18 DDR quad I/O read\nAdditional sequence diagrams, specific  to each command, are provided in “Commands” on page 72.CS#\nSCK\nIO0\nIO1\nPhase \n                                        \n7 6 5 4 3 2 1 0 3028 06420 7  6 5  4 321  0 64206 \n3129 17531 7  6 5  4 321  0 75317 \nInstruction Mode Dum DLP Data 1 Address\nCS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                             \n76543210282420161284040 765432104040\n292521171395151 765432105151\n3026221814106262 765432106262\n3127231915117373 765432107373\nInstruction Address Dummy DLP D1D2 Mode\nDatasheet 23 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\n3.3 Interface states\nThis section describes the input and output signal  levels as related to the SPI interface behavior.\nTable 4 Interface states summary\nInterface state VCC VIO RESET# SCK CS#HOLD# \n/\nI/O3WP# / \nz\nI/O2SO / \nI/O1SI / \nI/O0\nPower-Off < VCC (low) ≤VCC XX X X X Z X\nLow Power \nHardware Data Protection<V\nCC (cut-off) ≤VCC XX X X X Z X\nPower-On (cold) \nReset ≥VCC (min) ≥VIO (min) \n≤VCCXX X X X Z X\nHardware (warm) \nReset≥VCC (min) ≥VIO (min) \n≤VCCHL X X X X Z X\nInterface Standby ≥VCC (min) ≥VIO (min) \n≤VCCHH X HH X X Z X\nInstruction Cycle ≥VCC (min) ≥VIO (min) \n≤VCCHH HT HL HH HV Z HV\nHold Cycle ≥VCC (min) ≥VIO (min) \n≤VCCHH HV or \nHTHL HL X X X\nSingle Input Cycle\nHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL HH X Z HV\nSingle Latency \n(Dummy) Cycle≥VCC (min) ≥VIO (min) \n≤VCCHH HT HL HH X Z X\nSingle Output Cycle\nMemory to Host Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL HH X MV X\nDual Input Cycle\nHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL HH X HV HV\nDual Latency \n(Dummy) Cycle≥VCC (min) ≥VIO (min) \n≤VCCHH HT HL HH X X X\nDual Output Cycle\nMemory to Host Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL HH X MV MV\nQPP Address Input \nCycleHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL X X X HV\nQuad Input Cycle\nHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL HV HV HV HV\nQuad Latency \n(Dummy) Cycle≥VCC (min) ≥VIO (min) \n≤VCCHH HT HL X X X X\nQuad Output Cycle\nMemory to Host Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL MV MV MV MV\nDatasheet 24 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nLegend:\nZ = no driver - floating signalHL = Host driving V\nIL\nHH = Host driving VIH\nHV = either HL or HHX = HL or HH or Z\nHT = Toggling between HL and HH\nML = Memory driving V\nIL\nMH = Memory driving VIH\nMV = either ML or MH\n3.3.1 Power-off\nWhen the core supply voltage is at or below the VCC (low) voltage, the device is considered to be powered off. The \ndevice does not react to external signals, and is prev ented from performing any program or erase operation. \n3.3.2 Low power hardware data protection\nWhen VCC is less than VCC (cut-off) the memory device will ignore commands to ensure that program and erase \noperations can not start when the core supp ly voltage is out of the operating range.DDR Single Input \nCycleHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL X X X HV\nDDR Dual Input Cycle\nHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL X X HV HV\nDDR Quad Input \nCycleHost to Memory Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL HV HV HV HV\nDDR Latency \n(Dummy) Cycle≥VCC (min) ≥VIO (min) \n≤VCCHH HT HL MV or Z MV or \nZMV or \nZMV or \nZ\nDDR Single Output \nCycleMemory to Host Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL Z Z MV X\nDDR Dual Output \nCycleMemory to Host Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL Z Z MV MV\nDDR Quad Output \nCycleMemory to Host Transfer≥V\nCC (min) ≥VIO (min) \n≤VCCHH HT HL MV MV MV MVTable 4 Interface states summary  (continued)\nInterface state VCC VIO RESET# SCK CS#HOLD# \n/\nI/O3WP# / \nz\nI/O2SO / \nI/O1SI / \nI/O0\nDatasheet 25 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\n3.3.3 Power-on (cold) reset\nWhen the core voltage supply remains at or below the VCC (low) voltage for ≥ tPD time, then rises to ≥ VCC (Minimum)  \nthe device will begin its Power-On Reset (POR) process. POR continues until the end of tPU. During tPU the device \ndoes not react to external input signals no r drive any outputs. Following the end of tPU the device transitions to \nthe Interface Standby state and can accept commands. For additional information on POR, see “Power-on (cold) \nreset” on page 37.\n3.3.4 Hardware (warm) reset\nSome of the device package options provide a RE SET# input. When RESET# is driven low for tRP time the device \nstarts the hardware reset process. The process continues for tRPH time. Following the end of both tRPH and the \nreset hold time following the rise of RESET# (tRH) the device transitions to the Interface Standby state and can \naccept commands. For additional information on hardware reset, see “POR followed by hardware reset” on \npage 38.\n3.3.5 Interface standby\nWhen CS# is high the SPI interface is in standby state. Inputs other than RESET# are ignored. The interface waits \nfor the beginning of a new command. The next interface st ate is Instruction Cycle when CS# goes low to begin a \nnew command. \nWhile in interface standby state the memory device draws standby current (ISB) if no embedded algorithm is in \nprogress. If an embedded algorithm is in progress, the related current is drawn until the end of the algorithm \nwhen the entire device retu rns to standby current draw.\n3.3.6 Instruction cycle\nWhen the host drives the MSb of an instruction and CS# goes low, on the next rising edge of SCK the device \ncaptures the MSb of the instruction that begins the ne w command. On each following rising edge of SCK the \ndevice captures the next lower significance bit of the 8 bit instruction. The host keeps RESET# high, CS# low, \nHOLD# high, and drives Write Protect (W P#) signal as needed for the instruct ion. However, WP# is only relevant \nduring instruction cycles of a WRR command and is otherwise ignored.\nEach instruction selects the address space that is operat ed on and the transfer form at used during the remainder \nof the command. The transfer format may be Single, Dual output, Quad output, Dual I/O, Quad I/O, DDR Single I/O, DDR Dual I/O, or DDR Quad I/O.  The expected next interface state depends on the instruction received.\nSome commands are stand alone, needing no address or da ta transfer to or from the memory. The host returns \nCS# high after the rising edge of SCK for the eighth bit of the instruction in such commands. The next interface \nstate in this case is Interface Standby.\n3.3.7 Hold\nWhen Quad mode is not enabled (CR[1] =0) the HOLD# / I/O3 signal is used as the HOLD# input.  The host keeps \nRESET# high, HOLD# low, SCK may be at a valid level or continue toggling, and CS# is low. When HOLD# is low a \ncommand is paused, as though SCK were held low. SI / I/O0 and SO / I/O1 ignore the input level when acting as inputs and are high impedance when acting as outputs du ring hold state. Whether these signals are input or \noutput depends on the command an d the point in the command sequen ce when HOLD# is asserted low.\nWhen HOLD# returns high the next state is the same stat e the interface was in just before HOLD# was asserted \nlow. \nWhen Quad mode is enabled the HOLD # / I/O3 signal is used as I/O3. \nDuring DDR commands the HOLD# and WP# inputs are ignored.\n3.3.8 Single input cycle - Host to memory transfer\nSeveral commands transfer information af ter the instruction on the single serial input (SI) signal from host to the \nmemory device. The dual output, and quad output comma nds send address to the memory using only SI but \nreturn read data using the I/O signals.  The host keeps RESET# high, CS# low, HOLD# high, and drives SI as needed \nfor the command. The memory does not dr ive the Serial Output (SO) signal.\nDatasheet 26 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\nThe expected next interface state depends on the instru ction. Some instructions continue sending address or \ndata to the memory using additional Single Input Cycles. Ot hers may transition to Single Latency, or directly to \nSingle, Dual, or Quad Output.\n3.3.9 Single latency (Dummy) cycle\nRead commands may have zero to several latency cycles during which read data is read from the main flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the Latency Code in \nthe configuration register (CR[7:6]). During the latency cycles, the host keeps RESET# high, CS# low, and HOLD# \nhigh. The Write Protect (WP#) signal is ignored. The host may drive the SI signal during these cycles or the host \nmay leave SI floating. The memory does not use any data driven on SI / I/O0 or other I/O signals during the latency \ncycles. In dual or quad read commands, the host must st op driving the I/O signals on the falling edge at the end \nof the last latency cycle. It is recommended that the host  stop driving I/O signals during latency cycles so that \nthere is sufficient time for the host dr ivers to turn off before the memory begi ns to drive at the end of the latency \ncycles. This prevents driver conflict between host and memory when the signal direction changes. The memory \ndoes not drive the Serial Output (SO) or I/O signals during the latency cycles.\nThe next interface state depends on the command structur e, that is the number of latency cycles, and whether \nthe read is single, dual, or quad width.\n3.3.10 Single output cycle - Memory to host transfer\nSeveral commands transfer information back to the host on  the single Serial Output (SO) signal. The host keeps \nRESET# high, CS# low, and HOLD# high. The Write Protect (WP#) signal is ignored. The memory ignores the Serial \nInput (SI) signal. The memory drives SO with data.\nThe next interface state continues to be Single Output  Cycle until the host returns CS# to high ending the \ncommand.\n3.3.11 Dual input cycle - Host to memory transfer\nThe Read Dual I/O command transfers two address or mode  bits to the memory in each cycle. The host keeps \nRESET# high, CS# low, HOLD# high. The Write Protect (WP#) signal is ignored. The host  drives address on SI / I/O0 \nand SO / I/O1. \nThe next interface state following the delivery of address an d mode bits is a Dual Latency Cycle if there are latency \ncycles needed or Dual Output Cy cle if no latency is required.\n3.3.12 Dual latency (Dummy) cycle\nRead commands may have zero to several latency cycles during which read data is read from the main flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the Latency Code in \nthe configuration register (CR[7:6]). During the latency cycles, the host keeps RESET# high, CS# low, and HOLD# \nhigh. The Write Protect (WP#) signal is ignored. The ho st may drive the SI / I/O0 and SO / I/O1 signals during these \ncycles or the host may leave SI / I/O0 and SO / I/O1 floating . The memory does not use any data driven on SI / I/O0 \nand SO / I/O1 during the latency cycles. The host must stop  driving SI / I/O0 and SO / I/O1 on the falling edge at \nthe end of the last latency cycle. It is recommended that the host stop driving them during all latency cycles so \nthat there is sufficient time for the host drivers to turn  off before the memory begins to drive at the end of the \nlatency cycles. This prevents driver conflict between ho st and memory when the signal direction changes. The \nmemory does not drive the SI / I/O0 and SO / I/O1 signals during the latency cycles.\nThe next interface state following the last latency cycle is a Dual Output Cycle.\n3.3.13 Dual output cycle - Memory to host transfer\nThe Read Dual Output and Read Dual I/O return data to the host two bits in each cycle. The host keeps RESET# \nhigh, CS# low, and HOLD# high. The Write Protect (WP#) sign al is ignored. The memory drives data on the SI / I/O0 \nand SO / I/O1 signals during the dual output cycles.\nThe next interface state continues to be Dual Output Cycle until the host returns CS# to high ending the \ncommand.\nDatasheet 27 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\n3.3.14 QPP or QOR address input cycle\nThe Quad Page Program and Quad Output Read commands send address to the memory only on I/O0. The other \nI/O signals are ignored because the device must be in Quad mode for these commands thus the Hold and Write \nProtect features are not active. The host k eeps RESET# high, CS# low, and drives I/O0.\nFor QPP the next interface state following the delivery of address is the Quad Input Cycle.\nFor QOR the next interface state following address is a Quad Latency Cycle if there are latency cycles needed or \nQuad Output Cycle if no latency is required.\n3.3.15 Quad input cycle - Host to memory transfer\nThe Quad I/O Read command transfers four address or mode  bits to the memory in each cycle. The Quad Page \nProgram command transfers four data bits to the memory in each cycle. The host keeps RESET# high, CS# low, \nand drives the I/O signals.\nFor Quad I/O Read the next interface state following the delivery of address and mode bits is a Quad Latency Cycle \nif there are latency cycles needed or Quad Output Cycle if  no latency is required. For Quad Page Program the host \nreturns CS# high following the delivery of data to be  programmed and the interface returns to standby state.\n3.3.16 Quad latency (Dummy) cycle\nRead commands may have zero to several latency cycles during which read data is read from the main flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the Latency Code in \nthe configuration register (CR[7:6]). During the latency cy cles, the host keeps RESET# high, CS# low. The host may \ndrive the I/O signals during th ese cycles or the host may leave the I/O fl oating. The memory does not use any data \ndriven on I/O during the latency cycles . The host must stop driving the I/O si gnals on the falling edge at the end \nof the last latency cycle. It is recommended that the host stop driving them during all latency cycles so that there is sufficient time for the host drivers to turn off before the memory begins to drive at the end of the latency cycles. \nThis prevents driver conflict between host and memory when the signal direction changes. The memory does not \ndrive the I/O signals during the latency cycles.\nThe next interface state following the last latency cycle is a Quad Output Cycle.\n3.3.17 Quad output cycle - Memory to host transfer\nThe Quad Output Read and Quad I/O Read return data to the host four bits in each cycle. The host keeps RESET# \nhigh, and CS# low. The memory drives data on I/ O0-I/O3 signals during the Quad output cycles.\nThe next interface state continues to be Quad Output Cycle until the host returns CS# to high ending the \ncommand.\n3.3.18 DDR single input cycle - Host to memory transfer\nThe DDR Fast Read command sends address, and mode bits  to the memory only on the I/O0 signal. One bit is \ntransferred on the rising edge of SCK and one bit on the falling edge in each cycle. The host keeps RESET# high, \nand CS# low. The other I/O signals are ignored by the memory.\nThe next interface state following the delivery of address and mode bits is a DDR Latency Cycle.\n3.3.19 DDR dual input cycle - Host to memory transfer\nThe DDR Dual I/O Read command sends ad dress, and mode bits to the memory only on the I/O0 and I/O1 signals. \nTwo bits are transferred on the rising edge of SCK and two bits on the falling edge in each cycle. The host keeps \nRESET# high, and CS# low. The I/O2 and I/O3 signals are ignored by the memory.\nThe next interface state following the delivery of address and mode bits is a DDR Latency Cycle.\nDatasheet 28 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\n3.3.20 DDR quad input cycle - Host to memory transfer\nThe DDR Quad I/O Read command sends ad dress, and mode bits to the memory on all the I/O signals. Four bits \nare transferred on the rising edge of SCK and four bits on  the falling edge in each cycle. The host keeps RESET# \nhigh, and CS# low.\nThe next interface state following the delivery of address and mode bits is a DDR Latency Cycle.\n3.3.21 DDR latency cycle\nDDR Read commands may have one to several latency cycles during which read data is read from the main flash \nmemory array before transfer to the host. The number of  latency cycles are determined by the Latency Code in \nthe configuration register (CR[7:6]). During the latency cy cles, the host keeps RESET# high and CS# low. The host \nmay not drive the I/O signals during thes e cycles. So that there is sufficient time for the host drivers to turn off \nbefore the memory begins to drive. This prevents driv er conflict between host and memory when the signal \ndirection changes. The memory has an op tion to drive all the I/O signals with a Data Learning Pattern (DLP) during \nthe last 4 latency cycles. The DLP option should not be en abled when there are fewer than five latency cycles so \nthat there is at least one cycle of high impedance for tu rn around of the I/O signals before the memory begins \ndriving the DLP . When there are more than 4 cycles of la tency the memory does not drive the I/O signals until the \nlast four cycles of latency.\nThe next interface state following the last latency cycle is a DDR Single, Dual, or Quad Output Cycle, depending \non the instruction.\n3.3.22 DDR single output cycle - Memory to host transfer\nThe DDR Fast Read command returns bits to the host only on the SO / I/O1 signal. On e bit is transferred on the \nrising edge of SCK and one bit on the falling edge in ea ch cycle. The host keeps RESET# high, and CS# low. The \nother I/O signals are not driven by the memory.\nThe next interface state continues to be DDR Single Outp ut Cycle until the host returns CS# to high ending the \ncommand.\n3.3.23 DDR dual output cycle - Memory to host transfer\nThe DDR Dual I/O Read command returns bits to the host only on the I/O0 and I/O1 signals. Two bits are trans-\nferred on the rising edge of SCK and two bits on the falli ng edge in each cycle. The host keeps RESET# high, and \nCS# low. The I/O2 and I/O3 signals are not driven by the memory.\nThe next interface state continues to be DDR Dual Output Cycle until the host returns CS# to high ending the \ncommand.\n3.3.24 DDR quad output cycle - Memory to host transfer\nThe DDR Quad I/O Read command returns bits to the host on  all the I/O signals. Four bits are transferred on the \nrising edge of SCK and four bits on  the falling edge in each cycle. Th e host keeps RESET# high, and CS# low.\nThe next interface state continues to be DDR Quad Output  Cycle until the host returns CS# to high ending the \ncommand.\n3.4 Configuration register effects on the interface\nThe configuration register bits 7 and 6 (CR1[7:6]) select the latency code for all read commands. The latency code \nselects the number of mode bit and latency cycles for each type of instruction.\nThe configuration register bit 1 (CR1[1]) selects whethe r Quad mode is enabled to ignore HOLD# and WP# and \nallow Quad Page Program, Quad Output Read, and Quad I/O Read commands. Quad mode must also be selected to allow Read DDR Quad I/O commands.\n3.5 Data protection\nSome basic protection against unintended changes to st ored data are provided and controlled purely by the \nhardware design. These are described below. Other software managed protection methods are discussed in the software section ( page 52 ) of this document.\nDatasheet 29 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSignal protocols\n3.5.1 Power-up\nWhen the core supply voltage is at or below the VCC (low) voltage, the device is considered to be powered off. The \ndevice does not react to external signals, and is prev ented from performing any program or erase operation. \nProgram and erase operations continue to be prevented during the Power-on Reset (POR) because no command is accepted until the exit from POR to the Interface Standby state.\n3.5.2 Low power\nWhen VCC is less than VCC (cut-off) the memory device will ignore commands to ensure that program and erase \noperations can not start when the core supp ly voltage is out of the operating range.\n3.5.3 Clock pulse count\nThe device verifies that all program, erase, and Write Registers (WRR) commands consist of a clock pulse count \nthat is a multiple of eight before executing them. A command not having a multiple of 8 clock pulse counts is ignored and no error status is set for the command. \nDatasheet 30 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nElectrical specifications\n4 Electrical specifications\n4.1 Absolute maximum ratings\n4.2 Thermal resistance\n4.3 Operating ranges\nOperating ranges define those limits between whic h the functionality of the device is guaranteed.\n4.3.1 Power supply voltages\nSome package options provide access to a separate  input and output buffer power supply called VIO. Packages \nwhich do not provide the separate VIO connection, internally connect the device VIO to VCC. For these packages, \nthe references to VIO are then also references to VCC.Table 5 Absolute maximum ratings\nStorage Temperature Plastic Packages –65°C to +150°C\nAmbient Temperature with Power Applied –65°C to +125°C\nVCC –0.5 V to +4.0 V\nVIO[6]–0.5 V to +4.0 V\nInput Voltage with Respect to Ground (VSS)[7]–0.5 V to +(VIO + 0.5 V)\nOutput Short Circuit Current[8]100 mA\nTable 6 Thermal resistance\nParameter Description Test condition SL3016 FAB024 FAC024 Unit\nTheta JA Thermal resistance \n(junction to ambient)Test conditions follow \nstandard test methods \nand procedures for \nmeasuring thermal \nimpedance in accor-\ndance with \nEIA/JESD51. with Still \nAir (0 m/s).29.6 33.6 33.6 °C/W\nTheta JB Thermal resistance \n(Junction to board)7.9 17.6 17.6 °C/W\nTheta JC Thermal resistance \n(Junction to case)8.8 11 8.3 °C/W\nVCC 2.7V to 3.6V\nVIO 1.65V to VCC +200 mV\nNotes\n6. VIO must always be less than or equal VCC + 200 mV.\n7. See “Input signal overshoot” on page 31 for allowed maximums during signal transition. \n8. No more than one output may be shorted to ground at  a time. Duration of the short circuit should not be \ngreater than one second.\n9. Stresses above those listed under Table 4  may cause permanent damage to the device. This is a stress rating \nonly; functional operation of the device at these or any other conditions above those indicated in the opera-\ntional sections of this data sheet is not implied. Exposu re of the device to absolute maximum rating conditions \nfor extended periods may affect device reliability.\nDatasheet 31 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nElectrical specifications\n4.3.2 Temperature ranges\n4.3.3 Input signal overshoot\nDuring DC conditions, input or I/O signal s should remain equal to or between VSS and VIO. During voltage transi-\ntions, inputs or I/Os may overshoot VSS to –2.0V or overshoot to VIO +2.0V, for periods up to 20 ns.\nFigure 19 Maximum negative overshoot waveform\nFigure 20 Maximum positive overshoot waveformTable 7 Temperature ranges\nParameter Symbol DeviceSpecUnitMin Max\nAmbient Temperature TAIndustrial (I) –40 +85\n°CIndustrial Plus (V) –40 +105\nAutomotive, AEC-Q100 Grade 3 (A) –40 +85\nAutomotive, AEC-Q100 Grade 2 (B) –40 +105\nAutomotive, AEC-Q100 Grade 1 (M) –40 +125\nVIL\n- 2.0V\n20 ns20 ns 20 ns\nVIHVIO + 2.0V\n20 ns 20 ns20 ns\nNote\n10.Industrial Plus operating and performance parameters will be determined by device characterization and \nmay vary from standard industrial temperature range devices as currently shown in this specification.\nDatasheet 32 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nElectrical specifications\n4.4 Power-up and Power-down\nThe device must not be selected at power-up or power-down (that is, CS# must follow the voltage applied on VCC) \nuntil VCC reaches the correct value as follows:\n•VCC (min) at power-up, and then for a further delay of tPU\n•VSS at power-down\nA simple pull-up resistor (generally of the order of 100 k Ω) on Chip Select (CS#) can usua lly be used to insure safe \nand proper power-up and power-down.\nThe device ignores all instructions until a time delay of tPU has elapsed after the moment that VCC rises above the \nminimum VCC threshold. See Figure 21 . However, correct operation of th e device is not guaranteed if VCC returns \nbelow VCC (min) during tPU. No command should be sent to the device until the end of tPU.\nAfter power-up (tPU), the device is in Standby mode (not Deep Power Down mode), draws CMOS standby current \n(ISB), and the WEL bit is reset.\nDuring power-down or voltage drops below VCC (cut-off), the voltage must drop below VCC (low) for a period of \ntPD for the part to initialize correctly on power-up. See Figure 22 . If during a voltage drop the VCC stays above VCC \n(cut-off) the part will stay initia lized and will work correctly when VCC is again above VCC (min). In the event \nPower-on Reset (POR) did not complete correctly after powe r up, the assertion of the RESET# signal will restart \nthe POR process.\nNormal precautions must be taken for supply rail decoupling to stabilize the VCC supply at the device. Each device \nin a system should have the VCC rail decoupled by a suitable capacitor close to the package supply connection \n(this capacitor is generally of the order of 0.1 µf).\nTable 8 Power-up / Power-down voltage and timing\nFigure 21 Power-upSymbol Parameter Min Max Unit\nVCC (min) VCC (minimum operation voltage) 2.7  – V \nVCC (cut-off) VCC (Cut 0ff where re-initialization is needed) 2.4 – V \nVCC (low) VCC (low voltage for initialization to occur) \nVCC (Low voltage for initialization to occur at embedded) 1.6 \n2.3  –V  \ntPU VCC (min) to Read operation  – 300 µs \ntPD VCC (low) time 10.0 – µs \n(max)\n(min)VCC\ntPU Full Device Access\nTimeVCCVCC\nDatasheet 33 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nElectrical specifications\nFigure 22 Power-down and voltage droptPD(max)\n(min)VCC\ntPU Device Access\n     Allowed\nTimeVCCVCC\nNo Device Access Allowed\n(cut-off)VCC\n(low)VCC\nDatasheet 34 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nElectrical specifications\n4.5 DC characteristics\nApplicable within operating ranges.\nTable 9 DC characteristics\nSymbol Parameter Test conditions Min Typ[11] Max Unit\nVIL Input Low Voltage  -0.5  – 0.2 x VIO V\nVIH Input High Voltage  0.7 x VIO – VIO+0.4 V\nVOL Output Low \nVoltage IOL = 1.6 mA, VCC = VCC min  – 0.15 x VIO V\nVOH Output High \nVoltage IOH = –0.1 mA 0.85 x VIO –  V\nILI Input Leakage \nCurrent VCC = VCC Max, VIN = VIH or VIL – – ±2 µA \nILO Output Leakage \nCurrent VCC = VCC Max, VIN = VIH or VIL – – ±2 µA \nICC1 Active Power \nSupply Current (READ) Serial SDR@50 MHz\nSerial SDR@133 MHz Quad SDR @ 80 MHz Quad SDR @104 MHz Quad DDR @ 66 MHz Quad DDR @80 MHz Outputs unconnected during read data return\n[12] – – 1 6\n33/35[13]\n50 61 75 90mA \nI\nCC2 Active Power \nSupply Current (Page Program) CS# = V\nIO – – 100 mA \nICC3 Active Power \nSupply Current (WRR) CS# = V\nIO – – 100 mA \nICC4 Active Power \nSupply Current (SE) CS# = V\nIO – – 100 mA \nICC5 Active Power \nSupply Current (BE) CS# = V\nIO – – 100 mA \nISB (Industrial) Standby Current RESET#, CS# = VIO; SI, SCK = VIO or \nVSS, Industrial Temp– 70 100 µA\nISB \n(Industrial \nPlus)Standby Current RESET#, CS# = VIO; SI, SCK = VIO or \nVSS, Industrial Plus Temp– 70 300 µA\nNotes\n11.Typical values are at TAI = 25°C and VCC = VIO = 3V.\n12.Output switching current is not included.13.Industrial temperature range / Industrial Plus temperature range.\nDatasheet 35 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nElectrical specifications\n4.5.1 Active power and standby power modes\nThe device is enabled and in the Active Power mode when Chip Select (CS#) is Low. When CS# is high, the device \nis disabled, but may still be in an Active Power mode  until all program, erase, and write operations have \ncompleted. The device then goes into the Standby Power mode, and power consumption drops to ISB.\nDatasheet 36 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5 Timing specifications\n5.1 Key to switching waveforms\nFigure 23 Waveform element meanings\nFigure 24 Input, output, and timing reference levels\n5.2 AC test conditions\nFigure 25 Test setupInput\nSymbol\nOutputValid at logic high or low High Impedance Any change permitted Logic High Logic Low\nChanging, state unknown Valid at logic high or low High Impedance Logic High Logic Low\nVIO + 0.4V\n0.7 x VIO\n0.2 x VIO\n- 0.5VTiming Reference Level0.5 x VIO 0.85 x VIO\n0.15 x VIOInput LevelsOutput Levels\nDevice \nUnder \nTest\nCL\nDatasheet 37 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5.2.1 Capacitance characteristics\n5.3 Reset\n5.3.1 Power-on (cold) reset\nThe device executes a Power-On Reset (POR) process until a time delay of tPU has elapsed after the moment that \nVCC rises above the minimum VCC threshold. See Figure 21 , Table 7 , and Table 11 . The device must not be \nselected (CS# to go high with VIO) during power-up (tPU), i.e. no commands may be sent to the device until the \nend of tPU. RESET# is ignored during POR. If RESET# is low during POR and remains low through and beyond the \nend of tPU, CS# must remain high until tRH after RESET# returns high. RESET# must return high for greater than \ntRS before returning low to initiate a hardware reset.\nFigure 26 Reset low at the end of PORTable 10 AC measurement conditions\nSymbol Parameter Min Max Unit\nCLLoad Capacitance 30\n15[17]pF\nInput Rise and Fall \nTimes– 2.4 ns\nInput Pulse Voltage 0.2 x VIO to 0.8 VIO V\nInput Timing Ref \nVoltage0.5 VIO V\nOutput Timing Ref \nVoltage0.5 VIO V\nTable 11 Capacitance\nParameter Test conditions Min Max Unit\nCIN Input Capacitance (applies to SCK, CS#, RESET#) 1 MHz, TA = 25°C – 8 pF \nCOUT Output Capacitance (applies to All I/O) 1 MHz, TA = 25°C – 8 pF\nNotes\n14.Output High-Z is defined as the po int where data is no longer driven.\n15.Input slew rate: 1.5 V/ns.16.AC characteristics tables assume clock and da ta signals have the same slew rate (slope).\n17.DDR Operation.18.For more information on capacitance, please consult the IBIS models.VCC\nVIO\nRESET#\nCS#If RESET# is low at tPU end\nCS# must be high at tPU endtPU\ntRH\nDatasheet 38 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\nFigure 27 Reset high at the end of POR\nFigure 28 POR followed by hardware reset\n5.3.2 Hardware (warm) reset\nWhen the RESET# input transitions from VIH to VIL the device will reset register states in the same manner as \npower-on reset but, does not go through the full reset process that is performed during POR. The hardware reset process requires a period of t\nRPH to complete. If the POR process did not complete correctly for any reason during \npower-up (tPU), RESET# going low will initiate the full POR proc ess instead of the hardware reset process and will \nrequire tPU to complete the POR process.\nThe RESET# input provides a hardware method of re setting the flash memory device to standby state.\n•R E S E T #  m u s t  b e  h i g h  f o r  tRS following tPU or tRPH, before going low again to initiate a hardware reset.\n• When RESET# is driven low for at least a minimum period of time (tRP), the device terminates any operation in \nprogress, tri-states all outputs, and ignores all read/write commands for the duration of tRPH. The device resets \nthe interface to standby state.\n• If CS# is low at the time RESET# is asserted, CS# must return high during tRPH before it can be asserted low again \nafter tRH.\n• Hardware Reset is only offered in 16-lead SOIC and BGA packages.\nFigure 29 Hardware resetVCC\nVIO\nRESET#\nCS#If RESET# is high at tPU end\nCS# may stay high or go low at tPU endtPU\ntPU\nVCC\nVIO\nRESET#\nCS#tRS tPU\ntPU\nRESET#\nCS#Any prior reset\ntRStRP\ntRH tRH\ntRPH tRPH\nDatasheet 39 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\nTable 12 Hardware reset parameters\nParameter Description Limit Time Unit\ntRS Reset Setup - Prior Reset end and RESET# high before RESET# \nlowMin 50 ns\ntRPH Reset Pulse Hold - RESET# low to CS# low Min 35 µs\ntRP RESET# Pulse Width Min 200 ns \ntRH Reset Hold - RESET# high before CS# low Min 50 ns \nNotes\n19.RESET# Low is optional and ignored during Power-up (tPU). If Reset# is asserted during the end of tPU, the \ndevice will remain in the reset state and tRH will determine when CS# may go Low.\n20.Sum of tRP and tRH must be equal to or greater than tRPH.\nDatasheet 40 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5.4 SDR AC characteristics\nTable 13 AC characteristics (Single die package, VIO = VCC 2.7V to 3.6V)\nSymbol Parameter Min Typ Max Unit\nFSCK, R  SCK Clock Frequency for READ and 4READ instruc-\ntions DC – 50 MHz\nFSCK, C  SCK Clock Frequency for single commands as \nshown in Table 40[24]DC – 133 MHz\nFSCK, C  SCK Clock Frequency for the following dual and \nquad commands: DOR, 4DOR, QOR, 4QOR, DIOR, \n4DIOR, QIOR, 4QIORDC – 104 MHz\nFSCK, QPP  SCK Clock Frequency for the QPP , 4QPP commands DC – 80 MHz\nPSCK SCK Clock Period 1/ FSCK – ∞  \ntWH, tCH Clock High Time[25]45% PSCK – – ns \ntWL, tCL Clock Low Time[25]45% PSCK – – ns \ntCRT, tCLCH  Clock Rise Time (slew rate) 0.1 – – V/ns\ntCFT, tCHCL Clock Fall Time (slew rate) 0.1 – – V/ns\ntCS CS# High Time (Read Instructions) \nCS# High Time (Program/Erase) 10 \n50 – – ns \ntCSS CS# Active Setup Time (relative to SCK) 3 – – ns \ntCSH CS# Active Hold Time (relative to SCK) 3 – – ns \ntSU Data in Setup Time 1.5 –  3000[26]ns \ntHD Data in Hold Time 2 –  ns \ntV Clock Low to Output Valid – – 8.0[22] \n7.65[23] \n6.5[24] ns \ntHO Output Hold Time 2 –  ns \ntDIS Output Disable Time 0 – 8 ns \n tWPS  WP# Setup Time 20[21] – – ns \n tWPH  WP# Hold Time 100[21] – – ns \ntHLCH  HOLD# Active Setup Time (relative to SCK) 3 – – ns \ntCHHH  HOLD# Active Hold Time (relative to SCK) 3 – – ns \ntHHCH  HOLD# Non Active Setup Time (relative to SCK) 3 – – ns \ntCHHL  HOLD# Non Active Hold Time (relative to SCK) 3 – – ns \ntHZ HOLD# enable to Output Invalid – – 8 ns \ntLZ HOLD# disable to Output Valid – – 8 ns \nNotes\n21.Only applicable as a constraint for W RR instruction when SRWD is set to a 1.\n22.Full VCC range (2.7 - 3.6V) and CL = 30 pF.\n23.Regulated VCC range (3.0 - 3.6V) and CL = 30 pF.\n24.Regulated VCC range (3.0 - 3.6V) and CL = 15 pF.\n25.±10% duty cycle is supported for frequencies ≤ 50 MHz.\n26.Maximum value only appl ies during Program/Erase Suspend/Resume commands.\nDatasheet 41 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5.4.1 Clock timing\nFigure 30 Clock timingTable 14 AC characteristics (Single die package, VIO 1.65V to 2.7V, VCC 2.7V to 3.6V)\nSymbol Parameter Min Typ Max Unit\nFSCK, R  SCK Clock Frequency for READ, 4READ instructions DC – 50 MHz\nFSCK, C  SCK Clock Frequency for all others[29]DC – 66 MHz\nPSCK SCK Clock Period 1/ FSCK – ∞  \ntWH, tCH Clock High Time[30]45% PSCK – – ns \ntWL, tCL Clock Low Time[30]45% PSCK – – ns \ntCRT, tCLCH  Clock Rise Time (slew rate) 0.1 – – V/ns\ntCFT, tCHCL Clock Fall Time (slew rate) 0.1 – – V/ns\ntCS CS# High Time (Read Instructions) \nCS# High Time (Program/Erase) 10 \n50 – – ns \ntCSS CS# Active Setup Time (relative to SCK) 10 – – ns \ntCSH CS# Active Hold Time (relative to SCK) 3 – – ns \ntSU Data in Setup Time 5 – 3000[31]ns \ntHD Data in Hold Time 4 –  ns \ntV Clock Low to Output Valid – – 14.5[28] \n12.0[29]ns \ntHO Output Hold Time 2 – ns \ntDIS Output Disable Time 0 – 14 ns \n tWPS  WP# Setup Time 20[27] – – ns \n tWPH  WP# Hold Time 100[27] – – ns \ntHLCH  HOLD# Active Setup Time (r elative to SCK) 5 – – ns \ntCHHH  HOLD# Active Hold Time (relative to SCK) 5 – – ns \ntHHCH  HOLD# Non Active Setup Time (relative to SCK) 5 – – ns \ntCHHL  HOLD# Non Active Hold Time (relative to SCK) 5 – – ns \ntHZ HOLD# enable to Output Invalid – – 14 ns \ntLZ HOLD# disable to Output Valid – – 14 ns \nVIH mintCH\ntCLPSCK\nNotes\n27.Only applicable as a constraint for WRR instruction when SRWD is set to a 1.28.CL = 30 pF.29.CL = 15 pF.30.±10% duty cycle is s upported for frequencies \n≤ 50 MHz\n31.Maximum value only applies during Program/Erase Suspend/Resume commands.\nDatasheet 42 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5.4.2 Input / Output timing\nFigure 31 SPI single bit input timing\nFigure 32 SPI single bit output timing\nFigure 33 SPI SDR MIO timingCS#\nSCK\nSI\nSOMSB IN LSB INtCSS tCSStCSH tCSHtCS\ntSU\ntHD\nCS#\nSCK\nSI\nSO MSB OUT LSB OUTtCS\ntHO tV tDIS tLZ\nCS#\nSCK\nIO MSB IN LSB IN MSB OUT . LSB OUTtCSH\ntCSStCSS\ntSU\ntHD tLZ tHOtCS\ntDIS tV\nDatasheet 43 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\nFigure 34 Hold timing\nFigure 35 WP# input timingCS#\nSCK\nHOLD#\nSI_or_IO_(during_input)\nSO_or_IO_(during_output) A B B C D EtHZ tHZ tLZ tLZtCHHL tCHHLtHLCHtHLCH tCHHH\ntCHHH tHHCH\nHold Condition \nStandard UseHold Condition \nNon-standard Use\nCS#\nWP#\nSCK\nSI\nSO\nPhase7654321076543210\nWRR Instruction Input DatatWPS tWPH\nDatasheet 44 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5.5 DDR AC characteristics\n5.5.1 DDR input timing\nFigure 36 SPI DDR input timingTable 15 AC characteristics DDR operation\nSym-\nbol Parameter 66 MHz 80 MHzUnit Min Typ Max Min Typ Max \nFSCK, R  SCK Clock Frequency for DDR \nREAD instruction DC – 66 DC – 80 MHz\nPSCK, R  SCK Clock Period for DDR READ \ninstruction 15 – ∞ 12.5 – ∞ ns \ntWH, \ntCH Clock High Time 45% \nPSCK– – 45% PSCK – – ns \ntWL, tCLClock Low Time 45% \nPSCK– – 45% PSCK – – ns \ntCS CS# High Time (Read Instructions) 10 – – 10 – – ns \ntCSS CS# Active Setup Time (relative to \nSCK) 3 – – 3 – – ns \ntCSH CS# Active Hold Time (relative to \nSCK) 3 – – 3 – – ns \ntSU I/O in Setup Time 2 –  \n3000[33]1.5 –  \n3000[33\n]ns \ntHD I/O in Hold Time 2 –  1.5 –  ns \ntV Clock Low to Output Valid –  6.5[32]–  6.5[32] ns \ntHO Output Hold Time 1.5 –  1.5 –  ns \ntDIS Output Disable Time  – 8  – 8 ns \ntLZ Clock to Output Low Impedance 0 – 8 0 – 8 ns \ntIO_SKE\nW First Output to last Output data \nvalid time – – 600 – – 600 ps \nNotes\n32.Regulated VCC range (3.0 - 3.6V) and CL =15 pF.\n33.Maximum value only applies during Program/Erase Suspend/Resume commands.SCK\nSI_or_IO\nSOMSB IN LSB INtCSS tCSStCSH tCSH\ntSU\ntSUtHD\ntHD\nDatasheet 45 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nTiming specifications\n5.5.2 DDR output timing\nFigure 37 SPI DDR output timing\n5.5.3 DDR data valid timing using DLP\nFigure 38 SPI DDR data valid window\nThe minimum data valid window (tDV) and tV minimum can be calculated as follows:\ntDV = Minimum half clock cycle time (tCLH)[34]- tOTT[36] - tIO_SKEW[35]\ntV _min = tHO + tIO_SKEW + tOTT\nExample: \n80 MHz clock frequency = 12.5 ns clock period, DD R operations and duty cycle of 45% or higher\ntCLH = 0.45 x PSCK = 0.45 x 12.5 ns = 5.625 ns\nBus impedance of 45 ohm and capacitance of 22 pf, with timing reference of 0.75VCC, the rise time from 0 to 1 or \nfall time 1 to 0 is 1.4[39] x RC time constant (Tau)[38] = 1.4 x 0.99 ns = 1.39 ns\ntOTT = rise time or fall time = 1.39 ns.\nData Valid Window\ntDV = tCLH - tIO_SKEW - tOTT = 5.625 ns - 600 ps - 1.39 ns = 3.635 ns\ntV Minimum\ntV _min = tHO + tIO_SKEW + tOTT = 1.0 ns + 600 ps + 1.39 ns = 2.99 nsCS#\nSCK\nSI\nSO_or_IO MSB LSBtCS\ntHO tV tV tDIS tLZ\nSCK\ntIO SKEWtCLtCHpSCK\ntV\nNotes\n34.tCLH is the shorter duration of tCL or tCH.\n35.tIO_SKEW  is the maximum difference (delta ) between the minimum and maximum tV (output valid) across all \nIO signals.\n36.tOTT is the maximum Output Transition Time from one valid data value to the next valid data value on each \nIO. tOTT is dependent on system le vel considerations including:\na. Memory device output impedance (drive strength).\nb. System level parasitics on the IOs (primarily bus capacitance).c. Host memory controller input V\nIH and VIL levels at which 0 to 1 and 1 to 0 transitions are recognized.\nd. tOTT is not a specification tested by Infineon, it is system dependen t and must be derived by the system designer based on the abov e considerations.\n37.tDV is the data valid window.\n38.Tau = R (Output Impedance) x C (Load capacitance).39.Multiplier of Tau time for voltage to rise to 75% of V\nCC.\nDatasheet 46 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPhysical interface\n6P h y s i c a l  i n t e r f a c e\n6.1 SOIC 16-lead package\n6.1.1 SOIC 16 connection diagram\nFigure 39 16-lead SOIC package, top viewTable 16 Model specific connections\nVIO / RFU Versatile I/O or RFU — Some device models bond this connector to the device I/O power \nsupply, other models bond the device I/O supp ly to Vcc within the package leaving this \npackage connector unconnected.\nRESET# / RFU RESET# or RFU — Some device mode ls bond this connector to the device RESET# \nsignal, other models bond the RESET# signal to Vcc within the package leaving this package connector unconnected.\n1\n2\n3\n416\n15\n14\n13HOLD#/IO3\nVCC\nRESET#/RFU\nDNU NCVIO/RFUSI/IO0SCK\n5\n6\n7\n812\n11\n10\n9 WP#/IO2VSSDNUDNU DNU\nRFU\nCS#\nSO/IO1\nNote\n40.Refer to Table 2  for signal descriptions.\nDatasheet 47 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPhysical interface\n6.1.2 SOIC 16 physical diagram\nFigure 40 SOIC 16-lead, 300-mil body width (SO3016)0.33  C\n0.25  M D CA - B0.20  C A-B\n0.10  C\n0.10  C0.10  C D\n2X\n2.  DIMENSIONING AND TOLERANCING PER ASME Y14.5M - 1994.\n3.  DIMENSION D DOES NOT INCLUDE MOLD FLASH, PROTRUSIONS OR GATE BURRS. \n END. DIMENSION E1 DOES NOT INCLUDE INTERLEAD FLASH OR PROTRUSION.\nINTERLEAD FLASH OR PROTRUSION SHALL NOT EXCEED 0.25 mm PER SIDE. 1.  ALL DIMENSIONS ARE IN MILLIMETERS.NOTES: \nD AND E1 DIMENSIONS ARE DETERMINED AT DATUM H.\n FLASH, BUT INCLUSIVE OF ANY MISMATCH BETWEEN THE TOP AND BOTTOM OFEXCLUSIVE OF MOLD FLASH, TIE BAR BURRS, GATE BURRS AND INTERLEAD4.  THE PACKAGE TOP MAY BE SMALLER THAN THE PACKAGE BOTTOM. DIMENSIONS\n5.  DATUMS A AND B TO BE DETERMINED AT DATUM H.\n6.  "N" IS THE MAXIMUM NUMBER OF TERMINAL POSITIONS FOR THE SPECIFIED \n7.  THE DIMENSIONS APPLY TO THE FLAT SECTION OF THE LEAD BETWEEN 0.10 TO\n   MAXIMUM MATERIAL CONDITION. THE DAMBAR CANNOT BE LOCATED ON THE8.  DIMENSION "b" DOES NOT INCLUDE DAMBAR PROTRUSION. ALLOWABLE DAMBAR\n  LOWER RADIUS OF THE LEAD FOOT.\nIDENTIFIER MUST BE LOCATED WITHIN THE INDEX AREA INDICATED.9.  THIS CHAMFER FEATURE IS OPTIONAL. IF IT IS NOT PRESENT, THEN A PIN 1 \n10.  LEAD COPLANARITY SHALL BE WITHIN 0.10 mm AS MEASURED FROM THE \nh\n0D\nL2\nNeA1\nb\nc\nE\nE1A\n0.7510.30 BSC\n1.27 BSC0.30\n10.30 BSC0.33\n0°0.25160.20\n7.50 BSC0.10\n0.31\n8°0.512.65 2.35\nA2 2.05 2.55\nb1 0.27 0.48\n0.30 0.20 c1\nL10.40 L 1.27\n1.40 REF\n0.25 BSC\n0 5° 15°\n0 0°1\n2 -DIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n-----------\n-MOLD FLASH, PROTRUSIONS OR GATE BURRS SHALL NOT EXCEED 0.15 mm PER\n D AND E1 ARE DETERMINED AT THE OUTMOST EXTREMES OF THE PLASTIC BODY \n 0.25 mm FROM THE LEAD TIP.\n PROTRUSION SHALL BE 0.10 mm TOTAL IN EXCESS OF THE "b" DIMENSION AT THE PLASTIC BODY.\nPACKAGE LENGTH.\nSEATING PLANE.\nDatasheet 48 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPhysical interface\n6.2 FAB024 24-ball BGA package\n6.2.1 Connection diagram\nFigure 41 24-ball BGA, 5 x 5 ball footprint (FAB024), top view[41]\nNote\n41.Signal connections are in the same relative positions as FAC024 BGA, allowing a single PCB footprint to use \neither package.3 25 4 1\nNC NC NC RESET#/\nRFU\nB\nD\nEA\nCVSS SCK NC VCC DNU\nRFU CS# NC WP#/IO2 DNU\nSI/IO0 SO/IO1 NC HOLD#/IO3 DNU\nNC NC NC VIO/RFU NC\nDatasheet 49 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPhysical interface\n6.2.2 FAB024 physical diagram\nFigure 42 Ball grid array 24-ball 6x8 mm (FAB024)METALLIZED MARK INDENTATION OR OTHER MEANS.A1 CORNER TO BE IDENTIFIED BY CHAMFER, LASER OR INK MARK,N IS THE NUMBER OF POPULATED SOLDER BALL POSITIONS FOR MATRIX SIZE MD X ME.\nWHEN THERE IS AN EVEN NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" = eD/2 ANDWHEN THERE IS AN ODD NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" OR "SE" = 0.POSITION OF THE CENTER SOLDER BALL IN THE OUTER ROW. "SD" AND "SE" ARE MEASURED WITH RESPECT TO DATUMS A AND B AND DEFINE THESYMBOL "ME" IS THE BALL MATRIX SIZE IN THE "E" DIRECTION. SYMBOL "MD" IS THE BALL MATRIX SIZE IN THE "D" DIRECTION. e REPRESENTS THE SOLDER BALL GRID PITCH.\nDIMENSION "b" IS MEASURED AT THE MAXIMUM BALL DIAMETER IN A PLANE     BALL POSITION DESIGNATION PER JEP95, SECTION 3, SPP-020.    DIMENSIONING AND TOLERANCING METHODS PER ASME Y14.5M-1994.\n"+" INDICATES THE THEORETICAL CENTER OF DEPOPULATED BALLS. 8.\n9.7    ALL DIMENSIONS ARE IN MILLIMETERS.\nPARALLEL TO DATUM C.5.\n64.3.2.1.NOTES:\nSDb\neDeEME\nN\n0.35\n0.00 BSC1.00 BSC1.00 BSC0.40245\n0.45D1\nMDE1EDA\nA1 0.20-\n4.00 BSC\n4.00 BSC\n56.00 BSC8.00 BSC-- 1.20\n-\nSE 0.00 BSCDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n"SE" = eE/2.\nDatasheet 50 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPhysical interface\n6.3 FAC024 24-ball BGA package\n6.3.1 Connection diagram\nFigure 43 24-ball BGA, 4 x 6 ball footprint (FAC024), top view[42]\nNote\n42.Signal connections are in the same relative positions as FAC024 BGA, allowing a single PCB footprint to use \neither package.3 24 1\nNC NC RESET#/\nRFU\nB\nD\nEA\nCVSS SCK VCC DNU\nRFU CS# WP#/IO2 DNU\nSI/IO0 SO/IO1 HOLD#/IO3 DNU\nNC NC VIO/RFU NCNC\nNC NC NC NCF\nDatasheet 51 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nPhysical interface\n6.3.2 FAC024 physical diagram\nFigure 44 Ball grid array 24-ball 6x8 mm (FAC024)\n6.3.3 Special handling instructions for FBGA packages\nFlash memory devices in BGA packages may be damaged if exposed to ultrasonic cleaning methods. The package \nand/or data integrity may be compromised if the pack age body is exposed to temperatures above 150°C for \nprolonged periods of time.METALLIZED MARK INDENTATION OR OTHER MEANS.A1 CORNER TO BE IDENTIFIED BY CHAMFER, LASER OR INK MARK,N IS THE NUMBER OF POPULATED SOLDER BALL POSITIONS FOR MATRIX SIZE MD X ME.\nWHEN THERE IS AN EVEN NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" = eD/2 ANDWHEN THERE IS AN ODD NUMBER OF SOLDER BALLS IN THE OUTER ROW, "SD" OR "SE" = 0.POSITION OF THE CENTER SOLDER BALL IN THE OUTER ROW. "SD" AND "SE" ARE MEASURED WITH RESPECT TO DATUMS A AND B AND DEFINE THESYMBOL "ME" IS THE BALL MATRIX SIZE IN THE "E" DIRECTION. SYMBOL "MD" IS THE BALL MATRIX SIZE IN THE "D" DIRECTION. e    REPRESENTS THE SOLDER BALL GRID PITCH.\nDIMENSION "b" IS MEASURED AT THE MAXIMUM BALL DIAMETER IN A PLANE     BALL POSITION DESIGNATION PER JEP95, SECTION 3, SPP-020.    DIMENSIONING AND TOLERANCING METHODS PER ASME Y14.5M-1994.\n"+" INDICATES THE THEORETICAL CENTER OF DEPOPULATED BALLS. 8.\n9.7    ALL DIMENSIONS ARE IN MILLIMETERS.\nPARALLEL TO DATUM C.5.\n64.3.2.1.NOTES:\nSDb\neDeEME\nN\n0.35\n0.50 BSC1.00 BSC1.00 BSC0.40244\n0.45D1\nMDE1EDA\nA1 0.25-\n5.00 BSC\n3.00 BSC\n66.00 BSC8.00 BSC-- 1.20\n-\nSE 0.50 BSCDIMENSIONS\nSYMBOL\nMIN. NOM. MAX.\n "SE" = eE/2.\nDatasheet 52 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface\nSoftware interface\nThis section discusses the features and behaviors most rele vant to host system software that interacts with the \nS25FL512S memory device.\nDatasheet 53 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7 Address space maps\n7.1 Overview\n7.1.1 Extended address\nThe S25FL512S device supports 32-bit ad dresses to enable higher density devices than allowed by previous \ngeneration (legacy) SPI devices that supported only 24-bi t addresses. A 24-bit byte resolution address can access \nonly 16 MB (128 Mb) of maximum density. A 32-bit byte reso lution address allows direct addressing of up to a 4 \nGbytes (32 Gbits) of address space.\nLegacy commands continue to support 24-bit addresses fo r backward software compatibility. Extended 32-bit \naddresses are enabled in three ways:\n• Bank address register — a software (command) loadable in ternal register that supplies the high order bits of \naddress when legacy 24-bit addresses are in use.\n• Extended address mode — a bank address register bit th at changes all legacy commands to expect 32 bits of \naddress supplied from the host system.\n• New commands — that perform both legacy an d new functions, which expect 32-bit address.\nThe default condition at power-up and after reset, is the Bank address register loaded with zeros and the \nextended address mode set for 24-bit addresses. This enab les legacy software compatible access to the first 128 \nMb of a device. \n7.1.2 Multiple address spaces\nMany commands operate on the main flash memory arra y. Some commands operate on address spaces separate \nfrom the main flash array. Each separate address space uses the full 32-bit address but may only define a small \nportion of the available address space.\n7.2 Flash memory array\nThe main flash array is divided into erase units called  sectors. The sectors are organized as uniform 256-KB \nsectors. \nNote  This is a condensed table that uses a sector as a refe rence. There are address ranges that are not explicitly \nlisted. All 256-kB sectors have  the pattern XXXX0000h-XXXXFFFFh.\n7.3 ID-CFI address space\nThe RDIDJ command (9Fh) reads information from a separa te flash memory address space for device identifi-\ncation (ID) and Common Flash Interface (CFI) information. See “Device ID and common flash interface (ID-CFI) \naddress map” on page 128 for the tables defining the contents of the ID-CFI address space. The ID-CFI address \nspace is programmed by Infineon and read-only for the host system.Table 17 S25FL512S sector and memory address map, uniform 256-KB sectors\nSector size (KB) Sector count Sector range Address range \n(8-bit) Notes \n256 256SA00 00000000h-0003FFF\nFh Sector Starting \nAddress\n—\nSector Ending \nAddress: : \nSA255 03FC0000h-03FFFFF\nFh\nDatasheet 54 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.4 JEDEC JESD216 serial flash disc overable parameters (SFDP) space.\nThe RSFDP command (5Ah) reads information from a separa te Flash memory address space for device identifi-\ncation, feature, and configuration information, in acco rd with the JEDEC JESD216B standard for Serial Flash \nDiscoverable Parameters. The ID-CFI address space is incorporated as one of the SFDP parameters.\nSee “Serial flash discoverable parameters (SFDP) address map” on page 124 for the table defining the \ncontents of the SFDP address space. The SFDP address space is programmed by Infineon and is read-only for the \nhost system\n7.5 OTP address space\nEach S25FL512S memory device has a 1024-byte One Time Program (OTP) address space that is separate from \nthe main flash array. The OTP area is divided into 32, individually lockable, 32-byte aligned and length regions.\nIn the 32-byte region starting at address zero:\n• The 16 lowest address bytes are programmed by Infineon  with a 128-bit random number. Only Infineon is able \nto program these bytes.\n• The next 4 higher address bytes (OTP Lock Bytes) are used to provide one bit per OTP region to permanently \nprotect each region from programming. The bytes are erased when shipped from Infineon. After an OTP region is programmed, it can be locked to prevent further programming, by programming the related protection bit in the OTP Lock Bytes.\n• The next higher 12 bytes of the lowest address region ar e Reserved for Future Use (RFU). The bits in these RFU \nbytes may be programmed by the host system but it must  be understood that a future device may use those \nbits for protection of a larger OTP space. The bytes are erased when shipped from Infineon.\nThe remaining regions are erased when shipped from Infi neon, and are available for programming of additional \npermanent data.\nRefer to Figure 45  for a pictorial representati on of the OTP memory space.\nThe OTP memory space is intended for increased system  security. OTP values, such as the random number \nprogrammed by Infineon, can be used to “mate” a flash component with the system CPU/ASIC to prevent device \nsubstitution.\nThe configuration register FREEZE (CR1[0]) bit protects  the entire OTP memory space from programming when \nset to 1. This allows trusted boot code to control prog ramming of OTP regions then set the FREEZE bit to prevent \nfurther OTP memory space programming during the remainder of normal power-on system operation.\nFigure 45 OTP address space32 Byte OTP Region 3 1\n32 Byte OTP Region 3 0\n32 Byte OTP Region 2 9\n.\n.\n.\n32 Byte OTP Region 3\n32 Byte OTP Region 2\n32 Byte OTP Region 1\n32 Byte OTP Region 0\n16 Byte Random Numbe r Reserve d Lock Byte sLock Bits 31 to 0...When programmed to\n“0” each lock bit \nprotects its related 32\nbyte region from any\nfurther programming\nContents of Region 0 {\nByte 0 Byte 10 Byte 1 F\nDatasheet 55 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.6 Registers\nRegisters are small groups of memory cells used to configure how the S25FL512-S memory device operates or to \nreport the status of device operations. The register s are accessed by specific commands. The commands (and \nhexadecimal instruction codes) used for each register ar e noted in each register description. The individual \nregister bits may be volatile, non-volatile, or One Time Programmable (OTP). The type for each bit is noted in each register description. The default state shown for each bit re fers to the state after power-on reset, hardware reset, \nor software reset if the bit is volatile. If the bit is non-vo latile or OTP , the default state is the value of the bit when \nthe device is shipped from Infineon. Non-volatile bits have the same cycling (erase and program) endurance as \nthe main flash array.Table 18 OTP address map\nRegion Byte address range (Hex) ContentsInitial delivery state \n(Hex)\nRegion 0 000 Least Significant Byte \n(LSB) of Spansion \nProgrammed Random \nNumberSpansion Programmed \nRandom Number\n... ...\n00F Most Significant Byte \n(MSB) of Spansion \nProgrammed Random \nNumber\n010 to 013 Region Locking Bits\nByte 10 [bit 0] locks region \n0 from programming \nwhen = 0\n...\nByte 13 [bit 7] locks region \n31 from programming \nwhen = 0All bytes = FF\n014 to 01F Reserved for Future Use \n(RFU)All bytes = FF\nRegion 1 020 to 03F Available for User \nProgrammingAll bytes = FF\nRegion 2 040 to 05F Available for User \nProgrammingAll bytes = FF\n... ... Available for User \nProgrammingAll bytes = FF\nRegion 31 3E0 to 3FF Available for User \nProgrammingAll bytes = FF\nTable 19 Register descriptions\nRegister Abbreviation Type Bit location\nStatus Register 1 SR1[7:0] Volatile 7:0Configuration Register 1 CR1[7:0] Volatile 7:0Status Register 2 SR2[7:0] RFU 7:0AutoBoot Register ABRD[31:0] Non-volatile 31:0Bank Address Register BRAC[7:0] Volatile 7:0ECC Status Register ECCSR[7:0] Volatile 7:0\nDatasheet 56 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.6.1 Status register 1 (SR1)\nRelated Commands: Read Status Register (RDSR1 05h),  Write Registers (WRR 01h), Write Enable (WREN 06h), \nWrite Disable (WRDI 04h), Clear Status Register (CLSR 30h). \nThe Status Register contains both status and control bits:\nStatus Register Write Disable (SRWD) SR1[7] : Places the device in the Hardware Protected mode when this bit \nis set to 1 and the WP# input is driven low. In this mode , the SRWD, BP2, BP1, and BP0 bits of the Status Register ASP Register ASPR[15:1] OTP 15:1\nASP Register ASPR[0] RFU 0Password Register PASS[63:0] Non-volatile OTP 63:0PPB Lock Register PPBL[7:1] Volatile 7:1PPB Lock Register PPBL[0] Volatile \nRead Only0\nPPB Access Register PPBAR[7:0] Non-volatile 7:0\nDYB Access Register DYBAR[7:0] Volatile 7:0SPI DDR Data Learning Registers NVDLR[7:0] Non-volatile 7:0SPI DDR Data Learning Registers VDLR[7:0] Volatile 7:0\nTable 20 Status register-1 (SR1) \nBits Field \nname Function Type Default \nstate Description \n7 SRWD Status \nRegister \nWrite \nDisable Non-volatile 0 1 = Locks state of SRWD, BP , and configuration \nregister bits when WP# is low by ignoring WRR command0 = No protection, even when WP# is low\n6 P_ERR Programmi\nng Error \nOccurred Volatile, Read \nonly 0 1 = Error occurred.\n0 = No Error\n5 E_ERR Erase Error \nOccurred Volatile, Read \nonly 0 1 = Error occurred \n0 = No Error \n4 BP2 Block \nProtection Volatile if \nCR1[3]=1, \nNon-volatile if \nCR1[3]=0 1 if \nCR1[3]=1, \n0 when \nshipped \nfrom \nInfineon Protects selected range of sectors (Block) \nfrom Program or Erase 3 BP1 \n2 BP0 \n1 WEL Write Enable \nLatch Volatile 0 1 = Device accepts Write Registers (WRR), \nprogram or erase commands 0 = Device ignores Write Registers (WRR), program or erase commands This bit is not affected by WRR, only WREN and WRDI commands affect this bit\n0 WIP Write in \nProgress Volatile, Read \nonly 0 1 = Device Busy, a Write Registers (WRR), \nprogram, erase or other operation is in progress 0 = Ready Device is in standby mode and can accept commands Table 19 Register descriptions\nRegister Abbreviation Type Bit location\nDatasheet 57 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\nbecome read-only bits and the Write Registers (WRR) command is no longer accepted for execution. If WP# is high \nthe SRWD bit and BP bits may be changed by the WRR command. If SRWD is 0, WP# has no effect and the SRWD bit and BP bits may be changed by the WRR command. Th e SRWD bit has the same non-volatile endurance as the \nmain flash array.\nProgram Error (P_ERR) SR1[6] : The Program Error Bit is used as a program operation success or failure \nindication. When the Program Error bit is set to a 1 it indicates that there was an error in the last program \noperation. This bit will also be set when the user attemp ts to program within a protected main memory sector or \nlocked OTP region. When the Program Error bit is set to a 1 this bit can be reset to 0 with the Clear Status Register \n(CLSR) command. This is a read-only bit and is not affected by the WRR command.\nErase Error (E_ERR) SR1[5] : The Erase Error Bit is used as an Erase op eration success or failure indication. When \nthe Erase Error bit is set to a 1 it indicates that there was an error in the last erase operation. This bit will also be \nset when the user attempts to erase an individual prot ected main memory sector. The Bulk Erase command will \nnot set E_ERR if a protected sector is found during the co mmand execution. When the Erase Error bit is set to a 1 \nthis bit can be reset to 0 with the Clear Status Register (CLSR) command. This is a read-only bit and is not affected \nby the WRR command.\nBlock Protection (BP2, BP1, BP0) SR1[4:2] : These bits define the main flash array area to be software-protected \nagainst program and erase commands. The BP bits are either  volatile or non-volatile, depending on the state of \nthe BP non-volatile bit (BPNV) in the configuration register. When one or more of the BP bits is set to 1, the \nrelevant memory area is protected against program and erase. The Bulk Erase (BE) command can be executed \nonly when the BP bits are cleared to 0’s. See “Block protection” on page 67 for a description of how the BP bit \nvalues select the memory array area protected. The BP bits have the same non-volatile endurance as the main \nflash array.\nWrite Enable Latch (WEL) SR1[1] : The WEL bit must be set to 1 to enable program, write, or erase operations as \na means to provide protection against inadvertent chan ges to memory or register values. The Write Enable \n(WREN) command execution sets the Write Enable Latch to  a 1 to allow any program, erase, or write commands \nto execute afterwards. The Write Disable (WRDI) command can be used to set the Write Enable Latch to a 0 to \nprevent all program, erase, and write commands from exec ution. The WEL bit is cleared to 0 at the end of any \nsuccessful program, write, or erase operation. Followi ng a failed operation the WEL bit may remain set and \nshould be cleared with a WRDI command following a CLSR command. After a power down/power up sequence, \nhardware reset, or software reset, the Write Enable Latch is set to a 0 The WRR command does not affect this bit.\nWrite In Progress (WIP) SR1[0] : Indicates whether the device is performing a program, write, erase operation, \nor any other operation, during which a new operation comma nd will be ignored. When the bit is set to a 1 the \ndevice is busy performing an operation. While WIP is 1, only Read Status (RDSR1 or RDSR2), Erase Suspend (ERSP), Program Suspend (PGSP), Clear Status Register (C LSR), and Software Reset (RESET) commands may be \naccepted. ERSP and PGSP will only be accepted if memory  array erase or program operations are in progress. The \nstatus register E_ERR and P_ERR bits are updated while WI P = 1. When P_ERR or E_ERR bits are set to one, the \nWIP bit will remain set to one indicating the device rema ins busy and unable to receive new operation commands. \nA Clear Status Register (CLSR) command must be received to return the device to standby mode. When the WIP bit is cleared to 0 no operation is in progress. This is a read-only bit.\nDatasheet 58 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.6.2 Configuration register 1 (CR1)\nRelated Commands: Read Configuration Register (RDC R 35h), Write Registers (WRR 01h). The Configuration \nRegister bits can be changed using the WRR command with si xteen input cycles.\nThe configuration register controls certain interface and data protection functions.\nLatency Code (LC) CR1[7:6]:  The Latency Code selects the number of  mode and dummy cycles between the end \nof address and the start of read data output for all read commands. \nSome read commands send mode bits following the address to indicate that the next command will be of the \nsame type with an implied, rather than an explicit, instruction. The next command  thus does not provide an \ninstruction byte, only a new address and mode bits. This  reduces the time needed to send each command when \nthe same command type is repeated in a sequence of commands. \nDummy cycles provide additional latency that is needed to complete the initial read access of the flash array \nbefore data can be returned to the host system. Some read commands require additional latency cycles as the SCK frequency is increased.\nThe following latency code tables provide different latenc y settings that are configured by Infineon. The High \nPerformance versus the Enhanced High Performance se ttings are selected by the ordering part number. \nWhere mode or latency (dummy) cycles are shown in the tables as a dash, that read command is not supported \nat the frequency shown. Read is supported only up to 50 MHz but the same latency value is assigned in each latency code and the command may be used when the device is operated at \n≤ 50 MHz with any latency code \nsetting. Similarly, only the Fast Read command is support ed up to 133 MHz but the same 10b latency code is used \nfor Fast Read up to 133 MHz and for the other dual and quad read commands up to 104 MHz. It is not necessary \nto change the latency code from a higher to a lower frequency when operating at lower frequencies where a particular command is supported. The latency code values  for a higher frequency can be used for accesses at \nlower frequencies.\nThe High Performance settings provide latency options th at are the same or faster than alternate source SPI \nmemories. These settings provide mode bits only for the Quad I/O Read command. \nThe Enhanced High Performance settings  similarly provide latency options the same or faster than additional \nalternate source SPI memories and adds mode bits  for the Dual I/O Read, DDR Fast Read, and DDR \nDual I/O Read commands.Table 21 Configuration register (CR1)\nBits Field name Function Type De-\nfault \nstate Description \n7 LC1 Latency Code Non-volatile 0 Selects number of initial read \nlatency cycles\nSee Latency Code Tables 6 LC0 0 \n5 TBPROT Configures Start of Block \nProtection OTP 0 1 = BP starts at bottom (Low \naddress)\n0 = BP starts at top (High \naddress) \n4 DNU DNU  DNU 0 Do not Use 3 BPNV Configures BP2-0 in Status \nRegister OTP 0 1 = Volatile \n0 = Non-volatile \n2 RFU RFU RFU 0 Reserved for Future Use 1 QUAD Puts the device into Quad I/O \noperation Non-volatile 0 1 = Quad \n0 = Dual or Serial \n0 FREEZE Lock current state of BP2-0 bits in \nStatus Register, TBPROT in \nConfiguration Register, and OTP \nregions Volatile 0 1 = Block Protection and OTP \nlocked\n0 = Block Protection and OTP \nun-locked \nDatasheet 59 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\nRead DDR Data Learning Pattern (DLP) bits may be placed  within the dummy cycles i mmediately before the start \nof read data, if there are 5 or more dummy cycles. See “Read memory array commands” on page 90 for more \ninformation on the DLP .\nTable 22 Latency codes for SDR high performance \nFreq\n. \n(MH\nz)LCRead Fast Read Read Dual Out Read Quad Out Dual I/O Read Quad I/O \nRead \n(03h, 13h) (0Bh, 0Ch) (3Bh, 3Ch)  (6Bh, 6Ch) (BBh, BCh) (EBh, ECh)\nModeDum-\nmyModeDum-\nmyModeDum-\nmyModeDum-\nmyModeDum-\nmyMod\neDum-\nmy\n≤ 5 0 1 1 0000000004 2 1\n≤ 8 0 0 0 –  –  08080804 2 4\n≤ 9 0 0 1 –  –  08080805 2 4\n≤1 0 4 1 0 –  –  08080806 2 5\n≤133 10 – – 0 8 – – – – – – – – \nTable 23 Latency codes for DDR high performance \nFreq. \n(MHz)LCDDR Fast Read DDR Dual I/O Read Read DDR Quad I/O\n(0Dh, 0Eh) (BDh, BEh) (EDh, EEh)\nMode Dummy Mode Dummy Mode Dummy\n≤ 5 0 1 1 040413\n≤ 6 6 0 0 050616\n≤ 6 6 0 1 060717\n≤ 6 6 1 0 070818\nTable 24 Latency codes for SDR enhanced high performance \nFreq. \n(MHz)LCRead Fast Read Read Dual OutRead Quad \nOutDual I/O Read Quad I/O Read \n(03h, 13h) (0Bh, 0Ch) (3Bh, 3Ch)  (6Bh, 6Ch) (BBh, BCh) (EBh, ECh)\nModeDum-\nmyModeDum-\nmyModeDum-\nmyModeDum-\nmyModeDum-\nmyModeDum-\nmy\n≤ 5 0 1 1 00000000 4 0 2 1\n≤ 8 0 0 0 –  –  080808 4 0 2 4\n≤ 9 0 0 1 –  –  080808 4 1 2 4\n≤104 10 – – 0 8 0 8 0 8 4 2 2 5\n≤133 10 – – 0 8 – – – – – – – – \nDatasheet 60 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\nTop or Bottom Protection (TBPROT) CR1[5]:  This bit defines the operation of  the Block Protection bits BP2, \nBP1, and BP0 in the Status Register. As described in the st atus register section, the BP 2-0 bits allow the user to \noptionally protect a portion of the array, ranging from 1/64, 1/4, 1/2, etc., up to the entire array. When TBPROT is \nset to a 0 the Block Protection is defined to start from the top (maximum address) of the array. When TBPROT is \nset to a 1 the Block Protection is defined to start from the bottom (zero address) of the array. The TBPROT bit is \nOTP and set to a 0 when shipped from Infineon. If TBPROT is programmed to 1, an attempt to change it back to 0 will fail and set the Program Error bit (P_ERR in SR1[6]). \nThe desired state of TBPROT must be selected during the initial configuration of the device during system \nmanufacture; before the first program or erase operat ion on the main flash arra y. TBPROT must not be \nprogrammed after programming or erasin g is done in the main flash array. \nCR1[4]:  Reserved for Future Use\nBlock Protection Non-volatile (BPNV) CR1[3] : The BPNV bit defines whether or not the BP2-0 bits in the Status \nRegister are volatile or non-volatile. The BPNV bit is OT P and cleared to a0 with the BP bits cleared to 000 when \nshipped from Infineon. When BPNV is set to a 0 the BP2-0 bits in the Status Register are non-volatile. When BPNV \nis set to a 1 the BP2-0 bits in the Status Register are vo latile and will be reset to binary 111 after POR, hardware \nreset, or command reset. If BPNV is programmed to 1, an attempt to change it back to 0 will fail and set the Program Error bit (P_ERR in SR1[6]). \nCR1[2] : Reserved for Future Use.\nQuad Data Width (QUAD) CR1[1] : When set to 1, this bit switches the data width of the device to 4 bit - Quad \nmode. That is, WP# becomes I/O2 and HOLD# becomes I/O3. The WP# and HOLD# inputs are not monitored for \ntheir normal functions and are internally set to high (i nactive). The commands for Serial, Dual Output, and Dual \nI/O Read still function normally but, there is no need  to drive WP# and Hold# inputs for those commands when \nswitching between commands using different data path wi dths. The QUAD bit must be set to one when using \nRead Quad Out, Quad I/O Read, Read DDR Quad I/O,  and Quad Page Program commands. The QUAD bit is \nnon-volatile.\nFreeze Protection (FREEZE) CR1[0] : The Freeze Bit, when set to 1, locks the current state of the BP2-0 bits in \nStatus Register, the TBPROT and TBPARM bits in the Co nfiguration Register, and the OTP address space. This \nprevents writing, programming, or erasing these areas. As  long as the FREEZE bit remains cleared to logic 0 the \nother bits of the Configuration Register, including FREE ZE, are writable, and the OTP address space is program-\nmable. Once the FREEZE bit has been written to a logic 1 it can only be cleared to a logic 0 by a power-off to power-on cycle or a hardware reset. Software reset will no t affect the state of the FREEZE bit. The FREEZE bit is \nvolatile and the default state of FREEZE after power-on is 0. The FREEZE bit can be set in parallel with updating \nother values in CR1 by a single WRR command. Table 25 Latency codes for DDR enhanced high performance\nFreq. \n(MHz)LCDDR Fast Read DDR Dual I/O Read Read DDR Quad I/O\n(0Dh, 0Eh) (BDh, BEh) (EDh, EEh)\nMode Dummy Mode Dummy Mode Dummy\n≤ 5 0 1 1 412213\n≤ 6 6 0 0 422416\n≤ 6 6 0 1 442517\n≤ 6 6 1 0 452618\n≤ 8 0 0 0 422416\n≤ 8 0 0 1 442517\n≤ 8 0 1 0 452618\nNote\n43.When using DDR I/O commands with the Data Learning Pattern (DLP) enabled, a Latency Code that provides \n5 or more dummy cycles should be selected to allow 1 cycle of additional time for the host to stop driving \nbefore the memory starts driving the 4 cycle DLP . It is recommended to use LC 10 for DDR Fast Read, LC 01 for \nDDR Dual I/O Read, and LC 00 for DDR Quad I/O Read, if the Data Learning Pattern (DLP) for DDR is used.\nDatasheet 61 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.6.3 Status register 2 (SR2)\nRelated Commands: Read Status Register 2 (RDSR2 07h).\nErase Suspend (ES) SR2[1] : The Erase Suspend bit is used to determine when the device is in Erase Suspend \nmode. This is a status bit that cannot be written. When Eras e Suspend bit is set to 1, th e device is in erase suspend \nmode. When Erase Suspend bit is cleared to 0, the device  is not in erase suspend mode. Refer to Erase Suspend \nand Resume Commands (75h) (7Ah) for detail s about the Erase Suspend/Resume commands.\nProgram Suspend (PS) SR2[0]:  The Program Suspend bit is used to determine when the device is in Program \nSuspend mode. This is a status bit that cannot be written. When Program Suspend bit is set to 1, the device is in \nprogram suspend mode. When the Progra m Suspend bit is cleared to 0, the device is not in program suspend \nmode. Refer to “Program suspend (PGSP 85h) and resume (PGRS 8Ah)” on page 108 for details.\n7.6.4 AutoBoot register\nRelated Commands: AutoBoot Read (ABRD 14h) and AutoBoot Write (ABWR 15h).\nThe AutoBoot Register provides a means to automatically read boot code as part of the power on reset, hardware \nreset, or software reset process.\n7.6.5 Bank address register\nRelated Commands: Bank Register Access (BRAC B9h), Writ e Register (WRR 01h), Bank Register Read (BRRD 16h) \nand Bank Register Write (BRWR 17h).\nThe Bank Address register supplies additional high order bits of the main flash array byte boundary address for \nlegacy commands that supply only the low order 24 bits of address. The Bank Address is used as the high bits of Table 26 Status register-2 (SR2)\nBits Field name Function Type Default \nstate Description \n7 RFU Reserved – 0 Reserved for Future Use \n6 RFU Reserved – 0 Reserved for Future Use \n5 RFU Reserved – 0 Reserved for Future Use \n4 RFU Reserved – 0 Reserved for Future Use 3 RFU Reserved – 0 Reserved for Future Use 2 RFU Reserved – 0 Reserved for Future Use 1 ES Erase \nSuspend Volatile, Read \nonly 0 1 = In erase suspend mode\n0 = Not in erase suspend mode\n0 PS Program \nSuspend Volatile, Read \nonly 0 1 = In program suspend mode\n0 = Not in program suspend mode\nTable 27 AutoBoot register\nBits Field name Function Type Default \nstate Description \n31 to 9 ABSA AutoBoot Start \nAddress Non-volatile 000000h 512 byte boundary address for the \nstart of boot code access\n8 to 1 ABSD AutoBoot Start \nDelay Non-volatile 00h Number of initial delay cycles \nbetween CS# going low and the first bit of boot code being transferred\n0 ABE AutoBoot Enable Non-volati le 0 1 = AutoBoot is enabled\n0 = AutoBoot is not enabled\nDatasheet 62 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\naddress (above A23) for all 3-byte  address commands when EXTADD=0. Th e Bank Address is not used when \nEXTADD = 1 and traditional 3-byte address commands are in stead required to provide all four bytes of address.\nExtended Address (EXTADD) BAR[7]: EXTADD controls the ad dress field size for legacy SPI commands. By default \n(power up reset, hardware reset, and software reset), it is cleared to 0 for 3 bytes (24 bits) of address. When set to \n1, the legacy commands will require 4 bytes (32 bits ) for the address field. This is a volatile bit.\n7.6.6 ECC status register (ECCSR)\nRelated Commands: ECC Read (ECCRD 18h). ECCSR does not have user programmable non-volatile bits. All \ndefined bits are volatile read only status. The default state of these bits are set by hardware. See “Automatic \nECC” on page 106.\nThe status of ECC in each ECC unit is provided by the 8-bit ECC Status Register (ECCSR). The ECC Register Read \ncommand is written followed by an ECC unit address. The contents of the status register then indicates, for the \nselected ECC unit, whether there is an error in the ECC unit eight bit error co rrection code, the ECC unit of 16 Bytes \nof data, or that ECC is disabled for that ECC unit.\nECCSR[2] = 1 indicates an error was corrected in the ECC. ECCSR[1] = 1 indicates an error was corrected in the ECC \nunit data. ECCSR[0] = 1 indicates the ECC is disabled. The de fault state of “0” for all these bits indicates no failures \nand ECC is enabled.\nECCSR[7:3] are reserved. These have undefined high or low values that can change from one ECC status read to \nanother. These bits should be treated as “don’t care” and ignored by any software reading status.Table 28 Bank address register (BAR)\nBits Field \nname Function Type Default \nstate Description \n7 EXTADD Extended \nAddress Enable Volatile 0b 1 = 4-byte (32-bits) addressing required from \ncommand.0 = 3-byte (24-bits) addressing from command + Bank Address \n6 to 2 RFU Reserved Volatile 00000b Reserved for Future Use \n1 BA25 Bank Address Volatile 0 A25 for 512 Mb device0 BA24 Bank Address Volatile 0 A24 for 512 Mb device\nTable 29 ECC status register (ECCSR)\nBits Field \nname Function Type Default \nstate Description \n7 to 3 RFU Reserved 0 Reserved for Future Use \n2 EECC Error in ECC Volatile, Read \nonly 0 1 = Single Bit Error found in the ECC \nunit eight bit error correction code 0 = No error. \n1 EECCD Error in ECC unit \ndata Volatile, Read \nonly 0 1 = Single Bit Error corrected in ECC \nunit data. 0 = No error. \n0 ECCDI ECC Disabled Volatile, Read \nonly 0 1 = ECC is disabled in the selected ECC \nunit. 0 = ECC is enabled in the selected ECC unit. \nDatasheet 63 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.6.7 ASP register (ASPR)\nRelated Commands: ASP Read (ASPRD 2Bh) and ASP Program (ASPP 2Fh).\nThe ASP register is a 16-bit OTP memory location used to  permanently configure the be havior of Advanced Sector \nProtection (ASP) features.\nReserved for Future Use (RFU) ASPR[15:3, 0] .\nPassword Protection Mode Lock Bit (PWDMLB) ASPR[2]:  When programmed to 0, the Password Protection \nMode is permanently selected.\nPersistent Protection Mode Lock Bit (PSTMLB) ASPR[1]:  When programmed to 0, the Persistent Protection \nMode is permanently selected. PWDMLB and PSTMLB are mutually exclusive, only one may be programmed to \nzero.\n7.6.8 Password register (PASS)\nRelated Commands: Password Read (PASSRD E7h) and Password Program (PASSP E8h).Table 30 ASP register (ASPR)\nBits Field name Function Type Default \nstate Description \n15 to 9 RFU Reserved OTP 1 Reserved for Future Use \n8 RFU Reserved OTP Note [44] Reserved for Future Use \n7 RFU Reserved OTP Reserved for Future Use 6 RFU Reserved OTP 1 Reserved for Future Use 5 RFU Reserved OTP Note \n[44]Reserved for Future Use \n4 RFU Reserved OTP Reserved for Future Use 3 RFU Reserved OTP Reserved for Future Use 2 PWDMLB Password \nProtection \nMode Lock Bit OTP 1 0 = Password Protection Mode permanently \nenabled. 1 = Password Protection Mode not permanently enabled.\n1 PSTMLB Persistent \nProtection \nMode Lock Bit OTP 1 0 = Persistent Protection Mode permanently \nenabled. 1 = Persistent Protection Mode not permanently enabled.\n0 RFU Reserved OTP 1 Reserved for Future Use \nTable 31 Password register (PASS)\nBits Field \nname Function Type Default state Description \n63 to 0 PWD Hidden \nPassword OTP FFFFFFFF-FFFFF\nFFFh Non-volatile OTP storage of 64-bit password. The \npassword is no longer readable after the password protection mode is selected by programming ASP register bit 2 to zero. \nNotes\n44.Default value depends on ordering part number, see “Initial delivery state” on page 154.\nDatasheet 64 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\n7.6.9 PPB lock register (PPBL)\nRelated Commands: PPB Lock Read (PLBRD A7h, PLBWR A6h)\n7.6.10 PPB access register (PPBAR)\nRelated Commands: PPB Read (PPBRD E2h)\n7.6.11 DYB access register (DYBAR)\nRelated Commands: DYB Read (DYBRD E0h) and DYB Program (DYBP E1h).\n7.6.12 SPI DDR data learning registers\nRelated Commands: Program NVDLR (PNVDLR 43h), Write VDLR (WVDLR 4Ah), Data Learning Pattern Read \n(DLPRD 41h).\nThe Data Learning Pattern (DLP) resides in an 8-bit Non-vola tile Data Learning Register (NVDLR) as well as an 8-bit \nVolatile Data Learning Register (VDLR). When shipped from Infineon, the NVDLR value is 00h. Once programmed, \nthe NVDLR cannot be reprogrammed or erased; a copy of the data pattern in the NVDLR will also be written to the VDLR. The VDLR can be written to at any time, but on rese t or power cycles the data pattern will revert back to \nwhat is in the NVDLR. During the learning phase descri bed in the SPI DDR modes, the DLP will come from the \nVDLR. Each I/O will output the same DLP value for every clock edge. For example, if the DLP is 34h (or binary \n00110100) then during the first clock edge all I/O’s will outp ut 0; subsequently, the 2nd clock edge all I/O’s will \noutput 0, the 3rd will output 1, etc.Table 32 PPB lock register (PPBL)\nBits Field \nname Function Type Default state Description \n7 to 1 RFU Reserved Volatile 00h Reserved for Future Use \n0 PPBLOCK Protect PPB \nArray Volatile Persistent Protection \nMode = 1 \nPassword Protection \nMode = 0 0 = PPB array protected until next \npower cycle or hardware reset \n1 = PPB array may be programmed or \nerased. \nTable 33 PPB access register (PPBAR)\nBits Field name Function Type De-\nfault \nstate Description \n7 to 0 PPB Read or Program \nper sector PPB Non-volatile FFh 00h = PPB for the sector addressed by the \nPPBRD or PPBP command is programmed to 0, protecting that sector from program or erase operations. FFh = PPB for the sector addressed by the PPBRD or PPBP command is erased to 1, not protecting that sector from program or erase operations. \nTable 34 DYB access register (DYBAR)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 DYB Read or \nWrite per \nsector DYB Volatile FFh 00h = DYB for the sector addressed by the DYBRD or \nDYBP command is cleared to 0, protecting that sector from program or erase operations. FFh = DYB for the sector addressed by the DYBRD or DYBP command is set to 1, not protecting that sector from program or erase operations. \nDatasheet 65 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nAddress space maps\nWhen the VDLR value is 00h, no preamble data patte rn is presented during the dummy phase in the DDR \ncommands.\nTable 35 Non-volatile data learning register (NVDLR)\nBits Field \nname Function Type Default state Description \n7 to 0 NVDLP Non-volatile \nData \nLearning \nPatternOTP 00h OTP value that may be transferred to the host \nduring DDR read command latency (dummy) \ncycles to provide a training pattern to help \nthe host more accurately center the data capture point in the received data bits.\nTable 36 Volatile data learning register (NVDLR)\nBits Field \nname Function Type Default state Description \n7 to 0 VDLP Volatile Data \nLearning \nPattern Volatile Takes the value of \nNVDLR during POR \nor ResetVolatile copy of the NVDLP used to enable and \ndeliver the Data Learning Pattern (DLP) to the outputs. The VDLP may be changed by the host during system operation.\nDatasheet 66 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData protection\n8D a t a  p r o t e c t i o n\n8.1 Secure silicon region (OTP)\nThe device has a 1024-byte One Time Pr ogram (OTP) address space that is se parate from the main flash array. \nThe OTP area is divided into 32, individually  lockable, 32-byte aligned and length regions.\nThe OTP memory space is intended for increased system security. OTP values can “mate” a flash component with \nthe system CPU/ASIC to prevent device substitution. See “OTP address space” on page 54, “One time program \narray commands” on page 113, and “OTP read (OTPR 4Bh)” on page 113.\n8.1.1 Reading OTP memory space\nThe OTP Read command uses the same protocol as Fast Read. OTP Read operations outside the valid 1-kB OTP \naddress range will yield indeterminate data.\n8.1.2 Programming OTP memory space\nThe protocol of the OTP programming command is the same as Page Program. The OTP Program command can \nbe issued multiple times to any given OTP addre ss, but this address space can never be erased. \nAutomatic ECC is programmed on the first programming operation to each 16-byte region. Programming within \na 16-byte region more than once disables the ECC. It is recommended to program each 16-byte portion of each \n32-byte region once so that ECC remains en abled to provide the best data integrity.\nThe valid address range for OTP Program is depicted in Figure 45 . OTP Program operations outside the valid OTP \naddress range will be ignored and the WEL in SR1 will remain high (set to 1). OTP Program operations while \nFREEZE = 1 will fail with  P_ERR in SR1 set to 1.\n8.1.3 Infineon programmed random number\nInfineon standard practice is to program the low order 16 bytes of the OTP memory space (locations 0x0 to 0xF) \nwith a 128-bit random number using the Linear Congruen tial Random Number Method . The seed value for the \nalgorithm is a random number concatenated with the day and time of tester insertion.\n8.1.4 Lock bytes\nThe LSb of each Lock byte protects the lowest address region related to the byte, the MSb protects the highest \naddress region related to the byte. The next higher addres s byte similarly protects the next higher 8 regions. The \nLSb bit of the lowest address Lock Byte protects the high er address 16 bytes of the lowest address region. In other \nwords, the LSb of location 0x10 protects all the Lock Bytes and RFU bytes in the lowest address region from further programming. See “OTP address space” on page 54.\n8.2 Write enable command\nThe Write Enable (WREN) command must  be written prior to any command that modifies non-volatile data. The \nWREN command sets the Write Enable Latch (WEL) bit. The WEL bit is cleared to 0 (disables writes) during \npower-up, hardware reset, or after the device completes the following commands:\n•R e s e t\n• Page Program (PP)\n• Sector Erase (SE)•B u l k  E r a s e  ( B E )\n•W r i t e  D i s a b l e  ( W R D I )\n•W r i t e  R e g i s t e r s  ( W R R )• Quad-input Page Programming (QPP)• OTP Byte Programming (OTPP)\nDatasheet 67 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData protection\n8.3 Block protection\nThe Block Protect bits (Status Register bits BP2, BP1,  BP0) in combination with the Configuration Register \nTBPROT bit can be used to protect an address range of the main flash array from program and erase operations. \nThe size of the range is determined by the value of the BP  bits and the upper or lower starting point of the range \nis selected by the TBPROT bit of the configuration register.\nWhen Block Protection is enabled (i.e.,  any BP2-0 are set to 1), Advanced Sector Protection (ASP) can still be used \nto protect sectors not protected by the Block Protection scheme. In the case that bo th ASP and Block Protection \nare used on the same sector the logical OR of ASP and Block Protection related to the sector is used. Recommen-\ndation: ASP and Block Protection should not be used  concurrently. Use one or the other, but not both. \n8.3.1 Freeze bit\nBit 0 of the Configuration Register is the FREEZE bit. The FREEZE bit locks the BP2-0 bits in Status Register 1 and \nthe TBPROT bit in the Co nfiguration Register to their value at the time the FREEZE bit is set to 1. Once the FREEZE \nbit has been written to a logic 1 it cannot be cleared to a logic 0 until a power-on-reset is executed. As long as the FREEZE bit is cleared to logic 0 the status register BP bits and the TBPROT bit of the Configuration Register are \nwritable. The FREEZE bit also protects the entire OT P memory space from programming when set to 1. Any \nattempt to change the BP bits with the WRR command wh ile FREEZE = 1 is ignored and no error status is set.\n8.3.2 Write protect signal\nThe Write Protect (WP#) input in combination with the Stat us Register Write Disable (SRWD) bit provide hardware \ninput signal controlled protection. When WP# is Low and SRWD is set to 1 the Status and Configuration register \nis protected from alteration. This prevents disabling or changing the protection define d by the Block Protect bits.Table 37 Upper array start of protection (TBPROT = 0)\nStatus Register ContentProtected Fraction of Memory \nArrayProtected Memory (KB)\nFL512S\n512 Mb BP2 BP1 BP0\n000 N o n e 0\n0 0 1 Upper 64th 10240 1 0 Upper 32nd 20480 1 1 Upper 16th 40961 0 0 Upper 8th 81921 0 1 Upper 4th 163841 1 0 Upper Half 327681 1 1 All Sectors 65536\nTable 38 Lower array start of protection (TBPROT = 1)\nStatus Register ContentProtected Fraction of Memory \nArrayProtected Memory (KB)\nFL512S\n512 Mb BP2 BP1 BP0\n000 N o n e 0\n0 0 1 Lower 64th 10240 1 0 Lower 32nd 20480 1 1 Lower 16th 40961 0 0 Lower 8th 81921 0 1 Lower 4th 163841 1 0 Lower Half 327681 1 1 All Sectors 65536\nDatasheet 68 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData protection\n8.4 Advanced sector protection\nAdvanced Sector Protection (ASP) is the name used for a set of independ ent hardware and software methods \nused to disable or enable programming or erase operations , individually, in any or all sectors. An overview of \nthese methods is shown in Figure 46 .\nBlock Protection and ASP protection settings for each sect or are logically OR’d to define the protection for each \nsector, i.e. if either mechanism is protecting a sector the sector cannot be programmed or erased. Refer to “Block \nprotection” on page 67 for full details of the BP2-0 bits.\nFigure 46 Advanced sector protection overview\nEvery main flash array sector has a non-volatile (PPB) and a volatile (DYB) protection bit associated with it. When \neither bit is 0, the sector is protec ted from program and erase operations.\nThe PPB bits are protected from program and erase when  the PPB Lock bit is 0. There are two methods for \nmanaging the state of the PPB Lock bit, Pers istent Protection and Password Protection.\nThe Persistent Protection method sets the PPB Lock bit to  1 during POR, or Hardware Reset so that the PPB bits \nare unprotected by a device reset. There is a command to clear the PPB Lock bit to 0 to protect the PPB. There is \nno command in the Persistent Protection method to set the PPB Lock bit to 1, therefore the PPB Lock bit will \nremain at 0 until the next power-off or hardware reset. The Persistent Protection method allows boot code the option of changing sector protection by programming or  erasing the PPB, then protecting the PPB from further \nchange for the remainder of normal system operation by cl earing the PPB Lock bit to 0. This is sometimes called \nBoot-code controlled sector protection.\nThe Password method clears the PPB Lock bit to 0 during POR, or Hardware Reset to protect the PPB. A 64-bit \npassword may be permanently programmed and hidden fo r the password method. A command can be used to \nprovide a password for comparison with the hidden password. If the password matches, the PPB Lock bit is set to 1 to unprotect the PPB. A command can be used to clear the PPB Lock bit to 0. This method requires use of a password to control PPB protection.\nThe selection of the PPB Lock bit management method is made by programming OTP bits in the ASP Register so \nas to permanently select the method used.ASP Register  \nOne Time Programmable  \nPassword Method  \n(ASPR[2]=0) Persistent Method  \n(ASPR[1]=0) \n64 - bit Password  \n(One Time Protect)  \nPBB Lock Bit  \n“0” = PPBs locked  \nSector 0  Memory Array  \nSector N  - 2 Sector 1  \nSector 2  \nSector N  - 1 \nSector N  \n1.) N = Highest Address Sector  PPB 0  Persistent \nProtection Bit  \n(PPB) \nPPB N  - 2 PPB 1  \nPPB 2  \nPPB N  - 1 \nPPB N  DYB 0  Dynamic \nProtection Bit  \n(DYB) \nDYB N  - 2 DYB 1  \nDYB 2  \nDYB N  - 1 \nDYB N  \n2.) 3.) DYB are volatile bits  “1”=PPBs unlocked  64 - bit Password  \n(One Time Protect)  \nSector 0  Memory Array  \nSector N  - 2 Sector 1  \nSector 2  \nSector N  - 1 \nSector N  \n1.) N = Highest Address Sector,  \na sector is protected if its PPB =”0”  or its DYB = “0” PPB 0  Persistent \nProtection Bits  \n(PPB) \nPPB N  - 2 PPB 1  \nPPB 2  \nPPB N  - 1 \nPPB N  DYB 0  Dynamic \nProtection Bits  \n(DYB) \nDYB N  - 2 DYB 1  \nDYB 2  \nDYB N  - 1 \nDYB N  \nPPB are programmed individually \nbut erased as a group 3.) DYB are volatile bits  4.) PPB Lock bit is volatile and defaults to “1” (persistent mode).or “0” (password mode) upon reset \n5.) PPB Lock = “0” locks all PPBs \nto their current state\n 6.) Password Method requires a password to set PPB Lock to “1” to enable program or erase of PPB bits 7.) Persistent  Method only allows PPB Lock to be cleared to “0” to prevent program or erase of PPB bits. Power off or hardware reset required to  set PPB Lock to “1” \nDatasheet 69 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData protection\n8.4.1 ASP register\nThe ASP register is used to permanen tly configure the behavior of Advanced Sector Protection (ASP) features. \nSee Table 29 .\nAs shipped from the factory, all devices default ASP to the Persistent Protection mode, with all sectors unpro-\ntected, when power is applied. The device programmer or host system must then choose which sector protection \nmethod to use. Programming either of the, one-time pr ogrammable, Protection Mode Lock Bits, locks the part \npermanently in the selected mode:\n• ASPR[2:1] = 11 = No ASP mode selected, Pe rsistent Protection Mode is the default.\n• ASPR[2:1] = 10 = Persistent Protection Mode permanently selected.\n• ASPR[2:1] = 01 = Password Protection Mode permanently selected.\n• ASPR[2:1] = 00 = Illegal condition, attempting to progra m both bits to zero results in a programming failure.\nASP register programming rules:\n• If the password mode is chosen, the password must be programmed prior to setting the Protection Mode Lock \nBits.\n• Once the Protection Mode is selected, the Protection Mode Lock Bits are permanently protected from \nprogramming and no further changes to the ASP register is allowed.\nThe programming time of the ASP Register is the same as the typical page progra mming time. The system can \ndetermine the status of the ASP register programming op eration by reading the WIP bit in the Status Register. \nSee “Status register 1 (SR1)” on page 56 for information on WIP .\nAfter selecting a sector protection method, each se ctor can operate in each of the following states:\n• Dynamically Locked — A sector is protected and can be changed by a simple command.• Persistently Locked — A sector is protected and cannot be changed if its PPB Bit is 0.\n• Unlocked — The sector is unprotected and can be changed by a simple command.\n8.4.2 Persistent protection bits\nThe Persistent Protection Bits (PPB) are located in a sepa rate non-volatile flash array. One of the PPB bits is \nrelated to each sector. When a PPB is 0, its related sector is protected from program and erase operations. The PPB are programmed individually but must be erased as  a group, similar to the way individual words may be \nprogrammed in the main array but an entire sector must be erased at the same time. The PPB have the same \nprogram and erase endurance as the main flash memory array. Preprogramming and verification prior to erasure are handled by the device.\nProgramming a PPB bit requires the typical page programmi ng time. Erasing all the PPBs requires typical sector \nerase time. During PPB bit programming and PPB bit erasing,  status is available by reading the Status register. \nReading of a PPB bit requires the initial access time of the device.\nNotes\nEach PPB is individually programmed to 0 and all are erased to 1 in parallel.\nIf the PPB Lock bit is 0, the PPB Program or PPB Eras e command does not execute and fails without programming \nor erasing the PPB.\nThe state of the PPB for a given sector can be verified by using the PPB Read command.\n8.4.3 Dynamic protection bits\nDynamic Protection Bits are volatile and unique for ea ch sector and can be indi vidually modified. DYB only \ncontrol the protection for sectors that have their PPB set to 1. By issuing the DYB Write command, a DYB is cleared \nto 0 or set to 1, thus placing each sector in the protected or unprotected state respectively. This feature allows software to easily protect sectors against inadverten t changes, yet does not prevent the easy removal of \nprotection when changes are needed. The DYBs can be set or  cleared as often as needed as they are volatile bits.\nDatasheet 70 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData protection\n8.4.4 PPB lock bit (PPBL[0])\nThe PPB Lock Bit is a volatile bit for protecting all PPB bi ts. When cleared to 0, it locks all PPBs and when set to \n1, it allows the PPBs to be changed.\nThe PLBWR command is used to clear the PPB Lock bit to 0. The PPB Lock Bit must be cleared to 0 only after all \nthe PPBs are configured to the desired settings.\nIn Persistent Protection mode, the PPB Lock is set to 1 during POR or a hardware reset. When cleared to 0, no \nsoftware command sequence can set the PPB Lock bit to 1, only another hardware reset or power-up can set the \nPPB Lock bit.\nIn the Password Protection mode, the PPB Lock bit is cleared to 0 during POR or a hardware reset. The PPB Lock \nbit can only be set to 1 by the Password Unlock command.\n8.4.5 Sector protection states summary\nEach sector can be in one of the following protection states:\n• Unlocked — The sector is unprotected and protection can be changed by a simple command. The protection \nstate defaults to unprotected after a power cycle, software reset, or hardware reset.\n• Dynamically Locked — A sector is protected and protection can be changed by a simple command. The \nprotection state is not saved across a power cycle or reset.\n• Persistently Locked — A sector is protected and protection  can only be changed if the PPB Lock Bit is set to 1. \nThe protection state is non-volatile and saved across a power cycle or reset. Changing the protection state requires programming and or erase of the PPB bits\n8.4.6 Persistent protection mode\nThe Persistent Protection method sets the PPB Lock bit to  1 during POR or Hardware Reset so that the PPB bits \nare unprotected by a device hardware reset. Software  reset does not affect the PPB Lock bit. The PLBWR \ncommand can clear the PPB Lock bit to 0 to protect th e PPB. There is no command to set the PPB Lock bit \ntherefore the PPB Lock bit will remain at 0 until the next power-off or hardware reset.\n8.4.7 Password protection mode\nPassword Protection Mode allows an even higher level of security than the Persistent Sector Protection Mode, by \nrequiring a 64-bit password for unlocking the PPB Lock bit.  In addition to this password requirement, after power \nup and hardware reset, the PPB Lock bit is cleared to 0 to ensure protection at power-up. Successful execution of the Password Unlock command by en tering the entire password clears the PPB Lock bit, allowing for sector \nPPB modifications.\nPassword Protection Notes\n• Once the Password is programmed and verified, the Passwor d Mode (ASPR[2]=0) must be set in order to prevent \nreading the password.Table 39 Sector protection states\nProtection Bit Values  Sector StatePPB Lock PPB DYB\n1 1 1 Unprotected – PPB and DYB are changeable 1 1 0 Protected – PPB and DYB are changeable 1 0 1 Protected – PPB and DYB are changeable 1 0 0 Protected – PPB and DYB are changeable 0 1 1 Unprotected – PPB not changeable, DYB is changeable0 1 0 Protected – PPB not changeable, DYB is changeable 0 0 1 Protected – PPB not changeable, DYB is changeable 0 0 0 Protected – PPB not changeable, DYB is changeable \nDatasheet 71 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData protection\n• The Password Program Command is only capable of programming ‘0’s. Programming a 1 after a cell is \nprogrammed as a 0 results in the cell left as a 0 with no programming error set.\n• The password is all 1’s when shipped from Infineon. It  is located in its own memory space and is accessible \nthrough the use of the Password Program and Password Read commands.\n• All 64-bit password combinations are valid as a password.• The Password Mode, once programmed, prevents reading the 64-bit password and further password \nprogramming. All further program and read commands  to the password region are disabled and these \ncommands are ignored. There is no means to verify what  the password is after the Password Mode Lock Bit is \nselected. Password verification is only allowed before selecting the Password Protection mode.\n• The Protection Mode Lock Bits are not erasable.\n• The exact password must be entered in order for the unlocking function to occur. If the password unlock \ncommand provided password does not match the hidden in ternal password, the unlock operation fails in the \nsame manner as a programming operation on a protected sector. The P_ERR bit is set to one and the WIP Bit \nremains set. In this case it is a failure to change the st ate of the PPB Lock bit because it is still protected by the \nlack of a valid password.\n• The Password Unlock command cannot be accepted any faster than once every 100 µs ± 20 µs. This makes it \ntake an unreasonably long time (58 million years) for a hacker to run through all the 64-bit combinations in an attempt to correctly match a password. The Read Status Register 1 command may be used to read the WIP bit to determine when the device has completed the passw ord unlock command or is ready to accept a new \npassword command. When a valid password is provided  the password unlock command does not insert the \n100 µs delay before returning the WIP bit to zero.\n• If the password is lost after selecting the Passwor d Mode, there is no way to set the PPB Lock bit.\n• ECC status may only be read from sectors that are read able. In read protection mode the addresses are forced \nto the boot sector address. ECC status is shown in that sector while read protection mode is active.\nDatasheet 72 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9C o m m a n d s\nAll communication between the host system and the S25F L512S memory device is in the form of units called \ncommands. \nAll commands begin with an instruction that selects the type of information transfer or device operation to be \nperformed. Commands may also have an address, instruct ion modifier, latency period, data transfer to the \nmemory, or data transfer from the memory. All instruction,  address, and data information is transferred serially \nbetween the host system and memory device.\nAll instructions are transferred from  host to memory as a single bit serial sequence on the SI signal.\nSingle bit wide commands may provide an address or data sent only on the SI signal. Data may be sent back to \nthe host serially on SO signal.\nDual or Quad Output commands provide an address sent to the memory only on the SI signal. Data will be \nreturned to the host as a sequence of bit pairs on I/O0 and I/O1 or four bit (nibble) groups on I/O0, I/O1, I/O2, and I/O3. \nDual or Quad Input/Output (I/O) comma nds provide an address sent from the host as bit pairs on I/O0 and I/O1 \nor, four bit (nibble) groups on I/O0, I/O1, I/O2, and I/O3. Data is returned to the host similarly as bit pairs on I/O0 and I/O1 or, four bit (nibble) groups on I/O0, I/O1, I/O2, and I/O3.\nCommands are structured as follows:\n• Each command begins with an eight bit (byte) instruction.\n• The instruction may be stand alone or may be followed by address bits to select a location within one of several \naddress spaces in the device. The address may be either a 24-bit or 32-bit byte boundary address. \n• The Serial Peripheral Interface with Multiple I/O provides  the option for each transfer of address and data infor-\nmation to be done one, two, or four bits in parallel . This enables a trade off be tween the number of signal \nconnections (I/O bus width) and the speed of information transfer. If the host system can support a two or four \nbit wide I/O bus the memory performance can be increase d by using the instructions that provide parallel two \nbit (dual) or parallel four bit (quad) transfers.\n• The width of all transfers following the instru ction are determined by the instruction sent. \n• All sIngle bits or parallel bit groups are transferred in most to least significant bit order.\n• Some instructions send instruction modifier (mode) bi ts following the address to indicate that the next \ncommand will be of the same type with an implied, rather than an explicit , instruction. The next command thus \ndoes not provide an instruction byte, only a new address and mode bits. This reduces the time needed to send \neach command when the same command type is repeated in a sequence of commands.\n• The address or mode bits may be followed by write data to be stored in the memory device or by a read latency \nperiod before read data is returned to the host. \n• Read latency may be zero to several SCK cycles (also referred to as dummy cycles). • All instruction, address, mode, and data information is transferred in byte granularity. Addresses are shifted \ninto the device with the MSB first. All data is transferre d with the lowest address byte sent first. Following bytes \nof data are sent in lowest to highest byte address order i.e. the byte address increments.\n• All attempts to read the flash memory array during a pr ogram, erase, or a write cycle (embedded operations) \nare ignored. The embedded operation will continue to execute without any affect. A very limited set of \ncommands are accepted during an embedded operatio n. These are discussed in the individual command \ndescriptions. While a program, erase, or write operation is in progress, it is recommended to check that the \nWrite-In Progress (WIP) bit is 0 before issuing most co mmands to the device, to ensure the new command can \nbe accepted. \n• Depending on the command, the time for execution vari es. A command to read status information from an \nexecuting command is available to determine when the command completes execution and whether the \ncommand was successful.\n• Although host software in some cases is  used to directly control the SPI interface signals, the hardware interfaces \nof the host system and the memory device generally hand le the details of signal relationships and timing. For \nDatasheet 73 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nthis reason, signal relationships and timing are not cove red in detail within this software interface focused \nsection of the document. Instead, the focus is on the logical sequence of bits transferred in each command \nrather than the signal timing and relationships. Followin g are some general signal relationship descriptions to \nkeep in mind. For additional information on the bit leve l format and signal timing relationships of commands, \nsee “Command protocol” on page 18.\n- The host always controls the Chip Select (CS#), Serial Clock (SCK), and Serial Input (SI) - SI for single bit wide \ntransfers. The memory drives Serial Ou tput (SO) for single bit read transf ers. The host and memory alternately \ndrive the I/O0-I/O3 signals durin g Dual and Quad transfers. \n- All commands begin with the host selecting the memory by  driving CS# low before the first rising edge of SCK. \nCS# is kept low throughout a command and when CS# is returned high the command ends. Generally, CS# \nremains low for eight bit transfer multiples to transfer  byte granularity information. Some commands will not \nbe accepted if CS# is returned high not at an 8 bit boundary.\n9.1 Command set summary\n9.1.1  Extended addressing\nTo accommodate addressing above 128 Mb, there are three options:\n1. New instructions are provided with 4-byte addr ess, used to access up to 32 Gb of memory.\n2. For backward compatibility to the 3-byte address inst ructions, the standard inst ructions can be used in \nconjunction with the EXTADD Bit in the Bank Address Register (BAR[7]). By default BAR[7] is cleared to 0 (following power up and hardware reset), to enable 3-byte (24-bit) addressing. When set to 1, the legacy Instruction name Description Code (Hex)\n4FAST_READ Read Fast (4-byte Address) 0C\n4READ Read (4-byte Address) 13\n4DOR Read Dual Out (4-byte Address) 3C\n4QOR Read Quad Out (4-byte Address) 6C\n4DIOR Dual I/O Read (4-byte Address) BC\n4QIOR Quad I/O Read  (4-byte Address) EC\n4DDRFR Read DDR Fast (4-byte Address) 0E\n4DDRDIOR DDR Dual I/O Read (4-byte \nAddress)BE\n4DDRQIOR DDR Quad I/O Read (4-byte \nAddress)EE\n4PP Page Program (4-byte Address) 12\n4QPP Quad Page Program (4-byte \nAddress)34\n4SE Erase 256 kB (4-byte Address) DC\nDatasheet 74 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\ncommands are changed to require 4 bytes (32 bits) for the address field. The following instructions can be used \nin conjunction with EXTADD bit to switch from 3 bytes to 4 bytes of address field.\n3. For backward compatibility to the 3-byte addressing, the standard instructions can be used in conjunction \nwith the Bank Address Register:\na. The Bank Address Register is used to switch between  128-Mb (16-MB) banks of memory, The standard 3-byte \naddress selects an address within the bank  selected by the Bank Address Register.\ni. The host system writes the Ba nk Address Register to access beyond the first 128 Mb of memory.\nii. This applies to read, erase, and program commands.\nb. The Bank Register provides the high order (4th) byte  of address, which is used to address the available \nmemory at addresses greater than 16 MB.\nc. Bank Register bits are volatile.\ni. On power up, the default is Bank0 (the lowest address 16 MB).\nd. For Read, the device will continuously tr ansfer out data until the end of the array.\ni. There is no bank to bank delay.\nii. The Bank Address Register is not updated.\niii. The Bank Address Register value is used only for the in itial address of an access.Instruction name Description Code (Hex)\nREAD Read (3-byte Address) 03\nFAST_READ Read Fast (3-byte Address) 0B\nDOR Read Dual Out (3-byte Address) 3B\nQOR Read Quad Out (3-byte Address) 6B\nDIOR Dual I/O Read (3-byte Address) BB\nQIOR Quad I/O Read (3-byte Address) EB\nDDRFR Read DDR Fast (3-byte Address) 0D\nDDRDIOR DDR Dual I/O Read (3-byte \nAddress)BD\nDDRQIOR DDR Quad I/O Read (3-byte \nAddress)ED\nPP Page Program (3-byte Address) 02\nQPP Quad Page Program (3-byte \nAddress)32\nSE Erase 256 kB (3-byte Address) D8\nTable 40 Bank address map\nBank Address Register BitsBank Memory Array Address Range (Hex)Bit 1 Bit 0\n0 0 0 00000000 00FFFFFF0 1 1 01000000 01FFFFFF1 0 2 02000000 02FFFFFF1 1 3 03000000 03FFFFFF\nDatasheet 75 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nTable 41 S25FL512S command set (sorted by function)\nFunctionCommand \nname Command description Instruction \nvalue (Hex)Maximum \nfrequency \n(MHz)\nRead Device \nIdentificationREAD_ID \n(REMS) Read Electronic Manufacturer Signature 90 133\nRDID Read ID (JEDEC Manufacturer ID and JEDEC CFI) 9F 133\nRES Read Electronic Signature AB 50\nRSFDP Read Serial Flash Discoverable Parameters 5A 133\nRegister \nAccessRDSR1 Read Status Register-1 05 133\nRDSR2 Read Status Register-2 07 133\nRDCR Read Configuration Register-1 35 133\nWRR Write Register (Status-1, Configuration-1) 01 133\nWRDI Write Disable 04 133\nWREN Write Enable 06 133\nCLSR Clear Status Register-1 - Erase/Prog. Fail Reset 30 133\nECCRD ECC Read (4-byte address 18 133\nABRD AutoBoot Register Read 14 133 \n(QUAD=0)\n104 \n(QUAD=1)\nRegister \nAccessABWR AutoBoot Register Write 15 133\nBRRD Bank Register Read 16 133\nBRWR Bank Register Write 17 133\nBRAC Bank Register Access \n(Legacy Command formerly used for Deep Power Down)B9 133\nDLPRD Data Learning Pattern Read 41 133\nPNVDLR Program NV Data Learning Register 43 133\nWVDLR Write Volatile Data Learning Register 4A 133\nDatasheet 76 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nRead Flash \nArrayREAD Read (3- or 4-byte address) 03 50\n4READ Read (4-byte address) 13 50\nFAST_READ Fast Read (3- or 4-byte address) 0B 133\n4FAST_READ Fast Read (4-byte address) 0C 133\nDDRFR DDR Fast Read (3- or 4-byte address) 0D 80\n4DDRFR DDR Fast Read (4-byte address) 0E 80\nDOR Read Dual Out (3- or 4-byte address) 3B 104\n4DOR Read Dual Out (4-byte address) 3C 104\nQOR Read Quad Out (3- or 4-byte address) 6B 104\n4QOR Read Quad Out (4-byte address) 6C 104\nDIOR Dual I/O Read (3- or 4-byte address) BB 104\n4DIOR Dual I/O Read (4-byte address) BC 104\nDDRDIOR DDR Dual I/O Read (3- or 4-byte address) BD 80\n4DDRDIOR DDR Dual I/O Read (4-byte address) BE 80\nQIOR Quad I/O Read (3- or 4-byte address) EB 104\n4QIOR Quad I/O Read (4-byte address) EC 104\nDDRQIOR DDR Quad I/O Read (3- or 4-byte address) ED 80\n4DDRQIOR DDR Quad I/O Read (4-byte address) EE 80\nProgram Flash \nArrayPP Page Program (3- or 4-byte address) 02 133\n4PP Page Program (4-byte address) 12 133\nQPP Quad Page Program (3- or 4-byte address) 32 80QPP Quad Page Program - Alternate instruction (3- or \n4-byte address)38 80\n4QPP Quad Page Program (4-byte address) 34 80\nPGSP Program Suspend 85 133\nPGRS Program Resume 8A 133\nErase Flash \nArrayBE Bulk Erase 60 133\nBE Bulk Erase (alternate command) C7 133\nSE Erase 256 kB (3- or 4-byte address) D8 133\n4SE Erase 256 kB (4-byte address) DC 133\nERSP Erase Suspend 75 133ERRS Erase Resume 7A 133\nOne Time \nProgram ArrayOTPP OTP Program 42 133\nOTPR OTP Read 4B 133Table 41 S25FL512S command set (sorted by function)\n (continued)\nFunctionCommand \nname Command description Instruction \nvalue (Hex)Maximum \nfrequency \n(MHz)\nDatasheet 77 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.1.2 Read device identification\nThere are multiple commands to read information about the device manufacturer, device type, and device \nfeatures. SPI memories from different vendors have used different commands and formats for reading infor-\nmation about the memories. The S25FL512S device s upports the three most common device information \ncommands.\n9.1.3 Register read or write\nThere are multiple registers for reporting embedded op eration status or controlling device configuration \noptions. There are commands for reading or writing th ese registers. Registers contain both volatile and \nnon-volatile bits. Non-volatile bits in registers are automatically erased and programmed as a single (write) \noperation.\n9.1.3.1 Monitoring operation status\nThe host system can determine when a write, program, er ase, suspend or other embedded operation is complete \nby monitoring the Write in Progress (WIP) bit in the Status Register. The Read from Status Register-1 command \nprovides the state of the WIP bit. The program error (P_E RR) and erase error (E_ERR) bits in the status register \nindicate whether the most recent program or erase command has not completed successfully. When P_ERR or E_ERR bits are set to one, the WIP bit will remain set to one indicating the device remains busy. Under this \ncondition, only the CLSR, WRDI, RD SR1, RDSR2, and software RESET commands are valid commands. A Clear \nStatus Register (CLSR) followed by a Write Disable (WRDI) command must be sent to return the device to standby \nstate. CLSR clears the WIP , P_ERR, and E_ERR bits. WRDI clears the WEL bit. Alternatively, Hardware Reset, or \nSoftware Reset (RESET) may be used to return the device to standby state.Advanced \nSector \nProtectionDYBRD DYB Read E0 133\nDYBWR DYB Write E1 133\nPPBRD PPB Read E2 133\nPPBP PPB Program E3 133\nPPBE PPB Erase E4 133\nASPRD ASP Read 2B 133\nASPP ASP Program 2F 133\nPLBRD PPB Lock Bit Read A7 133\nPLBWR PPB Lock Bit Write A6 133\nPASSRD Password Read E7 133\nPASSP Password Program E8 133\nPASSU Password Unlock E9 133\nReset RESET Software Reset F0 133\nMBR Mode Bit Reset FF 133\nReserved for \nFuture UseMPM Reserved for Multi-I/O-High Perf Mode (MPM) A3 133\nRFU Reserved-18 Reserved 18\nRFU Reserved-E5 Reserved E5RFU Reserved-E6 Reserved E6Table 41 S25FL512S command set (sorted by function)\n (continued)\nFunctionCommand \nname Command description Instruction \nvalue (Hex)Maximum \nfrequency \n(MHz)\nDatasheet 78 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.1.3.2 Configuration\nThere are commands to read, write, and protect registers that control interface path width, interface timing, \ninterface address length, and some aspects of data protection.\n9.1.4 Read flash array\nData may be read from the memory starting at any byte boundary. Data bytes are sequentially read from incre-mentally higher byte addresses until the host ends the data  transfer by driving CS# input High. If the byte address \nreaches the maximum address of the memory array, the read will continue at address zero of the array.\nThere are several different read commands to specify differ ent access latency and data path widths. Double Data \nRate (DDR) commands also define the address an d data bit relationship to both SCK edges:\n• The Read command provides a single address bit per SCK rising edge on the SI signal with read data returning \na single bit per SCK falling edge on the SO signal. This command has zero latency between the address and the returning data but is limited to a maximum SCK rate of 50 MHz.\n• Other read commands have a latency period between th e address and returning data but can operate at higher \nSCK frequencies. The latency depends on the configuration register latency code.\n• The Fast Read command provides a single address bit pe r SCK rising edge on the SI signal with read data \nreturning a single bit per SCK falling edge on  the SO signal and may operate up to 133 MHz.\n• Dual or Quad Output read commands provide address a si ngle bit per SCK rising edge on the SI / I/O0 signal \nwith read data returning two bits, or four bits of  data per SCK falling edge on the I/O0-I/O3 signals.\n• Dual or Quad I/O Read commands provide address two bits or four bits per SCK rising edge with read data \nreturning two bits, or four bits of data per SCK falling edge on the I/O0-I/O3 signals.\n• Fast (Single), Dual, or Quad Double Data Rate read commands provide address one bit, two bits or four bits per \nevery SCK edge with read data returning one bit, two bits, or four bits of data per every SCK edge on the I/O0-I/O3 \nsignals. Double Data Rate (DDR) operation is only  supported for core and I/O voltages of 3 to 3.6V.\n9.1.5 Program flash array\nProgramming data requires two commands: Write Enable  (WREN), and Page Progra m (PP or QPP). The Page \nProgram command accepts from 1 byte up to 512 consecutive bytes of data (page) to be programmed in one operation. Programming means that bits can either be left  at 1, or programmed from 1 to 0. Changing bits from \n0 to 1 requires an erase operation.\n9.1.6 Erase flash array\nThe Sector Erase (SE) and Bulk Erase (BE) commands set all the bits in a sector or the entire memory array to 1. \nA bit needs to be first erased to 1 before programming can change it to a 0. While bits can be individually programmed from a 1 to 0, erasing bits from 0 to 1 must be done on a sector-wide (SE) or array-wide (BE) level.\n9.1.7 OTP , block protection, and advanced sector protection\nThere are commands to read and program a separate One TIme Programmable (OTP) array for permanent data such as a serial number. There are commands to control a contiguous group (block) of flash memory array sectors \nthat are protected from program and erase operations. There are commands to control which individual flash \nmemory array sectors are protected from program and erase operations.\n9.1.8 Reset\nThere is a command to reset to the default conditions present after power on to the device. There is a command to reset (exit from) the Enhanc ed Performance Read Modes. \nDatasheet 79 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.1.9 Reserved\nSome instructions are reserved for future use. In th is generation of the S25FL512S some of these command \ninstructions may be unused and not affect device  operation, some may have undefined results. \nSome commands are reserved to ensure  that a legacy or alternate source  device command is allowed without \naffect. This allows legacy software to issue some co mmands that are not relevant for the current generation \nS25FL512S device with the assurance these comma nds do not cause some unexpected action. \nSome commands are reserved for use in special versions of the FL-S not ad dressed by this document or for a \nfuture generation. This allows new host memory controller designs to plan the flexibility to issue these command instructions. The command format is defined if known at the time this document revision is published.\n9.2 Identification commands\n9.2.1 Read identification - REMS (Read_ID or REMS 90h)\nThe READ_ID command identifies the Device Manufacturer ID  and the Device ID. The command is also referred to \nas Read Electronic Manufacturer and device Signature (REMS). READ-ID (REMS) is only supported for backward \ncompatibility and should not be used for new software designs. New software designs should instead make use \nof the RDID command. \nThe command is initiated by shifting on SI the instru ction code “90h” followed by a 24-bit address of 00000h. \nFollowing this, the Manufacturer ID and th e Device ID are shifted out on SO starting at the falling edge of SCK after \naddress. The Manufacturer ID and the De vice ID are always shifted out with th e MSb first. If the 24-bit address is \nset to 000001h, then the Device ID is read out first follo wed by the Manufacturer ID. The Manufacturer ID and \nDevice ID output data toggles between address 000000H an d 000001H until terminated by a low to high transition \non CS# input. The maximum clock frequency for the READ_ID command is 133 MHz.\nFigure 47 READ_ID (90h) command sequence\n9.2.2 Read identification (RDID 9Fh)\nThe Read Identification (RDID) command provides read access to manufacturer identification, device identifi-\ncation, and Common Flash Interface (CFI) information. The ma nufacturer identification is  assigned by JEDEC. The \nCFI structure is defined by JEDEC standard. The device id entification and CFI values are assigned by Infineon.\nThe JEDEC Common Flash Interface (CFI) specification defi nes a device information structure, which allows a \nvendor-specified software flash management program (drive r) to be used for entire families of flash devices. \nSoftware support can then be device-independent, JEDEC manufacturer ID independent, forward and \nbackward-compatible for the specified flash device famili es. System vendors can standardize their flash drivers Table 42 Read_ID values\nDevice Manufacturer ID (hex) Device ID (hex)\nS25FL512S 01 19CS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321023  10  \n7654321076543210 \nInstruction (90h) Manufacturer ID Device ID Address\nDatasheet 80 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nfor long-term software compatibility by using the CFI values  to configure a family driver from the CFI information \nof the device in use.\nAny RDID command issued while a progra m, erase, or write cycle is in prog ress is ignored and has no effect on \nexecution of the program, erase, or  write cycle that is in progress.\nThe RDID instruction is shifted on SI. After the last bit of the RDID instruction is shifte d into the device, a byte of \nmanufacturer identification, two bytes of device identi fication, extended device identification, and CFI infor-\nmation will be shifted sequentially out on SO. As a wh ole this information is referred to as ID-CFI. See “ID-CFI \naddress space” on page 53 for the detail description of the ID-CFI contents. \nContinued shifting of output beyond the end of the defi ned ID-CFI address space will provide undefined data. The \nRDID command sequence is terminated  by driving CS# to the logic high state anytime during data output.\nThe maximum clock fr equency for the RDID command is 133 MHz.\nFigure 48 Read identification (RDID 9Fh) command sequence\n9.2.3 Read electronic signature (RES) (ABh)\nThe RES command is used to read a single byte Electronic Signature from SO. RES is only supported for backward \ncompatibility and should not be used for new software designs. New software designs should instead make use \nof the RDID command.\nThe RES instruction is shifted in followed by three dummy  bytes onto SI. After the last bit of the three dummy \nbytes are shifted into the device, a byte of Electronic Signat ure will be shifted out of SO. Each bit is shifted out by \nthe falling edge of SCK. Th e maximum clock frequency for the RES command is 50 MHz.\nThe Electronic Signature can be read repeatedly  by applying multiples of eight clock cycles.\nThe RES command sequence is terminated  by driving CS# to the logic high  state anytime during data output.\nFigure 49 Read electronic signature (RES ABh) command sequence\nTable 43 RES values\nDevice Device ID (hex)\nS25FL512S 19CS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nCS#\nSCK\nSI\nSO\nPhase \n                                \n7654321023 10  \n76543210 \nInstruction (ABh)        Dummy Device ID\nDatasheet 81 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.2.4 Read serial flash discover able parameters (RSFDP 5Ah)\nThe command is initiated by shifting on SI the instru ction code ‘5Ah’ , followed by a 24-bit address of 000000h, \nfollowed by eight dummy cycles. The SFDP bytes are then sh ifted out on SO starting at the falling edge of SCK \nafter the eight dummy cycles. The SFDP bytes are always shif ted out with the MSb first. If the 24-bit address is set \nto any other value, the selected location in the SFDP sp ace is the starting point of the data read. This enables \nrandom access to any parameter in the SFDP space. The maximum clock frequency for the RSFDP command is \n133 MHz.\nFigure 50 RSFDP command sequence\n9.3 Register access commands\n9.3.1 Read status register-1 (RDSR1 05h)\nThe Read Status Register-1 (RDSR1) command allows the Status Register-1 contents to be read from SO. The \nStatus Register-1 contents may be read at any time, even while a program, erase, or write operation is in progress. \nIt is possible to read the Status Register-1 continuously by providing multiples of eigh t clock cycles. The status is \nupdated for each eight cycle read. The maximum cloc k frequency for the RDSR1 (05h) command is 133 MHz.\nFigure 51 Read status register-1 (RDSR1 05h) command sequence\n9.3.2 Read status register-2 (RDSR2 07h)\nThe Read Status Register (RDSR2) command allows the Status  Register-2 contents to be read from SO. The Status \nRegister-2 contents may be read at any time, even while a program, erase, or write operation is in progress. It is \npossible to read the Status Register-2 continuously by providing multiples of eight clock cycles. The status is \nupdated for each eight cycle read. The maximum clock frequency for the RDSR2 command is 133 MHz.CS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321023  10  \n76543 210 \nInstruction Address Dummy Cycles Data 1\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Status    Updated Status\nDatasheet 82 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nFigure 52 Read status register-2 (RDSR2 07h) command sequence\n9.3.3 Read configuration register (RDCR 35h)\nThe Read Configuration Register (RDCR)  command allows the Configuration Register contents to be read from \nSO. It is possible to read the Configuration Register cont inuously by providing multiple s of eight clock cycles. The \nConfiguration Register contents may be read at any time, even while a program, erase, or write operation is in \nprogress.\nFigure 53 Read configuration register (RDCR 35h) command sequence\n9.3.4 Bank register read (BRRD 16h)\nThe Read the Bank Register (BRRD) command allows the Bank address Register contents to be read from SO. The \ninstruction is first shifted in from SI. Then the 8-bit Bank Register is shifted out on SO. It is possible to read the \nBank Register continuously by providing multiples of eight clock cycles. The maximu m operating clock frequency \nfor the BRRD command is 133 MHz.\nFigure 54 Read bank register (BRRD 16h) command\n9.3.5 Bank register write (BRWR 17h)\nThe Bank Register Write (BRWR) command is used to write address bits above A23, into  the Bank Address Register \n(BAR). The command is also used to write the Extended ad dress control bit (EXTADD) that is also in BAR[7]. BAR \nprovides the high order addresses needed by devices having more than 128 Mb ( 16 MB), when using 3-byte \naddress commands without extended addressing enabled (BAR[7] EXTADD = 0). Because this command is part of CS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Status    Updated Status\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\n7 6 5 43 2 1 0 7 6 5 4 3 2 1 0\nInstruction Register Read Repeat Register Read\nDatasheet 83 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nthe addressing method and is not changing data in th e flash memory, this command does not require the WREN \ncommand to precede it.\nThe BRWR instruction is entered, followed by the data byte  on SI. The Bank Register is one data byte in length.\nThe BRWR command has no effect on the P_ERR, E_ERR or  WIP bits of the Status and Configuration Registers. \nAny bank address bit reserved for the fu ture should always be written as a 0.\nFigure 55 Bank register write (BRWR 17h) command\n9.3.6 Bank register access (BRAC B9h)\nThe Bank Register Read and Write commands provide full ac cess to the Bank Address Register (BAR) but they are \nboth commands that are not present in legacy SPI memo ry devices. Host system SPI memory controller inter-\nfaces may not be able to easily su pport such new commands. The Bank Register Access (BRAC) command uses \nthe same command code and format as the Deep Power Down (DPD) command that is available in legacy SPI \nmemories. The FL-S family does not support a DPD featur e but assigns this legacy command code to the BRAC \ncommand to enable write access to the Bank Address Regist er for legacy systems that are able to send the legacy \nDPD (B9h) command.\nWhen the BRAC command is sent, the FL-S family devi ce will then interpret an immediately following Write \nRegister (WRR) command as a write to the lower address bits of the BAR. A WREN command is not used between \nthe BRAC and WRR commands. Only the lower two bits of  the first data byte following the WRR command code \nare used to load BAR[1:0]. The upper bits of that byte and the content of the optional WRR command second data \nbyte are ignored. Following the WRR command the access to  BAR is closed and the devi ce interface returns to the \nstandby state. The combined BRAC followed by WRR comm and sequence has no affect on the value of the ExtAdd \nbit (BAR[7]). \nCommands other than WRR may immediately follow BRAC and execute normally. However, any command other \nthan WRR, or any other sequence in which CS# goes lo w and returns high, following a BRAC command, will close \nthe access to BAR and return to the normal interpretation  of a WRR command as a write to Status Register-1 and \nthe Configuration Register. \nThe BRAC + WRR sequence is allowed only when the devi ce is in standby, program suspend, or erase suspend \nstates. This command sequence is illegal when the devi ce is performing an embedded algorithm or when the \nprogram (P_ERR) or erase (E_ERR) status bits are set to 1. \nFigure 56 BRAC (B9h) command sequence\n9.3.7 Write registers (WRR 01h)\nThe Write Registers (WRR) command allows new values to be written to both the Status Register-1 and Configu-\nration Register. Before the Write Registers (WRR) command can be accepted by the device, a Write Enable (WREN) CS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Data\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDatasheet 84 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\ncommand must be received. After the Write Enable (WRE N) command has been decoded successfully, the device \nwill set the Write Enable Latch (WEL) in the St atus Register to enable any write operations.\nThe Write Registers (WRR) command is entered by shifting  the instruction and the data bytes on SI. The Status \nRegister is one data byte in length.\nThe Write Registers (WRR) command will set the P_ERR or E_ ERR bits if there is a failure in the WRR operation. \nAny Status or Configuration Register bit reserved for the future must be written as a 0.\nCS# must be driven to the logic high state after the eighth  or sixteenth bit of data has been latched. If not, the \nWrite Registers (WRR) command is not executed. If CS# is dr iven high after the eighth cycle then only the Status \nRegister-1 is written; otherwise, after the sixteenth cycl e both the Status and Configur ation Registers are written. \nWhen the configuration register QUAD bit CR[1] is 1, only the WRR command format with 16 data bits may be used. \nAs soon as CS# is driven to  the logic high state, the self-timed Write Registers (WRR) operation is initiated. While \nthe Write Registers (WRR) operation is in progress, the Stat us Register may still be read  to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during the self-timed Write Registers (WRR) \noperation, and is a 0 when it is completed. When the Write Registers (WRR) operatio n is completed, the Write \nEnable Latch (WEL) is set to a 0. The WRR command mu st be executed under continuous power. The maximum \nclock frequency for the WRR command is 133 MHz.\nFigure 57 Write registers (WRR 01h) command sequence – 8 data bits\nFigure 58 Write registers (WRR 01h) command sequence – 16 data bits\nThe Write Registers (WRR) command allows the user to ch ange the values of the Block Protect (BP2, BP1, and \nBP0) bits to define the size of the area that is to be treated as read-only. The Write Registers (WRR) command also allows the user to set the Status Register Write Disable (S RWD) bit to a 1 or a 0. The Status Register Write Disable \n(SRWD) bit and Write Protect (WP#) signal allow the BP bits to be hardware protected. \nWhen the Status Register Write Disable (SRWD) bit of the St atus Register is a 0 (its initial delivery state), it is \npossible to write to the Status Register provided that the Write Enable Latch (WEL) bit has previously been set by \na Write Enable (WREN) command, regardless of the whether Wr ite Protect (WP#) signal is driven to the logic high \nor logic low state.\nWhen the Status Register Write Disable (SRWD) bit of the Status Register is set to a 1, two cases need to be \nconsidered, depending on the state of Write Protect (WP#):CS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Status Register- 1\nCS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input Status Register-1 Input Configuration Register\nDatasheet 85 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n• If Write Protect (WP#) signal is driven to the logic high stat e, it is possible to write to the Status and Configuration \nRegisters provided that the Write Enable Latch (WEL) bit has previously been set to a “1” by initiating a Write \nEnable (WREN) command.\n• If Write Protect (WP#) signal is driven to the logic low stat e, it is not possible to write to the Status and Config-\nuration Registers even if the Write Enable Latch (WEL) bit has previously been set to a 1 by a Write Enable (WREN) \ncommand. Attempts to write to the Status and Configuration Registers are rejected, and are not accepted for execution. As a consequence, all the data bytes in th e memory area that are protected by the Block Protect \n(BP2, BP1, BP0) bits of the Status Register, are also hardware protected by WP#.\nThe WP# hardware protection can be provided:\n• by setting the Status Register Write Disable (SRWD) bit after driving Write Protect (WP#) signal to the logic low \nstate;\n• or by driving Write Protect (WP#) signal to the logic lo w state after setting the Status Register Write Disable \n(SRWD) bit to a 1.\nThe only way to release the hardware protection is to pu ll the Write Protect (WP#) signal to the logic high state. \nIf WP# is permanently tied high, hardware protection of the BP bits can never be activated.\nThe WRR command has an alternate function of loading the Bank Address Register if the command immediately \nfollows a BRAC command. See “Bank register access (BRAC B9h)” on page 83.Table 44 Block protection modes\nWP#SRWD \nBitMode Write protection of registersMemory content\nProtected areaUnprotected \narea\n11\nSoftware \nProtected Status and Configuration Registers are \nWritable (if WREN command has set the WEL bit). The values in the SRWD, BP2, BP1, and BP0 bits and those in the Configuration Register can be changedProtected \nagainst Page Program, Quad Input Program, Sector Erase, and Bulk EraseReady to accept \nPage Program, Quad Input Program and Sector Erase commands10\n00\n01\nHardware \nProtected Status and Configuration Registers are \nHardware Write Protected. The values in the SRWD, BP2, BP1, and BP0 bits and those in the Configuration Register cannot be changedProtected \nagainst Page Program, Sector Erase, and Bulk EraseReady to accept \nPage Program or Erase commands\nNotes\n45.The Status Register originally show s 00h when the device is first shipped from Infineon to the customer.\n46.Hardware protection is disabled when Quad Mode is  enabled (QUAD bit = 1 in Co nfiguration Register). WP# \nbecomes I/O2; therefore, it cannot be utilized.\nDatasheet 86 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.3.8 Write enable (WREN 06h)\nThe Write Enable (WREN) command sets the Write Enable Latc h (WEL) bit of the Status Register 1 (SR1[1]) to a 1. \nThe Write Enable Latch (WEL) bit must be set to a 1 by is suing the Write Enable (WREN) command to enable write, \nprogram and erase commands.\nCS# must be driven into the logic high state after the eigh th bit of the instruction byte has been latched in on SI. \nWithout CS# being driven to the logic high state after the ei ghth bit of the instruction byte has been latched in on \nSI, the write enable operation will not be executed.\nFigure 59 Write enable (WREN 06h) command sequence\n9.3.9 Write disable (WRDI 04h)\nThe Write Disable (WRDI) command sets the Write Enable La tch (WEL) bit of the Status Register-1 (SR1[1]) to a 0.\nThe Write Enable Latch (WEL) bit may be set to a 0 by is suing the Write Disable (WRDI) command to disable Page \nProgram (PP), Sector Erase (SE), Bulk Erase (BE), Write Registers (WRR), OTP Program (OTPP), and other commands, that require WEL be set to 1 for execution. The WRDI command can be used by the user to protect \nmemory areas against inadvertent writes that can poss ibly corrupt the contents of the memory. The WRDI \ncommand is ignored during an embe dded operation while WIP bit =1.\nCS# must be driven into the logic high state after the eigh th bit of the instruction byte has been latched in on SI. \nWithout CS# being driven to the logic high state after the ei ghth bit of the instruction byte has been latched in on \nSI, the write disable operation will not be executed.\nFigure 60 Write disable (WRDI 04h) command sequence\n9.3.10 Clear status register (CLSR 30h):\nThe Clear Status Register command resets bit SR1[5] (Erase Fail Flag) and bit SR1[6] (Program Fail Flag). It is not \nnecessary to set the WEL bit before the Clear SR comman d is executed. The Clear SR command will be accepted \neven when the device remains busy with WIP set to 1, as the device does remain busy when either error bit is set. The WEL bit will be unchanged af ter this comman d is executed.\nFigure 61 Clear status register (CLSR 30h) command sequenceCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDatasheet 87 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.3.11 ECC status register read (ECCRD 18h)\nTo read the ECC Status Register, the command is followe d by the ECC unit (16 Bytes) address, the four least \nsignificant bits (LSb) of address must be set to zero. This  is followed by the number of dummy cycles selected by \nthe read latency value in CR2V[3:0]. Then the 8-bit cont ents of the ECC Register, for the ECC unit selected, are \nshifted out on SO 16 times, once for each byte in the ECC Unit. If CS# remains low the next ECC unit status is sent \nthrough SO/I/O1 16 times, once for each byte in the EC C Unit, this continues until CS# goes high. The maximum \noperating clock frequency for the ECC READ command is 133 MHz. See “Automatic ECC” on page 106 for details \non ECC unit.\nFigure 62 ECC status register read command sequence\n9.3.12 AutoBoot\nSPI devices normally require 32 or more cycles of command and address shifting to initiate a read command. And, \nin order to read boot code from an SPI device, the host memory controller or processor must supply the read command from a hardwired state machine or from some host processor internal ROM code.\nParallel NOR devices need only an initia l address, supplied in parallel in a si ngle cycle, and initial access time to \nstart reading boot code.\nThe AutoBoot feature allows the host memory controller to take boot code from an S25FL512S device immedi-\nately after the end of reset, without having to send a read command. This saves 32 or more cycles and simplifies the logic needed to initiate  the reading of boot code.\n• As part of the power up reset, hardware reset, or command reset process the AutoBoot feature automatically \nstarts a read access from a pre-specified address. At the time the reset process is completed, the device is ready \nto deliver code from the starting address. The host memo ry controller only needs to drive CS# signal from high \nto low and begin toggling the SCK signal. The S25FL512S device will delay code ou tput for a pre-specified \nnumber of clock cycles before code streams out.\n- The Auto Boot Start Delay (ABSD) field of the AutoBoot re gister specifies the initial delay if any is needed by \nthe host.\n- The host cannot send commands during this time.\n- If ABSD = 0, the maximu m SCK frequency is 50 MHz.\n- If ABSD > 0, the maximum SC K frequency is 133 MHz if the QUAD bit CR1[ 1] is 0 or 104 MHz if the QUAD bit is \nset to 1.\n• The starting address of the boot co de is selected by the value programmed into the AutoBoot Start Address \n(ABSA) field of the AutoBoot Register which specifies a 512 byte boundary aligned lo cation; the default address \nis 00000000h.\n- Data will continuously shif t out until CS# returns high.\n• At any point after the first data byte is transferred, wh en CS# returns high, the SPI device will reset to standard \nSPI mode; able to accept normal command operations.\n- A minimum of one byte must be transferred.\n- AutoBoot mode will not initiate again until another power cycle or a reset occurs.1321 0 987654 03 9 383736\nInstructio n32-Bit\nAddress\n31 2930 1 32 0\n1 32 0 765 44443424140 47 4645\n1 32 0 765 4Dummy Byt e5251504948 55 5453\nDATA OUT 1 DATA OUT 2SCK\nSI\nSO\nMSBHigh Impedance7\nMSBCS#\n1 32 0 765 4\nDatasheet 88 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n• An AutoBoot Enable bit (ABE) is se t to enable the AutoBoot feature.\nThe AutoBoot register bits are non-volatile and provide:\n• The starting address (512-byte boundary), set by the Aut oBoot Start Address (ABSA). Th e size of the ABSA field \nis 23 bits for devices up to 32-Gbit.\n• The number of initial delay cycles, set by th e AutoBoot Start Delay (ABSD) 8-bit count value.\n•T h e  A u t o B o o t  E n a b l e .\nIf the configuration register QUAD bit CR1[1] is set to 1, th e boot code will be provided 4 bits per cycle in the same \nmanner as a Read Quad Out command. If the QUAD bit is 0 the code is delivered serially in the same manner as a \nRead command.\nFigure 63 AutoBoot sequence (CR1[1]=0)\nFigure 64 AutoBoot sequence (CR1[1]=1)\n9.3.13 AutoBoot register read (ABRD 14h)\nThe AutoBoot Register Read command is shifted into SI. Then the 32-bit AutoBoot Regi ster is shifted out on SO, \nLSB first, most significant bit of each byte first. It is  possible to read the AutoBoot Register continuously by \nproviding multiples of 32 clock cycles . If the QUAD bit CR1[1] is cleared to 0, the maximum operating clock \nfrequency for ABRD command is 133 MHz. If the QUAD bi t CR1[1] is set to 1, th e maximum operating clock \nfrequency for ABRD command is 104 MHz.\nFigure 65 AutoBoot register read (ABRD 14h) commandCS#\nSCK\nSI\nSO\nPhase7654321076543210\nWait States (ABSD) Data 1 Data N\nCS#\nSCK\nIO0\nIO1IO2IO3\nPhase \n                                               \n40404040404\n51515151515\n62626262626\n73737373737\nWait States (ABSD) Data 1 Data 2 Data 3 Data 4 Data 5 ...\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nDatasheet 89 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.3.14 AutoBoot register write (ABWR 15h)\nBefore the ABWR command can be accepted, a Write Enable (WREN) command must be issued and decoded by \nthe device, which sets the Write Enable Latch (WEL) in the Status Register to enable any write operations.\nThe ABWR command is entered by shifting the instruction an d the data bytes on SI, LSB first, most significant bit \nof each byte first. The ABWR data is 32 bits in length. \nThe ABWR command has status reported in Status Register-1 as both an erase and a programming operation. An \nE_ERR or a P_ERR may be set depending on whether the erase or programming phase of updating the register fails.\nCS# must be driven to the logic high state after the 32nd bit of data has been latched. If not, the ABWR command \nis not executed. As soon as CS# is driven to the logic high  state, the self-timed ABWR operation is initiated. While \nthe ABWR operation is in progress, Status Register-1 may be  read to check the value of the Write-In Progress (WIP) \nbit. The Write-In Progress (WIP) bit is a 1 during the self-t imed ABWR operation, and is a 0. when it is completed. \nWhen the ABWR cycle is completed, the Write Enable Latc h (WEL) is set to a 0. The maximum clock frequency for \nthe ABWR command is 133 MHz.\nFigure 66 AutoBoot register write (ABWR) command\n9.3.15 Program NVDLR (PNVDLR 43h)\nBefore the Program NVDLR (PNVDLR) command can be acce pted by the device, a Write Enable (WREN) command \nmust be issued and decoded by the device. After the Write Enable (WREN) command has been decoded success-fully, the device will set the Write Enable Latch (WEL) to enable the PNVDLR operation.\nThe PNVDLR command is entered by shifting the instruction and the data byte on SI. \nCS# must be driven to the logic high state after the eighth  (8th) bit of data has been latched. If not, the PNVDLR \ncommand is not executed. As soon as CS# is driven to th e logic high state, the self-timed PNVDLR operation is \ninitiated. While the PNVDLR operation is  in progress, the Status Register ma y be read to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during the self-timed PNVDLR cycle, and is a 0. \nwhen it is completed. The PNVDLR op eration can report a program error in the P_ERR bit of the status register. \nWhen the PNVDLR operation is completed, the Write En able Latch (WEL) is set to a 0 The maximum clock \nfrequency for the PNVDLR command is 133 MHz.\nFigure 67 Program NVDLR (PNVDLR 43h) command sequenceCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7\nInstruction Input Data 1\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0\nInstruction Input Data\nDatasheet 90 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.3.16 Write VDLR (WVDLR 4Ah)\nBefore the Write VDLR (WVDLR) command can be accepted by the device, a Write Enable (WREN) command must \nbe issued and decoded by the device. After the Write Enable (WREN) command has been decoded successfully, the device will set the Write Enable Latch (WEL) to enable WVDLR operation.\nThe WVDLR command is entered by shifting the instruction and the data byte on SI.\nCS# must be driven to the logic high state after the eighth  (8th) bit of data has been latched. If not, the WVDLR \ncommand is not executed. As soon as CS# is driven to th e logic high state, the WVDLR operation is initiated with \nno delays. The maximum cl ock frequency for the PNVDLR command is 133 MHz.\nFigure 68 Write VDLR (WVDLR 4Ah) command sequence\n9.3.17 Data learning pattern read (DLPRD 41h)\nThe instruction is shifted on SI, then th e 8-bit DLP is shifted out on SO. It is  possible to read the DLP continuously \nby providing multiples of eight clock cycles. The ma ximum operating clock frequency for the DLPRD command \nis 133 MHz.\nFigure 69 DLP read (DLPRD 41h) command sequence\n9.4 Read memory array commands\nRead commands for the main flash array provide many options for prior generation SPI compatibility or \nenhanced performance SPI:\n• Some commands transfer address or data on each risi ng edge of SCK. These are called Single Data Rate \ncommands (SDR).\n• Some SDR commands transfer address one bit per rising edge of SCK and return data 1, 2, or 4 bits of data per \nrising edge of SCK. These are called Read or Fast Read for 1-bit data; Dual Output Read for 2-bit data, and Quad Output for 4-bit data.\n• Some SDR commands transfer both address and data 2 or 4 bits per rising edge of SC K. These are called Dual \nI/O for 2 bit and Quad I/O for 4 bit.\n• Some commands transfer address and data on both the rising edge and falling edge of SCK. These are called \nDouble Data Rate (DDR) commands.\n• There are DDR commands for 1, 2, or 4 bits of address or  data per SCK edge. These are called Fast DDR for 1-bit, \nDual I/O DDR for 2-bit, and Quad I/O DDR for 4-bit per edge transfer.CS#\nSCK\nSI\nSO\nPhase7654321076543210\nInstruction Input Data\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\n7 6 5 43 2 1 0 7 6 5 4 3 2 1 0\nInstruction Data 1 Data N\nDatasheet 91 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nAll of these commands begin with an instruction code that is transferred one bit per SCK rising edge. The \ninstruction is followed by either a 3- or 4-byte address transferred at SDR or DDR. Commands transferring address \nor data 2 or 4 bits per clock edge are called Multiple I/O (MIO) commands. For FL-S devices at 256 Mb or higher density, the traditiona l SPI 3-byte addresses are unable to directly address all locations in the \nmemory array. These device have a bank address register that is used with 3-byte address commands to supply the high order address bits beyond the address from the host system. The default bank address is zero. Commands are provided to load and read the bank addre ss register. These devices may also be configured to \ntake a 4-byte address from the host system with the traditional 3-byte address commands. The 4-byte address \nmode for traditional commands is activated by setting th e External Address (EXTADD) bit in the bank address \nregister to 1.\nThe Quad I/O commands provide a performance improvem ent option controlled by mode bits that are sent \nfollowing the address bits. The mode bits indicate whet her the command following the end of the current read \nwill be another read of the same type, without an instru ction at the beginning of the read. These mode bits give \nthe option to eliminate the instruction cycles when doing a series of Quad I/O read accesses.\nA device ordering option provides an enhanced high pe rformance option by adding a similar mode bit scheme \nto the DDR Fast Read, Dual I/O, and Dual I/O DDR commands, in addition to the Quad I/O command.\nSome commands require delay cycles following the address or mode bits to allow time to access the memory \narray. The delay cycles are traditionally called dummy cy cles. The dummy cycles are ignored by the memory thus \nany data provided by the host during thes e cycles is “don’t care” and the host may also leave the SI signal at high \nimpedance during the dummy cycles. When MIO commands ar e used the host must stop driving the I/O signals \n(outputs are high impedance) before the end of last dummy cycle. When DDR commands are used the host must \nnot drive the I/O signals during any dummy cycle. The numb er of dummy cycles varies with the SCK frequency or \nperformance option selected via the Configuration Register 1 (CR1) Latency Code (LC). Dummy cycles are measured from SCK falling edge to next SCK falling edge . SPI outputs are traditionally driven to a new value on \nthe falling edge of each SCK. Zero dummy cycles means th e returning data is driven by the memory on the same \nfalling edge of SCK that the host stops driving addres s or mode bits.\nThe DDR commands may optionally have an 8-edge Data Learning Pattern (DLP) driven by the memory, on all \ndata outputs, in the dummy cycles immediately before the start of data. The DLP can help the host memory \ncontroller determine the phase shift from SCK to data ed ges so that the memory controller can capture data at \nthe center of the data eye.\nWhen using SDR I/O commands at higher  SCK frequencies (>50 MHz), an LC that  provides 1 or more dummy cycles \nshould be selected to allow additional time for the host to stop driving before the memory starts driving data, to \nminimize I/O driver conflict. When using DDR I/O commands with the DLP enabled, an LC  that provides 5 or more \ndummy cycles should be selected to allow 1 cycle of ad ditional time for the host to stop driving before the \nmemory starts driving the 4 cycle DLP .\nEach read command ends when CS# is returned High at any point during data return. CS# must not be returned \nHigh during the mode or dummy cycles before data returns as this may cause mode bits to be captured incor-rectly; making it indeterminate as to whether the devi ce remains in enhanced high performance read mode.\n9.4.1 Read (Read 03h or 4READ 13h)\nThe instruction \n• 03h (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• 03h (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 13h is followed by a 4-byte address (A31-A0)\nThen the memory contents, at the address given, are sh ifted out on SO. The maximum operating clock frequency \nfor the READ command is 50 MHz.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nDatasheet 92 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFigure 70 Read command sequence (READ 03h or 13h)\n9.4.2 Fast read (FAST_READ 0Bh or 4FAST_READ 0Ch)\nThe instruction\n• 0Bh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• 0Bh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 0Ch is followed by a 4-byte address (A31-A0)\nThe address is followed by zero or eight dummy cycles depending on the latency code set in the Configuration \nRegister. The dummy cycles allow the de vice internal circuits additional time for accessing the initial address \nlocation. During the dummy cycles the data value on SO is “don’t care” and may be high impedance. Then the \nmemory contents, at the address given, are shifted out on SO.\nThe maximum operating clock frequenc y for FAST READ command is 133 MHz.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFigure 71 Fast read (FAST_READ 0Bh or 0Ch) command sequence with read latency\nFigure 72 Fast read command (FAST_READ 0Bh or 0Ch) sequence without read latencyCS#\nSCK\nSI\nSO\nPhase \n                                                \n76543210A 10  \n7654321076543210  \nInstruction Address Data 1 Data N\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n76543210A 10  \n76543210  \nInstruction Address     Dummy Cycles Data 1\nCS#\nSCK\nSI\nSO\nPhase \n                                                \n76543210A 10  \n7654321076543210  \nInstruction Address Data 1 Data N\nDatasheet 93 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.4.3 Dual output read (DOR 3Bh or 4DOR 3Ch)\nThe instruction \n• 3Bh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• 3Bh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 3Ch is followed by a 4-byte address (A31-A0)\nThen the memory contents, at the address given, is shifted out two bits at a time through I/O0 (SI) and I/O1 (SO). \nTwo bits are shifted out at the SCK frequenc y by the falling edge of the SCK signal.\nThe maximum operating clock frequency for the Dual Output Read command is 104 MHz. For Dual Output Read \ncommands, there are zero or eight dummy cycles required af ter the last address bit is shifted into SI before data \nbegins shifting out of I/O0 and I/O1. This latency period (i.e., dummy cycles) allows the device’s internal circuitry enough time to read from the initial address. During the dummy cycles, the data value on SI is a “don’t care” and \nmay be high impedance. The number of dummy cycles is determined by the frequency of SCK (refer to Table 23 ).\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nFigure 73 Dual output read command sequence (3-byte address, 3Bh [ExtAdd=0], LC=10b)\nFigure 74 Dual output read command sequence (4-byte address, 3Ch or 3Bh [ExtAdd=1, LC=10b])\nFigure 75 Dual output read command sequence (4-byte address, 3Ch or 3Bh [ExtAdd=1, LC=11b])CS#\nSCK\nIO0\nIO1\nPhase765432102322210 64206420\n75317531\nInstruction 8 Dummy Cycles Data 1 Data 2 Address\nCS#\nSCK\nIO0\nIO1\nPhase765432103130290 64206420\n75317531\nInstruction 8 Dummy Cycles Data 1 Data 2 Address\nSCK\nIO0\nIO1\nPhase76543210313029064206420\n75317531\nInstruction Data 1 Data 2 Address\nDatasheet 94 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.4.4 Quad output read (QOR 6Bh or 4QOR 6Ch)\nThe instruction \n• 6Bh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• 6Bh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 6Ch is followed by a 4-byte address (A31-A0)\nThen the memory contents, at the address given, is shifted out four bits at a time through I/O0-I/O3. Each nibble \n(4 bits) is shifted out at the SCK frequenc y by the falling edge of the SCK signal.\nThe maximum operating clock frequenc y for Quad Output Read command is  104 MHz. For Quad Output Read \nMode, there may be dummy cycles required  after the last address bit is shifted into SI before data begins shifting \nout of I/O0-I/O3. This latency period (i.e., dummy cycles) allows the device’s internal circuitry enough time to set \nup for the initial address. During the dummy cycles, the data value on I/O0-I/O3 is a “don’t care” and may be high impedance. The number of dummy  cycles is determined by th e frequency of SCK (refer to Table 23 ).\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nThe QUAD bit of Configuration Register must be se t (CR Bit1=1) to enable the Quad mode capability.\nFigure 76 Quad output read (QOR 6Bh or 4QOR  6Ch) command sequence with read latency\nFigure 77 Quad output read (QOR 6Bh or 4QOR  6Ch) command sequence without read latency\n9.4.5 Dual I/O read (DIOR BBh or 4DIOR BCh)\nThe instruction \n• BBh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n• BBh (ExtAdd=1) is followed by a 4-byte address (A31-A0) orCS#\nSCK\nIO0IO1IO2IO3\nPhase \n                                                              \n76543210A 10 40404040404\n51515151515\n62626262626\n73737373737\nInstruction Address Dummy D1D2D3D4D5\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                               \n7 6 5 4 3 2 1 0 A  1 0 4 0 4 0 4 0 4 0 4 0 4\n5 1 5 1 5 1 5 1 5 1 5\n6 2 6 2 6 2 6 2 6 2 6\n7 3 7 3 7 3 7 3 7 3 7\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nDatasheet 95 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n• BCh is followed by a 4-byte address (A31-A0)\nThe Dual I/O Read commands improve throughput with two I/O signals — I/O0 (SI) and I/O1 (SO). It is similar to \nthe Dual Output Read command but takes input of the addr ess two bits per SCK rising edge. In some applications, \nthe reduced address input time might allow for code executio n in place (XIP) i.e. directly from the memory device.\nThe maximum operating clock freque ncy for Dual I/O Read is 104 MHz.\nFor the Dual I/O Read command, there is a latency required after the last address bits are shifted into SI and SO \nbefore data begins shifting out of I/O0 and I/O1. There ar e different ordering part numbers that select the latency \ncode table used for this command, either the High Perf ormance LC (HPLC) table or the Enhanced High Perfor-\nmance LC (EHPLC) table. The HPLC table does not provide cycles for mode bits so each Dual I/O Read command starts with the 8 bit instruction, followed by address, followed by a latency period.\nThis latency period (dummy cycles) allows the device intern al circuitry enough time to access data at the initial \naddress. During the dummy cycles, the data value on SI and SO are “don’t care” and may be high impedance. The \nnumber of dummy cycles is determ ined by the frequency of SCK ( Table 23 ). The number of dummy cycles is set \nby the LC bits in the Co nfiguration Register (CR1).\nThe EHPLC table does provide cycles for mode bits so a series of Dual I/O Read commands may eliminate the 8-bit \ninstruction after the first Dual I/O Read command sends a mode bit pattern of Axh that indicates the following \ncommand will also be a Dual I/O Read command. The first Du al I/O Read command in a series starts with the 8-bit \ninstruction, followed by address, followed by four cycles of mode bits, followed by a latency period. If the mode bit pattern is Axh the next command is assumed to be an additional Dual I/O Read command that does not \nprovide instruction bits. That command starts with address, followed by mode bits, followed by latency.\nThe Enhanced High Performance feature removes the need  for the instruction sequence and greatly improves \ncode execution (XIP). The upper nibble (bits 7-4) of the Mode bits control th e length of the next Dual I/O Read \ncommand through the inclusion or exclus ion of the first byte instruction code. The lower nibble (bits 3-0) of the \nMode bits are “don’t care” (“x”) and may be high impedance. If the Mode bits equal Axh, then the device remains in Dual I/O Enhanced High Performance Read Mode and the next address can be entered (after CS# is raised high \nand then asserted low) without the BB h or BCh instruction, as shown in Figure 81 ; thus, eliminating eight cycles \nfor the command sequence. The following sequences will rele ase the device from Dual I/O Enhanced High Perfor-\nmance Read mode; after which, the device can accept standard SPI commands:\n1. During the Dual I/O Enhanced High Performance Comman d Sequence, if the Mode bits are any value other than \nAxh, then the next time CS# is raised high the device will be released from Dual I/O Read Enhanced High Per-formance Read mode.\nDuring any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (I/O0 and I/O1) are \nnot set for a valid instruction sequence, then the device will be released from Dual I/O Enhanced High Perfor-\nmance Read mode. Note that the four mode bit cycles are part of the device’s internal circuitry latency time to access the initial address after the last address cycl e that is clocked into I/O0 (SI) and I/O1 (SO).\nIt is important that the I/O signals be set to high-impedance at or before the falling edge of the first data out clock. \nAt higher clock speeds the time availabl e to turn off the host outputs before the memory device begins to drive \n(bus turn around) is diminished. It is allowed and may be helpful in preventing I/O signal contention, for the host system to turn off the I/O signal ou tputs (make them high impedance) during the last two “don’t care” mode \ncycles or during any dummy cycles.\nFollowing the latency period the memory content, at the ad dress given, is shifted out two bits at a time through \nI/O0 (SI) and I/O1 (SO). Two bits are shifted out at the SCK frequency at the falling edge of SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nCS# should not be driven high during mode or dummy bits as this may make the mode bits indeterminate.\nDatasheet 96 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nFigure 78 Dual I/O read command sequence (3-byte address, BBh [ExtAdd=0], HPLC=00b)\nFigure 79 Dual I/O read command sequence (4-byte address, BBh [ExtAdd=1], HPLC=10b)\nFigure 80 Dual I/O read command sequence (4-byte address, BCh or BBh [ExtAdd=1], EHPLC=10b)\nFigure 81 Continuous dual I/O read command sequ ence (4-byte address, BCh or BBh [ExtAdd=1], EH-\nPLC=10b)CS#\nSCK\nIO0\nIO1\nPhase765432102220180 64206420\n2321191 75317531\nInstruction Address 4 Dummy Data 1 Data 2\nCS#\nSCK\nIO0\nIO1\nPhase765432103028260 64206420\n3129271 75317531\nInstruction 6 Dummy Data 1 Data 2 Address\nCS#\nSCK\nIO0\nIO1\nPhase \n                                                      \n7654321030  206420 64206420 \n31  317531 75317531 \nInstruction Address Mode Dum Data 1 Data 2\nCS#\nSCK\nIO0\nIO1\nPhase  \n                                                 \n6420 30  206420 64206420 \n7531 31  317531 75317531 \nData N Address Mode Dum Data 1 Data 2\nDatasheet 97 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.4.6 Quad I/O read (QIOR EBh or 4QIOR ECh)\nThe instruction\n• EBh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• EBh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• ECh is followed by a 4-byte address (A31-A0)\nThe Quad I/O Read command improves throughput with four I/O signals — I/O0-I/O3. It is similar to the Quad \nOutput Read command but allows input of the address bits four bits per serial SCK clock. In some applications, \nthe reduced instruction overhead might allow for code execution (XIP) directly from the S25FL512S device. The \nQUAD bit of the Configuration Register must be set (CR Bit1=1) to enable the Quad capability of the S25FL512S \ndevice.\nThe maximum operating clock freque ncy for Quad I/O Read is 104 MHz.\nFor the Quad I/O Read command, there is a latency required  after the mode bits (described below) before data \nbegins shifting out of I/O0-I/O3. This latency period (i.e., dummy cycles) allows the device’s internal circuitry enough time to access data at the initial address. During  latency cycles, the data value on I/O0-I/O3 are “don’t \ncare” and may be high impedance. The number of dummy cycles is determined by th e frequency of SCK and the \nlatency code table (refer to Table 23 ). There are different ordering part numbers that select the latency code \ntable used for this command, either the High Performanc e LC (HPLC) table or the Enhanced High Performance \nLC (EHPLC) table. The number of dummy cycles is set by the LC bits in the Configuration Register (CR1). However, \nboth latency code tables use the same late ncy values for the Quad I/O Read command.\nFollowing the latency period, the memory contents at the a ddress given, is shifted out four bits at a time through \nI/O0-I/O3. Each nibble (4 bits) is shifted out at th e SCK frequency by the falling edge of the SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nAddress jumps can be done without the need for additional Quad I/O Read instructions. This is controlled through \nthe setting of the Mode bits (after  the address sequence, as shown in Figure 84  or Figure 85 ). This added feature \nremoves the need for the instruction sequence and greatl y improves code execution (X IP). The upper nibble (bits \n7-4) of the Mode bits contro l the length of the next Quad I/O instructio n through the inclusion or exclusion of the \nfirst byte instruction code. The lower nibble (bits 3-0) of the Mode bits are “don’t care” (“x”). If the Mode bits equal \nAxh, then the device remains in Quad I/O High Performanc e Read Mode and the next address can be entered (after \nCS# is raised high and then asserted low) without requiring the EBh or ECh instruction, as shown in Figure 83  or \nFigure 85 ; thus, eliminating eight cycles for the command sequence. The following sequences will release the \ndevice from Quad I/O High Performance Read mode; after which, the device can accept standard SPI commands:\n1. During the Quad I/O Read Command Sequence, if the Mo de bits are any value other than Axh, then the next \ntime CS# is raised high the device will be released from Quad I/O High Performance Read mode.\nDuring any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (I/O0-I/O3) are not \nset for a valid instruction sequence, then the device will be released from Quad I/O High Performance Read mode. \nNote that the two mode bit cl ock cycles and additional wait states (i.e., dummy cycles) allow the device’s internal \ncircuitry latency time to access the initial address after the last address cycle that is clocked into I/O0-I/O3.\nIt is important that the I/O0-I/O3 signals be set to high-i mpedance at or before the falling edge of the first data \nout clock. At higher clock speeds the time available to tu rn off the host outputs before the memory device begins \nto drive (bus turn around) is dimini shed. It is allowed and may be help ful in preventing I/O0-I/O3 signal \ncontention, for the host system to turn off the I/O0-I/O 3 signal outputs (make them high impedance) during the \nlast “don’t care” mode cycle or during any dummy cycles.\nCS# should not be driven high during mode or dummy bits as this may make the mode bits indeterminate.\nDatasheet 98 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nFigure 82 Quad I/O read command sequence (3-byte address, EBh [ExtAdd=0], LC=00b)\nFigure 83 Continuous quad I/O read co mmand sequence (3-byte address), LC=00b\nFigure 84 Quad I/O read command sequence(4-byte address, ECh or EBh [ExtAdd=1], LC=00b)\nFigure 85 Continuous quad I/O read co mmand sequence (4-byte address), LC=00bCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                     \n7654321020  4040 40404040  \n21  5151 51515151  \n22  6262 62626262  \n23  7373 73737373  \nInstruction Address Mode Dummy D1 D2 D3 D4\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase  \n                                                  \n40 4 0 20  4 0 4 0 4 0 4 06 4 2 0  \n51 5 1 21  5 1 5 1 5 1 5 17 5 3 1 \n6 2 6 2 22  6 2 6 2 6 26 1 7 5 3 1 \n7 3 7 3 23  7 3 7 3 7 37 1 7 5 3 1 \nDN-1 D N Address Mode Dummy D1 D  2 D 3 D 4\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase \n                                                     \n7654321028  4040 40404040  \n29  5151 51515151  \n30  6262 62626262  \n31  7373 73737373  \nInstruction Address Mode Dummy D 1 D 2 D 3 D 4\nCS#\nSCK\nIO0IO1\nIO2\nIO3\nPhase  \n                                                  \n40 4 0 28  4 0 4 0 4 0 4 06 4 2 0  \n51 5 1 29  5 1 5 1 5 1 5 17 5 3 1 \n6 2 6 2 30  6 2 6 2 6 26 1 7 5 3 1 \n7 3 7 3 31  7 3 7 3 7 37 1 7 5 3 1 \nDN-1 D N Address Mode Dummy D 1 D 2 D 3 D 4\nDatasheet 99 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.4.7 DDR fast read (DDRFR 0Dh, 4DDRFR 0Eh)\nThe instruction \n• 0Dh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• 0Dh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 0Eh is followed by a 4-byte address (A31-A0)\nThe DDR Fast Read command improves throughput by transferring address and data on both the falling and \nrising edge of SCK. It is similar to the Fast Read command but allows transfer of address and data on every edge of the clock.\nThe maximum operating clock frequency for DDR Fast Read command is 80 MHz.\nFor the DDR Fast Read command, there is a latency required after the last address bits are shifted into SI before \ndata begins shifting out of SO. There are different orderi ng part numbers that select the latency code table used \nfor this command, either the High Performance LC (HPLC)  table or the Enhanced High Performance LC (EHPLC) \ntable. The HPLC table does not provide cycles for mode bits so each DDR Fast Read command starts with the 8-bit instruction, followed by address, followed by a latency period.\nThis latency period (dummy cycles) allows the device intern al circuitry enough time to access data at the initial \naddress. During the dummy cycles, the data value on SI is “don’t care” and may be high impedance. The number \nof dummy cycles is determined  by the frequency of SCK (see Table 23 ). The number of dummy cycles is set by \nthe LC bits in the Configuration Register (CR1).\nThen the memory contents, at the address given, is shifte d out, in DDR fashion, one bit at a time on each clock \nedge through SO. Each bit is shifted out at the SCK freq uency by the rising and falli ng edge of the SCK signal.\nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nThe EHPLC table does provide cycles for mode bits so a series of DDR Fast Read commands may eliminate the \n8-bit instruction after the first DDR Fast Read command  sends a mode bit pattern of complementary first and \nsecond Nibbles, e.g. A5h, 5Ah, 0Fh, etc., that indicate s the following command will also be a DDR Fast Read \ncommand. The first DDR Fast Read command in a series starts with the 8-bit instruction, followed by address, followed by four cycles of mode bits, followed by a latency period. If the mode bit pattern is complementary the next command is assumed to be an additional DDR Fast  Read command that does not provide instruction bits. \nThat command starts with address, followed by mode bits, followed by latency.\nWhen the EHPLC table is used, address jumps can be done without the need fo r additional DDR Fast Read instruc-\ntions. This is controlled through the setting of the Mode bits (after  the address sequence, as shown in Figure 89  \nand Figure 88 . This added feature removes the need for the eigh t bit SDR instruction sequ ence to reduce initial \naccess time (improves XIP performance). The Mode bits co ntrol the length of the next  DDR Fast Read operation \nthrough the inclusion or exclusion of th e first byte instruction code. If the up per nibble (I/O[7:4]) and lower nibble \n(I/O[3:0]) of the Mode bits are complementary (i.e. 5h an d Ah) then the next address can be entered (after CS# is \nraised high and then asserted low) without requ iring the 0Dh or 0Eh inst ruction, as shown in Figure  and \nFigure 89 , thus, eliminating eight cycles from the command sequence. The following sequences will release the \ndevice from this continuous DDR Fast Read mode; after which, the device can accept standard SPI commands:\n1. During the DDR Fast Read Command Sequence, if the Mo de bits are not complementary the next time CS# is \nraised high the device will be released from the continuous DDR Fast Read mode.\n2. During any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (SI) are not set \nfor a valid instruction sequence, then the device will be released from DDR Fast Read mode. \nCS# should not be driven high during mode or dummy bits as this may make the mode bits indeterminate.\nThe HOLD function is not valid during any part of a Fast DDR Command. Although the data learning pattern (DLP) is programmab le, the following example shows example of the DLP of \n34h. The DLP 34h (or 00110100) will be driven on each of the ac tive outputs (i.e. all four I/Os on a x4 device, both \nI/Os on a x2 device and the single SO output on a x1 device). This pattern was chosen to cover both DC and AC data transition scenarios. The two DC transition scenario s include data low for a long period of time (two half \nDatasheet 100 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nclocks) followed by a high going transition (001) and the complementary low going transition (110). The two AC \ntransition scenarios include data low for a short period of time (one half clock) followed by a high going transition (101) and the complementary low going transition (010). Th e DC transitions will typically occur with a starting \npoint closer to the supply rail than the AC transitions that may not have fu lly settled to their steady state (DC) \nlevels. In many cases the DC transitions will bound the be ginning of the data valid period and the AC transitions \nwill bound the ending of the data valid period. These tr ansitions will allow the host controller to identify the \nbeginning and ending of the valid data eye. Once the da ta eye has been characterized the optimal data capture \npoint can be chosen. See “SPI DDR data learning registers” on page 64 for more details. \nFigure 86 DDR fast read initial access (3-byte address, 0Dh [ExtAdd=0, EHPLC=11b])\nFigure 87 Continuous DDR fast read subseque nt access (3-byte address [ExtAdd=0, EHPLC=11b])\nFigure 88 DDR fast read initial access (4-byt e address, 0Eh or 0Dh [ExtAdd=1], EHPLC=01b)[47]\nFigure 89 Continuous DD R fast read subsequent access (4-byte address [ExtAdd=1], EHPLC=01b)[47]CS#\nSCK\nSI\nSO\nPhase \n                                               \n7 6 5 4 3 2 1 02322 076543210  \n7654321076543210\nInstruction Address Mode Dummy Data 1 Data 2\nCS#\nSCK\nIO0\nIO1\nPhase \n                          \n23 1076543210  \n7654321076\nAddress Mode Dum Data 1 D2\nCS#\nSCK\nSI\nSO\nPhase \n                                               \n7 6 5 4 3 2 1 0 31 1076543210  \n7 6 5 4 321 0 7654321076\nInstruction Address Mode DLP Data 1 D2\nCS#\nSCK\nSI\nSO\nPhase \n                                \n31 1076543210  \n7   6 5   4 321   0 7654321076\nAddress Mode DLP Data 1 D2\nNote\n47.Example DLP of 34h (or 00110100).\nDatasheet 101 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nFigure 90 DDR fast read subsequent access (4-byte address, HPLC=01b)\n9.4.8 DDR dual I/O read (BDh, BEh)\nThe instruction \n• BDh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• BDh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• BEh is followed by a 4-byte address (A31-A0)\nThen the memory contents, at the address given, is shifted out, in a DDR fashion, two bits at a time on each clock \nedge through I/O0 (SI) and I/ O1 (SO). Two bits are shifted out at the SC K frequency by the rising and falling edge \nof the SCK signal.\nThe DDR Dual I/O Read command improves throughput with tw o I/O signals — I/O0 (SI) an d I/O1 (SO). It is similar \nto the Dual I/O Read command but transfers two address, mode, or data bits on every edge of the clock. In some applications, the reduced instruction overhead might allo w for code execution (XIP) directly from the S25FL512S \ndevice.\nThe maximum operating clock frequency fo r DDR Dual I/O Read command is 80 MHz.\nFor DDR Dual I/O Read commands, there is a latency required after the last address bits are shifted into I/O0 and \nI/O1, before data begins shifting out of I/O0 and I/O1. There are different ordering part numbers that select the \nlatency code table used for this command, either the Hi gh Performance LC (HPLC) table or the Enhanced High \nPerformance LC (EHPLC) table. The number of latency (d ummy) clocks is determined by the frequency of SCK \n(refer to Table 22  or Table 24 ). The number of dummy cycles is set by the LC bits in the Configuration Register \n(CR1).\nThe HPLC table does not provide cycles for mode bits so each Dual I/O command starts with the 8 bit instruction, \nfollowed by address, followed by a latency period. This latency period allows the device’s internal circuitry \nenough time to access the initial addre ss. During these latency cy cles, the data value on SI (I/O0) and SO (I/O1) \nare “don’t care” and may be high impedance. When the Da ta Learning Pattern (DLP) is enabled the host system \nmust not drive the I/O signals during the dummy cycles. The I/O signals must be left high impedance by the host so that the memory device can driv e the DLP during the dummy cycles.\nThe EHPLC table does provide cycles for mode bits so a series of Dual I/O DDR comm ands may eliminate the 8 bit \ninstruction after the first command sends a co mplementary mode bit pattern, as shown in Figure 91  and \nFigure 93 . This added feature removes the need for the eigh t bit SDR instruction sequence and dramatically \nreduces initial access times (improves XIP performance). Th e Mode bits control the length of the next DDR Dual \nI/O Read operation through the inclusion or exclusion of  the first byte instruction code. If the upper nibble \n(I/O[7:4]) and lower nibble (I/O[3:0]) of the Mode bits are complementary (i.e. 5h and Ah) the device transitions \nto Continuous DDR Dual I/O Read Mode and the next addr ess can be entered (after CS# is raised high and then \nasserted low) without requiring the BD h or BEh instruction, as shown in Figure 92 , and thus, eliminating eight \ncycles from the command sequence. Th e following sequences will release th e device from Continuous DDR Dual \nI/O Read mode; after which, the device can accept standard SPI commands:\n1. During the DDR Dual I/O Read Command Sequence, if th e Mode bits are not complementary the next time CS# \nis raised high and then asserted low the device  will be released from DDR Dual I/O Read mode.CS#\nSCK\nSI\nSO\nPhase \n                                            \n7 6 5 4 3 2 1 0 3.10  \n7654321076\nInstruction Address Dummy Data 1 D2\nDatasheet 102 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n2. During any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (I/O0 and I/O1) \nare not set for a valid instruction sequence, then the de vice will be released from DDR Dual I/O Read mode. \nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nCS# should not be driven high during mode or dummy bits  as this may make the mode bits indeterminate. The \nHOLD function is not valid during Dual I/O DDR commands.\nNote that the memory devices may drive the I/Os with a preamble prior to the first data value. The preamble is a \ndata learning pattern (DLP) that is used by the host controller to optimize data capture at higher frequencies. The preamble DLP drives the I/O bus for the four clock cycles immediately before data is output. The host must be sure to stop driving the I/O bus prior to the time  that the memory starts outputting the preamble.\nThe preamble is intended to give the host controller an indication about the round trip time from when the host \ndrives a clock edge to when the corresponding data valu e returns from the memory device. The host controller \nwill skew the data capture point during the preamble pe riod to optimize timing margins and then use the same \nskew time to capture the data during the rest of the re ad operation. The optimized capture point will be deter-\nmined during the preamble period of every read operation.  This optimization strategy is intended to compensate \nfor both the PVT (process, voltage, temperature) of both  the memory device and the host controller as well as \nany system level delays caused by flight time on the PCB.\nDatasheet 103 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nAlthough the data learning pattern (DLP) is programmab le, the following example shows example of the DLP of \n34h. The DLP 34h (or 00110100) will be driven on each of the ac tive outputs (i.e. all four SIOs on a x4 device, both \nSIOs on a x2 device and the single SO output on a x1 device). This pattern was chosen to cover both DC and AC data transition scenarios. The two DC transition scenario s include data low for a long period of time (two half \nclocks) followed by a high going transition (001) and the complementary low going transition (110). The two AC \ntransition scenarios include data low for a short period of time (one half clock) followed by a high going transition (101) and the complementary low going transition (010). Th e DC transitions will typically occur with a starting \npoint closer to the supply rail than the AC transitions that may not have fu lly settled to their steady state (DC) \nlevels. In many cases the DC transitions will bound the be ginning of the data valid period and the AC transitions \nwill bound the ending of the data valid period. These tr ansitions will allow the host controller to identify the \nbeginning and ending of the valid data eye. Once the da ta eye has been characterized the optimal data capture \npoint can be chosen. See “SPI DDR data learning registers” on page 64 for more details.\nFigure 91 DDR dual I/O read initial access (4-byte address, BEh or BDh [ExtAdd=1], EHPLC= 01b)\nFigure 92 Continuous DDR dual I/O read subsequent access (4-byte address, EHPLC= 01b)\nFigure 93 DDR dual I/O read (4-byte address, BEh or BDh [ExtAdd=1], HPLC=00b)\n9.4.9 DDR quad I/O read (EDh, EEh)\nThe Read DDR Quad I/O command improves throughput with four I/O signals - I/O0-I/O3. It is similar to the Quad \nI/O Read command but allows input of the address four bits on every edge of the clock. In some applications, the reduced instruction overhead might al low for code execution (XIP) directly from the S25FL512S device. The QUAD \nbit of the Configuration Register must be se t (CR Bit1=1) to enable the Quad capability.\nThe instruction \n• EDh (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n• EDh (ExtAdd=1) is followed by a 4-byte address (A31-A0) or• EEh is followed by a 4-byte address (A31-A0)CS#\nSCK\nIO0\nIO1\nPhase \n                                        \n7 6 5 4 3 2 1 0 3028 06420 7  6 5  4 321  0 64206 \n3129 17531 7  6 5  4 321  0 75317 \nInstruction Address Mode Dum DLP Data 1\nCS#\nSCK\nIO0\nIO1\nPhase \n                        \n30 2 0 64 2 0 7     6 4     5 3 21     0 6 42 0 6  \n31 3 1 75 3 1 7     6 4     5 3 21     0 7 53 1 7  \nAddress Mode Dummy DLP Data 1 D2\nCS#\nSCK\nIO0\nIO1\nPhase \n                                      \n7 6 5 4 3 2 1 0 30 20 64206 \n31 31 75317\nInstruction Address Dummy Data 1 D2\nDatasheet 104 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nThe address is followed by mode bits. Then the memory contents, at the addr ess given, is shifted out, in a DDR \nfashion, with four bits at a time on each clock edge through I/O0-I/O3.\nThe maximum operating clock frequency for Read DDR Quad I/O command is 80 MHz.For Read DDR Quad I/O, there is a latency required afte r the last address and mode bits are shifted into the \nI/O0-I/O3 signals before data begins shifting out of I/ O0-I/O3. This latency period (dummy cycles) allows the \ndevice’s internal circuitry enough time to access the in itial address. During these la tency cycles, the data value \non I/O0-I/O3 are “don’t care” and may be high impedance.  When the Data Learning Pattern (DLP) is enabled the \nhost system must not drive the I/O signals during the dummy cycles. The I/O signals must be left high impedance by the host so that the memory device can drive the DLP during the dummy cycles.\nThere are different ordering part numbers that select th e latency code table used for this command, either the \nHigh Performance LC (HPLC) table or the Enhanced High  Performance LC (EHPLC) table. The number of dummy \ncycles is determined by the frequency of SCK (refer to Table 22 ). The number of dummy cycles is set by the LC \nbits in the Configuration Register (CR1).\nBoth latency tables provide cycles for mode bits so a series of Quad I/O DDR commands may eliminate the 8 bit \ninstruction after the first command sends a co mplementary mode bit pattern, as shown in Figure 94  and \nFigure 96 . This feature removes the need for the eight bit SDR instruction sequence and dramatically reduces \ninitial access times (improves XIP performance). The Mode bi ts control the length of the next Read DDR Quad I/O \noperation through the inclusion or exclus ion of the first byte instruction code. If the upper nibble (I/O[7:4]) and \nlower nibble (I/O[3:0]) of the Mode bits are complementar y (i.e. 5h and Ah) the device transitions to Continuous \nRead DDR Quad I/O Mode and the next address can be ente red (after CS# is raised high and then asserted low) \nwithout requiring the EDh or EE h instruction, as shown in Figure 95  and Figure 97  thus, eliminating eight cycles \nfrom the command sequence. The following sequences will  release the device from Continuous Read DDR Quad \nI/O mode; after which, the device can accept standard SPI commands:\n1. During the Read DDR Quad I/O Command Sequence, if th e Mode bits are not complementary the next time CS# \nis raised high and then asserted low the device  will be released from Read DDR Quad I/O mode.\n2. During any operation, if CS# toggles high to low to high for eight cycles (or less) and data input (I/O0, I/O1, I/O2, \nand I/O3) are not set for a valid instruction sequence, then  the device will be released from Read DDR Quad I/O \nmode. \nThe address can start at any byte location of the memory  array. The address is auto matically incremented to the \nnext higher address in sequential order after each byte of data is shifted out. The entire memory can therefore \nbe read out with one single read instruction and addr ess 000000h provided. When the hi ghest address is reached, \nthe address counter will wrap around and roll back to 000000h, allowing the read sequence to be continued \nindefinitely.\nCS# should not be driven high during mode or dummy bits  as this may make the mode bits indeterminate. The \nHOLD function is not valid during Quad I/O DDR commands.\nNote that the memory devices drive the I/Os with a preamble prior to the first data value. The preamble is a \npattern that is used by the host controller to optimize data capture at higher frequencies. The preamble drives \nthe I/O bus for the four clock cycles immediately before data  is output. The host must be sure to stop driving the \nI/O bus prior to the time that the me mory starts outputting the preamble.\nThe preamble is intended to give the host controller an indication about the round trip time from when the host \ndrives a clock edge to when the corresponding data valu e returns from the memory device. The host controller \nwill skew the data capture point during the preamble pe riod to optimize timing margins and then use the same \nskew time to capture the data during the rest of the re ad operation. The optimized capture point will be deter-\nmined during the preamble period of every read operation.  This optimization strategy is intended to compensate \nfor both the PVT (process, voltage, temperature) of both  the memory device and the host controller as well as \nany system level delays caused by flight time on the PCB.\nDatasheet 105 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nAlthough the data learning pattern (DLP) is programmab le, the following example shows example of the DLP of \n34h. The DLP 34h (or 00110100) will be driven on each of the ac tive outputs (i.e. all four SIOs on a x4 device, both \nSIOs on a x2 device and the single SO output on a x1 device). This pattern was chosen to cover both DC and AC data transition scenarios. The two DC transition scenario s include data low for a long period of time (two half \nclocks) followed by a high going transition (001) and the complementary low going transition (110). The two AC \ntransition scenarios include data low for a short period of time (one half clock) followed by a high going transition (101) and the complementary low going transition (010). Th e DC transitions will typically occur with a starting \npoint closer to the supply rail than the AC transitions that may not have fu lly settled to their steady state (DC) \nlevels. In many cases the DC transitions will bound the be ginning of the data valid period and the AC transitions \nwill bound the ending of the data valid period. These tr ansitions will allow the host controller to identify the \nbeginning and ending of the valid data eye. Once the da ta eye has been characterized the optimal data capture \npoint can be chosen. See “SPI DDR data learning registers” on page 64 for more details.\nFigure 94 DDR quad I/O read initial access (3-byte address, EDh [ExtAdd=0], HPLC=11b)\nFigure 95 Continuous DDR quad I/O read su bsequent access (3-byte address, HPLC=11b)\nFigure 96 DDR quad I/O read initial access (4-byte address, EEh or EDh [ExtAdd=1], EHPLC=01b)\n[48]\nFigure 97 Continuous DDR quad I/O read su bsequent access (4-byte address, EHPLC=01b)[48]CS#\nSCK\nIO0\nIO1IO2IO3\nPhase \n                                           \n7 6 5 4 3 2 1 0 201612 84040 765432104040\n211713 95151 765432105151\n22181410 6262 765432106262\n23191511 7373 765432107373\nInstruction Address Mode Dummy DLP D1 D2\nCS#\nSCK\nIO0\nIO1\nIO2 \n                         \n201612 84040 4040404040\n211713 95151 5151515151\n22181410 6262 6262626262\nCS#\nSCK\nIO0\nIO1\nIO2\nIO3\nPhase \n                                            \n7 6 5 4 3 2 1 0 2.2.2.1.1.84040 7  6 5  4 321  0 4040\n2.2.2.1.1.95151 7  6 5  4 321  0 5151\n3.2.2.1.1.1.6262 7  6 5  4 321  0 6262\n3.2.2.1.1.1.7373 7  6 5  4 321  0 7373\nInstruction Address Mod .Dummy DLP D1 D2\nCS#\nSCK\nIO0\nIO1\nIO2\nIO3\nPhase \n                             \n2824201612 84040 7   6 5   4 321   0 40404\n2925211713 95151 7   6 5   4 321   0 51515\n302622181410 6262 7   6 5   4 321   0 62626\n312723191511 7373 7   6 5   4 321   0 73737\nAddress Mode Dummy DLP D1 D2\nNote\n48.Example DLP of 34h (or 00110100).\nDatasheet 106 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.5 Program flash array commands\n9.5.1 Program granularity9.5.1.1 Automatic ECC\nEach 16 byte aligned and 16 byte length  Programming Block has an  automatic Error Correction Code (ECC) value. \nThe data block plus ECC form an ECC unit. In combination with Error Detection and Correction (EDC) logic the ECC is used to detect and correct any single bit error found during a read access. When data is first programmed within an ECC unit the ECC value is set for the entire ECC unit. If the same ECC unit is programmed more than once \nthe ECC value is changed to disable the EDC function. A se ctor erase is needed to again enable Automatic ECC on \nthat Programming Block. The 16 byte Program Block is th e smallest program granularity on which Automatic ECC \nis enabled.\nThese are automatic operations transparent to the us er. The transparency of the Automatic ECC feature \nenhances data accuracy for typical programming operations  which write data once to each ECC unit but, facili-\ntates software compatibility to previous generations of FL family of products by allowing for single byte \nprogramming and bit walking in which the same ECC unit is programmed more than once. When an ECC unit has \nAutomatic ECC disabled, EDC is not done on  data read from the ECC unit location.\nAn ECC status register is provided for determining if ECC is enabled on an ECC unit and whether any errors have \nbeen detected and corrected in the ECC unit data or the ECC (See “ECC status register (ECCSR)” on page 62.) \nThe ECC Status Register Read (ECCRD) command is used to read the ECC status on any ECC unit.\nError Detection and Correction (EDC) is applied to all part s of the Flash address spaces  other than registers. An \nError Correction Code (ECC) is calculated for each group of  bytes protected and the ECC is stored in a hidden area \nrelated to the group of bytes. The group of protected by tes and the related ECC are together called an ECC unit.\nECC is calculated for each 16 byte aligned and length ECC unit.\n• Single Bit EDC is supported with 8 ECC bits per ECC unit, plus 1 bit for an ECC disable Flag.• Sector erase resets all ECC bits and ECC disable flags in a sector to the default state (enabled).\n• ECC is programmed as part of the standard Program commands operation.\n• ECC is disabled automatically if multiple progra mming operations are done on the same ECC unit.\n• Single byte programming or bit walking is allowed but disables ECC on the second program to the same 16-byte \nECC unit.\n• The ECC disable flag is programmed when ECC is disabled.\n• To re-enable ECC for an ECC unit that has been disabled, the Sector that includes th e ECC unit must be erased.\n• To ensure the best data integrity provided by EDC, each ECC unit should be programmed only once so that ECC \nis stored for that unit and not disabled.\n• The calculation, programming, and disabling of ECC is done automatically as part of a programming operation. \nThe detection and correction, if needed, is done automatica lly as part of read operations. The host system sees \nonly corrected data from a read operation.\n• ECC protects the OTP region - however a second program operation on the same ECC unit will disable ECC \npermanently on that ECC unit (OTP is one time progra mmable, hence an erase operation to re-enable the ECC \nenable/indicator bit is prohibited).\n9.5.1.2 Page programming\nPage Programming is done by loading a Page Buffer with data to be programmed and issuing a programming command to move data from the buffer to the memory array.  This sets an upper limit on the amount of data that \ncan be programmed with a single programming command.  Page Programming allows up to a page size (512 \nbytes) to be programmed in one operation. The page is aligned on the page size address boundary. It is possible to program from one bit up to a page size in each Page programming operation. It is recommended that a multiple of 16 byte length and aligned Program Blocks be written. For the very best performance, programming \nDatasheet 107 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nshould be done in full pages of 512 bytes aligned on 512- byte boundaries with each Page being programmed only \nonce.\n9.5.1.3 Single byte programming\nSingle Byte Programming allows full backward compat ibility to the standard SPI Page Programming (PP) \ncommand by allowing a single byte to be programmed anywhere in the memory array. While single byte \nprogramming is supported, this will disable Automatic ECC on the 16 byte ECC unit where the byte is located.\n9.5.2 Page program (PP 02h or 4PP 12h)\nThe Page Program (PP) commands allows bytes to be pr ogrammed in the memory (changing bits from 1 to 0). \nBefore the Page Program (PP) commands can be accepted by the device, a Write Enable (WREN) command must be issued and decoded by the device. After the Write Enable (WREN) command has been decoded successfully, the device sets the Write Enable Latch (WEL) in the Status Register to enable any write operations.\nThe instruction \n• 02h (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n• 02h (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 12h is followed by a 4-byte address (A31-A0)\nand at least one data byte on SI. Up to a page can be provided on SI after the 3-byte address with instruction 02h \nor 4-byte address with instruction 12h has been provided. If the 9 least significant address bits (A8-A0) are not all \nzero, all transmitted data that goes beyond the end of the current page are programmed from the start address \nof the same page (from the address whose 9 least significan t bits (A8-A0) are all zero) i.e. the address wraps within \nthe page aligned address boundaries. This is a result of only requiring the user to enter one single page address \nto cover the entire page boundary.\nIf less than a page of data is sent to the device, these data bytes will be programmed in sequence, starting at the \nprovided address within the page, without having any affect on th e other bytes of the same page.\nFor optimized timings, using the Page Program (PP) command  to load the entire page size program buffer within \nthe page boundary will save overall programming time versus loading less than a page size into the program buffer.\nThe programming process is managed by the flash memory  device internal control logic. After a programming \ncommand is issued, the programming operation status can be checked using the Read Status Register-1 \ncommand. The WIP bit (SR1[0]) will indicate when th e programming operation is completed. The P_ERR bit \n(SR1[6]) will indicate if an error occurs in the progra mming operation that prevents  successful completion of \nprogramming.\nFigure 98 Page program (PP 02h or 4PP 12h) command sequence\n9.5.3 Quad page program (QPP 32h or 38h, or 4QPP 34h)\nThe Quad-input Page Program (QPP) command allows by tes to be programmed in the memory (changing bits \nfrom 1 to 0). The Quad-input Page Program (QPP) command allows up to a page size (512 bytes) of data to be \nloaded into the Page Buffer using four signals: I/O0-I/O3. QPP can improve performance for PROM Programmer and applications that have slower clock speeds (< 12 MHz) by  loading 4 bits of data per clock cycle. Systems with \nfaster clock speeds do not realize as much benefit for the QPP command since the inherent page program time CS#\nSCK\nSI\nSO\nPhase76543210A 5432107654321076543210\nInstruction Address Input Data 1 Input Data 2\nDatasheet 108 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nbecomes greater than the time it takes to clock-in th e data. The maximum frequency for the QPP command is 80 \nMHz.\nTo use Quad Page Program the Quad Enable Bit in the Configuration Register must be set (QUAD=1). A Write \nEnable command must be executed be fore the device will accept the QPP command (Status Register-1, WEL=1). \nThe instruction \n• 32h (ExtAdd=0) is followed by a 3-byte address (A23-A0) or\n• 32h (ExtAdd=1) is followed by a 4-byte address (A31-A0) or\n• 38h (ExtAdd=0) is followed by a 3-byte address (A23-A0) or• 38h (ExtAdd=1) is followed by a 4-byte address (A31-A0) or• 34h is followed by a 4-byte address (A31-A0)\nand at least one data byte, into the I/O signals. Data mu st be programmed at the previously erased (FFh) memory \nlocations. \nRecommend the programming page is aligned on the page size address boundary. It is possible to program from \none bit up to a page size in each Page programming operatio n. It is recommended that a multiple of 16 byte length \nand aligned Program Blocks be written. This insures that Automatic ECC is not disabled” .\nAll other functions of QPP are identical to Page Progra m. The QPP command sequence is shown in the figure \nbelow.\nFigure 99 Quad 512-byte page program command sequence\n9.5.4 Program suspend (PGSP 85h) and resume (PGRS 8Ah)\nThe Program Suspend command allows the system to in terrupt a programming operation and then read from \nany other non-erase-suspended sector or non-program-su spended-page. Program Suspend is valid only during \na programming operation. \nCommands allowed after the Program Suspend command is issued:\n• Read Status Register 1 (RDSR1 05h)\n• Read Status Register 2 (RDSR2 07h)\nThe Write in Progress (WIP) bit in Status Register 1 (S R1[0]) must be checked to know when the programming \noperation has stopped. The Program Suspend Status bit in the Status Register-2 (SR2[0]) can be used to \ndetermine if a programming operation has been suspended or was completed at the time WIP changes to 0. The \ntime required for the suspend operation to complete is tPSL, see Table 46 .\nSee Table 44  for the commands allowed while programming is suspend.\nThe Program Resume command 8Ah must be written to  resume the programming operation after a Program \nSuspend. If the programming operation was completed du ring the suspend operation, a resume command is not \nneeded and has no effect if issued. Program Resume commands will be ignored unless a Program operation is \nsuspended.\nAfter a Program Resume command is issued, the WIP bit in  the Status Register-1 will be set to a 1 and the \nprogramming operation will resume. Program operations may be interrupted as often as necessary e.g. a \nprogram suspend command could immediately follow a pr ogram resume command but, in order for a program CS#\nSCK\nIO0\nIO1\nIO2\nIO3\nPhase \n                                               \n7 6 5 4 3 2 1 0 A  1 0 4 0 4 0 4 0 4 0 4 0 4\n5 1 5 1 5 1 5 1 5 1 5\n6 2 6 2 6 2 6 2 6 2 6\n7 3 7 3 7 3 7 3 7 3 7\nInstruction Address Data 1 Data 2 Data 3 Data 4 Data 5 ...\nDatasheet 109 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\noperation to progress to completion there must be some  periods of time between resume and the next suspend \ncommand greater than or equal to tPRS. See Table 46 .\nFigure 100 Program suspend (PGSP 85h) command sequence\nFigure 101 10.55 Program resume (PGRS 8Ah) command sequence\n9.6 Erase flash array commands\n9.6.1 Sector erase (SE D8h or 4SE DCh)\nThe Sector Erase (SE) command sets all bits in the addres sed sector to 1 (all bytes are FFh). Before the Sector \nErase (SE) command can be accepted by the device, a Write Enable (WREN) command must be issued and \ndecoded by the device, which sets the Write Enable Latch (WEL) in the Status Register to enable any write opera-\ntions.\nThe instruction \n• D8h [ExtAdd=0] is followed by a 3-byte address (A23-A0), or\n• D8h [ExtAdd=1] is followed by a 4-byte address (A31-A0), or\n• DCh is followed by a 4-byte address (A31-A0)\nCS# must be driven into the logic high state after the twenty-fourth or thirty-second bit of address has been \nlatched in on SI. This will initiate the erase cycle, wh ich involves the pre-programming and erase of the chosen \nsector. If CS# is not driven high after the last bit of address, the sector erase operation will not be executed. \nAs soon as CS# is driven into the logic high state, the in ternal erase cycle will be initiated. With the internal erase \ncycle in progress, the user can read the value of the Write- In Progress (WIP) bit to check if the operation has been CS#\nSCK\nSI\nSO\nPhasePhase     \n                                                                         \n76543210 76543210 76543210\n76543210\nSuspend Instruction Read Status Instruction Status Instr. During Suspend\nRepeat Status Read Until SuspendedtPSL\nCS#\nSCK\nSI\nSO\nPhase7 6 5 4 3 2 1 0\nInstruction\nDatasheet 110 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\ncompleted. The WIP bit will indicate a 1 when the erase cycl e is in progress and a0 when the erase cycle has been \ncompleted.\nA Sector Erase (SE) command applied to a sector that ha s been Write Protected through the Block Protection bits \nor ASP , will not be executed and will set the E_ERR status.\nASP has a PPB and a DYB protection bit for each sector.\nFigure 102 Sector erase (SE D8h or 4SE DCh) command sequence\n9.6.2 Bulk erase (BE 60h or C7h)\nThe Bulk Erase (BE) command sets all bits to 1 (all bytes ar e FFh) inside the entire flash memory array. Before the \nBE command can be accepted by the device, a Write Enable (WREN) command must be issued and decoded by the device, which sets the Write Enable Latch (WEL) in the Status Register to enable any write operations.\nCS# must be driven into the logic high state after the eigh th bit of the instruction byte has been latched in on SI. \nThis will initiate the erase cycle, which involves the pre- programming and erase of the entire flash memory array. \nIf CS# is not driven high after the last bit of instruction, the BE operation will not be executed.\nAs soon as CS# is driven into the logic high state, the er ase cycle will be initiated. With the erase cycle in progress, \nthe user can read the value of the Write-In Progress (WIP) bit to determine when the operation has been \ncompleted. The WIP bit will indicate a 1 when the erase cycl e is in progress and a 0 when the erase cycle has been \ncompleted.\nA BE command can be executed only when the Block Protection  (BP2, BP1, BP0) bits are set to 0’s. If the BP bits \nare not zero, the BE command is not executed and E_E RR is not set. The BE command will skip any sectors \nprotected by the DYB or PPB and the E_ERR status will not be set.\nFigure 103 Bulk erase command sequence\n9.6.3 Erase suspend and resume commands (ERSP 75h or ERRS 7Ah)\nThe Erase Suspend command, allows the system to interr upt a sector erase operation and then read from or \nprogram data to, any other sector. Erase Suspend is valid only during a sector erase operation. The Erase Suspend command is ignored if written du ring the Bulk Erase operation.\nWhen the Erase Suspend command is written during the se ctor erase operation, the device requires a maximum \nof t\nESL (erase suspend latency) to suspend the er ase operation and update the status bits. See Table 47 .\nCommands allowed after the Erase Suspend command is issued:\n• Read Status Register 1 (RDSR1 05h)• Read Status Register 2 (RDSR2 07h)CS#\nSCK\nSI\nSO\nPhase \n                        \n7 6 5 4 3 2 1 0 A  1 0\nInstruction     Address\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDatasheet 111 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nThe Write in Progress (WIP) bit in Status Register 1 (SR1 [0]) must be checked to know when the erase operation \nhas stopped. The Erase Suspend bit in Status Register-2 (S R2[1]) can be used to determine if an erase operation \nhas been suspended or was completed at the time WIP changes to 0.\nIf the erase operation was completed during the suspen d operation, a resume comma nd is not needed and has \nno effect if issued. Erase Resume commands will be  ignored unless an Erase operation is suspended.\nSee Table 44  for the commands allowed while erase is suspend.\nAfter the erase operation has been suspended, the sector  enters the erase-suspend mode. The system can read \ndata from or program data to the device. Reading at any address within an erase-suspended sector produces \nundetermined data. \nA WREN command is required before any command that will change non-volatile data, even during erase \nsuspend.\nThe WRR and PPB Erase commands are not allowed during Eras e Suspend, it is therefore not possible to alter the \nBlock Protection or PPB bits during Erase Suspend. If th ere are sectors that may need programming during Erase \nsuspend, these sectors should be prot ected only by DYB bits that can be turned off during Erase Suspend. \nHowever, WRR is allowed immediately following the BRAC command; in this special ca se the WRR is interpreted \nas a write to the Bank Address Register, not a write to SR1 or CR1.\nIf a program command is sent for a location within an er ase suspended sector the program operation will fail with \nthe P_ERR bit set.\nAfter an erase-suspended program operation is complete , the device returns to th e erase-suspend mode. The \nsystem can determine the status of the program operation by reading the WIP bit in the Status Register, just as \nin the standard program operation.\nThe Erase Resume command 7Ah must be written to resume  the erase operation if an Erase is suspend. Erase \nResume commands will be ignored unless an Erase is Suspend.\nAfter an Erase Resume command is sent, the WIP bit in the status register will be set to a 1 and the erase operation \nwill continue. Further Resume commands are ignored. \nErase operations may be interrupted as often as nece ssary e.g. an erase suspend command could immediately \nfollow an erase resume command but, in order for an erase operation to progress to completion there must be some periods of time between resume and the ne xt suspend command greater than or equal to t\nERS. See \nTable 47 .\nFigure 104 Erase suspend (ERSP 75h) command sequence\nFigure 105 Erase resume (ERRS 7Ah) command sequenceCS#\nSCK\nSI\nSO\nPhasePhase     \n                                                                         \n76543210 76543210 76543210\n76543210\nSuspend Instruction Read Status Instruction Status Instr. During Suspend\nRepeat Status Read Until SuspendedtESL\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDatasheet 112 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nTable 45 Commands allowed during program or erase suspend\nInstruction \nnameInstruction \ncode \n(Hex)Allowed \nduring \nerase \nsuspendAllowed \nduring \nprogram \nsuspendComment\nBRAC B9 X X Bank address register may need to be changed during a \nsuspend to reach a sector for read or program.\nBRRD 16 X X Bank address register may need to be changed during a \nsuspend to reach a sector for read or program.\nBRWR 17 X X Bank address register may need to be changed during a \nsuspend to reach a sector for read or program.\nCLSR 30 X – Clear status may be used if a program operation fails during \nerase suspend. \nDYBRD E0 X – It may be necessary to remove and restore dynamic \nprotection during erase suspend to allow programming during erase suspend. \nDYBWR E1 X – It may be necessary to remove and restore dynamic \nprotection during erase suspend to allow programming during erase suspend. \nERRS 7A X – Required to resume from erase suspend.\nDDRFR 0D X X All array reads allowed in suspend.\n4DDRFR 0E X X All array reads allowed in suspend.\nFAST_READ 0B X X All array reads allowed in suspend.\n4FAST_READ 0C X X All array reads allowed in suspend.\nMBR FF X X May need to reset a read operation during suspend.\nPGRS 8A X X Needed to resume a program operation. A program resume \nmay also be used during nest ed program suspend within an \nerase suspend.\nPGSP 85 X – Program suspend allowed during erase suspend.\nPP 02 X – Required for array program during erase suspend.\n4PP 12 X – Required for array program during erase suspend.\nPPBRD E2 X – Allowed for checking persistent protection before \nattempting a program command during erase suspend. \nQPP 32, 38 X – Required for array program during erase suspend.\n4QPP 34 X – Required for array program during erase suspend.\n4READ 13 X X All array reads allowed in suspend.\nRDCR 35 X X –\nDIOR BB X X All array reads allowed in suspend.\n4DIOR BC X X All array reads allowed in suspend.\nDOR 3B X X All array reads allowed in suspend.\n4DOR 3C X X All array reads allowed in suspend.\nDDRDIOR BD X X All array reads allowed in suspend.\n4DDRDIOR BE X X All array reads allowed in suspend.\nDDRQIOR ED X X All array reads allowed in suspend.\nDDRQIOR4 EE X X All array reads allowed in suspend.\nDatasheet 113 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.7 One time program array commands\n9.7.1 OTP program (OTPP 42h)\nThe OTP Program command programs data in the One Time Program region, which is in a different address space \nfrom the main array data. The OTP region is 1024 bytes so, th e address bits from A23 to A10 must be zero for this \ncommand. Refer to “OTP address space” on page 54 for details on the OTP region. The protocol of the OTP \nProgram command is the same as the Page Program command. Before the OTP Program command can be accepted by the device, a Write Enable (WREN) command must be issued and decoded by the device, which sets the Write Enable Latch (WEL) in the Status Register to enable any write operations.\nTo program the OTP array in bit granularity, the rest of the bits within a data byte can be set to 1.Each region in the OTP memory space can be programmed one or more times, provided  that the region is not \nlocked. Attempting to program zeros in a region that is  locked will fail with the P_ERR bit in SR1 set to 1 \nProgramming ones, even in a protected area does not ca use an error and does not set P_ERR. Subsequent OTP \nprogramming can be performed only on the un-programmed bits (that is, 1 data). \nFigure 106 Page program (OTPP 42h) command sequence\n9.7.2 OTP read (OTPR 4Bh)\nThe OTP Read command reads data from the OTP region. The OTP region is 1024 bytes so, the address bits from \nA23 to A10 must be zero for this command. Refer to “OTP address space” on page 54 for details on the OTP \nregion. The protocol of the OTP Read command is similar to the Fast Read command except that it will not wrap to the starting address after the OTP address is at it s maximum; instead, the data beyond the maximum OTP QIOR EB X X All array reads allowed in suspend.\n4QIOR EC X X All array reads allowed in suspend.\nQOR 6B X X All array reads allowed in suspend.\n4QOR 6C X X All array reads allowed in suspend.\nRDSR1 05 X X Needed to read WIP to determine end of suspend process.RDSR2 07 X X Needed to read suspend status to determine whether the \noperation is suspended or complete.\nREAD 03 X X All array reads allowed in suspend.\nRESET F0 X X Reset allowed anytime.\nWREN 06 X – Required for program command within erase suspend.\nWRR 01 X X Bank register may need to be changed during a suspend to \nreach a sector needed for read or program. WRR is allowed when following BRAC.Table 45 Commands allowed during program or erase suspend\n (continued)\nInstruction \nnameInstruction \ncode \n(Hex)Allowed \nduring \nerase \nsuspendAllowed \nduring \nprogram \nsuspendComment\nCS#\nSCK\nSI\nSO\nPhase7654321023 5432107654321076543210\nInstruction Address Input Data 1 Input Data 2\nDatasheet 114 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\naddress will be undefined. Also, the OTP Read command is not affected by the latency code. The OTP read \ncommand always has one dummy byte of latency as shown below.\nFigure 107 Read OTP (OTPR 4Bh) command sequence\n9.8 Advanced sector protection commands\n9.8.1 ASP read (ASPRD 2Bh)\nThe ASP Read instruction 2Bh is shifted into SI by the risi ng edge of the SCK signal. Then the 16-bit ASP register \ncontents is shifted out on the serial output SO, LSB first. Each bit is shifted out at the SCK frequency by the falling \nedge of the SCK signal. It is possible to read the ASP register continuously by providing multiples of 16 clock \ncycles. The maximum operating clock frequency for the ASP Read (ASPRD) command is 133 MHz.\nFigure 108 ASPRD command\n9.8.2 ASP program (ASPP 2Fh)\nBefore the ASP Program (ASPP) command can be accepted  by the device, a Write Enable (WREN) command must \nbe issued. After the Write Enable (WREN) command has b een decoded, the device will set the Write Enable Latch \n(WEL) in the Status Register to enable any write operations.\nThe ASPP command is entered by driving CS# to the logi c low state, followed by the instruction and two data \nbytes on SI, LSB first. The ASP Register is two data bytes in length. \nThe ASPP command affects the P_ERR and WIP bits of the Status and Configuration Registers in the same manner \nas any other programming operation.\nCS# input must be driven to the logic high state after the si xteenth bit of data has been latched in. If not, the ASPP \ncommand is not executed. As soon as CS# is driven to the logic high state, the self-timed ASPP operation is \ninitiated. While the ASPP operation is in  progress, the Status Register may be read to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bi t is a 1 during the self-timed  ASPP operation, and is a 0 \nwhen it is completed. When the AS PP operation is completed, the Write Enable Latch (WEL) is set to a 0.\nFigure 109 ASPP (2Fh) commandCS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321023  10  \n76543210  \nInstruction Address Dummy Cycles Data 1\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nCS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input ASPR Low Byte Input ASPR High Byte\nDatasheet 115 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.8.3 DYB read (DYBRD E0h)\nThe instruction E0h is latched into SI by the rising edge of the SCK signal. Followed by  the 32-bit address selecting \nlocation zero within the desired sector (note, the high or der address bits not used by a particular density device \nmust be zero). Then the 8-bit DYB access register contents  are shifted out on the seri al output SO. Each bit is \nshifted out at the SCK frequency by the falling edge of th e SCK signal. It is possible to read the same DYB access \nregister continuously by providing mu ltiples of eight clock cycles. The address of the DYB register does not \nincrement so this is not a means to read the entire DYB array. Each location must be read with a separate DYB Read command. The maximum operating cloc k frequency for READ command is 133 MHz.\nFigure 110 DYBRD command sequence\n9.8.4 DYB write (DYBWR E1h)\nBefore the DYB Write (DYBWR) command can be accepted by the device, a Write Enable (WREN) command must \nbe issued. After the Write Enable (WREN) command has b een decoded, the device will set the Write Enable Latch \n(WEL) in the Status Register to enable any write operations.\nThe DYBWR command is entered by driving CS# to the logi c low state, followed by the instruction, the 32-bit \naddress selecting location zero within the desired sect or (note, the high order ad dress bits not used by a \nparticular density device must be zero), then the data byte on SI. The DYB Access Register is one data byte in length.\nThe DYBWR command affects the P_ERR and WIP bits of the Status and Configuration Registers in the same \nmanner as any other programming operation. CS# must be driven to the logic high state after the eighth bit of \ndata has been latched in. If not, the DYBWR command is no t executed. As soon as CS# is driven to the logic high \nstate, the self-timed DYBWR operation is initiated. While the DYBWR operation is in progress, the Status Register \nmay be read to check the value of the Write-In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during the self-timed DYBWR operation, and is a 0 when it is comp leted. When the DYBWR operat ion is completed, the Write \nEnable Latch (WEL) is set to a 0. \nFigure 111 DYBWR (E1h) command sequence\n9.8.5 PPB read (PPBRD E2h)\nThe instruction E2h is shifted into SI by the rising edges of the SCK signal, followed by the 32-bit address selecting \nlocation zero within the desired sector (note, the high or der address bits not used by a particular density device \nmust be zero) Then the 8-bit PPB access register contents are shifted out on SO. \nIt is possible to read the same PPB access register contin uously by providing multiple s of eight clock cycles. The \naddress of the PPB register does not in crement so this is not a means to read the entire PPB array. Each location CS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n7654321076543210  \nInstruction Address Register Repeat Register\nCS#\nSCK\nSI\nSO\nPhase76543210 3 1 54321076543210\nInstruction Address Input Data\nDatasheet 116 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nmust be read with a separate PPB Read command. Th e maximum operating clock fr equency for the PPB Read \ncommand is 133 MHz.\nFigure 112 PPBRD (E2h) command sequence\n9.8.6 PPB program (PPBP E3h)\nBefore the PPB Program (PPBP) command can be accepted by the device, a Write Enable (WREN) command must \nbe issued. After the Write Enable (WREN) command has b een decoded, the device will set the Write Enable Latch \n(WEL) in the Status Register to enable any write operations.\nThe PPBP command is entered by driving CS# to the logic low state, followed by the instruction, followed by the \n32-bit address selecting location zero within the desired se ctor (note, the high order address bits not used by a \nparticular density device must be zero).\nThe PPBP command affects the P_ERR and WIP bits of the Status and Configuration Registers in the same manner \nas any other programming operation.\nCS# must be driven to the logic high state after the last  bit of address has been latched in. If not, the PPBP \ncommand is not executed. As soon as CS# is driven to the logic high state, the self-timed PPBP operation is \ninitiated. While the PPBP oper ation is in progress, the Status Register  may be read to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bi t is a 1 during the self-timed  PPBP operation, and is a 0 \nwhen it is completed. When the PP BP operation is completed, the Write Enable Latch (WEL) is set to a 0.\nFigure 113 PPBP (E3h) command sequence\n9.8.7 PPB erase (PPBE E4h)\nThe PPB Erase (PPBE) command sets all PPB bits to 1. Before the PPB Erase command can be accepted by the \ndevice, a Write Enable (WREN) command must be issued and decoded by the device, which sets the Write Enable \nLatch (WEL) in the Status Register to enable any write operations.\nThe instruction E4h is shifted into SI by the rising edges of the SCK signal.\nCS# must be driven into the logic high state after the eigh th bit of the instruction byte has been latched in on SI. \nThis will initiate the beginning of internal erase cycle, which involves the pre-programming and erase of the entire CS#\nSCK\nSI\nSO\nPhase \n                                                \n7654321031  10  \n7654321076543210  \nInstruction Address Register Repeat Register\nCS#\nSCK\nSI\nSO\nPhase \n                         \n7 6 5 4 3 2 1 0 31  1 0\nInstruction     Address\nDatasheet 117 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nPPB memory array. Without CS# being driven to the logic hi gh state after the eighth bit of the instruction, the PPB \nerase operation will not be executed.\nWith the internal erase cycle in progress, the user can read  the value of the Write-In Progress (WIP) bit to check if \nthe operation has been completed. The WIP bit will indicate  a 1 when the erase cycle is in progress and a 0 when \nthe erase cycle has been completed. Erase suspend is not allowed during PPB Erase.\nFigure 114 PPB erase (PPBE E4h) command sequence\n9.8.8 PPB lock bit read (PLBRD A7h)\nThe PPB Lock Bit Read (PLBRD) command allows the PPB Lock Register contents to be read out of SO. It is \npossible to read the PPB lock register continuously by providing multiples of eight clock cycles. The PPB Lock \nRegister contents may only be read when the device is in  standby state with no other operation in progress. It is \nrecommended to check the Write-In Progress (WIP) bit of  the Status Register before issuing a new command to \nthe device.\nFigure 115 PPB lock register read command sequence\n9.8.9 PPB lock bit write (PLBWR A6h)\nThe PPB Lock Bit Write (PLBWR) command clears the PPB Lock Register to zero. Before the PLBWR command can \nbe accepted by the device, a Write Enable (WREN) comm and must be issued and decoded by the device, which \nsets the Write Enable Latch (WEL) in the Status Register to enable any write operations.\nThe PLBWR command is entered by driving CS# to the logic low state, followed by the instruction.\nCS# must be driven to the logic high state after the eighth  bit of instruction has been latched in. If not, the PLBWR \ncommand is not executed. As soon as CS# is driven to the logic high state, the self-timed PLBWR operation is \ninitiated. While the PLBWR operation is in progress, the Stat us Register may still be read to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during the self-timed PLBWR operation, and is a \n0 when it is completed. When the PLBWR operation is comp leted, the Write Enable Latch (WEL) is set to a 0. The \nmaximum clock frequency for the PLBWR command is 133 MHz.\nFigure 116 PPB lock bit write (PLBWR A6h) command sequenceCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nCS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Register Read Repeat Register Read\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDatasheet 118 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\n9.8.10 Password read (PASSRD E7h)\nThe correct password value may be read only after it is programmed and before the Password Mode has been \nselected by programming the Password Protection Mode bi t to 0 in the ASP Register (ASP[2]). After the Password \nProtection Mode is selected the PASSRD command is ignored.\nThe PASSRD command is shifted into SI. Then the 64-bit Pass word is shifted out on the serial output SO, LSB first, \nmost significant bit of each byte first. Each bit is shif ted out at the SCK frequency by the falling edge of the SCK \nsignal. It is possible to read the Password continuously  by providing multiples of 64 clock cycles. The maximum \noperating clock frequency for the PASSRD command is 133 MHz.\nFigure 117 Password read (PASSRD E7h) command sequence\n9.8.11 Password program (PASSP E8h)\nBefore the Password Program (PASSP) command can be  accepted by the device, a Write Enable (WREN) \ncommand must be issued and decoded by the device . After the Write Enable (WREN) command has been \ndecoded, the device sets the Write Enable Latch (WEL) to enable the PASSP operation.\nThe password can only be programmed before the Password Mode is selected by programming the Password \nProtection Mode bit to 0 in the ASP Register (ASP[2]). Af ter the Password Protection Mode is selected the PASSP \ncommand is ignored.\nThe PASSP command is entered by driving CS# to the logic low state, followed by the instruction and the \npassword data bytes on SI, LSB first, most significant bit of each byte first. The password is sixty-four (64) bits in \nlength. \nCS# must be driven to the logic high state after the sixty-fourth (64th) bit of data has been latched. If not, the \nPASSP command is not executed. As soon as CS# is driven to the logic high state, the self-timed PASSP operation \nis initiated. While the PASSP operation is in progress, th e Status Register may be read to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during the self-timed PASSP cycle, and is a 0 when it is completed. The PASSP command can report a program error in the P_ERR bit of th e status register. When the \nPASSP operation is completed, the Write Enable Latch (W EL) is set to a 0. The maximum clock frequency for the \nPASSP command is 133 MHz.\nFigure 118 Password program (PASSP E8h) command sequence\n9.8.12 Password unlock (PASSU E9h)\nThe PASSU command is entered by driving CS# to the lo gic low state, followed by the instruction and the \npassword data bytes on SI, LSB first, most significant bit of each byte first. The password is sixty-four (64) bits in \nlength. \nCS# must be driven to the logic high state after the sixty-fourth (64th) bit of data has been latched. If not, the \nPASSU command is not executed. As soon as CS# is driven to the logic high state, the self-timed PASSU operation CS#\nSCK\nSI\nSO\nPhase76543210\n7654321076543210\nInstruction Data 1 Data N\nCS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input Password Low Byte     Input Password High Byte\nDatasheet 119 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nis initiated. While the PASSU operation is in progress, th e Status Register may be read to check the value of the \nWrite-In Progress (WIP) bit. The Write-In Progress (WIP) bit is a 1 during the self-timed PASSU cycle, and is a 0 when \nit is completed. \nIf the PASSU command supplied password does not match the hidden password in the Password Register, an \nerror is reported by setting the P_ERR bit to 1. The WIP bit of  the status register also remains set to 1. It is necessary \nto use the CLSR command to clear the status register, th e RESET command to software reset the device, or drive \nthe RESET# input low to initiate a hardware reset, in orde r to return the P_ERR and WIP bits to 0. This returns the \ndevice to standby state, ready for new commands such as a retry of the PASSU command.\nIf the password does match, the PPB Lock bit is set to 1. The maximum clock frequency for the PASSU command \nis 133 MHz.\nFigure 119 Password unlock (PASSU E9h) command sequence\n9.9 Reset commands\n9.9.1 Software reset command (RESET F0h)\nThe Software Reset command (RESET) restores the device to its initial power up state, except for the volatile \nFREEZE bit in the Configuration register CR1[1] and the vo latile PPB Lock bit in the PPB Lock Register. The Freeze \nbit and the PPB Lock bit will remain set at their last value prior to the software reset. To clear the FREEZE bit and \nset the PPB Lock bit to its protection mode selected power on state, a full power-on-reset sequence or hardware reset must be done. Note that the non-volatile bits in the configuration register, TBPROT , TBPARM, and BPNV, \nretain their previous state after a Software Reset. The Bl ock Protection bits BP2, BP1, and BP0, in the status \nregister will only be reset if they are configured as vola tile via the BPNV bit in the Configuration Register (CR1[3]) \nand FREEZE is cleared to zero . The software reset cannot be used to circumvent the FREEZE or PPB Lock bit protection mechanisms for the other security configurat ion bits. The reset command is executed when CS# is \nbrought to high state and requires t\nRPH time to execute.\nFigure 120 Software reset (RESET F0h) command sequence\n9.9.2 Mode bit reset (MBR FFh)\nThe Mode Bit Reset (MBR) command can be used to return  the device from continuous high performance read \nmode back to normal standby awaiting any new comma nd. Because some device packages lack a hardware \nRESET# input and a device that is in a continuous high performance read mode may not recognize any normal SPI command, a system hardware reset or software reset command may not be recognized by the device. It is recommended to use the MBR command after a system reset when the RESET# signal is not available or, before \nsending a software reset, to ensure the device is released from continuous high performance read mode.\nThe MBR command sends Ones on SI or I/O0 for 8 SCK cycl es. I/O1 to I/O3 are “don’t  care” during these cycles.CS#\nSCK\nSI\nSO\nPhase765432107654321076543210\nInstruction Input Password Low Byte     Input Password High Byte\nCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nDatasheet 120 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nCommands\nFigure 121 Mode bit (MBR FFh) reset command sequence\n9.10 Embedded algorithm performance tables\nTable 46 Program and erase performance\nSymbol Parameter Min Typ[49]Max[50]Unit\ntW WRR Write Time  – 560 2000 ms \ntPP Page Programming (512 bytes) – 340 750/1300[51]µs\ntSE Sector Erase Time \n(256-kB logical sectors = 4 x 64 kB physical sectors) – 520 2600 ms\ntBE Bulk Erase Time (S25FL512S) – 103 460 sec\nTable 47 Program suspend AC parameters\nParameter MinTypi-\ncal Max Unit Comments \nProgram Suspend Latency (tPSL) –  40 µs  The time from Program Suspend \ncommand until the WIP bit is 0\nProgram Resume to next Program \nSuspend (tPRS) 0.06 100  – µs Minimum is the time needed to issue the \nnext Program Suspend command but ≥ \ntypical periods are needed for Program to progress to completion\nTable 48 Erase suspend AC parameters\nParameter MinTypi-\ncal Max Unit Comments \nErase Suspend Latency (t\nESL) –  – 45 µs  The time from Erase Suspend \ncommand until the WIP bit is 0\nErase Resume to next Erase \nSuspend (tERS)  0.06 100 – µs Minimum is the time needed to issue \nthe next Erase Suspend command but ≥ \ntypical periods are needed for the Erase to progress to completionCS#\nSCK\nSI\nSO\nPhase76543210\nInstruction\nNotes\n49.Typical program and erase times assume the following conditions: 25°C, VCC = 3.0V; 10,000 cycles; checker-\nboard data pattern.\n50.Under worst case conditions of 90°C; 100,000 cycles max.51.Industrial temperature range / Industrial Plus temperature range.\nDatasheet 121 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nData integrity\n10 Data integrity\n10.1 Erase endurance\n10.2 Data retention\nContact Infineon Sales and FAE for further information on the data integrity.Table 49 Erase endurance\nParameter Minimum Unit \nProgram/Erase cycles per main Fl ash array sectors 100K PE cycle\nProgram/Erase cycles per PPB array or non-volatile register \narray[52]100K PE cycle\nTable 50 Data retention\nParameter Test conditions Minimum \ntime Unit \nData Retention Time 1K Program/Erase Cycles 20 Years\n10K Program/Erase Cycles 20 Years\n100K Program/Erase Cycles 2 Years\nNote\n52.Each write command to a non-volatile register causes a PE cycle on the entire non-volatile register array. OTP \nbits and registers internally reside in a separate array that is not PE cycled.\nDatasheet 122 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n11 Software interface reference\n11.1 Command summary\nTable 51 S25FL512S instruction set (sorted by instruction)\nInstruction (Hex) Command name Command description Maximum frequency \n(MHz)\n01 WRR Write Register \n(Status-1, Configuration-1) 133\n02 PP Page Program (3- or 4-byte \naddress) 133\n03 READ Read (3- or 4-byte address) 50\n04 WRDI Write Disable 133\n05 RDSR1 Read Status Register-1 133\n06 WREN Write Enable 13307 RDSR2 Read Status Register-2 133\n0B FAST_READ Fast Read (3- or 4-byte \naddress)133\n0C 4FAST_READ Fast Read (4-byte address) 133\n0D DDRFR DDR Fast Read (3- or 4-byte \naddress)80\n0E 4DDRFR DDR Fast Read (4-byte \naddress) 80\n12 4PP Page Program (4-byte \naddress) 133\n13 4READ Read (4-byte address) 50\n14 ABRD AutoBoot Register Read 133\n15 ABWR AutoBoot Register Write 13316 BRRD Bank Register Read 133\n17 BRWR Bank Register Write 133\n18 ECCRD ECC Read 133\n2B ASPRD ASP Read 133\n2F ASPP ASP Program 133\n30 CLSR Clear Status Register - \nErase/Program Fail Reset 133\n32 QPP Quad Page Program (3- or \n4-byte address)80\n34 4QPP Quad Page Program (4-byte \naddress) 80\n35 RDCR Read Configuration \nRegister-1 133\n38 QPP Quad Page Program (3- or \n4-byte address)80\n3B DOR Read Dual Out (3- or 4-byte \naddress)104\nDatasheet 123 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n3C 4DOR Read Dual Out (4-byte \naddress) 104\n41 DLPRD Data Learning Pattern Read 133\n42 OTPP OTP Program 133\n43 PNVDLR Program NV Data Learning \nRegister 133\n4A WVDLR Write Volatile Data \nLearning Register 133\n4B OTPR OTP Read 133\n5A RSFDP Read Serial Flash Discov-\nerable Parameters133\n60 BE Bulk Erase 133\n6B QOR Read Quad Out (3- or 4-byte \naddress)104\n6C 4QOR Read Quad Out (4-byte \naddress) 104\n75 ERSP Erase Suspend 133\n7A ERRS Erase Resume 133\n85 PGSP Program Suspend 133\n8A PGRS Program Resume 133\n90 READ_ID (REMS) Read Electronic Manufac-\nturer Signature 133\n9F RDID Read ID (JEDEC Manufac-\nturer ID and JEDEC CFI)133\nA3 MPM Reserved for Multi-I/O-High \nPerf Mode (MPM) 133\nA6 PLBWR PPB Lock Bit Write 133\nA7 PLBRD PPB Lock Bit Read 133\nAB RES Read Electronic Signature 50\nB9 BRAC Bank Register Access\n(Legacy Command formerly used for Deep Power Down)133\nBB DIOR Dual I/O Read (3- or 4-byte \naddress)104\nBC 4DIOR Dual I/O Read (4-byte \naddress) 104\nBD DDRDIOR DDR Dual I/O Read (3- or \n4-byte address)80\nBE 4DDRDIOR DDR Dual I/O Read (4-byte \naddress) 80\nC7 BE Bulk Erase (alternate \ncommand) 133Table 51 S25FL512S instruction set (sorted by instruction)\n (continued)\nInstruction (Hex) Command name Command description Maximum frequency \n(MHz)\nDatasheet 124 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n11.2 Serial flash discoverable parameters (SFDP) address map\nThe SFDP address space has a header starting at address zero that identifies the SFDP data structure and provides \na pointer to each parameter. One Basic Flash parameter is mandated by the JEDEC JESD216B standard. Two \noptional parameter tables for Sector Map and 4 Byte Addr ess Instructions follow the Basic Flash table. Infineon \nprovides an additional parameter by pointing to the ID-CFI  address space i.e. the ID-CFI address space is a sub-set \nof the SFDP address space. The parameter tables portion of  the SFDP data structure are located within the ID-CFI \naddress space and is thus both a CFI parameter and an SF DP parameter. In this way both SFDP and ID-CFI infor-\nmation can be accessed by eith er the RSFDP or RDID commands.D8 SE Erase 256 kB (3- or 4-byte \naddress)133\nDC 4SE Erase 256 kB (4-byte \naddress) 133\nE0 DYBRD DYB Read 133\nE1 DYBWR DYB Write 133\nE2 PPBRD PPB Read 133\nE3 PPBP PPB Program 133E4 PPBE PPB Erase 133\nE5 Reserved-E5 Reserved –\nE6 Reserved-E6 Reserved –E7 PASSRD Password Read 133\nE8 PASSP Password Program 133\nE9 PASSU Password Unlock 133\nEB QIOR Quad I/O Read (3- or 4-byte \naddress)104\nEC 4QIOR Quad I/O Read (4-byte \naddress) 104\nED DDRQIOR DDR Quad I/O Read (3- or \n4-byte address)80\nEE 4DDRQIOR DDR Quad I/O Read (4-byte \naddress) 80\nF0 RESET Software Reset 133\nFF MBR Mode Bit Reset 133\nTable 52 SFDP overview map\nByte address Description\n0000h Location zero within JEDEC JESD216B  SFDP space – start of SFDP header \n,,, Remainder of SFDP header followed by undefined space \n1000h Location zero within ID-CFI spac e – start of ID-CFI parameter tables \n... ID-CFI parameters \n1120h Start of SFDP parameter which is also one of the CFI parameter tables \n... Remainder of SFDP parameter tables followed by either more CFI parameters or undefined \nspace Table 51 S25FL512S instruction set (sorted by instruction)\n (continued)\nInstruction (Hex) Command name Command description Maximum frequency \n(MHz)\nDatasheet 125 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n11.2.1 Field definitions\nTable 53 SFDP header\nRelative \nbyte ad-\ndressSFDP \nDword ad-\ndressData Description \n00h SFDP \nHeader 1st \nDWORD 53h This is the entry poin t for Read SFDP (5Ah) command i.e. location zero \nwithin SFDP space ASCII “S” \n01h 46h ASCII “F” 02h 44h ASCII “D” 03h 50h ASCII “P” 04h SFDP \nHeader 2nd \nDWORD 06h SFDP Minor Revision (06h = JEDE C JESD216 Revision B) This revision \nis backward compatible with all pr ior minor revisions. Minor revisions \nare changes that define previously reserved fields, add fields to the end, or that clarify definitions of existing fields. Increments of the \nminor revision value indicate that previously reserved parameter fields may have been assigned a new definition or entire Dwords may have been added to the parameter table. However, the definition of previously existing fields is unchanged and therefore remain backward compatible with earlier SFDP parameter table revisions. Software can safely ignore increments of the minor revision number, as long as only those parameters the software was designed to support are used i.e. previously reserved fields and additional Dwords must be masked or ignored . Do no t do a simple compare on the minor \nrevision number, looking only for a match with the revision number that the software is designed to handle. There is no problem with using a higher number minor revision.\n05h 01h SFDP Major Revision This is th e original major revision. This major \nrevision is compatible with all SFDP reading and parsing software. \n06h 05h Number of Parameter Headers (zero based, 05h = 6 parameters) 07h FFh Unused 08h Parameter \nHeader 0 1st \nDWORD 00h Parameter ID LSb (00h = JEDEC SFDP Basic SPI Flash Parameter) \n09h 00h Parameter Minor Revision (00h  = JESD216) - This older revision \nparameter header is provided for any legacy SFDP reading and parsing \nsoftware that requires seeing a minor revision 0 parameter header. SFDP software designed to hand le later minor revisions should \ncontinue reading parameter headers looking for a higher numbered minor revision that contains additional parameters for that software revision. \n0Ah 01h Parameter Major Revision (01h = The original major revision - all SFDP \nsoftware is compatible with this major revision. \n0Bh 09h Parameter Table Length (in double words = Dwords = 4 byte units) 09h \n= 9 Dwords \n0Ch Parameter \nHeader 0 \n2nd DWORD 20h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC Basic \nSPI Flash parameter byte offset = 1120h \n0Dh 11h Parameter Table Pointer Byte 1 \n0Eh 00h Parameter Table Pointer Byte 2 \n0Fh FFh Parameter ID MSb (FFh = JEDEC defined legacy Parameter ID) \nDatasheet 126 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n10h Parameter \nHeader 1 1st \nDWORD 00h Parameter ID LSb (00h = JEDEC SFDP Basic SPI Flash Parameter) \n11h 05h Parameter Minor Revision (05h  = JESD216 Revision A) - This older \nrevision parameter header is provided for any legacy SFDP reading and parsing software that requires seeing a minor revision 5 parameter header. SFDP software designed to handle later minor revisions should continue reading parameter headers looking for a later minor revision that contains additional parameters. \n12h 01h Parameter Major Revision (01h = The original major revision - all SFDP \nsoftware is compatible with this major revision. \n13h 10h Parameter Table Length (in double words = Dwords = 4 byte units) 10h \n= 16 Dwords \n14h Parameter \nHeader 1 \n2nd DWORD 20h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC Basic \nSPI Flash parameter byte  offset = 1120h address \n15h 11h Parameter Table Pointer Byte 1 16h 00h Parameter Table Pointer Byte 2 17h FFh Parameter ID MSb (FFh = JEDEC defined Parameter) 18h Parameter \nHeader 2 1st \nDWORD 00h Parameter ID LSb (00h = JEDEC SFDP Basic SPI Flash Parameter) \n19h 06h Parameter Minor Revision (06h = JESD216 Revision B) \n1Ah 01h Parameter Major Revision (01h = The original major revision - all SFDP \nsoftware is compatible with this major revision. \n1Bh 10h Parameter Table Length (in double words = Dwords = 4 byte units) 10h \n= 16 Dwords \n1Ch Parameter \nHeader 2 \n2nd DWORD 20h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC Basic \nSPI Flash parameter byte  offset = 1120h address \n1Dh 11h Parameter Table Pointer Byte 1 \n1Eh 00h Parameter Table Pointer Byte 2 \n1Fh FFh Parameter ID MSb (FFh = JEDEC defined Parameter) 20h Parameter \nHeader 3 1st \nDWORD 81h Parameter ID LSb (81h = SFDP Sector Map Parameter) \n21h 00h Parameter Minor Revision (00h = Initial version as defined in JESD216 \nRevision B) \n22h 01h Parameter Major Revision (01h = The original major revision - all SFDP \nsoftware that recognizes this parameter’s ID is compatible with this major revision. \n23h 02h Parameter Table Length (in double words = Dwords = 4 byte units) 02h \n= 2 Dwords \n24h Parameter \nHeader 3 \n2nd DWORD 60h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC \nparameter byte offset = 1160h \n25h 11h Parameter Table Pointer Byte 1 26h 00h Parameter Table Pointer Byte 2 27h FFh Parameter ID MSb (FFh = JEDEC defined Parameter) Table 53 SFDP header\n (continued)\nRelative \nbyte ad-\ndressSFDP \nDword ad-\ndressData Description \nDatasheet 127 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n28h Parameter \nHeader 4 1st \nDWORD 84h Parameter ID LSb (00h = SFDP 4 By te Address Instructions Parameter) \n29h 00h Parameter Minor Revision (00h = Initial version as defined in JESD216 \nRevision B) \n2Ah 01h Parameter Major Revision (01h = The original major revision - all SFDP \nsoftware that recognizes this parameter’s ID is compatible with this major revision. \n2Bh 02h Parameter Table Length (in double words = Dwords = 4 byte units) (2h \n= 2 Dwords) \n2Ch Parameter \nHeader 4 \n2nd DWORD 68h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) JEDEC \nparameter byte offset = 1168h \n2Dh 11h Parameter Table Pointer Byte 1 \n2Eh 00h Parameter Table Pointer Byte 2 \n2Fh FFh Parameter ID MSb (FFh = JEDEC defined Parameter) 30h Parameter \nHeader 5 1st \nDWORD \n 01h Parameter ID LSb (Spansion Vendor Specific ID-CFI parameter) Legacy \nManufacturer ID 01h = AMD / Spansion \n31h 01h Parameter Minor Revision (01h = ID-CFI updated with SFDP Rev B \ntable) \n32h 01h Parameter Major Revision (01h = The original major revision - all SFDP \nsoftware that recognizes this parameter’s ID is compatible with this major revision. \n33h 5Ch Parameter Table Length (in double  words = Dwords = 4 byte units) CFI \nstarts at 1000h, the final SFDP parame ter (CFI ID = A5) starts at 111Eh \n(SFDP starting point of 1120h -2hB of CFI parameter header), for a length of 11EhB excluding the CFI A5 parameter. The final CFI A5 \nparameter adds an additional 52hB for a total of 11Eh + 82h = 170hB. 170hB/4 = 5Ch Dwords.\n34h Parameter \nHeader 5 \n2nd DWORD 00h Parameter Table Pointer Byte 0 (Dword = 4 byte aligned) Entry point \nfor ID-CFI parameter is byte offset  = 1000h relative to SFDP location \nzero. \n35h 10h Parameter Table Pointer Byte 1 36h 00h Parameter Table Pointer Byte 2 37h 01h Parameter ID MSb (01h = JEDEC JEP106 Bank Number 1) Table 53 SFDP header\n (continued)\nRelative \nbyte ad-\ndressSFDP \nDword ad-\ndressData Description \nDatasheet 128 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n11.3 Device ID and common flash interface (ID-CFI) address map\n11.3.1 Field definitions\nTable 54 Manufacturer and Device ID\nByte address Data Description \n00h 01h Manufacturer ID for Spansion01h 02h (512 Mb) Device ID MSB - Memory Interface Type\n02h 20h (512 Mb) Device ID LSB - Density\n03h xxh ID-CFI Length - number bytes following. Adding this \nvalue to the current location of 03h gives the address of the last valid location in th e ID-CFI address map. A value \nof 00h indicates the entire 512-byte ID-CFI space must be read because the actual length of the ID-CFI infor-\nmation is longer than can be indicated by this legacy single byte field. The value is OPN dependent.\n04h 00h (Uniform 256-kB sect ors) Sector Architecture\n05h 80h (FL-S Family) Family ID06h xxh ASCII characters for Model\nRefer to “Ordering information” on page 155 for the \nmodel number definitions.07h xxh\n08h xxh Reserved\n09h xxh Reserved\n0Ah xxh Reserved\n0Bh xxh Reserved\n0Ch xxh Reserved\n0Dh xxh Reserved\n0Eh xxh Reserved\n0Fh xxh Reserved\nTable 55 CFI query identification string \nByte address Data Description \n10h\n11h12h 51h\n52h59h Query Unique ASCII string “QRY” \n13h\n14h 02h\n00h Primary OEM Command Set\nFL-P backward compatible command set ID\n15h\n16h 40h\n00h Address for Primary Extended Table \n17h\n18h 53h\n46h Alternate OEM Command Set \nASCII characters “FS” for SPI (F) interface, S Technology\n19h\n1Ah 51h\n00h Address for Alternate OEM Extended Table \nDatasheet 129 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 56 CFI system interface string\nByte address Data Description \n1Bh 27h VCC Min. (erase/program): 100 millivolts\n1Ch 36h VCC Max. (erase/program): 100 millivolts\n1Dh 00h VPP Min. voltage (00h = no VPP present) \n1Eh 00h VPP Max. voltage (00h = no VPP present) \n1Fh 06h Typical timeout per single byte program 2N µs\n20h 09h (512B page) Typical timeout for Min. size Page program 2N µs \n(00h = not supported) \n21h 09h (256 kB) Typical timeout per individual sector erase 2N ms \n22h 11h (512 Mb) Typical time out for full chip erase 2N ms (00h = not \nsupported) \n23h 02h Max. timeout for byte program 2N times typical \n24h 02h Max. timeout for page program 2N times typical \n25h 03h Max. timeout per individual sector erase 2N times \ntypical\n26h 03h Max. timeout for full chip erase 2N times typical \n(00h = not supported) \nTable 57 Device geometry definition for 512-Mb device\nByte address Data Description \n27h 1Ah (512 Mb) Device Size = 2N bytes;\n28h 02h Flash Device Interface Description; \n0000h = x8 only 0001h = x16 only 0002h = x8/x16 capable 0003h = x32 only 0004h = Single I/O SPI, 3-byte address 0005h = Multi I/O SPI, 3-byte address 0102h = Multi I/O SPI, 3- or 4-byte address 29h 01h \n2Ah 09h Max. number of bytes in multi-byte write = 2\nN\n(0000 = not supported\n0009h = 512B page) 2Bh 00h \n2Ch 01h Number of Erase Block Regions within device \n1 = Uniform Device, 2 = Boot Device \n2Dh FFh Erase Block Region 1 Information (refer to JEDEC \nJEP137)32 sectors = 32-1 = 001Fh 4-kB sectors = 256 bytes x 0010h 2Eh 00h \n2Fh 00h 30h 04h \n31h thru 3Fh FFh RFU \nDatasheet 130 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 58 CFI primary vendor-specific extended query  \nByte address Data Description \n40h 50h Query-unique ASCII string “PRI” 41h 52h 42h 49h 43h 31h Major version number = 1, ASCII 44h 33h Minor version number = 3, ASCII \n45h 21h Address Sensitiv e Unlock (Bits 1-0) \n00b = Required01b = Not Required Process Technology (Bits 5-2)0000b = 0.23 µm Floating Gate 0001b = 0.17 µm Floating Gate 0010b = 0.23 µm MirrorBit0011b = 0.11 µm Floating Gate 0100b = 0.11 µm MirrorBit0101b = 0.09 µm MirrorBit1000b = 0.065 µm MirrorBit\n46h 02h Erase Suspend \n0 = Not Supported1 = Read Only2 = Read and Program\n47h 01h Sector Protect \n00 = Not SupportedX = Number of sectors in group \n48h 00h Temporary Sector Unprotect \n00 = Not Supported01 = Supported \n49h 08h Sector Protect/Unprotect Scheme \n04 = High Voltage Method 05 = Software Command Locking Method 08 = Advanced Sector Protection Method 09 = Secure\n4Ah 00h Simultaneous Operation \n00 = Not SupportedX = Number of Sectors \n4Bh 01h Burst Mode (Synchronous sequential read) support\n00 = Not Supported01 = Supported \n4Ch xxh Page Mode Type, model dependent\n00 = Not Supported01 = 4 Word Read Page02 = 8 Read Word Page03 = 256-Byte Program Page04 = 512-Byte Program Page \n4Dh 00h ACC (Acceleration) Supply Minimum \n00 = Not Supported, 100 mV \n4Eh 00h ACC (Acceleration) Supply Maximum \n00 = Not Supported, 100 mV \nDatasheet 131 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nThe Alternate Vendor-Specific Extended Query provides  information related to the expanded command set \nprovided by the FL-S family. The alternate query parameters use a format in which each parameter begins with an identifier byte and a parameter length byte. Driver  software can check each parameter ID and can use the \nlength value to skip to the next parameter if the para meter is not needed or not recognized by the software.4Fh 07h WP# Protection \n01 = Whole Chip 04 = Uniform Device with Bottom WP Protect 05 = Uniform Device with Top WP Protect 07 = Uniform Device with Top or Bottom Write Protect (user select)\n50h 01h Program Suspend \n00 = Not Supported01 = Supported \nTable 59 CFI alternate vendor-specific extended query header\nByte address Data Description \n51h 41h \nQuery-unique ASCII string “AL T” 52h 4Ch \n53h 54h 54h 32h Major version number = 2, ASCII 55h 30h Minor version number = 0, ASCII \nTable 60 CFI alternate vendor-specific extended query parameter 0\nParameter relative \nbyte address offsetData Description \n00h 00h Parameter ID (Ordering Part Number)\n01h 10h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current loca tion value +1 = the first byte of the \nnext parameter)\n02h 53h ASCII “S” for manufacturer (Spansion)03h 32h ASCII “25” for Product Characters (Single Die SPI)04h 35h05h 46h ASCII “FL” for Interface Characters (SPI 3 Volt)06h 4Ch07h 35h (512 Mb) ASCII characters for density08h 31h (512 Mb)09h 32h (512 Mb)\n0Ah 53h ASCII “S” for Technology (65nm MirrorBit)\n0Bh xxh Reserved for Future Use (RFU)\n0Ch xxh\n0Dh xxh\n0Eh xxh\n0Fh xxh\n10h xxh11h xxhTable 58 CFI primary vendor-specific extended query  \n (continued)\nByte address Data Description \nDatasheet 132 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 61 CFI alternate vendor-specific extended query parameter 80h address options\nParameter relative \nbyte address offsetData Description \n00h 80h Parameter ID (Ordering Part Number)\n01h 01h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current location  value +1 = the first byte of the next \nparameter)\n02h F0h Bits 7:4 - Reserved = 1111b\nBit 3 - AutoBoot support - Ye s= 0b, No = 1bBit 2 - 4-byte address instructions supported - Yes = 0b, No = 1bBit 1 - Bank address + 3-byte address instructions supported - Yes = 0b, No = 1bBit 0 - 3-byte address instructions supported - Yes = 0b, No = 1b\nTable 62 CFI alternate vendor-specific extended query parameter 84h suspend commands\nParameter relative \nbyte address offsetData Description \n00h 84h Parameter ID (Suspend Commands\n01h 08h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current location value +1 = the first byte of the next parameter)\n02h 85h Program suspend instruction code03h 28h Program suspend latency maximum (µs)04h 8Ah Program resume instruction code05h 64h Program resume to next suspend typical (µs)06h 75h Erase suspend instruction code07h 28h Erase suspend latency maximum (µs)08h 7Ah Erase resume instruction code09h 64h Erase resume to next suspend typical (µs)\nTable 63 CFI alternate vendor-specific extended query parameter 88h data protection\nParameter relative \nbyte address offsetData Description \n00h 88h Parameter ID (Data Protection)\n01h 04h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current location  value +1 = the first byte of the next \nparameter)\n02h 0Ah OTP size 2\nN bytes, FFh = not supported\n03h 01h OTP address map format, 01h = FL-S format, FFh = not supported\n04h xxh Block Protect Type, model dependent\n00h = FL-P , FL-S, FFh = not supported\n05h xxh Advanced Sector Protection type, model dependent\n01h = FL-S ASP\nDatasheet 133 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 64 CFI alternate vendor-specific extended query parameter 8Ch reset timing\nParameter relative \nbyte address offsetData Description \n00h 8Ch Parameter ID (Reset Timing)\n01h 06h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current location value +1 = the first byte of the next parameter)\n02h 96h POR maximum value03h 01h POR maximum exponent 2\nN µs\n04h 23h Hardware Reset maximum value, FFh = not supported05h 00h Hardware Reset maximum exponent 2\nN µs\n06h 23h Software Reset maximum value, FFh = not supported07h 00h Software Reset maximum exponent 2\nN µs\nTable 65 CFI alternate vendor-specific extended query parameter 90h - HPLC(SDR)\nParameter relative \nbyte address offsetData Description \n00h 90h Parameter ID (Latency Code Table)\n01h 56h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current location value +1 = the first byte of the next parameter)\n02h 06h Number of rows03h 0Eh Row length in bytes04h 46h Start of header (row 1), ASCII “F” for frequency column header05h 43h ASCII “C” for Code column header06h 03h Read 3-byte address instruction07h 13h Read 4-byte address instruction08h 0Bh Read Fast 3-byte address instruction09h 0Ch Read Fast 4-byte address instruction\n0Ah 3Bh Read Dual Out 3-byte address instruction\n0Bh 3Ch Read Dual Out 4-byte address instruction\n0Ch 6Bh Read Quad Out 3-byte address instruction\n0Dh 6Ch Read Quad Out 4-byte address instruction\n0Eh BBh Dual I/O Read 3-byte address instruction\n0Fh BCh Dual I/O Read 4-byte address instruction10h EBh Quad I/O Read 3-byte address instruction11h ECh Quad I/O Read 4-byte address instruction12h 32h Start of row 2, SCK frequency limit for this row (50 MHz)13h 03h Latency Code for this row (11b)\n14h 00h Read mode cycles\n15h 00h Read latency cycles16h 00h Read Fast mode cycles\nDatasheet 134 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n17h 00h Read Fast latency cycles\n18h 00h Read Dual Out mode cycles19h 00h Read Dual Out latency cycles\n1Ah 00h Read Quad Out mode cycles\n1Bh 00h Read Quad Out latency cycles\n1Ch 00h Dual I/O Read mode cycles\n1Dh 04h Dual I/O Read latency cycles\n1Eh 02h Quad I/O Read mode cycles\n1Fh 01h Quad I/O Read latency cycles20h 50h Start of row 3, SCK frequency limit for this row (80 MHz)21h 00h Latency Code for this row (00b)22h FFh Read mode cycles (FFh = command  not supported at this frequency)\n23h FFh Read latency cycles24h 00h Read Fast mode cycles25h 08h Read Fast latency cycles26h 00h Read Dual Out mode cycles27h 08h Read Dual Out latency cycles28h 00h Read Quad Out mode cycles29h 08h Read Quad Out latency cycles\n2Ah 00h Dual I/O Read mode cycles\n2Bh 04h Dual I/O Read latency cycles\n2Ch 02h Quad I/O Read mode cycles\n2Dh 04h Quad I/O Read latency cycles\n2Eh 5Ah Start of row 4, SCK freque ncy limit for this row (90 MHz)\n2Fh 01h Latency Code for this row (01b)30h FFh Read mode cycles (FFh = command  not supported at this frequency)\n31h FFh Read latency cycles32h 00h Read Fast mode cycles33h 08h Read Fast latency cycles34h 00h Read Dual Out mode cycles35h 08h Read Dual Out latency cycles36h 00h Read Quad Out mode cycles37h 08h Read Quad Out latency cycles38h 00h Dual I/O Read mode cycles39h 05h Dual I/O Read latency cycles\n3Ah 02h Quad I/O Read mode cycles\n3Bh 04h Quad I/O Read latency cycles\n3Ch 68h Start of row 5, SCK freque ncy limit for this row (104 MHz)\n3Dh 02h Latency Code for this row (10b)Table 65 CFI alternate vendor-specific extended query parameter 90h - HPLC(SDR)\n (continued)\nParameter relative \nbyte address offsetData Description \nDatasheet 135 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n3Eh FFh Read mode cycles (FFh = command not supported at this frequency)\n3Fh FFh Read latency cycles40h 00h Read Fast mode cycles41h 08h Read Fast latency cycles42h 00h Read Dual Out mode cycles\n43h 08h Read Dual Out latency cycles\n44h 00h Read Quad Out mode cycles45h 08h Read Quad Out latency cycles46h 00h Dual I/O Read mode cycles47h 06h Dual I/O Read latency cycles48h 02h Quad I/O Read mode cycles49h 05h Quad I/O Read latency cycles\n4Ah 85h Start of row 6, SCK frequency limit for this row (133 MHz)\n4Bh 02h Latency Code for this row (10b)\n4Ch FFh Read mode cycles (FFh = command not supported at this frequency)\n4Dh FFh Read latency cycles\n4Eh 00h Read Fast mode cycles\n4Fh 08h Read Fast latency cycles50h FFh Read Dual Out mode cycles51h FFh Read Dual Out latency cycles52h FFh Read Quad Out mode cycles53h FFh Read Quad Out latency cycles54h FFh Dual I/O Read mode cycles55h FFh Dual I/O Read latency cycles56h FFh Quad I/O Read mode cycles57h FFh Quad I/O Read latency cycles\nTable 66 CFI alternate vendor-specific extended query parameter 9Ah - HPLC DDR \nParameter relative \nbyte address offsetData Description \n00h 9Ah Parameter ID (Latency Code Table)\n01h 2Ah Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current locati on value +1 = the first byte of the \nnext parameter)\n02h 05h Number of rows03h 08h Row length in bytes04h 46h Start of header (row 1), ASC II “F” for frequency column header\n05h 43h ASCII “C” for Code column header06h 0Dh Read Fast DDR 3-byte address instruction07h 0Eh Read Fast DDR 4-byte address instructionTable 65 CFI alternate vendor-specific extended query parameter 90h - HPLC(SDR)\n (continued)\nParameter relative \nbyte address offsetData Description \nDatasheet 136 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n08h BDh DDR Dual I/O Read 3-byte address instruction\n09h BEh DDR Dual I/O Read 4-byte address instruction\n0Ah EDh Read DDR Quad I/O 3- byte address instruction\n0Bh EEh Read DDR Quad I/O 4- byte address instruction\n0Ch 32h Start of row 2, SCK frequency limit for this row (50 MHz)\n0Dh 03h Latency Code for this row (11b)\n0Eh 00h Read Fast DDR mode cycles\n0Fh 04h Read Fast DDR latency cycles10h 00h DDR Dual I/O Read mode cycles11h 04h DDR Dual I/O Read latency cycles12h 01h Read DDR Quad I/O mode cycles13h 03h Read DDR Quad I/O latency cycles14h 42h Start of row 3, SCK frequency limit for this row (66 MHz)15h 00h Latency Code for this row (00b)16h 00h Read Fast DDR mode cycles17h 05h Read Fast DDR latency cycles18h 00h DDR Dual I/O Read mode cycles19h 06h DDR Dual I/O Read latency cycles\n1Ah 01h Read DDR Quad I/O mode cycles\n1Bh 06h Read DDR Quad I/O latency cycles\n1Ch 42h Start of row 4, SCK frequency limit for this row (66 MHz)\n1Dh 01h Latency Code for this row (01b)\n1Eh 00h Read Fast DDR mode cycles\n1Fh 06h Read Fast DDR latency cycles20h 00h DDR Dual I/O Read mode cycles21h 07h DDR Dual I/O Read latency cycles22h 01h Read DDR Quad I/O mode cycles23h 07h Read DDR Quad I/O latency cycles24h 42h Start of row 5, SCK frequency limit for this row (66 MHz)25h 02h Latency Code for this row (10b)26h 00h Read Fast DDR mode cycles27h 07h Read Fast DDR latency cycles28h 00h DDR Dual I/O Read mode cycles29h 08h DDR Dual I/O Read latency cycles\n2Ah 01h Read DDR Quad I/O mode cycles\n2Bh 08h Read DDR Quad I/O latency cyclesTable 66 CFI alternate vendor-specific extended query parameter 9Ah - HPLC DDR \n (continued)\nParameter relative \nbyte address offsetData Description \nDatasheet 137 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 67 CFI alternate vendor-specific extended query parameter 90h - EHPLC (SDR)\nParameter relative \nbyte address offsetData Description \n00h 90h Parameter ID (Latency Code Table)\n01h 56h Parameter Length (The number of following bytes in this parameter. \nAdding this value to the current loca tion value +1 = the first byte of the \nnext parameter)\n02h 06h Number of rows03h 0Eh Row length in bytes04h 46h Start of header (row 1), ASCII “F” for frequency column header05h 43h ASCII “C” for Code column header06h 03h Read 3-byte address instruction07h 13h Read 4-byte address instruction08h 0Bh Read Fast 3-byte address instruction09h 0Ch Read Fast 4-byte address instruction\n0Ah 3Bh Read Dual Out 3-byte address instruction\n0Bh 3Ch Read Dual Out 4-by te address instruction\n0Ch 6Bh Read Quad Out 3-byte address instruction\n0Dh 6Ch Read Quad Out 4-byte address instruction\n0Eh BBh Dual I/O Read 3-byte address instruction\n0Fh BCh Dual I/O Read 4-byte address instruction10h EBh Quad I/O Read 3-byte address instruction11h ECh Quad I/O Read 4-byte address instruction12h 32h Start of row 2, SCK frequency limit for this row (50 MHz)13h 03h Latency Code for this row (11b)14h 00h Read mode cycles15h 00h Read latency cycles16h 00h Read Fast mode cycles17h 00h Read Fast latency cycles18h 00h Read Dual Out mode cycles19h 00h Read Dual Out latency cycles\n1Ah 00h Read Quad Out mode cycles\n1Bh 00h Read Quad Out latency cycles\n1Ch 04h Dual I/O Read mode cycles\n1Dh 00h Dual I/O Read latency cycles\n1Eh 02h Quad I/O Read mode cycles\n1Fh 01h Quad I/O Read latency cycles20h 50h Start of row 3, SCK frequency limit for this row (80 MHz)21h 00h Latency Code for this row (00b)22h FFh Read mode cycles (FFh = command not supported at this frequency)23h FFh Read latency cycles24h 00h Read Fast mode cycles\nDatasheet 138 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n25h 08h Read Fast latency cycles\n26h 00h Read Dual Out mode cycles27h 08h Read Dual Out latency cycles28h 00h Read Quad Out mode cycles29h 08h Read Quad Out latency cycles\n2Ah 04h Dual I/O Read mode cycles\n2Bh 00h Dual I/O Read latency cycles\n2Ch 02h Quad I/O Read mode cycles\n2Dh 04h Quad I/O Read latency cycles\n2Eh 5Ah Start of row 4, SCK frequency limit for this row (90 MHz)\n2Fh 01h Latency Code for this row (01b)30h FFh Read mode cycles (FFh = command not supported at this frequency)31h FFh Read latency cycles32h 00h Read Fast mode cycles33h 08h Read Fast latency cycles34h 00h Read Dual Out mode cycles35h 08h Read Dual Out latency cycles36h 00h Read Quad Out mode cycles37h 08h Read Quad Out latency cycles38h 04h Dual I/O Read mode cycles39h 01h Dual I/O Read latency cycles\n3Ah 02h Quad I/O Read mode cycles\n3Bh 04h Quad I/O Read latency cycles\n3Ch 68h Start of row 5, SCK frequency limit for this row (104 MHz)\n3Dh 02h Latency Code for this row (10b)\n3Eh FFh Read mode cycles (FFh = command not supported at this frequency)\n3Fh FFh Read latency cycles40h 00h Read Fast mode cycles41h 08h Read Fast latency cycles42h 00h Read Dual Out mode cycles43h 08h Read Dual Out latency cycles44h 00h Read Quad Out mode cycles45h 08h Read Quad Out latency cycles46h 04h Dual I/O Read mode cycles47h 02h Dual I/O Read latency cycles48h 02h Quad I/O Read mode cycles49h 05h Quad I/O Read latency cycles\n4Ah 85h Start of row 6, SCK frequency limit for this row (133 MHz)\n4Bh 02h Latency Code for this row (10b)Table 67 CFI alternate vendor-specific extended query parameter 90h - EHPLC (SDR)\n (continued)\nParameter relative \nbyte address offsetData Description \nDatasheet 139 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n4Ch FFh Read mode cycles (FFh = command not supported at this frequency)\n4Dh FFh Read latency cycles\n4Eh 00h Read Fast mode cycles\n4Fh 08h Read Fast latency cycles50h FFh Read Dual Out mode cycles\n51h FFh Read Dual Out latency cycles\n52h FFh Read Quad Out mode cycles53h FFh Read Quad Out latency cycles54h FFh Dual I/O Read mode cycles55h FFh Dual I/O Read latency cycles56h FFh Quad I/O Read mode cycles57h FFh Quad I/O Read latency cycles\nTable 68 CFI alternate vendor-specific extended query parameter 9Ah - EHPLC DDR \nParameter relative \nbyte address offsetData Description \n00h 9Ah Parameter ID (Latency Code Table)\n01h 2Ah Parameter Length (The number of  following bytes in this parameter. \nAdding this value to the current loca tion value +1 = the first byte of the \nnext parameter)\n02h 05h Number of rows03h 08h Row length in bytes04h 46h Start of header (row 1), ASCII “F” for frequency column header05h 43h ASCII “C” for Code column header06h 0Dh Read Fast DDR 3-byte address instruction07h 0Eh Read Fast DDR 4-byte address instruction08h BDh DDR Dual I/O Read 3-byte address instruction09h BEh DDR Dual I/O Read 4-byte address instruction\n0Ah EDh Read DDR Quad I/O 3-byte address instruction\n0Bh EEh Read DDR Quad I/O 4-byte address instruction\n0Ch 32h Start of row 2, SCK frequency limit for this row (50 MHz)\n0Dh 03h Latency Code for this row (11b)\n0Eh 04h Read Fast DDR mode cycles\n0Fh 01h Read Fast DDR latency cycles10h 02h DDR Dual I/O Read mode cycles\n11h 02h DDR Dual I/O Read latency cycles12h 01h Read DDR Quad I/O mode cycles13h 03h Read DDR Quad I/O latency cycles14h 42h Start of row 3, SCK frequency limit for this row (66 MHz)15h 00h Latency Code for this row (00b)Table 67 CFI alternate vendor-specific extended query parameter 90h - EHPLC (SDR)\n (continued)\nParameter relative \nbyte address offsetData Description \nDatasheet 140 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n16h 04h Read Fast DDR mode cycles\n17h 02h Read Fast DDR latency cycles18h 02h DDR Dual I/O Read mode cycles\n19h 04h DDR Dual I/O Read latency cycles\n1Ah 01h Read DDR Quad I/O mode cycles\n1Bh 06h Read DDR Quad I/O latency cycles\n1Ch 42h Start of row 4, SCK frequency limit for this row (66 MHz)\n1Dh 01h Latency Code for this row (01b)\n1Eh 04h Read Fast DDR mode cycles\n1Fh 04h Read Fast DDR latency cycles20h 02h DDR Dual I/O Read mode cycles\n21h 05h DDR Dual I/O Read latency cycles22h 01h Read DDR Quad I/O mode cycles23h 07h Read DDR Quad I/O latency cycles24h 42h Start of row 5, SCK frequency limit for this row (66 MHz)25h 02h Latency Code for this row (10b)26h 04h Read Fast DDR mode cycles27h 05h Read Fast DDR latency cycles28h 02h DDR Dual I/O Read mode cycles\n29h 06h DDR Dual I/O Read latency cycles\n2Ah 01h Read DDR Quad I/O mode cycles\n2Bh 08h Read DDR Quad I/O latency cycles\nTable 69 CFI alternate vendor-specific extended query parameter F0h RFU\nParameter relative \nbyte address offsetData Description \n00h F0h Parameter ID (RFU)\n01h 0Fh Parameter Length (The number of  following bytes in this parameter. \nAdding this value to the current loca tion value +1 = the first byte of the \nnext parameter)\n02h FFh RFU\n... FFh RFU\n10h FFh RFUTable 68 CFI alternate vendor-specific extended query parameter 9Ah - EHPLC DDR \n (continued)\nParameter relative \nbyte address offsetData Description \nDatasheet 141 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \n00h — N/A A5h CFI Parameter ID (JEDEC SFDP) \n01h — N/A 50h CFI Parameter Length (The number of following \nbytes in this parameter. Adding this value to the current location value +1 = the first byte of the next parameter) \n02h 00h JEDEC \nBasic Flash \nParameter \nDword-1 E7h Start of SFDP JEDEC parameter, located at 1120h \nin the overall SFDP address space. Bits 7:5 = unused = 111b Bit 4:3 = 06h is status register write instruction & status register is default non-volatile= 00b Bit 2 = Program Buffer > 64Bytes = 1 Bits 1:0 = Uniform 4KB erase unavailable = 11b \n03h 01h FFh Bits 15:8 = Uniform 4KB erase opcode = not \nsupported = FFh \n04h 02h F3h \n(FLxxxSAG) \nF7h \n(FLxxxSDP) Bit 23 = Unused = 1b Bit 22 = Supports Quad Out \nRead = Yes = 1b Bit 21 = Supports Quad I/O Read = Yes =1b Bit 20 = Supports Dual I/O Read = Yes = 1b Bit19 = Supports DDR 0= No, 1 = Yes Bit 18:17 = Number of Address Bytes, 3 or 4 = 01b Bit 16 = Supports Dual Out Read = Yes = 1b \n05h 03h FFh Bits 31:24 = Unused = FFh 06h 04h JEDEC \nBasic Flash \nParameter \nDword-2 FFh Density in bits, zero  based, 512Mb = 1FFFFFFFh \n07h 05h FFh 08h 06h FFh 09h 07h 1Fh \n0Ah 08h JEDEC \nBasic Flash \nParameter \nDword-3 44h Bits 7:5 = number of Qu ad I/O Mode cycles = 010b \nBits 4:0 = number of Quad I/O Dummy cycles = 00100b for default latency code 00b \n0Bh 09h EBh Quad I/O instruction code \n0Ch 0Ah 08h Bits 23:21 = number of Quad Out Mode cycles = \n000b Bits 20:16 = number of Quad Out Dummy cycles = 01000b \n0Dh 0Bh 6Bh Quad Out instruction code \n0Eh 0Ch JEDEC \nBasic Flash \nParameter \nDword-4 08h Bits 7:5 = number of Du al Out Mode cycles = 000b \nBits 4:0 = number of Dual Out Dummy cycles = 01000b for default latency code \n0Fh 0Dh 3Bh Dual Out instruction code \n10h 0Eh 04h (HPLC) \n80h \n(EHPLC)Bits 23:21 = number of Du al I/O Mode cycles = \n100b for EHPLC or 000b for HPLC Bits 20:16 = number of Dual I/O Dummy cycles = 00000b for EHPLC or 00100b for HPLC Default Latency code = 00b \n11h 0Fh BBh Dual I/O instruction code \nDatasheet 142 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n12h 10h JEDEC \nBasic Flash \nParameter \nDword-5 EEh Bits 7:5 RFU = 111b Bit 4 = Quad All supported = \nNo = 0b Bits 3:1 RFU = 111b Bit 0 = Dual All not supported = 0b \n13h 11h FFh Bits 15:8 = RFU = FFh 14h 12h FFh Bits 23:16 = RFU = FFh 15h 13h FFh Bits 31:24 = RFU = FFh 16h 14h JEDEC \nBasic Flash \nParameter \nDword-6 FFh Bits 7:0 = RFU = FFh \n17h 15h FFh Bits 15:8 = RFU = FFh 18h 16h FFh Bits 23:21 = number of  Dual All Mode cycles = 111b \nBits 20:16 = number of Dual All Dummy cycles = 11111b \n19h 17h FFh Dual All instruction code \n1Ah 18h JEDEC \nBasic Flash \nParameter \nDword-7 FFh Bits 7:0 = RFU = FFh \n1Bh 19h FFh  \n1Ch 1Ah FFh Bits 15:8 = RFU = FFh \n1Dh 1Bh EBh Bits 23:21 = number of Quad All Mode cycles = \n111b Bits 20:16 = number of Quad All Dummy cycles = 11111b \n1Eh 1Ch JEDEC \nBasic Flash \nParameter \nDword-8 00h Quad All mode Quad I/O (4-4-4) instruction code \n1Fh 1Dh FFh Erase type 1 inst ruction = not supported = FFh \n20h 1Eh 00h Erase type 2 size 2\nN Bytes = not supported = 00h \n21h 1Fh FFh Erase type 2 instruction = not supported = FFh 22h 20h JEDEC \nBasic Flash \nParameter \nDword-9 12h Erase type 3 size 2\nN Bytes = 256KB = 12h \n23h 21h D8h Erase type 3 instruction 24h 22h 00h Erase type 4 size 2\nN Bytes = not supported = 00h \n25h 23h FFh Erase type 4 instruction = not supported = FFh Table 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B  (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 143 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n26h 24h JEDEC \nBasic Flash \nParameter \nDword-10 F2h Bits 31:30 = Erase type 4 Erase, Typical time units \n(00b: 1 ms, 01b: 16 ms, 10b: 128 ms, 11b: 1 s) = RFU = 11b Bits 29:25 = Erase type 4 Erase, Typical time count = RFU = 11111b ( typ erase time = count +1 * units = RFU ) Bits 24:23 = Erase type 3 Erase, Typical time units (00b: 1 ms, 01b: 16 ms, 10b: 128 ms, 11b: 1 s) = 128mS = 10b Bits 22:18 = Erase type 3 Erase, Typical time count = 00011b ( typ erase time = count +1 * units = 4*128mS = 512mS) Bits 17:16 = Erase type 2 Erase, Typical time units (00b: 1 ms, 01b: 16 ms, 10b: 128 ms, 11b: 1 s) = RFU = 11b Bits 15:11 = Erase type 2 Erase, Typical time count = RFU = 11111b ( typ erase time = count +1 * units = RFU ) Bits 10:9 = Erase type 1 Erase, Typical time units (00b: 1 ms, 01b: 16 ms, 10b: 128 ms, 11b: 1 s) = RFU = 11b Bits 8:4 = Erase type 1 Erase, Typical time count = RFU = 11111b ( typ erase time = count +1 * units = RFU ) Bits 3:0 = Multiplier from typical erase time to maximum \nerase time = 2*(N+1), N=2h = 6x multiplier Binary Fields: 11-11111-10-00011-11-11111-11-11111-0010 Nibble Format: 1111_1111_0000_1111_1111_1111_1111_0010 Hex Format: FF_0F_FF_F2 27h 25h FFh \n28h 26h 0Fh 29h 27h FFhTable 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 144 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n2Ah 28h JEDEC \nBasic Flash \nParameter \nDword-11 91h Bit 31 Reserved = 1b Bits 30:29 = Chip Erase, \nTypical time units (00b: 16 ms, 01b: 256 ms, 10b: 4 s, 11b: 64 s) = 4s = 10b Bits 28:24 = Chip Erase, Typical time count, (count+1)*units, count = 11001b, ( typ Program time = count +1 * units = 26*.4uS = 104S Bits 23 = Byte Program Typical time, additional byte units (0b:1uS, 1b:8uS) = 1uS = 0b Bits 22:19 = Byte Program Typical time, additional byte count, (count+1)*units, count = 0000b, ( typ Program time = count +1 * units = 1*1uS = 1uS Bits 18 = Byte Program Typical time, first byte units (0b:1uS, 1b:8uS) = 8uS = 1b Bits 17:14 = Byte Program Typical time, first byte count, (count+1)*units, count = 1100b, ( typ Program time = count +1 * units = 13*8uS = 104uS Bits 13 = Page Program Typical time units (0b:8uS, 1b:64uS) = 64uS = 1b Bits 12:8 = Page Program Typical time count, (count+1)*units, count = 00101b, ( typ Program time = count +1 * units =6*64uS = 384uS) Bits 7:4 = Page size 2\nN, \nN=9h, = 512B page Bits 3:0 = Multiplier from typical time to maximum for Page or Byte program = 2*(N+1), N=1h = 4x multiplier Binary Fields: 1-10-11001-0-0000-1-1100-1-00101-1001-0001 Nibble Format: 1101_1001_0000_0111_0010_0101_1001_0001 Hex Format: D9_07_25_91 2Bh 29h 25h \n2Ch 2Ah 07h \n2Dh 2Bh D9h Table 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 145 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n2Eh 2Ch JEDEC \nBasic Flash \nParameter \nDword-12 ECh Bit 31 = Suspend and Resume supported = 0b Bits \n30:29 = Suspend in-progress erase max latency units (00b: 128ns, 01b: 1us,  10b: 8us, 11b: 64us) = \n8us= 10b Bits 28:24 = Suspend in-progress erase max latency count = 00101b, max erase suspend latency = count +1 * units = 6*8uS = 48uS Bits 23:20 = Erase resume to suspend interval count = 0001b, interval = count +1 * 64us = 2 * 64us = 128us Bits 19:18 = Suspend in-progress program max latency units (00b: 128ns, 01b: 1us, 10b: 8us, 11b: 64us) = 8us= 10b Bits 17: 13 = Suspend in-progress \nprogram max latency count = 00100b, max erase suspend latency = count +1 * units = 5*8uS = 40uS Bits 12:9 = Program resume to suspend interval count = 0001b, interval = count +1 * 64us = 2 * 64us = 128us Bit 8 = RFU = 1b Bits 7:4 = Prohibited operations during erase suspend = xxx0b: May not initiate a new erase anywhere (erase nesting not permitted) + xx1xb: May not initiate a page program in the erase suspended sector size + x1xxb: May not initiate a read in the erase suspended sector size + 1xxxb: The erase and program restrictions in bits 5:4 are sufficient = 1110b Bits 3:0 = Prohibited Operations During Program Suspend = xxx0b: May not initiate a new erase anywhere (erase nesting not permitted) + xx0xb: May not initiate a new page program anywhere (program nesting not permitted) + x1xxb: May not initiate a read in the program suspended page size + 1xxxb: The erase and program restrictions in bits 1:0 are sufficient = 1100b Binary Fields: 0-10-00101-0001-10-00100-0001-1-1110-1100 Nibble Format: 0100_0101_0001_1000_1000_0011_1110_1100 Hex Format: 45_18_83_EC 2Fh 2Dh 83h \n30h 2Eh 18h 31h 2Fh 45h \n32h 30h JEDEC \nBasic Flash \nParameter \nDword-13 8Ah Bits 31:24 = Erase Suspend Instruction = 75h Bits \n23:16 = Erase Resume Instruction = 7Ah Bits 15:8 = Program Suspend Instruction = 85h Bits 7:0 = Program Resume Instruction = 8Ah 33h 31h 85h \n34h 32h 7Ah 35h 33h 75h Table 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 146 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n36h 34h JEDEC \nBasic Flash \nParameter \nDword-14 \n F7h Bit 31 = Deep Power Down Supported = not \nsupported = 1 Bits 30:23 = Enter Deep Power Down Instruction = not supported = FFh Bits 22:15 = Exit Deep Power Down Instruction = not supported = FFh Bits 14:13 = Exit Deep Power Down to next operation de lay units = (00b: 128ns, \n01b: 1us, 10b: 8us, 11b: 64us) = 64us = 11b Bits \n12:8 = Exit Deep Power Down to next operation delay count = 11111b, Exit Deep Power Down to next operation delay = (count+1)*units = not supported Bits 7:4 = RFU = Fh Bit 3:2 = Status Register Polling Device Busy = 01b: Legacy status polling supported = Use le gacy polling by reading \nthe Status Register with 05h instruction and checking WIP bit[0] (0=ready; 1=busy). Bits 1:0 = RFU = 11b Binary Fields: 1-11111111-11111111-11-11111-1111-01-11 Nibble Format: 1111_1111_1111_1111_1111_1111_1111_0111 Hex Format: FF_FF_FF_F7 37h 35h FFh \n38h 36h FFh 39h 37h  FFh\n3Ah 38h JEDEC \nBasic Flash \nParameter \nDword-15 00h Bits 31:24 = RFU = FFh Bit 23 = Hold and WP \nDisable = not supported = 0b Bits 22:20 = Quad Enable Requirements = 101b: QE is bit 1 of the status register 2. Status register 1 is read using Read Status instruction 05h. Status register 2 is read using instruction 35h. QE is set via Write Status instruction 01h wi th two data bytes where \nbit 1 of the second byte is one. It is cleared via Write Status with two data bytes where bit 1 of the second byte is zero. Bits 19:16 0-4-4 Mode Entry Method = xxx1b: Mode Bits[7:0] = A5h Note QE must be set prior to using this mode + x1xxb: Mode Bits[7:0] = Axh + 1xxxb: RFU = 1101b Bits 15:10 0-4-4 Mode Exit Method = xx_xxx1b: Mode Bits[7:0] = 00h will terminate this mode at the end of the current read operation + xx_1xxxb: Input Fh (mode bit reset) on DQ0-DQ 3 for 8 clocks. This will \nterminate the mode prior to the next read operation. + x1_xxxxb: Mode Bit[7:0] != Axh + 1x_x1xx: RFU 3Bh 39h F6h \n3Ch 3Ah 5Dh \n3Dh 3Bh FFh Table 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 147 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n3Eh 3Ch JEDEC \nBasic Flash \nParameter \nDword-16 F0h Bits 31:24 = Enter 4-Byte Addressing = xxxx_1xxxb: \n8-bit volatile bank register used to define A[30:A24] bits. MSb (bit[7]) is used to enable/disable 4-byte address mode. When MSb is set to ‘1’ , 4-byte address mode is active and A[30:24] bits are don’t care. Read with instruction 16h. Write instruction is 17h with 1 byte of data. When MSb is cleared to ‘0’ , select the active 128 Mb segment by setting the appropriate A[30:24] bits and use 3-Byte addressing. + xx1x_xxxxb: Supports dedicated 4-Byte address instruction set. Consult vendor data sheet for the instruction set definition or look for 4 Byte Address Parameter Table. + 1xxx_xxxxb: Reserved = 10101000b Bits 23:14 = Exit 4-Byte Addressing = xx_xxxx_1xxxb: 8-bit volatile bank register used to define A[30:A24] bits. MSb (bit[7]) is used to enable/disable 4-byte address mode. When MSb is cleared to ‘0’ , 3-byte address mode is active and A30:A24 are used to select the active 128 Mb memory segment. Read with instruction 16h. Write instruction is 17h, data length is 1 byte. + xx_xx1x_xxxxb: Hardware reset + xx_x1xx_xxxxb: Software reset (see bits 13:8 in this DWORD) + xx_1xxx_xxxxb: Power cycle + x1_xxxx_xxxxb: Reserved + 1x_xxxx_xxxxb: Reserved = 1111101000b Bits 13:8 = Soft Reset and Rescue Sequence Support = x0_1xxxb: issue instruction F0h + 1x_xxxxb: exit 0-4-4 mode is required prior to other reset sequences above if the device may be operating in this mode. = 101000b Bit 7 = RFU = 1 Bits 6:0 = Volatile or Non-volatile Register and Write Enable Instruction for Status Register 1 = xx1_xxxxb: Status Register 1 contains a mix of volatile and non-volatile bits. The 06h instruction is used to enable writing of the register. + x1x_xxxxb: Reserved + 1xx_xxxxb: Reserved = 1110000b Binary Fields: 10101000-1111101000-101000-1-1110000 Nibble Format: 1010_1000_1111_1010_0010_1000_1111_0000 Hex Format: A8_FA_28_F0 3Fh 3Dh 28h \n40h 3Eh FAh 41h 3Fh A8h \n42h 40h JEDEC \nSector Map \nParameter \nDword-1 \nConfig-0 \nHeader FFh Bits 31:24 = RFU = FFh Bits 23:16 = Region count \n(Dwords -1) = 00h: One region Bits 15:8 = Configu-ration ID = 00h: Uniform 256KB sectors Bits 7:2 = RFU = 111111b Bit 1 = Map Descriptor = 1 Bit 0 = The end descriptor = 1 43h 41h 00h \n44h 42h 00h 45h 43h FFh Table 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 148 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n46h 44h JEDEC \nSector Map \nParameter \nDword-2 \nConfig-0 \nRegion-0 F4h Bits 31:8 = Region size = 00FFFFh: Region size as \ncount-1 of 256 Byte units = 64MB/256 = 256K Count = 262144, value = count -1 = 262144 -1 = 262143 = 3FFFFh Bits 4:7 = RFU = Fh Erase Type not supported = 0/ supported = 1 Bits 3 = Erase Type 4 support = 0b ---Erase Type 4 is not defined Bits 2 = Erase Type 3 support = 1b ---Erase Type 3 is 256KB erase and is supported in the 256KB sector region Bits 1 = Erase Type 2 support = 0b ---Erase Type 2 is 64KB erase and is not supported in the 256KB sector region Bits 0 = Erase Type 1 support = 0b --- Erase Type 1 is 4KB erase and is not supported in the 256KB sector region Format: 0000_0011_1111_1111_1111_1111_1111_0100 Hex Format: 03_FF_FF_F4 47h 45h FFh \n48h 46h FFh 49h 47h 03h \n4Ah 48h JEDEC 4 \nByte \nAddress \nInstruc-\ntions \nParameter \nDword-1 FFh Supported = 1, Not Supp orted = 0 Bits 31:20 = RFU \n= FFFh Bit 19 = Support for non-volatile individual sector lock write command, Instruction=E3h = 1 Bit 18 = Support for non-volatile individual sector lock read command, Instruction=E2h = 1 Bit 17 = Support for volatile individual sector lock Write command, Instruction=E1h = 1 Bit 16 = Support for volatile individual sector lock Read command, Instruction=E0h = 1 Bit 15 = Support for (1-4-4) DTR_Read Command, Instruction=EEh = 1 Bit 14 = Support for (1-2-2) DTR_Read Command, Instruction=BEh = 1 Bit 13 = Support for (1-1-1) DTR_Read Command, Instruction=0Eh = 1 Bit 12 = Support for Erase Command – Type 4 = 0 Bit 11 = Support for Erase Command – Type 3 = 1 Bit 10 = Support for Erase Command – Type 2 = 0 Bit 9 = Support for Erase Command – Type 1 = 0 Bit 8 = Support for (1-4-4) Page Program Command, Instruction=3Eh =0 Bit 7 = Support for (1-1-4) Page Program Command, Instruction=34h = 1 Bit 6 = Support for (1-1-1) Page Program Command, Instruction=12h = 1 Bit 5 = Support for (1-4-4) FAST_READ Command, Instruction=ECh = 1 Bit 4 = Support for (1-1-4) FAST_READ Command, Instruction=6Ch = 1 Bit 3 = Support for (1-2-2) FAST_READ Command, Instruction=BCh = 1 Bit 2 = Support for (1-1-2) FAST_READ Command, Instruction=3Ch = 1 Bit 1 = Support for (1-1-1) FAST_READ Command, Instruction=0Ch = 1 Bit 0 = Support for (1-1-1) READ Command, Instruction=13h = 1 4Bh 49h E8h \n4Ch 4Ah FFh \n4Dh 4Bh  FFhTable 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 149 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nThis parameter type (Parameter ID F0h) may appear mult iple times and have a different length each time. The \nparameter is used to reserve space in the ID-CFI map or to force space (pad) to align a following parameter to a \nrequired boundary.\n11.4 Device ID and common flash interf ace (ID-CFI) ASO map — Automotive \nonly\nThe CFI Primary Vendor-Specific Extended Query is extended  to include Electronic Marking information for device \ntraceability.\nFab Lot # + Wafer # + Die X Coordinate + Die Y Coordinate gives a unique ID for each device.\n11.5 Registers\nThe register maps are copied in this  section as a quick reference. See “Registers” on page 55 for the full \ndescription of the register contents.4Eh 4Ch JEDEC 4 \nByte \nAddress \nInstruc-\ntions \nParameter \nDword-2 FFh Bits 31:24 = FFh = Instruction for Erase Type 4: RFU \nBits 23:16 = DCh = Instruction for Erase Type 3 Bits 15:8 = FFh = Instruction for Erase Type 2: RFU Bits 7:0 = FFh = Instruction for Erase Type 1: RFU 4Fh 4Dh FFh \n50h 4Eh DCh 51h 4Fh FFh \nTable 71 Device ID and common flash interface ASO map\nAddress Data field # of \nbytes Data \nformat Example \nof actual \ndata Hex read out of example data \n(SA) + 0180h Size of Electronic Marking 1 Hex 20 14h \n(SA) + 0181h Revision of Electronic \nMarking 1 Hex 1 01h \n(SA) + 0182h Fab Lot # 8 ASCII LD87270 4Ch, 44h, 38h, 37h, 32h, 37h, 30h, FFh \n(SA) + 018Ah Wafer # 1 Hex 23 17h (SA) + 018Bh Die X Coordinate 1 Hex 10 0Ah (SA) + 018Ch Die Y Coordinate 1 Hex 15 0Fh (SA) + 018Dh Class Lot # 7 ASCII BR33150 42h, 52h, 33h, 33h, 31h, 35h, 30h (SA) + 0194h Reserved for Future 12 N/A N/A FF h, FFh, FFh, FFh, FFh, FFh, FFh, FFh, \nFFh, FFh, FFh, FFh \nTable 72 Status register-1 (SR1)\nBits Field \nname Function Type Default \nstate Description \n7 SRWD Status \nRegister \nWrite \nDisable Non-volatile 0 1 = Locks state of SRWD, BP , and configuration \nregister bits when WP# is low by ignoring WRR command0 = No protection, even when WP# is low \n6 P_ERR Programmi\nng Error \nOccurred Volatile, Read \nonly 0 1 = Error occurred \n0 = No Error Table 70 CFI alternate vendor-specific extended query parameter A5h, JEDEC SFDP Rev B\n (continued)\nCFI Parameter \nrelative byte \naddress offset SFDP Parameter \nrelative byte \naddress offset SFDP \nDword \nname Data  Description \nDatasheet 150 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n5 E_ERR Erase Error \nOccurred Volatile, Read \nonly 0 1= Error occurred \n0 = No Error \n4 BP2 Block \nProtection Volatile if \nCR1[3]=1, \nNon-volatile if \nCR1[3]=0 1 if \nCR1[3]=1, \n0 when \nshipped \nfrom \nInfineon Protects selected range of sectors (Block) \nfrom Program or Erase 3 BP1 \n2 BP0 \n1 WEL Write Enable \nLatch Volatile 0 1 = Device accepts Write Registers (WRR), \nprogram or erase commands 0 = Device ignores Write Registers (WRR), program or erase commands This bit is not affected by WRR, only WREN and WRDI commands affect this bit. \n0 WIP Write in \nProgress Volatile, Read \nonly 0 1= Device Busy, a Write Registers (WRR), \nprogram, erase or other operation is in progress 0 = Ready Device is in standby mode and can accept commands Table 72 Status register-1 (SR1)\nBits Field \nname Function Type Default \nstate Description \nDatasheet 151 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 73 Configuration register (CR1)\nBits Field \nname Function Type Default \nstate Description \n7 LC1 Latency Code Non-volatile 0 Select s number of initial read latency cycles\nSee Latency Code Tables 6 LC0 0 \n5 TBPROT Configures Start \nof Block \nProtection OTP 0 1 = BP starts at bottom (Low address)\n0 = BP starts at top (High address) \n4 RFU RFU  RFU 0 Reserved for Future Use \n3 BPNV Configures BP2-0 \nin Status \nRegister OTP 0 1 = Volatile \n0 = Non-volatile \n2 RFU RFU RFU 0 Reserved for Future Use \n1 QUAD Puts the device \ninto Quad I/O \noperation Non-volatile 0 1 = Quad \n0 = Dual or Serial \n0 FREEZE Lock current \nstate of BP2-0 \nbits in Status \nRegister, \nTBPROT in \nConfiguration \nRegister, and \nOTP regions Volatile 0 1 = Block Protection and OTP locked\n0 = Block Protection and OTP un-locked \nTable 74 Status register-2 (SR2)\nBits Field name Function Type Default \nstate Description \n7 RFU Reserved – 0 Reserved for Future Use \n6 RFU Reserved – 0 Reserved for Future Use 5 RFU Reserved – 0 Reserved for Future Use 4 RFU Reserved – 0 Reserved for Future Use 3 RFU Reserved – 0 Reserved for Future Use 2 RFU Reserved – 0 Reserved for Future Use 1 ES Erase \nSuspend Volatile, Read \nonly 0 1 = In erase suspend mode. \n0 = Not in erase suspend mode. \n0 PS Program \nSuspend Volatile, Read \nonly 0 1 = In program suspend mode. \n0 = Not in program suspend mode.\nTable 11-1 Bank address register (BAR)\nBits Field \nname Function Type Default \nstate Description \n7 EXTADD Extended \nAddress Enable Volatile 0b 1 = 4-byte (32-bits) addressing required from \ncommand.0 = 3-byte (24-bits) addressing from command + Bank Address \n6 to 2 RFU Reserved Volatile 00000b Reserved for Future Use \nDatasheet 152 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n1 BA25 Bank Address Volatile 0 A25 for 512 Mb device\n0 RFU Bank Address Volatile 0 RFU for lower density device Table 11-1 Bank address register (BAR)\nBits Field \nname Function Type Default \nstate Description \nDatasheet 153 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\nTable 75 ASP register (ASPR)\nBits Field name Function Type Default \nstate Description \n15 to 9 RFU Reserved OTP 1 Reserved for Future Use \n8 RFU Reserved OTP Note [53] Reserved for Future Use \n7 RFU Reserved OTP Reserved for Future Use 6 RFU Reserved OTP 1 Reserved for Future Use 5 RFU Reserved OTP Note \n[53]Reserved for Future Use \n4 RFU Reserved OTP Reserved for Future Use 3 RFU Reserved OTP Reserved for Future Use 2 PWDMLB Password \nProtection \nMode Lock Bit OTP 1 0 = Password Protection Mode permanently enabled. \n1 = Password Protection Mode not permanently enabled.\n1 PSTMLB Persistent \nProtection \nMode Lock Bit OTP 1 0 = Persistent Protection Mode permanently enabled. \n1 = Persistent Protection Mode not permanently enabled.\n0 RFU Reserved OTP 1 Reserved for Future Use \nTable 76 Password register (PASS)\nBits Field \nname Function Type Default state Description \n63 to 0 PWD Hidden \nPassword OTP FFFFFFFF-FFFFF\nFFFh Non-volatile OTP storage of 64-bit password. The \npassword is no longer readable after the password protection mode is selected by programming ASP register bit 2 to zero. \nTable 77 PPB lock register (PPBL)\nBits Field \nname Function Type Default state Description \n7 to 1 RFU Reserved Volatile 00h Reserved for Future Use \n0 PPBLOCK Protect PPB \nArray Volatile Persistent Protection \nMode = 1 \nPassword Protection \nMode = 0 0 = PPB array protected until next \npower cycle or hardware reset 1 = PPB array may be programmed or erased\nTable 78 PPB access register (PPBAR)\nBits Field name Function Type Default \nstate Description \n7 to 0 PPB Read or \nProgram per \nsector PPB Non-volatile FFh 00h = PPB for the sector addressed by the \nPPBRD or PPBP command is programmed to ‘0’ , protecting that sector from program or erase operations. FFh = PPB for the sector addressed by the PPBRD or PPBP command is erased to ‘1’ , not protecting that sector from program or erase operations. \nNote\n53.Default value depends on ordering part number, see “Initial delivery state” on page 154.\nDatasheet 154 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nSoftware interface reference\n11.6 Initial delivery state\nThe device is shipped from Infineon wi th non-volatile bits set as follows:\n• The entire memory array is erased: i.e. all bits are set to 1 (each byte contains FFh).• The OTP address space has the first 16 bytes programmed to  a random number. All othe r bytes are erased to FFh.\n• The SFDP address space contains the values as de fined in the description of the SFDP address space.\n• The ID-CFI address space contains the values as de fined in the description of  the ID-CFI address space.\n• The Status Register 1 contains 00h (all SR1 bits are cleared to 0’s).\n• The Configuration Register 1 contains 00h.\n• The Autoboot register contains 00h.• The Password Register contains FFFFFFFF-FFFFFFFFh\n• All PPB bits are 1.\n• The ASP Register contents depend on the ordering options selected:Table 79 DYB access register (DYBAR)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 DYB Read or \nWrite per \nsector DYB Volatile FFh 00h = DYB for the sector addressed by the DYBRD or \nDYBP command is cleared to ‘0’ , protecting that sector from program or erase operations. FFh = DYB for the sector addressed by the DYBRD or DYBP command is set to ‘1’ , not protecting that sector from program or erase operations. \nTable 80 Non-volatile data learning register (NVDLR)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 NVDLP Non-volatile \nData \nLearning \nPatternOTP 00h OTP value that may be transferred to the host during \nDDR read command latency (dummy) cycles to provide a training pattern to help the host more accurately center the data capture point in the received data bits.\nTable 81 Volatile data learning register (NVDLR)\nBits Field \nname Function Type Default \nstate Description \n7 to 0 VDLP Volatile Data \nLearning \nPattern Volatile Takes the \nvalue of \nNVDLR \nduring POR \nor ResetVolatile copy of the NVDLP used to enable and deliver \nthe Data Learning Pattern (DLP) to the outputs. The VDLP may be changed by the host during system operation.\nTable 82 ASP register content\nOrdering part number model ASPR default value\n01, 21, 31, R1, A1, B1, C1, D1,91, Q1, 71, 61, 81 FE7Fh\nK1, L1. S1, T1, Y1, Z1, M1, N1, U1, V1, W1, X1 FE4Fh\nDatasheet 155 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nOrdering information\n12 Ordering information\nThe ordering part number is formed by a valid combination of the following:\nS25FL 512 S AG M F I 0 1 1\nPacking type\n0 = Tray \n1 = Tube\n3 = 13” Tape and Reel\nModel number (Sector Type)\n1 = Uniform 256-kB sectors[54]\nModel number (Latency type, Package details, RESET# and VIO support)\n0 = EHPLC, SO footprint\n2 = EHPLC, 5 x 5 ball BGA footprint3 = EHPLC, 4 x 6 ball BGA footprint\nG = EHPLC, SO footprint with RESET#\nR = EHPLC, SO footpr int with RESET# and V\nIOA = EHPLC, 5 x 5 ball BGA footprint with RESET# and VIOB = EHPLC, 4 x 6 ball BGA footprint with RESET# and VIOC = EHPLC, 5 x 5 ball BG A footprint with RESET#\nD = EHPLC, 4 x 6 ball BG A footprint with RESET#\n9 = HPLC, SO footprint\n4 = HPLC, 5 x 5 ball BGA footprint8 = HPLC, 4 x 6 ball BGA footprint\nH = HPLC, SO foot print with RESET#\nQ = HPLC, SO footprint with RESET# and V\nIO7 = HPLC, 5 x 5 ball BGA footprint with RESET# and VIO6 = HPLC, 4 x 6 ball BGA footprint with RESET# and VIOE = HPLC, 5 x 5 ball BG A footprint with RESET#\nF = HPLC, 4 x 6 ball BGA footprint with RESET#\nTemperature range \nI = Industrial (–40°C to + 85°C)\nV = Industrial Plus (–40°C to + 105°C)\nA = Automotive, AEC-Q100 Grade 3 (–40°C to + 85°C)B = Automotive, AEC-Q100 Grade 2 (–40°C to + 105°C)\nM = Automotive, AEC-Q100 Grade 1 (–40°C to + 125°C)\nPackage materials[57]\nF = Halogen-free, Lead (Pb)-free \nH = Halogen free, Lead (Pb)-free\nPackage type\nM = 16-pin SO package\nB = 24-ball BGA 6 x 8 mm package, 1.00 mm pitch\nSpeed\nAG = 133 MHz\nDP = 66 MHz DDR\nDS = 80 MHz DDR\nDevice technology\nS = 65 nm MirrorBit Process Technology\nDensity512 = 512 Mb\nDevice familyS25FLInfineon Memory 3.0 V-Only, Serial Peripheral Interface (SPI) F lash Memory\nNotes\n54.Uniform 256-kB sectors = All sectors are un iform 256-kB with a 512B programming buffer.\n55.EHPLC = Enhanced High Performance Latency Code table.56.HPLC = High Performa nce Latency Code table.\n57.Halogen free definition is in acco rdance with IE 61249-2-21 specification.\nDatasheet 156 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nOrdering information\n12.1 Valid combinations — Standard\nValid Combinations list configurations planned to be supp orted in volume for this device. Consult your local sales \noffice to confirm availability of specific valid comb inations and to check on newly released combinations.\n12.2 Valid combinations — Automotive Grade / AEC-Q100\nThe table below lists configurations that are Automot ive Grade / AEC-Q100 qualified and are planned to be \navailable in volume. The table will be updated as new combinations are released. Consult your local sales repre-sentative to confirm availability of specific combin ations and to check on newly released combinations.\nProduction Part Approval Process (PPAP) suppor t is only provided for AEC-Q100 grade products.\nProducts to be used in end-use applications that require ISO/TS-16949 compliance must be AEC-Q100 grade \nproducts in combination with PPAP . Non–AEC-Q100 grade pr oducts are not manufactured or documented in full \ncompliance with ISO/TS-16949 requirements.\nAEC-Q100 grade products are also offered without PPAP support for end-use applications that do not require \nISO/TS-16949 compliance.Table 83 Valid combinations - Standard\nValid combinations — Standard\nBase Or-\ndering part \nnumberSpeed \noptionPackage and \ntemperatureModel \nnumberPacking \ntypePackage marking[58]\nS25FL512SAGMFI, MFV 01, G1, R1 0, 1, 3 FL512S + A + (Temp) + F + (Model Number)\nBHI, BHV 21, 31, A1, \nB1, C1, D10, 3 FL512S + A + (Temp) + H + (Model Number)\nDPMFI, MFV 01, G1 0, 1, 3 FL512S + D + (Temp) + F + (Model Number)\nBHI, BHV 21, 31, C1, \nD10, 3 FL512S + D + (Temp) + H + (Model Number)\nDSMFI, MFV 01, G1, R1 0, 1, 3 FL512S + S + (Temp) + F + (Model Number)\nBHI, BHV 21, 31, A1, \nB1, C1, D10, 3 FL512S + S + (Temp) + H + (Model Number)\nTable 84 Valid combinations - Automotive Grade/AEC-Q100\nValid combinations — Automotive Grade / AEC-Q100\nBase order-\ning part \nnumberSpeed \noptionPackage \nand tem-\nperatureModel \nnumberPacking \ntypePackage marking \nS25FL512SAGMFA, MFB, \nMFM01, G1, R1 0, 1, 3 FL512S + A + (Temp) + F + (Model Number)\nBHA, BHB, \nBHM21, 31, A1, \nB1, C1, D10, 3 FL512S + A + (Temp) + H + (Model Number)\nDP BHB 21, C1 0, 3 FL512S + D + (Temp) + H + (Model Number)\nDSMFA, MFB, \nMFM01, G1, R1 0, 1, 3 FL512S + S + (Temp) + F + (Model Number)\nBHA, BHB, \nBHM21, 31, A1, \nB1, C1, D10, 3 FL512S + S + (Temp) + H + (Model Number)\nDP MFA, MFB G1 0 FL512S + D + (Temp) + F+ (Model Number)\nNote\n58.Example, S25FL512SAGMFI000 packag e marking would be FL512SAIF00.\nDatasheet 157 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nRevision history\nRevision history\nDocument\nversion.Date of release Description of changes\n** 2011-12-20 Initial release\n*A 2012-03-02 General: Changed data sheet designation from Advance Information to Prelim-\ninaryPerformance Summary: Current Consumption table: corrected Serial Read 50 MHz and Serial Read 133 MHz valuesDC Characteristics: DC Characteristics table: corrected ICC1 valuesSDR AC Characteristics: AC Characteristic s (Single Die Package, VIO = VCC 2.7V to \n3.6V) table: corrected TCSH and TSU Max valuesAC Characteristics (Single Die Package, VIO 1.65V to 2.7V, VCC 2.7V to 3.6V) table: corrected TCSH and TSU Max valuesEmbedded Algorithm Performance Tables: Program and Erase Performance table: corrected TW Typ and Max valuesDevice ID and Common Flash Interface (ID-CFI) Address Map: Updated table: CFI Alternate Vendor-Specific Extended Query Parameter 0\n*B 2012-05-02 Global: Added 105°C updates\nOrdering Information: Updated Valid Combinations tableEmbedded Algorithm Performance Tables: Updated table: Program and Erase Performance\n*C 2012-06-13 SDR AC Characteristics: Updated tHO value from 0 Min to 2 ns Min\n*D 2013-04-12 Global: Data Sheet designation updated from Preliminary to Full Production\n*E 2013-12-20 Global 80 MHz DDR Read operation added\nPerformance Summary:Updated Maximum Read Rates DDR (VIO = VCC = 3V to 3.6V) tableCurrent Consumption table: added Quad DDR Read 80 MHzMigration Notes FL Generations Comparison table: updated DDR values for FL-SSDR AC Characteristics:Updated Clock Timing figureDDR AC Characteristics: Updated AC Characteristics — DDR Operation tableDDR Output Timing: Updated SPI DDR Data Valid Window figure and NotesOrdering Information:Added 80 MHz to Speed optionValid Combinations table: added DS to Speed Option\n*F 2014-01-08 DDR AC Characteristics: Removed AC Characteristics 80 MHz Operation table.\n*G 2014-12-18 SDR AC Characteristics: AC Ch aracteristics (Single Die Package, V\nIO = VCC 2.7V to \n3.6V) table: removed tV (Min) value.\nAC Characteristics (Single Die Package, VIO 1.65V to 2.7V, VCC 2.7V to 3.6V) table: \nremoved tV (Min) value.\nBank Address Register: Bank Address Register (BAR) table: corrected Bit 0.Serial Flash Discoverable Parameters (SFDP) Address Map: Updated section SFDP Overview Map table: updatedField Definitions: updated SFDP Header table.Device ID and Common Flash Interface (ID- CFI) Address Map: Field Definitions: \nadded CFI Alternate Vendor-Specific Extended Query Parameter A5h, JEDEC SFDP Rev B table.\nDatasheet 158 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nRevision history\n*H 2015-01-21 Capacitance Characteristics: Capacitance table: added TA = 25°C under Test \nConditions.SDR AC Characteristics: AC Characteristics (Single Die Package, V\nIO = VCC 2.7V to \n3.6V) table: changed tSU (Min).\nConfiguration Register 1 (CR1): Latenc y Codes for DDR Enhanced High Perfor-\nmance table: added 80 MHz\nCommand Set Summary: S 25FL512S Command Set (sorted by function) table: \nupdated Maximum Frequency (MHz) of DDR Command Descriptions to 80 MHz.Read Memory Array Commands: Changed 66 MHz to 80 MHz throughout section.\nSoftware Interface Reference: S25FL512S In struction Set (sorte d by instruction) \ntable: updated Maximum Frequency (MHz) of DDR Command Descriptions to 80 MHz.\n*I 2015-08-24 Replaced “Automotive Temperature Ra nge” with “Industrial Plus Temperature \nRange” in all instances across the document.Updated Section 2 :\nUpdated Section 2.11 :\nUpdated description.Updated to Cypress template.Document\nversion.Date of release Description of changes\nDatasheet 159 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nRevision history\n*J 2016-09-20 Added ECC related information in  all instances across the document.\nAdded “Extended” , “Automotive, AEC-Q100 Grade 3” , “Automotive, AECQ100 Grade 2” , “Automotive, AEC-Q100 Grade 1” temperature range related infor-mation in all instances across the document.Added Logic block diagram .\nUpdated Section 4\nAdded Section 4.2 .\nUpdated Section 4.4\nUpdated Table 6\nChanged minimum value of V\nCC (low) parameter from 1.0 V to 1.6 V.\nChanged minimum value of tPD parameter from 1.0 µs to 10.0 µs.\nUpdated Section 5\nUpdated Section 5.4\nUpdated Table 12\nUpdated Table 13\nUpdated Section 5.5  \nUpdated Table 14\nChanged minimum value of tHO parameter corresponding to 66 MHz from 0 ns to \n1.5 ns.Removed minimum value of t\nV parameter.\nUpdated Section 7\nUpdated Section 7.6\nAdded Section 7.6.6\nAdded Table 18 .\nUpdated Section 9 :\nUpdated Section 9.1 :\nUpdated Section 9.1.1 :\nUpdated Table 40 :\nUpdated Section 9.3 :\nUpdated Section 9.3.7 :\nUpdated description.Added Section 9.3.11 .\nUpdated Program flash array commands :\nUpdated Program granularity :\nAdded Automatic ECC .\nAdded Data integrity .\nUpdated Ordering information :\nNo change in part numbers.Added Valid combinations — Automotive Grade / AEC-Q100 .\nUpdated to new template.\n*K 2017-03-17 Updated t\nSU in Table 12 .\nUpdated Infineon logo and Sales page.\n*L 2017-05-22 Remove Extended Temperature Range MPN option Ordering information .\nUpdated Package Drawings SOIC 16-lead package , FAB024 24-ball BGA \npackage , FAC024 24-ball BGA package .\nUpdated Quad page program (QPP 32h or 38h, or 4QPP 34h) .\nAdded “DP” speed option in Valid combinations — Automotive Grade / \nAEC-Q100 .Document\nversion.Date of release Description of changes\nDatasheet 160 of 161 001-98284 Rev. *S\n2022-04-11  \n512 Mb (64 MB) FL-S Flash\nSPI Multi-I/O, 3.0 V\nRevision history\n*M 2017-11-10 Updated Table 5 .\nCorrected JEDEC Sector Map Parameter Dword-2 in Table 69 .\nUpdated Ordering information  definition of letters in OPN indicating package \nmaterial.Updated DDR data valid timing using DLP , Example.\nUpdated Package Drawings on Physical interface .\nChange the description of CR1[ 4] from “RFU” to “DNU” in Table 20 .\n*N 2017-12-15 Added Model C1 to DP speed option of Valid Combination in Valid combinations \n— Automotive Grade / AEC-Q100 .\nUpdated Sales page.\n*O 2018-03-21 Table 13  and Table 14 : Removed the Max value of t\nCSH and updated the Max \nvalue of tSU as “3000” .\n*P 2018-06-22 Updated Section 5.5.3 .\nUpdated Package Materials in Section 12 .\n*Q 2019-01-23 Updated FL-S device density in Section 1.2.2.5 .\nUpdated Thermal resistance .\n*R 2019-04-30 Added Device ID and common flash interface (ID-CFI) ASO map — Automotive \nonly .\nUpdated Glossary .\n*S 2022-04-11 Updated Chip select (CS#)\nUpdated Thermal resistance\nUpdated Valid combinations — Automotive Grade / AEC-Q100\nMigrated to IFX templateDocument\nversion.Date of release Description of changes\nEdition 2022-04-11\nPublished byInfineon Technologies AG81726 Munich, Germany\n© 2022 Infineon Technologies AG.\nAll Rights Reserved.\nDo you have a question about this \ndocument?\nGo to www.infineon.com/support\nDocument reference \n001-98284 Rev. *SIMPORTANT NOTICE\nThe information given in this document shall in no\nevent be regarded as a guarantee of conditions or\ncharacteristics (“Beschaffenheitsgarantie”). \nWith respect to any examples, hints or any typical\nvalues stated herein and/or any informationregarding the application of the product, Infineon\nTechnologies hereby disclaims any and all\nwarranties and liabilities of any kind, includingwithout limitation warranties of non-infringement of\nintellectual property rights of any third party. \nIn addition, any information given in this document\nis subject to customer’s  compliance with its\nobligations stated in this document and any\napplicable legal requirements, norms and standards\nconcerning customer’s products and any use of theproduct of Infineon Technologies in customer’s\napplications. \nThe data contained in th is document is exclusively\nintended for technically trained staff. It is theresponsibility of customer’s technical departments\nto evaluate the suitability of the product for the\nintended application and the completeness of theproduct information given in this document with\nrespect to such application.    For further information on the product, technology,\ndelivery terms and conditions and prices please\ncontact your nearest Infineon Technologies office(www.infineon.com ).\nWARNINGS\nDue to technical requirements products may contain\ndangerous substances. For information on the types\nin question please contact your nearest InfineonTechnologies office.\nExcept as otherwise explicitly approved by Infineon\nTechnologies in a written document signed by\nauthorized representatives of InfineonTechnologies, Infineon Te chnologies’ products may\nnot be used in any applications where a failure of the\nproduct or any consequences of the use thereof canreasonably be expected to result in personal injury.Trademarks\nAll referenced product or service names and trademar ks are the property of their respective owners.\nPlease read the Important Notice and Warnings at the end of this document\n'}]
!==============================================================================!
### Component Summary: S25FL512SAGMFMR10

#### Key Characteristics and Specifications:
- **Voltage Ratings:**
  - Core Supply Voltage (VCC): 2.7 V to 3.6 V
  - I/O Supply Voltage (VIO): 1.65 V to 3.6 V

- **Current Ratings:**
  - Active Power Supply Current (READ): Up to 90 mA (depending on operation mode)
  - Standby Current: 70 µA (typical for Industrial temperature range)

- **Power Consumption:**
  - Maximum Read Current: 33 mA at 133 MHz
  - Maximum Program Current: 100 mA
  - Maximum Erase Current: 100 mA

- **Operating Temperature Range:**
  - Industrial: -40 °C to +85 °C
  - Industrial Plus: -40 °C to +105 °C
  - Automotive AEC-Q100 Grade 1: -40 °C to +125 °C

- **Package Type:**
  - 16-pin SOIC (300 mil)
  - 24-ball BGA (6 × 8 mm and 4 × 6 mm)

- **Special Features:**
  - Supports SPI Multi-I/O with DDR options
  - Automatic ECC (Error Correction Code) for data integrity
  - Advanced Sector Protection (ASP) and Block Protection features
  - AutoBoot feature for immediate code execution after reset
  - 100,000 Program-Erase Cycles minimum
  - 20-Year Data Retention minimum

- **Moisture Sensitive Level (MSL):**
  - MSL Level 3 per JEDEC J-STD-020E

#### Description:
The **S25FL512S** is a 512 Mb (64 MB) non-volatile flash memory device from Cypress Semiconductor (now part of Infineon Technologies). It utilizes **MirrorBit™ technology** and **Eclipse architecture**, which enhances programming and erasing performance. The device interfaces with host systems via a **Serial Peripheral Interface (SPI)**, supporting various modes including single, dual, and quad I/O operations, as well as double data rate (DDR) commands.

#### Typical Applications:
The S25FL512S is designed for a wide range of embedded applications, including:
- **Code Shadowing**: Storing executable code that can be run directly from flash memory (Execute-In-Place or XIP).
- **Data Storage**: Retaining configuration settings, firmware, and other critical data in consumer electronics, automotive systems, and industrial applications.
- **Firmware Updates**: Facilitating easy updates to device firmware without requiring physical access to the hardware.
- **Secure Boot**: Utilizing the One Time Programmable (OTP) memory for secure storage of cryptographic keys or unique identifiers.

This component is particularly suitable for applications requiring high-density storage, fast access times, and robust data integrity features, making it ideal for modern electronic devices that demand reliability and performance.