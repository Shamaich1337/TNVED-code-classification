[{'role': 'system', 'content': 'You are a technical specialist with expertise in electronics. Your task is to analyze datasheets for electronic components and provide a concise summary of the product’s key characteristics and specifications. In addition, you need to gather textual information about the component, including its description and typical applications.Instructions:    Identify the correct component in the datasheet using the provided product code.    Summarize key parameters, including:        Voltage ratings        Current ratings        Power consumption        Operating temperature range        Package type        Special features or notes (if applicable)        Moisture Sensetive Level JEDEC J-STD-020E    Provide a short description of the component, including what it is (e.g., transistor, microcontroller, sensor) and its primary function.    Explain typical applications for the component (e.g., power management, signal processing, data storage, etc.).    Be thorough and accurate: Ensure the information corresponds specifically to the product code, as some datasheets cover multiple variants.Your goal is to create a clear and accurate technical summary that includes both key specifications and a description of what the component is used for.'}, {'role': 'user', 'content': 'Give me information about the component of W5200 production of WIZNET from the text: \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n1 \niEthernet  W5200   \n    \niEthernet W5200 \nDatasheet \nVersion 1.4.0 \n \n \n \n                   \n \nhttp://www.wiznet.co.kr  \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n2 \niEthernet  W5200 W5200 \nThe W5200 chip is a Hardwired TCP/IP embedded Et hernet controller that enables easier internet \nconnection for embedded systems using SPI (Serial Peripheral Interface). W5200 suits best for \nusers who need Internet connectivity for applic ation that uses a single chip to implement \nTCP/IP Stack, 10/100 Ethernet MAC and PHY . The W5200 is composed of a fully hardwired ma rket-proven TCP/IP stack and an integrated \nEthernet MAC & PHY .  Hardwired TCP/IP stack supports TCP , UDP , IPv4, ICMP , ARP , IGMP , and PPPoE, which has been proven in various applications for many years. W5200 uses a \n32Kbytes internal buffer as its data communication memory. By using W5200, users can implement the Ethernet application they need by using a simple socket program instead of \nhandling a complex Ethernet Controller. SPI (Serial Peripheral Interface) is provided for easy integration with the external MCU.  Using the only 4 pins of SPI to connect with MCU, it is possible to design for small form factor system with the MCU’s I/O pin limit. In order to reduce power consumption of th e system, W5200 provides WOL (Wake on LAN) \nand power down mode. To wake up during WO L, W5200 should be received magic packet, \nwhich is the Raw Ethernet packet.  \n \nFeatures \n- Support Hardwired TCP/IP Protocols : TCP , UD P , ICMP , IPv4 ARP , IGMP , PPPoE, Ethernet \n- Supports 8 independent sockets simultaneously \n- Very small 48 Pin QFN Package \n- Support Power down mode \n- Support Wake on LAN \n- Support High Speed Serial Periph eral Interface(SPI MODE 0, 3) \n- Internal 32Kbytes Memory for Tx/Rx Buffers \n- 10BaseT/100BaseTX Ethernet PHY embedded \n- Support Auto Negotiation (Full and half duplex, 10 and 100-based ) \n- Support Auto MDI/MDIX \n- Support ADSL connection (with support PPPoE Protocol with PAP/CHAP Authentication \nmode) \n- Not support IP Fragmentation \n- 3.3V operation with 5V I/O signal tolerance \n- Lead-Free Package \n- Multi-function LED outputs (F ull/Half duplex, Link, Speed) \n \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n3 \niEthernet  W5200  \nTarget Applications \nThe W5200 is well suited for many embedded applications, including: \n- Home Network Devices: Set-Top Boxe s, PVRs, Digital Media Adapters \n- Serial-to-Ethernet: Access Controls, LED displays, Wireless AP relays, etc. \n- Parallel-to-Ethernet: POS / Mini Printers, Copiers \n- USB-to-Ethernet: Storage Devices, Network Printers \n- GPIO-to-Ethernet: Home Network Sensors \n- Security Systems: DVRs, Network Cameras, Kiosks \n- Factory and Building Automations \n- Medical Monitoring Equipments \n- Embedded Servers \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n4 \niEthernet  W5200 Block Diagram \n \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n5 \niEthernet  W5200 Table of Contents  \n1 Pin Assignment ......................................................................................... 8 \n1.1 MCU Interface Signals ..................................................................... 8 1.2 PHY Signals ................................................................................. 10 1.3 Miscellaneou s Signals ..................................................................... 10 \n1.4 Power Supply Signals ..................................................................... 11 1.5 Clock Signals ............................................................................... 13 1.6 LED Signals ................................................................................. 13 \n2 Memory Map ........................................................................................... 14 3 W5200 Registers ....................................................................................... 15 \n3.1 common registers ......................................................................... 15 3.2 Socket re gisters ........................................................................... 16 \n4 Register Descriptions ................................................................................. 17 \n4.1 Common Registers ........................................................................ 17 4.2 Socket Re gisters ........................................................................... 24 \n5 Functional Desc riptions .............................................................................. 43 \n5.1 Initializa tion ............................................................................... 43 \n5.2 Data Commun ications .................................................................... 46 \n5.2.1 TCP .................................................................................... 46 \n5.2.1.1 TCP SERVER ..................................................................... 47 5.2.1.2 TCP CLIENT ..................................................................... 54 \n5.2.2 UDP .................................................................................... 55 \n5.2.2.1 Unicast an d Broadcast ........................................................ 55 \n5.2.2.2 Mult icast ........................................................................ 62 \n5.2.3 IPRAW ................................................................................. 65 5.2.4 MACRAW ............................................................................... 66 \n6 External Interface .................................................................................... 73 \n6.1 SPI (Serial Peripheral Interface) mode ................................................. 73 \n6.2 Device Operations ......................................................................... 73 \n6.3 Process of using genera l SPI Master device ........................................... 74 \n7 Electrical Spec ifications ............................................................................. 79 \n7.1 Absolute Maximu m Ratings .............................................................. 79 \n7.2 DC Characteristics ........................................................................ 79 7.3 POWER DISSIPATION(Vcc 3. 3V Temperatur e 25°C) ................................... 79 \n7.4 AC Characteristics......................................................................... 80 \n7.4.1 Reset Timing ......................................................................... 80 7.4.2 Crystal Char acteristics ............................................................. 80 \n7.4.3 SPI Timing ............................................................................ 81 \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n6 \niEthernet  W5200 7.4.4 Transformer Ch aracteristics ....................................................... 82 \n8 IR Reflow Temperature Profile (Lead-Free) ....................................................... 83 \n9 Package Descriptions ................................................................................. 84 Document History Information ........................................................................... 86 \n   \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n7 \niEthernet  W5200 Table of Figure  \nFigure 1 Pin Desc ription W5200 ................................................................ 8 \nFigure 2 XTAL_VDD Refe rence Schematic .................................................... 11 \nFigure 3 Power Design .......................................................................... 12 \nFigure 4 Crystal Reference Schematic ........................................................ 13 \nFigure 5 INTLEVEL  Timing ...................................................................... 21 \nFigure 6 Socket Stat us Transition ............................................................. 33 \nFigure 7 Physical Addr ess Calculat ion ........................................................ 39 \nFigure 8 Allocation Internal TX/RX memory of Socket n .................................. 45 \nFigure 9 TCP SERVER and TCP CLIENT ........................................................ 46 \nFigure 10 TCP SERVER Operation Fl ow ....................................................... 47 \nFigure 11 TCP CLIENT Operation Flow ........................................................ 54 \nFigure 12 UDP Oper ation Flow ................................................................. 55 \nFigure 13 The Received UDP data Format ................................................... 57 \nFigure 14 IPRAW Op eration Flow .............................................................. 65 \nFigure 15 The receive IPRAW data Format ................................................... 66 \nFigure 16 MACRAW Op eration Fl ow ........................................................... 67 \nFigure 17  The received MACRAW data Format ............................................ 68 \nFigure 18 SPI Interface .......................................................................... 73 \nFigure 19 W5200 SPI Frame Format ........................................................... 74 \nFigure 20 Address and OP/DATA Length Sequence Diagram ............................... 74 \nFigure 21 READ Sequence ...................................................................... 75 \nFigure 22 Write Sequence ...................................................................... 77 \nFigure 23 Reset Timing .......................................................................... 80 \nFigure 24 SPI Timing ............................................................................. 81 Figure 25 Transf ormer Type .................................................................... 82 \nFigure 26 IR Reflow  Temperature ............................................................. 83 \nFigure 27 Package Dimensions ................................................................. 84 \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n8 \niEthernet  W5200 1 Pin Assignment \n \nFigure 1 Pin Description W5200 \n1.1 MCU Interface Signals \nSymbol Type Pin No Description \nA0/DUP I 30 (*)ADDRESS[0] \nThis pin is used to select a register or memory when using indirect interface. \nA1/SPD I 31 (*)ADDRESS[1] \nThis pin is used to select a register or memory when using indirect interface. \nD7-0 I/O 32, 33, \n34, 35, 36, 37, 38, 39 (*)DATA \nThese pins are used to read and write register or memory data. \nRSTn I 46 RESET ( Active LOW ) \nThis pin is active Low input to initialize or re-initialize W5200. RESET should be held at least 2us after low assert, and \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n9 \niEthernet  W5200 wait for at least 150ms after high de-assert in order for \nPLL logic to be stable. Refer to RESET timing of “7 Electrical Specification” \nCSn I 41 SPI SLAVE SELECT ( Active LOW ) \nThis pin is used to SPI Slave Select signal Pin when using \nSPI interface. (*)CHIP SELECT ( Active LOW ) Chip Select is for MCU to access to internal registers or memory when using indirect interface. \nINTn O 40 INTERRUPT (Active LOW ) \nThis pin indicates that W5 200 requires MCU attention \nafter socket connecting, disconnecting, data receiving timeout, and WOL (Wake on LAN). The interrupt is cleared by writing IR(Interrupt Register) or Sn_IR (Socket n Interrupt Register). All interrupts are maskable. This pin is active low. \nSCLK/RDn I 42 SPI CLOCK \nThis pin is used to SPI Clock signal Pin when using SPI interface. (*)READ ENABLE ( Active LOW ) Strobe from MCU to read an internal register/memory selected by A[1:0] when using indirect interface. \nMOSI/WRn I 43 SPI MASTER OUT SLAVE IN \nT h i s  p i n  i s  u s e d  t o  S P I  M O S I  s i g n a l  p i n  w h e n  u s i n g  S P I  interface. (*)WRITE ENABLE ( Active LOW ) Strobe from MCU to write an internal register/memory selected by A[1:0] when using indirect interface. Data is latched into the W5200 on the rising edge of this input. \nMISO O 44 SPI MASTER IN SLAVE OUT \nThis pin is used to SPI MISO signal pin. \nPWDN I 45 POWER DOWN ( Active HIGH ) \nThis pin is used to power down pin. Low : Normal Mode Enable High : Power Down Mode Enable \nSPIEN I 6 (*)SPI ENABLE ( Active HIGH ) \nThis pin selects Enable/disable of the SPI Mode. Low = SPI Mode Disable High = SPI Mode Enable \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n10 \niEthernet  W5200 If you don’t use SPI mode, in other words, if you want to \nuse indirect mode, then you tied this signal to ‘0’. This function activate only when reset period. \n(*) These pins are related with indirect interf ace mode. If you need details, Please refer \nto the W5200_AN_Indirect.pdf file.  \n1.2 PHY Signals \nSymbol Type Pin No Description \nRXIP \n I 20 RXIP/RXIN Signal Pair \nThe differential data from the media is received on the RXIP/RXIN signal pair. \nRXIN \n I 21 \nTXOP O 17 TXOP/TXON Signal Pair \nThe differential data is transmitted to the media on the TXOP/TXIN signal pair. TXON O 18 \nBIAS O 12 BIAS Register \nConnect a resistor of 28.7 ㏀±1% to the ground. \nRefer to the “Reference schematic”. \nANE I 29 Auto Negotiation Mode Enable \nThis pin selects Enable/Dis able of Auto Negotiation \nMode. Low :Auto Negotiat ion Mode Disable \nHigh : Auto Negotiation Mode Enable \nA0/DUP I 30 Full Duplex Mode Enable \nThis pin selects Enable/Disable of Full Duplex Mode. Low = Half Duplex Mode Enable High = Full Duplex Mode Enable This function activates only during reset period. \nA1/SPD I 31 Speed Mode \nThis pin selects 100M/10M Speed Mode. Low = 10M Speed Mode High = 100M Speed Mode This function activates only during reset period. \n \n1.3 Miscellaneous Signals \nSymbol Type Pin No Description \nFDXLEDn/M2 \nSPDLEDn/M1 \nLINKLEDn/M0 I 3, \n4, \n5 W5200 MODE SELECT  \nNormal mode  : 111 Other test modes are internal test mode. \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n11 \niEthernet  W5200 This function activates only during reset \nperiod \nRSV I 7 Reserved Pin \n\uf06c Notes: Pull-Up/Down resistor  =  Typical value are 10K Ω. \n \n1.4 Power Supply Signals \nSymbol Type Pin No Description \nVCC3V3A Power 11, 15, 23 3.3V power supply for Analog part \nVCC3V3 Power 27, 47 3.3V power supply for Digital part \nVCC1V8 Power 8, 25 1.8V power supply for Digital part \nGNDA Ground 13, 19, 22, 24  Analog ground \nGND Ground 9, 10, 26, \n28, 48 Digital ground \n1V8O O 14 1.8V regulator output voltage \n1.8V/200mA power created by internal power regulator, is used fo r core operation power \n( VCC1V8).  Be sure to connect tantalum capacitor between 1V8O and GND for output frequency compensation, and selectively connect 0.1uF capacitor for high freq uency noise decoupling. \nNotice: 1V8O is the power for W5200 core operation. It should not be connected to the power of other devices . \nXTALVDD I 16 \n \nFigure 2 XTAL_VDD Reference Schematic \nConnect a capacitor of 10.1uF to the ground. \n※ Refer to the ‘W5200E01-M3 Reference schematic  \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n12 \niEthernet  W5200 \n \nFigure 3 Power Design \nRecommend for power design. \n1. Locate decoupling capacitor as close as possible to W5200. \n2. Use ground plane as wide as possible. \n3. If ground plane width is adequate, havi ng a separate analog ground plane and \ndigital ground plane is good practice. \n4. If ground plane is not wide, design analog  and digital ground planes as a single \nground plane, rather than separate them.  \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n13 \niEthernet  W5200 1.5 Clock Signals \nSymbol Type Pin No Description \nXI I 1 25MHz crystal input/output. A 25MHz crystal and \nOscillator is used to connect these pins. \n \nFigure 4 Crystal Reference Schematic XO O 2 \n \n1.6 LED Signals \nSymbol Type Pin No Description \nFDXLEDn/M2 O 3 Full Duplex/Collision LED \nLow: Full-duplex High: Half-duplex.  \nSPDLEDn/M1 O 4 Link speed LED \nLow: 100Mbps High: 10Mbps \nLINKLEDn/M0 O 5 Link LED \nLow: Link (10/100M)  High: Un-Link blink: TX or RX state on Link \n_\nXTAL OUT  \n XTAL IN  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n14 \niEthernet  W5200 2 Memory Map \nW5200 is composed of Common Register, Socket Register, TX Memory, and RX Memory as \nshown below.  \n \nW5200 Memory Map \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n15 \niEthernet  W5200 3 W5200 Registers \n3.1 common registers \n \nAddress Register \n0x0000 Mode (MR) \n \n0x0001 \n0x0002 \n0x0003 \n0x0004 Gateway Address  \n(GAR0) (GAR1) (GAR2) (GAR3) \n \n0x0005 \n0x0006 \n0x0007 \n0x0008 Subnet mask Address  \n(SUBR0) (SUBR1) (SUBR2) (SUBR3) \n \n0x0009 \n0x000A \n0x000B \n0x000C \n0x000D \n0x000E Source Hardware Address \n(SHAR0) (SHAR1) (SHAR2) (SHAR3) (SHAR4) (SHAR5) \n \n0x000F \n0x0010 \n0x0011 \n0x0012 Source IP Address \n(SIPR0) (SIPR1) (SIPR2) (SIPR3) \n0x0013 \n0x0014 Reserved \n0x0015 Interrupt (IR) \n0x0016 Interrupt Mask (IMR)  \n \n0x0017 \n0x0018 Retry Time \n(RTR0) (RTR1) \n0x0019 Retry Count (RCR) \n0x001A \nReserved \n0x001B  \nAddress Register \n \n \n0x001C \n0x001D Authentication Type \nin PPPoE (PATR0) (PATR1) \n \n \n0x001E Authentication \nAlgorithm in PPPoE (PPPALGO) \n0x001F Chip version(VERSIONR)  \n0x0020 \n~ \n0x0027 Reserved \n \n \n0x0028 PPP LCP \nRequestTimer (PTIMER) \n \n0x0029 PPP LCP Magic \nnumber (PMAGIC) \n0x002A \n~ \n0x002F Reserved \n \n0x0030 \n0x0031 Interrupt Low Level \nTimer (INTLEVEL0) (INTLEVEL1) \n \n0x0032 \n~ \n0x0033 Reserved \n0x0034 Socket Interrupt (IR2) \n0x0035 PHY Status(PSTATUS) \n0x0036 Socket Interrupt Mask \n(IMR2) \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n16 \niEthernet  W5200 3.2 Socket registers \nNote : n is socket number ( 0, 1, 2, 3, 4, 5, 6, 7 ) \n \nAddress Register \n0x4n00 Socket n Mode (Sn_MR) \n0x4n01 Socket n Command (Sn_CR) \n0x4n02 Socket n Interrupt (Sn_IR) \n0x4n03 Socket n Status (Sn_SR) \n \n0x4n04 \n0x4n05 Socket n Source Port \n(Sn_PORT0)  (Sn_PORT1) \n \n \n0x4n06 \n0x4n07 \n0x4n08 \n0x4n09 \n0x4n0A \n0x4n0B Socket n Destination Hardware Address  \n(Sn_DHAR0) \n(Sn_DHAR1) (Sn_DHAR2) (Sn_DHAR3) (Sn_DHAR4) (Sn_DHAR5) \n \n0x4n0C \n0x4n0D \n0x4n0E \n0x4n0F Socket n Destination IP Address \n(Sn_DIPR0) (Sn_DIPR1) (Sn_DIPR2) (Sn_DIPR3) \n \n0x4n10 \n0x4n11 Socket n Destination Port \n(Sn_DPORT0) (Sn_DPORT1) \n \n0x4n12 \n0x4n13 Socket n Maximum Segment Size \n(Sn_MSSR0) (Sn_MSSR1) \n \n0x4n14 Socket n Protocol in IP Raw mode \n(Sn_PROTO) \n0x4n15 Socket n IP TOS (Sn_TOS) \n0x4n16 Socket n IP TTL (Sn_TTL) \n0x4n17 \n~ \n0x4n1D Reserved  \nAddress  Register \n \n0x4n1E  Receive Memory Size \n(Sn_RXMEM_SIZE) \n \n0x4n1F  Transmit Memory Size (Sn_TXMEM_SIZE) \n \n0x4n20  \n0x4n21  Socket n TX Free Size (Sn_TX_FSR0) (Sn_TX_FSR1) \n \n0x4n22  \n0x4n23  Socket n TX Read Pointer (Sn_TX_RD0) (Sn_TX_RD1) \n \n0x4n24  \n0x4n25  Socket n TX Write Pointer (Sn_TX_WR0) (Sn_TX_WR1) \n \n0x4n26  \n0x4n27  Socket n RX Received Size (Sn_RX_RSR0) (Sn_RX_RSR1) \n \n0x4n28  \n0x4n29  Socket n RX Read Pointer (Sn_RX_RD0) (Sn_RX_RD1) \n \n0x4n2A  \n0x4n2B  Socket n RX Write Pointer (Sn_RX_WR0) (Sn_RX_WR1) \n \n0x4n2C  Socket n Interrupt Mask (Sn_IMR) \n \n0x4n2D  \n0x4n2E  Socket n Fragment Offset in IP header  \n(Sn_FRAG0) (Sn_FRAG1) \n0x4n30  \n~ \n0x4nFF  Reserved \n  \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n17 \niEthernet  W5200 4 Register Descriptions \n4.1 Common Registers \n \nMR (Mode Register) [R/W] [0x0000] [0x00] \nThis register is used for S/W rese t, ping block mode and PPPoE mode. \n7 6 5 4 3 2 1 0 \nRST  WOL PB PPPoE    \n \nBit Symbol Description \n7 RST S/W Reset \nIf this bit is ‘1’, internal register  will be initialized. It will be \nautomatically cleared after reset. \n6 Reserved Reserved \n5 WOL Wake on LAN \n0:Normal Mode 1:WOL mode If the bit is set as ‘1’, there is waiting for the Magic Packet. \n4 PB Ping Block Mode \n0 : Disable Ping block 1 : Enable Ping block If the bit is set as ‘1’, there is no response to the ping request. \n3 PPPoE PPPoE Mode \n0 : DisablePPPoE mode 1 : EnablePPPoE mode If you use ADSL without router or  etc, you should set the bit as \n‘1’ to connect to ADSL Server. For more detail, refer to the \napplication note, “How to connect ADSL” . \n2 Reserved Reserved \n1 Reserved Reserved \n0 Reserved Reserved \n \nGAR (Gateway IP Address Register) [R/W] [0x0001 – 0x0004] [0x00] \nThis Register sets up the default gateway address. \nEx) In case of “192.168.0.1” \n0x0001 0x0002 0x0003 0x0004 \n192 (0xC0) 168 (0xA8) 0 (0x00) 1 (0x01) \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n18 \niEthernet  W5200 SUBR (Subnet Mask Register) [R/W] [0x0005 – 0x0008] [0x00] \nThis register sets up the subnet mask address. \nEx) In case of “255.255.255.0” \n0x0005 0x0006 0x0007 0x0008 \n255 (0xFF) 255 (0xFF) 255 (0xFF) 0 (0x00) \nSHAR (Source Hardware Address Register) [R/W] [0x0009 – 0x000E] [0x00] \nThis register sets up the Source Hardware address. \nEx) In case of “00.08.DC.01.02.03” \n0x0009 0x000A 0x000B 0x000C 0x000D 0x000E \n0x00 0x08 0xDC 0x01 0x02 0x03 \nSIPR (Source IP Address Register) [R/W] [0x000F – 0x0012] [0x00] \nThis register sets up the Source IP address. \nEx) In case of “192.168.0.2” \n0x000F 0x0010 0x0011 0x0012 \n192 (0xC0) 168 (0xA8) 0 (0x00) 2 (0x02) \nIR (Interrupt Register) [R] [0x0015] [0x00] \nThis register is accessed by the host pr ocessor to know the cause of interrupt. Any \ninterruption can be masked in the Interrupt Mask  Register (IMR2). The INTn signal retain low \nas long as any masked signal is set, and will not go high until all masked bits in this Register \nhave been cleared.  \n7 6 5 4 3 2 1 0 \nCONFLICT Reserved PPPoE Reserved  Reserved  Reserved  Reserved Reserved  \n \nBit Symbol Description \n7 CONFLICT IP Conflict \nIt is set as ‘1’ when there is ARP request with same IP address as Source IP address. This bit is  cleared to ‘0’ by writing ‘1’ to \nthis bit.  \n6 Reserved Reserved \n 5 PPPoE PPPoE Connection Close \nIn the Point-to-Point Protocol over Ethernet (PPPoE) Mode, if the PPPoE connection is closed, ‘1’ is set. This bit will be cleared to ‘0’ by writing ‘1’ to this bit. \n4 Reserved Reserved \n3 Reserved Reserved \n2 Reserved Reserved \n1 Reserved Reserved \n0 Reserved Reserved \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n19 \niEthernet  W5200 IMR(Interrupt Mask Register)[R/W][0x0016][0x00] \nThe Interrupt Mask Register is used to mask in terrupts. Each interrupt mask bit corresponds to \na bit in the Interrupt Register2 (IR2). If an inte rrupt mask bit is set, an interruption will be \nissued whenever the corresponding bit in the IR2 is  set. If any bit in the IMR is set as ‘0’ an \ninterrupt will not occur though the bit.  \n7 6 5 4 3 2 1 0 \nS7_IMR S6_IMR S5_IMR S4_IMR S3_IMR S2_IMR S1_IMR S0_IMR \n \nBit Symbol Description \n7 S7_IMR IR2(S7_INT) Interrupt Mask \n6 S6_IMR IR2(S6_INT) Interrupt Mask \n5 S5_IMR IR2(S5_INT) Interrupt Mask \n4 S4_IMR IR2(S4_INT) Interrupt Mask \n3 S3_IMR IR2(S3_INT) Interrupt Mask \n2 S2_IMR IR2(S2_INT) Interrupt Mask \n1 S1_IMR IR2(S1_INT) Interrupt Mask \n0 S0_IMR IR2(S0_INT) Interrupt Mask \n \nRTR (Retry Time-value Register) [R/W] [0x0017 – 0x0018] [0x07D0] It configures the retransmission timeout-period. The standard unit of RTR is 100us. RTR is initialized with 2000(0x07D0) and has 200ms timeout-period.  \nEx) When timeout-period is set as 400ms, RTR = (400ms / 1ms) X 10 = 4000(0x0FA0) \n0x0017 0x0018 \n0x0F 0xA0 \nRe-transmission will occu r if there is no response from the remote peer to the commands of \nCONNECT , DISCON, CLOSE, SEND, SEND_MAC and SEND_KEEP , or the response is delayed.  \n RCR (Retry Count Register) [R/W] [0x0019] [0x08] It configures the number of retransmission time s. When retransmission occurs as many as \n‘RCR+1’ times, Timeout interrupt is set (‘TIMEOUT’ bit of Sn_IR is set as ‘1’). \nIn case of using TCP communication, the value  of Sn_SR (Socket n Status Register) is \nchanged to ‘SOCK_CLOSED’ and Sn_IR(Socket n Status Register) (TIMEOUT) turns into ‘1’. \nIn case of not using TCP communication, only Sn_IR(TIMEOUT) turns into ‘1’. \nEx) RCR = 0x0007 \n \n0x0019 \n0x07 \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n20 \niEthernet  W5200 The timeout of W5200 can be configurable with RTR and RCR. W5200’s timeout has Address \nResolution Protocol (ARP) and TCP retransmission timeout.  At the ARP (Refer to RFC 826, http://www.ietf.org/rfc.html ) retransmission timeout, W5200 \nautomatically sends ARP-request to the peer’s IP address in order to acquire MAC address \ninformation (used for communication of IP , UDP , or TCP). As waiting for ARP-response from the \npeer, if there is no response during the time se t in RTR, Timeout occurs and ARP-request is re-\ntransmitted. It is repeated as many as ‘RCR + 1’ times.  Even after ARP-request retransmissions are repe ated ‘RCR + 1’ times, if there is no ARP-\nresponse, the final timeout occurs  and Sn_IR(TIMEOUT) becomes ‘1’. \nThe value of final timeout (ARP\nTO) of ARP-request is as below. \nAt the TCP packet retransmission timeout, W52 00 transmits TCP packets (SYN, FIN, RST , DATA \npackets) and waits for the acknowledgement (ACK) during the time set in RTR and RCR. If there \nis no ACK from the peer, Timeout occurs and TC P packets (sent earlier) are retransmitted. The \nretransmissions are repeated as many as ‘RCR + 1’ times. Even after TCP packet retransmissions \nare repeated ‘RCR +1’ times, if there is no ACK from the peer, final timeout occurs and Sn_SR \nis changed to ‘SOCK_CLOSED” at the sa me time with Sn_IR(TIMEOUT) = ‘1’ \n \nEx) When RTR = 2000(0x07D0), RCR = 8(0x0008), \nARP TO = 2000 X 0.1ms X 9 = 1800ms = 1.8s \nTCP TO = (0x07D0 + 0x0FA0 + 0x1F40 + 0x3E80 + 0x7D00 + 0xFA00 + 0xFA00 + 0xFA00 + 0xFA00) X 0.1ms  \n     = (2000 + 4000 + 8000 + 16000 + 32000 + ((8 - 4) X 64000)) X 0.1ms      = 318000 X 0.1ms = 31.8s  The value of final timeout (TCP\nTO) of TCP packet retransmission can be calculated as below, \n \nPATR (Authentication Type in PPPoE mode) [R] [0x001C-0x001D] [0x0000] \nThis register notifies authentication method that  has been agreed at the connection with PPPoE \nServer. W5200 supports two types of Au thentication method - PAP and CHAP .  \nValue Authentication Type \n0xC023 PAP \n0xC223 CHAP \n M \nTCP TO = (  Σ(RTR X 2N )  + ((RCR-M) X RTR MAX)  ) X 0.1ms \n                 N=0 \nN     :  Retransmission count,  0 <= N <= M \nM     :  Minimum value when RTR X 2(M+1) > 65535 and 0 <= M <= RCR \nRTR MAX :  RTR X 2M ARP TO =(RTR X 0.1ms ) X ( RCR + 1 ) \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n21 \niEthernet  W5200 PPPALGO(Authentication Algorithm in  PPPoE mode)[R][0x001E][0x00] \nThis register notifies authentication algorithm in PPPoE mode. For detailed information, please \nrefer to PPPoE application note.  VERSIONR (W5200 Chip Version Register)[R][0x001F][0x03] This register is the W5200 chip version register.   PTIMER (PPP Link Control Protocol Request Timer Register) [R/W] [0x0028]  This register indicates the duration for sending LCP Echo Request. Value 1 is about 25ms. \nEx) in case that PTIMER is 200,    200 * 25(ms) = 5000(ms) = 5 seconds \n PMAGIC (PPP Link Control Protocol Magi c number Register) [R/W] [0x0029][0x00] \nThis register is used in Magic number option during LCP negotiation. Refer to the application \nnote, “How to connect ADSL” . \n \nINTLEVEL (Interrupt Low Level Timer Register)[R/W][0x0030 – 0x0031][0x0000] \nIt sets Interrupt Assert wait time (I AWT). It configures INTn Low Assert waiting time until \nthe next interrupt.  \nIAWT = (INTLEVEL + 1) * PLL_CLK1 (when INTLEVEL > 0) \n \nFigure 5 INTLEVEL Timing \na. At SOCKET 0, Receive Timeout Interrupt occurs  (S0_IR(3) = ‘1’) and corresponding IR2 bit is \nset as ‘1’ (IR(S0_IR) = ‘1’). INTn signal is asserted low. \nb. At SOCKET 1, Connected Interrupt occurs (S1_I R(0) = ‘1’) and corresponding IR2 bit set as ‘1’ \n(IR2(S1_IR) = ‘1’). \nc. The Host clears S0_IR(S0_IR = 0x00) and co rresponding IR2 bit is automatically cleared \n(IR2(S0_IR) = ‘0’). INTn signal becomes High. \n                                                 \n \n1 PLL_CLK is 125MHz \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n22 \niEthernet  W5200 d. S0_IR is cleared. As IR2 is not 0x00, INTn sho uld be asserted low right after 1PLL_CLK. However, \nas INTLEVEL is 0x000F , the interr upt about IR is processed after I AWT(16 PLL_CLK). \nIR2(W5200 SOCKET Interrupt Register)[R/W][0x0034][0x00] IR2 is the Register to notify W5200 SOCKET inte rrupt to the Host. If any interrupt occurs, the \nrelated bit of IR2 is set as ‘1’. When related Mask Bit is ‘1’, INTn signal is asserted low . INTn keeps low until all bits of Sn_I R becomes ‘0’. If all bits of Sn_IR become ‘0’, it becomes high \nautomatically.  \n7 6 5 4 3 2 1 0 \nS7_INT \nS6_INT S5_INT  S4_INT S3_INT S2_INT S1_INT S0_INT \n \nBit Symbol Description \n7 S7_INT When an interrupt occurs at SOCKET 7 , it becomes ‘1’. This interrupt \ninformation is applied to S7_IR. This bit is automatically cleared when S7_IR is cleared to 0x00 by host. \n6 S6_INT When an interrupt occurs at SOCKET 6 , it becomes ‘1’. This interrupt \ninformation is applied to S6_IR. This bit is automatically cleared when S6_IR is cleared to 0x00 by host. \n5 S5_INT When an interrupt occurs at SOCKET 5 , it becomes ‘1’. This interrupt \ninformation is applied to S5_IR. This bit is automatically cleared when S5_IR is cleared to 0x00 by host. \n4 S4_INT When an interrupt occurs at SOCKET 4 , it becomes ‘1’. This interrupt \ninformation is applied to S4_IR. This bit is automatically cleared when S4_IR is cleared to 0x00 by host. \n3 S3_INT When an interrupt occurs at SOCKET 3 , it becomes ‘1’. This interrupt \ninformation is applied to S3_IR. This bit is automatically cleared when S3_IR is cleared to 0x00 by host. \n2 S2_INT When an interrupt occurs at SOCKET 2 , it becomes ‘1’. This interrupt \ninformation is applied to S2_IR. This bit is automatically cleared when S2_IR is cleared to 0x00 by host. \n1 S1_INT When an interrupt occurs at SOCKET 1 , it becomes ‘1’. This interrupt \ninformation is applied to S1_IR. This bit is automatically cleared when S1_IR is cleared to 0x00 by host. \n0 S0_INT When an interrupt occurs at SOCKET 0 , it becomes ‘0’. This interrupt \ninformation is applied to S0_IR. This bit is automatically cleared when S0_IR is cleared to 0x00 by host. \n  \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n23 \niEthernet  W5200 PHYSTATUS(W5200 PHY status Register)[R/W][0x0035][0x00] \nPHYSTATUS is the Register to indicate W5200 status of PHY .  \nBit Symbol Description \n7 Reserved Reserved \n6 Reserved Reserved \n5 LINK Link Status Register[Read Only] \nThis register indicates Link status. 0 : Link down 1 : Link Up \n4  Power save mode of PHY[Read/Write]2 \n0 : Disable Power save mode(operates normal mode) \n1 : Enable Power save mode \n3 POWERDOWN Power down mode of PHY[Read/Write] \nThis register indicates status of Power down mode 0 : Disable Power down mode(operates normal mode) 1 : Enable Power down mode \n2 Reserved Reserved \n1 Reserved Reserved \n0 Reserved Reserved \n \nIMR2 (Socket Interrupt Mask Register2) [R/W] [0x0036] [0x00] The IMR2(Socket Interrupt Mask Register) is used  to mask interrupts. Each interrupt mask bit \ncorresponds to a bit in the Interrupt Register (IR ). If an interrupt mask bit is set, an interrupt \nwill be issued whenever the corresponding bit in the IR  is set. If any bit in the IMR2 is set as ‘0’, \nan interrupt will not occur though the bit in the IR is set.   \n7 6 5 4 3 2 1 0 \nIM_IR7 \nReserved  IM_IR5 Reserved  Reserved  Reserved  Reserved Reserved  \n \nBit Symbol Description \n7 IM_IR7 IP Conflict Enable \n6 Reserved Reserved   \n5 IM_IR5 PPPoE Close Enable \n4 Reserved Reserved  \n                                                 \n \n2 In this mode, the amplitudes of 10Mbps NLP and FLP will be reduced 3/8 off. And this kind of power \nsave is only for system level not chip level. This  mode is only for 10Mbps mode and the special link-\npartner which can accept this  kind of link-pulse. If link-partner do not support this kind of link-pulse, we \nrecommend disabling the power save mode. The default value of power save mode is ‘1’. \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n24 \niEthernet  W5200 3 Reserved Reserved  \n2 Reserved Reserved  \n1 Reserved Reserved  \n0 Reserved Reserved  \n \n \n4.2 Socket Registers \nSn3_MR (Socket n Mode Register) [R/W] [0x4000+0x0n00] [0x00]4 \nThis register sets up socket option or protocol type for each socket.  \n7 6 5 4 3 2 1 0 \nMULTI MF ND / MC  P3 P2 P1 P0 \n \nBit Symbol Description \n7 MULTI Multicasting \n0 : disable Multicasting 1 : enable Multicasting It is applied only in case of UDP . For using multicasting, write multicast group address to Socket n\n \nDestination IP and multicast group port number to Socket n  Destination Port Register, before OPEN command. \n6 MF MAC Filter \n0 : Disable MAC filter \n1 : Enable MAC filter \nIt is used in MACR AW (P3~P0: “0100”). \nWhen this bit is set as ‘1’, W5200 can receive packet that is belong in \nitself or broadcasting. When this bi t is set as ‘0’, W5200 can receive all \npackets on Ethernet. When using the hybrid TCP/IP stack, it is \nrecommended to be set as ‘1’ for reducing the receiving overhead of \nhost. \n5 ND/MC Use No Delayed ACK  \n0 : Disable No Delayed ACK option 1 : Enable No Delayed ACK option, This only applies to TCP case (P3-P0 : “0001”) If this bit is set as ‘1’, ACK packet is immediately transmitted after receiving data packet from a peer. If this bit is cleared, ACK packet is transmitted according to internal timeout mechanism. \n                                                 \n \n3n is Socket n-thumber (0, 1, 2, 3, 4, 5, 6, 7). \n4[Read/Write] [address of socket 0, address of socket 1,  address of socket 2, address of socket 3,address of \nsocket 4, address of socket 5, address of so cket 6, address of socket 7] [Reset value] \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n25 \niEthernet  W5200 Multicast \n0 : using IGMP version 2 1 : using IGMP version 1 This bit is valid when MULTI bit is enabled and UDP mode is used (P3-P0 : “0010”). In addition, multicast can be used to send out the version \nnumber in IGMP messages such as Join/Leave/Report to multicast-group\n \n4 Reserved Reserved \n3 P3 Protocol \nSets up corresponding socket as TCP , UDP , or IP RAW mode \nP\n3 P\n2 P\n1 P\n0 Meaning \n0 0 0 0 Closed \n0 0 0 1 TCP \n0 0 1 0 UDP \n0 0 1 1 IPRAW \n \n* In case of socket 0, MA CRAW and PPPoE mode exist. \nP\n3 P\n2 P\n1 P\n0 Meaning \n0 1 0 0 MACRAW \n0 1 0 1 PPPoE \nS0_MR_MACRAW and S0_MR_PPPoE are valid only in SOCKET 0. \nS0_MR_PPPoE is temporarily used for PPPoE server connection/Termination. After connect ion is established, it can be \nutilized as another protocol. 2 P2 \n1 P1 \n0 P0 \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n26 \niEthernet  W5200 Sn_CR (Socket n Command Register) [R/W] [0x4001+0x0n00] [0x00] \nThis is used to set the command for Socket n  such as OPEN, CLOSE, CONNECT , LISTEN, SEND, \nand RECEIVE. After W5200 identifies the command,  the Sn_CR register is automatically cleared \nto 0x00. Even though Sn_CR is cleared to 0x00, the command is still being processed. To verify \nwhether the command is completed or not, pl ease check the Sn_IR or Sn_SR registers. \nValue Symbol Description \n0x01 OPEN Socket n  is initialized and opened a ccording to the protocol selected in \nSn_MR (P3:P0). The table below shows the value of Sn_SR corresponding \nto Sn_MR   \nSn_MR(P3:P0) Sn_SR \nSn_MR_CLOSE (0x00) - \nSn_MR_TCP (0x01) SOCK_INIT (0x13) \nSn_MR_UDP (0x02) SOCK_UDP (0x22) \nSn_MR_IPRAW (0x03) SOCK_IPRAW (0x32) \nS0_MR_MACRAW (0x04) SOCK_MACRAW (0x42) \nS0_MR_PPPoE (0x05) SOCK_PPPoE (0x5F) \n \n0x02 LISTEN This is valid only in TCP mode (Sn_MR( P3:P0) = Sn_MR_TCP). In this mode, \nthe Socket n  is configured as a TCP server which is waiting for connection-request (SYN packet) from  any “TCP CLIENT”. The Sn_SR \nregister changes the state from SOCK_INIT to SOCKET_LISTEN. When a client’s connection request is  successfully established, the Sn_SR \nchanges from SOCK_LISTEN to SO CK_ESTABLISHED and the Sn_IR(0) \nbecomes ‘1’. On the other hand, Sn_IR( 3) is set as ‘1’ and Sn_SR changes \nto SOCK_CLOSED during a connectio n failure(SYN/ACK packet failed to \ntransfer) cf> If the destination port of the TCP Client does not exist during a connection request, W5200 will tran smit a RST packet and Sn_SR is \nunchanged. \n0x04 CONNECT This mode is only valid in TCP mode and operates the Socket n  as a TCP \nclient.A connect-request (SYN packet) is sent to the TCP server by connecting to the IP address and port stored in destination address and port registers (Sn_DIPR0 and Sn_DPORT0)      When a client’s connection request is  successfully established, the Sn_SR \nregister is changed to SOCK_ESTABLISHED and the Sn_IR(0) becomes ‘1’.In the following cases, th e connect-request fails  When a ARPTO occurs \n(Sn_IR(s)=‘1’) because the Destination Hardware Address is not acquired \nthrough the ARP process When a SYN/ACK packet is not re ceived and TCPTO(Sn_IR(3)) is’1’ \nWhen a RST packet is received instead of a SYN/ACK packet \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n27 \niEthernet  W5200 Above three cases, Sn_SR is changed to SOCK_CLOSED. \n0x08 DISCON Only valid in TCP mode \nRegardless of “TCP SERVER” or “TCP CLIENT”, this disconnect command  \nprocesses the Active close : it transmits disconnect-request(FIN packet) to the \nconnected peer Passive close : When FIN packet is received from peer, a FIN packet is \nreplied back to the peer when FIN/ACK packet is received, Sn_SR is changed to SOCK_CLOSED. \nWhen a disconnect request is not re ceived, TCPTO occu rs (Sn_IR(3)=’1’) \nand Sn_SR is change d to SOCK_CLOSED. \ncf> If CLOSE is used instead of DISCON, only Sn_SR is changed to SOCK_CLOSED without disconnect-pro cess(disconnect-request). If a RST \npacket is received from a peer during communication, Sn_SR is unconditionally changed to SOCK_CLOSED. \n0x10 CLOSE Closes Socket n . \nSn_SR is changed to SOCK_CLOSED. \n0x20 SEND SEND transmits all the data buffered in the TX memory. For more details, \nplease refer to Socket n  TX Free Size Register (Sn_TX_FSR0), Socket n  \nTX Write Pointer Register(Sn_TX_WR0) , and Socket n  TX Read Pointer \nRegister(Sn_TX_RD0). \n \n0x21 SEND_MAC  Used in UDP mode only \nThe basic operation is same as SE ND. Normally SEND operation needs \nDestination Hardware Address which can be retrieved by the ARP (Address \nResolution Protocol) process. SEND_M AC uses Socket n  Destination \nHardware Address(Sn_DHAR0) that is chosen by the user without going \nthrough the ARP process. \n0x22 SEND_KEEP  Used in TCP mode \nIt checks the connection status by sending 1byte data. If the connection \nhas no response from peers or is terminated, the Timeout interrupt will \noccur. \n0x40 RECV RECV processes the data received by using a RX read pointer \nregister(Sn_RX_RD). \nFor more detail, please refer to 5. 2.1.1 SERVER mode Receiving Process \nwith Socket n  RX Received Size Register (Sn_RX_RSR0), Socket n  RX \nWrite Pointer Register(Sn_RX_WR), and Socket n  RX Read Pointer \nRegister(Sn_RX_RD). \nBelow commands are only valid for SOCKET 0 and S0_MR(P3:P0) = S0_MR_PPPoE. For \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n28 \niEthernet  W5200 more detail refer to the “How to use ADSL”. \nValue Symbol Description \n0x23 PCON PPPoE connection begins by transmitting PPPoE discovery packet \n0x24 PDISCON Closes PPPoE connection \n0x25 PCR In each phase, it transmits REQ message. \n0x26 PCN In each phase, it transmits NAK message. \n0x27 PCJ In each phase, it transmits REJECT message. \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n29 \niEthernet  W5200 Sn_IR (Socket n Interrupt Register) [R] [0x4002+0x0n00] [0x00]  \nSn_IR register provides information such as the type of interrupt (establishment, termination, \nreceiving data, timeout) used in Socket n. When an interrupt occurs and the mask bit of Sn_IMR \nis ‘1’, the interrupt bit of Sn_IR becomes ‘1’. \nIn order to clear the Sn_IR bit,  the host should write the bit as ‘1’. When all the bits of \nSn_IR is cleared (‘0’), IR( n) is automatically cleared.  \n  \n7 6 5 4 3 2 1 0 \nPRECV  PFAIL  PNEXT  SEND_OK  TIMEOUT  RECV DISCON CON \n \nBit Symbol Description \n7 PRECV Sn_IR(PRECV) Interrupt  \nValid only in case of \'SOCKET=0\' and \'S0_MR(P3:P0)=S0_MR_PPPoE\' \nPPP Receive Interrupts when the option which is not supported is \nreceived \n6 PFAIL Sn_IR(PFAIL) Interrupt  \nValid only in case of \'SOCKET= 0\' & \'S0_MR(P3:P0)=S0_MR_PPPoE\' \nPPP Fail Interrupts when PAP Authentication is failed \n5 PNEXT Sn_IR(PNEXT) Interrupt  \nValid only in case of \'SOCKET= 0\' & \'S0_MR(P3:P0)=S0_MR_PPPoE\' \nPPP Next Phase Interrupts when the phase is changed during ADSL \nconnection process \n4 SEND_OK  Sn_IR(SENDOK) Interrupt  \nSEND OK Interrupts when the SEND command is completed \n3 TIMEOUT  Sn_IR(TIMEOUT) Interrupt  \nTIMEOUT Interrupts when ARP TO or TCP TO occurs \n2 RECV Sn_IR(RECV) Interrupt  \nReceive Interrupts whenever data packet is received from a peer \n1 DISCON Sn_IR(DISCON) Interrupt  \nDisconnect Interrupts when FIN of FIN/ACK packet is received from a \npeer \n0 CON Sn_IR(CON) Interrupt  \nConnect Interrupts when a connect ion is established with a peer \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n30 \niEthernet  W5200 Sn_SR (Socket n Status Register) [R] [0x4003+0x0n00] [0x00] \nThis register provides the status of Socket n . SOCKET status are changed when using the Sn_CR \nregister or during packet tran smission/reception. The table below describes the different states \nof Socket n .  \n \nValue Symbol Description \n0x00 SOCK_CLOSED It is the status that re source of SOCKETn is released. When \nDISCON or CLOSE command is performed, or ARP TO, or \nTCP TO occurs, it is changed to SOCK_CLOSED regardless of \nprevious value. \n0x13 SOCK_INIT It is shown in case that S n_MR is set as TCP and OPEN \ncommands are given to S n_CR. It is changed to SOCK_INIT \nwhen Sn_MR (P3:P0) is Sn_M R_TCP and OPEN command is \nperformed. It is the initial step of TCP connection establishment. It is possible to perform LISTEN command at the "TCP SERVER" mode and CONNECT command at the "TCP CLIENT". It is the status that SOCKETn operates as "TCP SERVER" and waits for connect-request (SYN packet) from "TCP CLIENT".\n \n0x14 SOCK_LISTEN Socket n  operates in  TCP Server Mode and waits for a \nconnection-request (SYN pack et) from a “TCP CLIENT”. \nWhen the LISTEN command is used, the stage changes to SOCK_LISTEN Once the connection is established, the SOCKET state changes from SOCK_LISTEN to SOCK_ESTABLISHED; however, if the connection fails, TCP\nTO occurs \n(Sn_IR(TIME_OUT) = ‘1’) and the state changes to SOCK_CLOSED. \n0x17 SOCK_ESTABLISHED It is shown in case that connection is established. It is \nchanged to SOCK_ESTABLISHED when SYN packet from “TCP CLIENT” is succes sfully processed at the \nSOCK_LISTEN, or CONNECTS command is successfully \nperformed. At this status, DATA packet can be transferred, that is, SEND or RECV command can be performed. \n0x1C SOCK_CLOSE_WAIT It is the status that disco nnect-request (FIN packet) is \nreceived from the peer As TCP connection is half-closed, it \nis possible to transfer data packet. In order to complete \nthe TCP disconnection, DISCON command should be \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n31 \niEthernet  W5200 performed.  \nFor SOCKETn close without disconnection-process, CLOSE \ncommand should be just performed. \n0x22 SOCK_UDP It is the status that SOCKETn is open as UDP mode. It is \nchanged to SOCK_UDP when Sn_MR(P3:P0) is Sn_MR_UDP \nand OPEN command is performed. DATA packet can be \ntransferred without connection that is necessary to TCP \nmode SOCKET . \n0x32 SOCK_IPRAW The socket is opened in IPRAW mode. The SOCKET status is \nchange to SOCK_IPRAW when Sn_MR (P3:P0) is \nSn_MR_IPRAW and OPEN command is used. IP Packet can \nbe transferred without a connection similar to the UDP \nmode. \n0x42 SOCK_MACRAW It is changed to SOCK_MACRAW in case of S0_CR=OPEN and \nS0_MR (P3:P0)=S0_MR_MACRAW. MACRAW packet (Ethernet \nframe) can be transferred similar to UDP mode. \n0x5F SOCK_PPPOE It is the status that SOCKET0 is open as PPPoE mode. It is \nchanged to SOCK_PPPoE in case of S0_CR=OPEN and S0_MR \n(P3:P0)=S0_MR_PPPoE . It is temporarily used at the PPPoE \nconnection. \nBelow is shown during changing the status. \nValue Symbol Description \n0x15 SOCK_SYNSENT This status indicates that a connect-request (SYN packet) \nis sent to a "TCP SERVER". This status shows changing process from SOCK_INIT to SOCK_ESTABLISHED by CONNECT command. At this status, if connect-accept (SYN/ACK packet) is received from "TCP SERVER", it is automatically changed to SOCK_ ESTBLISHED. If SYN/ACK packet is not \nreceived from the "TCP SERVER" before TCPTO occurs (Sn_IR(TIMEOUT)=‘1’), it is changed to SOCK_CLOSED. \n0x16 SOCK_SYNRECV This status indicate that a connect-request(SYN packet) is \nreceived from a "TCP CLIENT".  It is automatically changed to SOCK_ESTABLISHED when W5200 successfully transmits \nconnect-accept (SYN/ACK packet) to the "TCP CLIENT". If \nit is failed, TCPTO occurs (Sn _IR(TIMEOUT)=‘1’), and it is \nchanged to SOCK_CLOSED \n0x18 SOCK_FIN_WAIT These status shows that So cket n  is closed. It is observed \nin the disconnect-process of active close or passive close. 0x1A SOCK_CLOSING \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n32 \niEthernet  W5200 0X1B SOCK_TIME_WAIT It is changed to SOCK_C LOSED, when disconnect-process is \nsuccessfully finished or TC PTO occurs (Sn_IR (TIMEOUT) \n=‘1’). \n0X1D SOCK_LAST_ACK In case of Passive closing,this status indicate that W5200 \nwaits ACK for FIN packet. It is changed to SOCK_ CLOSED, when Timeout Interrupt occurs (Sn_IR(TIMEOUT)=‘1\'). \n0x01 SOCK_ARP This status indicates that ARP-request is transmitted in \norder to acquire destination ha rdware address. This status \nis observed when SEND command is performed at the SOCK_UDP or SOCK_IPRAW, or CONNECT command is performed at the SOCK_INIT .  If hardware address is successfully acquired from destination (when ARP-response is received), it is changed \nto SOCK_UDP , SOCK_IPRAW or SOCK_SYNSENT . If it\'s failed \nand ARPTO occurs (Sn_IR(TIMEOU T)=‘1’), in case of UDP or \nIPRAW mode it goes back to the previous status(the SOCK_UDP or SOCK_IPRAW), in case of TCP mode it goes to the SOCK_CLOSED. cf> ARP-process oper ates at the SOCK_UDP or SOCK_IPRAW \nwhen the previous and current values of Sn_DIPR are different. If the previous and current values of Sn_DIPR are same, ARP-process doesn’ t operate because the \ndestination hardware address is already acquired. \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n33 \niEthernet  W5200  \n \nFigure 6 Socket Status Transition \nSn_PORT (Socket n Source Port Register) [R/W] [0x4004+0x0n00-0x4005+0x0n00] \n[0x0000] \nThis register sets the Source Port number for each Socket when using TCP or UDP mode, and \nthe set-up needs to be made before executing the OPEN command. Ex) In case of Socket 0 Port = 5 000(0x1388), config ure as below, \n0x4004 0x4005 \n0x13 0x88 \n \nSn_DHAR (Socket n Destination Hardware Address Register) [R/W] [0x4006+0x0n00-\n0x400B+0x0n00] [0xFFFFFFFFFFFF] \nIt sets or is set as destination hardware address of Socket n . Also, if SOCKET 0 is used for PPPoE \nmode, S0_DHAR sets as PPPoE server hardware an address that is already known. When using SEND_MAC command at the UDP or IP RAW mode, it sets the destination hardware \naddress of Socket n . At the TCP , UDP and IPRAW mode, Sn_DHAR is set as destination hardware \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n34 \niEthernet  W5200 address that is acquired by ARP-process of CO NNECT or SEND command. The host can acquire \nthe destination hardware address through Sn_D HAR after successfully performing CONNET or \nSEND command. When using PPPoE-process of W5200, PPPoE server hardware address is not required to be set. However, even if PPPoE-process of W5200 is not used, but implemented by yourself with \nMACRAW mode, in order to transmit or receive the PPPoE packet, PPPoE server hardware address(acquired by your PPPoE-process), PPPoE server IP address, and PPP session ID should be set, and MR(PPPoE) also should be set as \'1\'.  \nS0_DHAR sets the PPP oE server hardware address before the OPEN command. PPP oE server hardware address which is set by S0_DHAR is  applied to PDHAR after performing the OPEN \ncommand. The configured PPPoE information is in ternally valid even after the CLOSE command. \nEx) In case of Socket 0 Destination Hardware  address = 08.DC.00.01.02.10, configuration is \nas below, \n0x4006 0x4007 0x4008 0x4009 0x400A 0x400B \n0x08 0xDC 0x00 0x01 0x02 0x0A \n \nSn_DIPR (Socket n Destination IP Address Register)[R/W][0x400C+0x0n00 0x400F+0x0n00] \n[0x00000000] It sets or is set as destination IP address of Socket n . If SOCKET0 is used as PPPoE mode, S0_DIPR sets PPPoE server IP address that is already known.  It is valid only in TCP , UDP , IPRAW or PPPoE \nmode, but ignored in MACRAW mode. At the TCP mode, when operating as "TCP CLIENT" it sets as IP address of "TCP SERVER" before performing CONNECT command and when operating as "TCP SERVER", it is internally set as IP addre ss of "TCP CLIENT" after successfully establishing \nconnection. At the UDP or IPRAW mode, Sn_DIPR sets as destin ation IP address to be used for transmitting \nUDP or IPRAW DATA packet before perf orming SEND or SEND_MAC command.  \n Ex) In case of Socket 0 Destination IP ad dress = 192.168.0.11, configure as below. \n0x400C 0x400D 0x400E 0x400F \n192 (0xC0) 168 (0xA8) 0 (0x00) 11 (0x0B) \n \nSn_DPORT (Socket n Destination Port Re gister)[R/W][0x4010+0x0n00-0x4011+0x0n00] \n[0x00] The destination port number is set in the Sn_DPORT  of Socket n . If SOCKET 0 is used as PPPoE \nmode, S0_DPORT0 sets PPP session ID that is alread y known. It is valid only in TCP , UDP or PPPoE \nmode, and ignored in other modes.  At the TCP mode, when operating as "TCP CLIENT",  it listens for the port number of the "TCP \nSERVER" before performing the CONNECT command.  At the UDP mode, the destination port number is se t in the Sn_DPORT to be used for transmitting \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n35 \niEthernet  W5200 UDP DATA packets before performing  SEND or SEND_MAC command.  \nAt the PPPoE mode, the PPP session ID that is al ready known is set in the S0_DPORT . PPP session \nID (set by S0_DPORT0) is applied to PS IDR after performing the OPEN command. \nEx) In case of Socket 0 Destination Port = 5000(0x1388), configure as below, \n0x4010 0x4011 \n0x13 0x88 \n \nSn_MSS (Socket n Maximum Segment Size Register)[R/W][0x4012+0x0n00-0x4013+0x0n00] \n[0x0000]  This register is used for MSS (Maximum Segment Size) of TCP , and the register displays MSS set \nby the other party when TCP is activated in Pa ssive Mode. It just supports TCP or UDP mode. \nWhen using PPPoE (MR(PPPoE)=‘1’), the MTU of TC P or UDP mode is assigned in the range of \nMTU of PPPoE.  \nMode Normal (MR(PPPoE)=‘0’) PPPoE  (MR(PPPoE)=‘1’) \nDefault \nMTU Range Default \nMTU Range \nTCP 1460 1 ~ 1460 1452 1 ~ 1452 \nUDP 1472 1 ~ 1472 1464 1 ~ 1464 \nIPRAW 1480 1472 \nMACRAW 1514 \n At the IPRAW or MACRAW, MTU is not processed internally, but default MTU is used. Therefore, \nwhen transmitting the data bigger than default MTU, the host should manually divide the data \ninto the unit of default MTU. At the TCP or UDP mode, if transmitting data is bigger than MTU, W52 00 automatically divides \nthe data into the unit of MTU. MTU is called as  MSS at the TCP mode. By selecting from Host-\nWritten-Value and peer\'s MSS, MSS is set as smaller value through TC P connection process. \n Ex) In case of Socket 0 MSS = 1 460(0x05B4), configure as below, \n0x4012 0x4013 \n0x05 0xB4 \n \nSn_PROTO (Socket n IP Protocol Register) [R/W] [0x4014+0x0n00] [0x00] \nIt is a 1 byte register that sets  the protocol number field of the IP header at the IP layer. It is \nvalid only in IPRAW mode, and ignored in other modes. Sn_PROTO is set before OPEN command. When Socket n  is opened in IPRAW mode, it transmits and receives the data of the protocol number set in Sn_PROTO. Sn_PROTO can be assigned in the range of 0x00 ~ 0xFF , but W5200 does not support TCP(0x06) and UDP(0x11) protocol number Protocol number is defined in IANA(Internet assigned numbers authority). For the detail, refer to online document (\nUhttp://www.iana.org/assignments/protocol-numbers U). \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n36 \niEthernet  W5200 Ex) Internet Control Message Protocol (ICMP) = 0x01, Internet Group Management Protocol = \n0x02   \nSn_TOS (Socket n IP Type Of Service Register) [R/W] [0x4015+0x0n00] [0x00] \nIt sets the TOS(Type of Service) field of the IP head er at the IP layer. It should be set before the \nOPEN command. Refer to \nUhttp://www.iana.org/assignments/ip-parameters U. \n \nSn_TTL (Socket n IP Time To Live Register) [R/W] [0x4016+0x0n00] [0x80] \nIt sets the TTL(Time T o Live) field of the IP header at the IP layer . It should be set before the OPEN command. Refer to \nUhttp://www.iana.org/assignments/ip-parameters U. \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n37 \niEthernet  W5200 Sn_RXMEM_SIZE(Socket n RX Memory Size Re gister) [R/W] [0x401E+0x0n00] [0x02] \nIt configures the internal RX Memory size of ea ch SOCKET . RX Memory size of each SOCKET is \nconfigurable in the size of 0, 1, 2, 4, 8, and 16 Kbytes. 2Kbytes is assigned when reset. \nSn_RXMEM_SIZE SUM(sum of Sn_RXMEM_SIZE) of ea ch SOCKET should be 16KB. \nValue 0x00 0x01 0x02 0x04 0x08 0x10 \nMemory size 0KB 1KB 2KB 4KB 8KB 16KB \n \nEx1) SOCKET 0 : 8KB, SOCKET 1 : 2KB \n0x401E 0x411E \n0x08 0x02 \nEx2) SOCKET 2 : 1KB, SOCKET 3 : 1KB \n0x421E 0x431E \n0x01 0x01 \nEx3) SOCKET 4 : 1KB, SOCKET 5 : 1KB \n0x441E 0x451E \n0x01 0x01 \nEx4) SOCKET 6 : 1KB, SOCKET 7 : 1KB \n0x461E 0x471E \n0x01 0x01 \n \nSn_TXMEM_SIZE(Socket n TX Memory size Register) [R/W][0x401F+0x0n00] [0x02] \nIt configures the internal TX Memory size of each SOCKET . TX Memory size of each SOCKET is configurable in the size of 0, 1, 2, 4, 8, and 16Kbytes. 2Kbytes is assigned when reset. \nSn_TXMEM_SIZE\nSUM(summation of Sn_TXMEM_SIZE) of  each SOCKET should be 16KB. \n \nEx1) SOCKET 0 : 4KB, SOCKET 1 : 1KB \n0x401F 0x411F \n0x04 0x01 \nEx2) SOCKET 2 : 2KB, SOCKET 3 : 1KB \n0x421F 0x431F \n0x02 0x01 \nEx3) SOCKET 4 : 2KB, SOCKET 5 : 2KB \n0x441F 0x451F \n0x02 0x02 \nEx4) SOCKET 6 : 2KB, SOCKET 7 : 2KB \n0x461F 0x471F \n0x02 0x02 \n \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n38 \niEthernet  W5200 Sn_TX_FSR (Socket n TX Free Size Register) [R] [0x4020+0x0n00-0x4021+0x0n00] [0x0800] \nIt notifies the available size of the internal TX  memory (the byte size of transmittable data) of \nSocket n . The host can’t write data as a size bigger than Sn_TX_FSR. Therefore, be sure to check Sn_TX_FSR before tran smitting data, and if your data size  is smaller than or the same as \nSn_TX_FSR, transmit the data with SEND or  SEND_MAC command after copying the data. \nAt the TCP mode, if the peer checks the tran smitted DATA packet (if DATA/ACK packet is \nreceived from the peer), Sn_TX_FSR is automatica lly increased by the size of that transmitted \nDATA packet. At the other modes, when Sn_IR (SENDOK) is ‘1’, Sn_TX_FSR is automatically \nincreased by the size of the transmitted data. When checking this register, user should read \nupper byte(0x4020, 0x4120, 0x4220, 0x4320, 0x4420, 0x4520, 0x4620, 0x4720) first and lower byte(0x4021, 0x4121, 0x4221, 0x4321, 0x4421, 0x4521, 0x4621, 0x4721) later to get the correct value.  \nEx) In case of 2048(0x0800) in S0_TX_FSR, \n0x4020 0x4021 \n0x08 0x00 \n \nSn_TX_RD (Socket n TX Read Pointer Register) [R] [0x4022+0x0n00-0x4023+0x0n00] [0x0000] This register shows the address of the last tran smission finishing in the TX memory. With the \nSEND command of Socket n  Command Register, it transmits data from the current Sn_TX_RD \nto the Sn_TX_WR and automatically updates after  transmission is finished. Therefore, after \ntransmission is finished, Sn_TX_ RD and Sn_TX_WR will have the same value. When reading this \nregister, user should read upper byte (0x4022, 0x4122, 0x4222, 0x4322, 0x4422, 0x4522,  0x4622, 0x4722) first, and lower byte (0x4023, 0x4123, 0x4223, 0x4323, 0x4423, 0x4523, 0x4623, \n0x4723) later to get the correct value.  Sn_TX_WR (Socket n TX Write Pointer Register) [R/W] [0x4024+0x0n00-0x4025+0x0n00] \n[0x0000] This register offers the location information to  write the transmission data. When reading this \nregister, user should read upper byte (0x4024, 0x4124, 0x4224, 0x4324, 0x4424, 0x4524, 0x4624, 0x4724) first, and lower byte (0x4025, 0x4125, 0x4225, 0x4325, 0x4425, 0x4525, 0x4625, 0x4725) later to get the correct value.  Caution: This register value is changed after the send command is successfully executed to \nSn_CR. \nEx) In case of 2048(0x0800) in S0_TX_WR, \n0x4024 0x4025 \n0x08 0x00 \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n39 \niEthernet  W5200 \n \nFigure 7 Physical Address Calculation \nBut this value itself is not the physical addre ss to read. So, the physical address should be \ncalculated as follow. 1. Socket n  TX Base Address (hereafter we\'ll call  gSn_TX_BASE)  and Socket n  TX Mask \nAddress (hereafter we\'ll call gSn_TX_MASK)  are calculated on TMSR value. Refer to the \npsedo code of the Initialization if detail is needed.  \n2. The bitwise-AND operation of two values, Sn_TX_WR and gSn_TX_MASK  give result to \nthe offset address(hereafter we\'ll call get_offset ) in TX memory range of the socket. \n3. Two values get_offset  and gSn_TX_BASE  are added together to give result tothe \nphysical address(hereafter,  we\'ll call get_start_address ). \nNow, write the transmission data to get_start_address  as large as you want. (* There\'s a case \nthat it exceeds the TX memory upper-bound of the socket while writing. In this case, write the \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n40 \niEthernet  W5200 transmission data to the upper-bound, an d change the physical address to the gSn_TX_BASE . \nNext, write the rest of the transmission data.) After that, be sure to increase the Sn_TX_WR value as much as the data size that indicate s the size of writing data. Finally, give SEND \ncommand to Sn_CR(Socket n  Command Register).  Refer to the psedo code of the transmission part on TCP Server mode if detail is needed.  Sn_RX_RSR (SOCKET n Received Size Register) [R] [0x4026+0x0n00-0x4027+0x0n00] [0x0000] It informs the user of the byte size of the receiv ed data in Internal RX Memory of Socket n . As \nthis value is internally calculated with th e values of Sn_RX_RD and Sn_RX_WR, it is \nautomatically changed by RECV command of Sock et n  Command Register (Sn_CR) and receives \ndata from the remote peer. When reading this register, user should read upper byte (0x4026, \n0x4126, 0x4226, 0x4326, 0x4426, 0x4526, 0x4626, 0x4726 ) first, and lower byte (0x4027, 0x4127, \n0x4227, 0x4327, 0x4427, 0x4527, 0x4627, 0x4727)  later to get the correct value. \nEx) In case of 2048(0x0800) in S0_RX_RSR, \n0x4026 0x04027 \n0x08 0x00 \nThe total size of this value can be decided according to the value  of RX Memory Size Register. \n Sn_RX_RD (Socket n RX Read Pointer Register) [R/W] [0x4028+0x0n00-0x4028+0x0n00] \n[0x0000] This register offers the location information to read the receiving data. When reading this \nregister, user should read upper byte (0x4028, 0x4128, 0x4228, 0x4328, 0x4428, 0x4528, 0x4628, 0x4728) first, and lower byte (0x4029, 0x4129, 0x4229, 0x4329, 0x4429, 0x4529, 0x4629, 0x4729) later to get the correct value. It has a random value as its initial value. \nCaution: This register value is changed after the SEND command is successfully executed to \nSn_CR. \nEx) In case of 2048(0x0800) in S0_RX_RD, \n0x4028 0x4029 \n0x08 0x00 \nBut this value itself is not the physical addre ss to read. So, the physical address should be \ncalculated as follow. 1. Socket n  RX Base Address (hereafter we\'ll call gSn_RX_BASE)  and Socket n  RX Mask \nAddress (hereafter we\'ll call gSn_RX_MASK)  are calculated on RMSR value. Refer to the \npseudo code of the 5.1 Initialization if the detail is needed.  \n2. The bitwise-AND operation of two values, Sn_RX_RD and gSn_RX_MASK  give result the \noffset address(hereafter we\'ll call get_offset) , in RX memory range of the socket. \n3. Two values get_offset  and gSn_RX_BASE  are added together to give result the physical \naddress(hereafter,  we\'ll call get_start_address).  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n41 \niEthernet  W5200 Sn_RX_WR (Socket n RX Write Pointer Register)[R/W][(0x402A + 0x0n00) – (0x402B + \n0x0n00)][0x0000] \nThis register offers the location information to write the receive data. When reading this \nregister, the user should read upper bytes (0x402A, 0x412A, 0x422A, 0x432A, 0x442A, 0x452A, 0x462A, 0x472A) first and lower bytes (0x402B, 0x412B, 0x422B, 0x432B, 0x442B, 0x452B, 0x462B, 0x472B) later to get the correct value. \nEx) In case of 2048(0x0800) in S0_RX_WR, \n0x402A 0x402B \n0x08 0x00 \n \nSn_IMR (Socket n Interrupt Mask Register)[R/W][0x402C+0x0n00][0xFF] \nIt configures the interrupt of Socket n  so as to  notify to the host. Interrupt mask bit of Sn_IMR \ncorresponds to interrupt bit of Sn_IR. If interrupt occurs in any SOCKET and the bit is set as ‘1’, \nits corresponding bit of Sn_IR is set as ‘1’. Wh en the bits of Sn_IMR and Sn_IR are ‘1’, IR( n) \nbecomes ‘1’. At this time, if IMR( n) is ‘1’, the interrupt is issued to the host. (‘INTn’ signal is \nasserted low) \n7 6 5 4 3 2 1 0 \nPRECV  PFAIL  PNEXT  SEND_OK  TIMEOUT  RECV DISCON CON \n \nBit Symbol Description \n7 PRECV Sn_IR(PRECV) Interrupt Mask \nValid only in case of ‘SOCKET = 0’ & ‘S0_MR(P3:P0) = S0_MR_PPPoE’ \n6 PFAIL Sn_IR(PFAIL) Interrupt Mask \nValid only in case of ‘SOCKET = 0’ & ‘S0_MR(P3:P0) = S0_MR_PPPoE’ \n5 PNEXT Sn_IR(PNEXT) Interrupt Mask \nValid only in case of ‘SOCKET = 0’ & ‘S0_MR(P3:P0) = S0_MR_PPPoE’ \n4 SENDOK Sn_IR(SENDOK) Interrupt Mask \n3 TIMEOUT Sn_IR(TIMEOUT) Interrupt Mask \n2 RECV Sn_IR(RECV) Interrupt Mask \n1 DISCON Sn_IR(DISCON) Interrupt Mask \n0 CON Sn_IR(CON) Interrupt Mask \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n42 \niEthernet  W5200 Sn_FRAG (Socket n Fragment Register)[R/W][0x402D+0x0n00-0x402E+ x0n00][0x4000] \nIt sets the Fragment field of the IP header  at the IP layer. W5200 does not support the \npacket fragment at the IP layer. Even though Sn_FRAG is configured, IP data is not fragmented, and not recommended either. It should be configured before performing \nOPEN command. \nEx) Sn_FRAG0 = 0x4000 (Don’t Fragment) \n0x402D 0x402E \n0x40 0x00 \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n43 \niEthernet  W5200 5 Functional Descriptions \nBy setting some register and memory operatio n, W5200 provides internet connectivity.  \nThis chapter describes how it can be operated.  \n5.1 Initialization \n \nBasic Setting \nFor the W5200 operation, select and utilize appropriate registers shown below. \n1. Mode Register (MR) \n2. Interrupt Mask Register (IMR) \n3. Retry Time-value Register (RTR) \n4. Retry Count Register (RCR) \nFor more information of above registers,  refer to the “Register Descriptions.” \n \nSetting network information \nBasic network information setting for communication: \nIt must be set the basic network information.  \n① SHAR(Source Hardware Address Register) \nIt is prescribed that the source hardware addresses, which is set by SHAR, use unique \nhardware addresses (Ethernet MAC address) in the Ethernet MAC layer. The IEEE manages the MAC address allocation. The manufacturer which produces the network device allocates the MAC address to product. \nDetails on MAC address allocation refer to the website as below. \nUhttp://www.ieee.org/ U, Uhttp://standards.ieee.org/regauth/oui/index.shtml U \n② GAR(Gateway Address Register) \n \n③ SUBR(Subnet Mask Register) \n \n④ SIPR(Source IP Address Register) \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n44 \niEthernet  W5200 Set socket memory information \nThis stage sets the socket tx/rx memory inform ation. The base address and mask address of \neach socket are fixed and saved in this stage. \nIn case of, assign 2KB rx , tx memory per SOCKET \n{ \ngS0_RX_BASE = 0x0000(Chip base address) + 0xC000(Internal RX buffer address); // Set \nbase address of RX memory for SOCKET 0 \nSn_RXMEM_SIZE(ch) = (uint8 *) 2;  // Assign 2K rx memory per SOCKET \ngS0_RX_MASK = 2K – 1; // 0x07FF , for getting offset a ddress within assigned SOCKET 0 \nRX memory \ngS1_RX_BASE = gS0_RX_BASE + (gS0_RX_MASK + 1); \ngS1_RX_MASK = 2K – 1; \ngS2_RX_BASE = gS1_RX_BASE + (gS1_RX_MASK + 1); \ngS2_RX_MASK = 2K – 1; \ngS3_RX_BASE = gS2_RX_BASE + (gS2_RX_MASK + 1); \ngS3_RX_MASK = 2K – 1; \ngS4_RX_BASE = gS3_RX_BASE + (gS3_RX_MASK + 1); \ngS4_RX_MASK = 2K – 1; \ngS5_RX_BASE = gS4_RX_BASE + (gS4_RX_MASK + 1); \ngS5_RX_MASK = 2K – 1; \ngS6_RX_BASE = gS5_RX_BASE + (gS5_RX_MASK + 1); \ngS6_RX_MASK = 2K – 1; \ngS7_RX_BASE = gS6_RX_BASE + (gS6_RX_MASK + 1); \ngS7_RX_MASK = 2K – 1; \ngS0_TX_BASE = 0x0000(Chip base address) + 0x8000(InternalTX buffer address); // Set \nbase address of TX memory for SOCKET 0 \nSn_TXMEM_SIZE(ch) = (uint8 *) 2;  // Assign 2K rx memory per SOCKET \ngS0_TX_MASK = 2K – 1;  \n/* Same method, set gS1_TX_BASE, gS1_TX_MASK, gS2_TX_BASE, gS2_TX_MASK, \ngS3_TX_BASE, gS3_TX_MASK, gS4_TX_BASE, gS4_TX_MASK, gS5_TX_BASE, gS5_TX_MASK, \ngS6_TX_BASE, gS6_tx_MASK, gS 7_TX_BASE, gS7_TX_MASK */ \n} \n \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n45 \niEthernet  W5200 \n \nFigure 8 Allocation Internal TX/RX memory of Socket n  \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n46 \niEthernet  W5200 5.2 Data Communications \nAfter the initialization process, W5200 can tr ansmit and receive the data with others by \n‘open’  the SOCKET of TCP , UDP , IPRA W ,  and MACRAW mode. The W5200 supports the \nindependently and simultaneously usable 8 SO CKETS. In this section, the communication \nmethod for each mode will be introduced. \n \n5.2.1  TCP \nThe TCP is a connection-oriented protocol . The TCP make the connection SOCKET by \nusing its own IP address, port number and de stination IP address, port number. Then \ntransmits and receives the da ta by using this SOCKET . \nMethods of making the connection to SOCKET are “TCP SERVER” and “TCP CLIENT”. It is divided by transmitting the connect-request (SYN packet). \nThe “TCP SERVER” listens to the connect-re quest from the “TCP CLIENT”, and makes \nconnection SOCKET by accepting the tran smitted connect-request (Passive-open). \nThe “TCP CLIENT” transmits the connect-reque st first to “TCP SERVER” to make the \nconnection (Active-open).  \n \nFigure 9 TCP SERVER and TCP CLIENT \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n47 \niEthernet  W5200 5.2.1.1  TCP SERVER \n \n \nFigure 10 TCP SERVER Operation Flow  \n \n  SOCKET Initialization \nSOCKET initialization is required for TCP data communication. The initialization is \nopening the SOCKET . The SOCK ET opening process selects one SOCKET from 8 SOCKETS \nof the W5200, and sets the protocol mode (Sn_MR) and Sn_PORT0 which is source port \nnumber (Listen port number in “TCP SERVER”) in the selected SOCKET , and then executes OPEN command. After the OPEN command, if the status of Sn_SR is changed \nto SOCK_INIT , the SOCKET initia lization process is completed. \nThe SOCKET initialization process is iden tically applied in “TCP SERVER” and “TCP \nCLIENT .”The Initialization process of So cket n  in TCP mode is shown below. \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n48 \niEthernet  W5200 { \nSTART: \nSn_MR = 0x01;  // sets TCP mode  \nSn_PORT0 = source_port;        // sets source port number \nSn_CR = OPEN;   // sets OPEN command  \n/* wait until Sn_SR is changed to SOCK_INIT */ \nif (Sn_SR != SOCK_INIT) Sn _CR = CLOSE; goto START;  \n} \nLISTEN \nRun as “TCP SERVER” by LISTEN command. \n{ \n/* listen SOCKET */ \nSn_CR = LISTEN; \n/* wait until  Sn_SR is changed to SOCK_LISTEN */ \nif (Sn_SR != SOCK_LISTEN) Sn _CR = CLOSE; goto START; \n} \n \nESTABLISHMENT \nWhen the status of Sn_SR is SOCK_LISTEN, if it receives a SYN packet, the status of Sn_SR \nis changed to SOCK_SYNRECV and transmits the SYN/ACK packet. After that, the Socket \nn  makes a connection. After it makes the conn ection of Socket n , it enables the data \ncommunication. There are two methods to confirm the connection of Socket n . \nFirst method : \n{ \nif (Sn_IR(CON) == ‘1’)  \n/* When an interrupt occurs and the mask bit of Sn_IMR is ‘1’, the interrupt bit of Sn_IR \nbecomes ‘1’ */   \nSn_IR(CON) = ‘1’;  \n /*In order to clear the Sn_IR bit, the host should write the bit as ‘1’. When all the bits \nof Sn_IR is cleared (‘0’), IR(n) is automatically cleared.*/ \ngoto ESTABLISHED stage; \n/* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to IR, \nIMR Sn_IMR and Sn_IR. */ \n} \nSecond method : \n{ \nif (Sn_SR == SOCK_ESTABLISHED)  goto ESTABLISHED stage; \n} \nESTABLISHMENT : Check received data \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n49 \niEthernet  W5200 Confirm the reception of the TCP data. \nFirst method : \n{ \nif (Sn_IR(RECV) == ‘1’) Sn_IR(RECV) = ‘1’; goto Receiving Process stage; \n/* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to IR, \nIMR Sn_IMR and Sn_IR. */ \n} \nSecond Method : \n{ \n   if (Sn_RX_RSR0 != 0x0000) goto Receiving Process stage; \n} \nThe First method: set the Sn_IR( RECV) to ‘1’ whenever you re ceive a DATA packet. If the \nhost receives the next DATA packet without setting the Sn_IR(RECV) as ‘1’ in the prior \nDATA packet, it cannot recognize the Sn_IR(RE CV) of the next DATA packet. This is due \nto the prior Sn_IR(RECV) and next Sn_IR(RECV ) being overlapped. So this method is not \nrecommended if the host cannot perfectly proc ess the DATA packets of each Sn_IR(RECV). \n \nESTABLISHMENT : Receiving process \nIn this process, it processes the TCP data wh ich was received in the Internal RX memory. \nAt the TCP mode, the W5200 cannot receive the data if the size of received data is \nlarger than the RX memory free size of So cket n . If the prior stated condition is \nhappened, the W5200 holds on to the conne ction (pauses), and waits until the RX \nmemory’s free size is larger than  the size of the received data. \n{ \n/* first, get the received size */ \nlen = Sn_RX_RSR;    // len is received size \n/* calculate offset address */ \nsrc_mask = Sn_RX_RD&gSn_RX_MASK;    // src_mask  is offset address \n/* calculate start address(physical address) */ \nsrc_ptr = gSn_RX_BASE + src_mask;    // src_ptr  is physical start address \n \n/* if overflow SOCKET RX memory */ \nIf((src_mask + len) > (gSn_RX_MASK + 1)) \n{ \n/* copy upper_size  bytes of source_ptr  to destination_address  */ \nupper_size = (gSn_RX_MASK + 1) – src_mask; \nmemcpy(src_ptr, dst_ptr, upper_size); \n/* update destination_ptr  */ \ndst_address += upper_size; \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n50 \niEthernet  W5200 /* copy left_size  bytes of gSn_RX_BASE to destination_address  */ \nleft_size = len – upper_size; \nmemcpy(gSn_RX_BASE, dst_ address, left_size); \n} \nelse \n{ \ncopy len bytes of source_ptr  to destination_address  */ \nmemcpy(src_ptr, dst_ptr, len); \n} \n/* increase Sn_RX_RD as length of len */ \nSn_RX_RD += len; \n/* set RECV command */ \nSn_CR = RECV; \n} \n \nESTABLISHMENT: Check send data / Send process \nThe size of the transmit data cannot be larger than assigned internal TX memory of \nSocket n . If the size of transmit data is larg er than configured MSS, it is divided by size \nof MSS and transmits. To transmit the next da ta, user must check the completion of prior \nSEND command. An error may occur if the SE ND command executes before completion \nof prior SEND command. The larger the data size, the more time to complete the SEND \ncommand. So the user should properly divide the data to transmit. To check the completion of the SEND command , it should be check that the send data \nlength is equal with the actual sent data  length. The actual sent data length is \ncalculated by the difference of the Sn_TX_RD  before and after performing the SEND \ncommand. If the actual sent data is less th an the send data length, the SEND command \nis retried for sending the left data. The send process is therefore completed the \nSENDwhen the sum of the actu al sent data is equal the send data length. A simple \nexample of the send process is as below \nEx) Send Data Length Size= 10,  \n1) Execute SEND Command wi th send data length \n2) Calculate the actual sent data length  \nIf the actual sent data length is 7 (=  Sn_TX_RD_after_SEND-Sn_TX_RD_befor_SEND), \nthe left Data length= 3 \n3) Retry SEND Command until the sum of the actual sent data length is same the \nsend data length. \nNote:  Don’t copy data until the sum of the actu al sent data length is the send data length. \n{ \n/* first, get the free TX memory size */ \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n51 \niEthernet  W5200 FREESIZE: \nfreesize = Sn_TX_FSR; \nif (freesize<len) goto FREESIZE;   // len is send size \n \n/* calculate offset address */ \ndst_mask= Sn_TX_WR0 &gSn_TX_MASK;    // dst_mask  is offset address \n/* calculate start address(physical address) */ \ndst_ptr = gSn_TX_BASE + dst_mask;    // destination_address  is physical start address \n/* if overflow SOCKETTX memory */ \nif ( (dst_mask + len) > (gSn_TX_MASK + 1) ) \n{ \n/* copy upper_size  bytes of source_addr  to destination_address  */ \nupper_size = (gSn_TX_MASK + 1) – dst_mask; \nmemcpy(src_addr, dst_ptr, upper_size); \n/* update source_addr */ \nsource_addr += upper_size; \n/* copy left_size  bytes of source_addr  to gSn_TX_BASE  */ \nleft_size = len – upper_size; \nmemecpy(source_addr, gSn_TX_BASE, left_size); \n} \nelse \n{ \n/* copy len bytes of source_addr  to destination_address  */ \nmemcpy(source_addr, dst_ptr, len);  \n} \n/* increase Sn_TX_WR as length of len */ \nSn_TX_WR0 += send_size; \n/* set SEND command */ \nSn_CR = SEND; \n/* return real packet size */ \nreturn ( read_ptr_after_send - read_ptr_befor_send ) \n/* if return value is not equal len ( len is send size ), \n retry send left data without copying data*/ \n} \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n52 \niEthernet  W5200 ESTABLISHMENT : Check disconnect-request(FIN packet) \nCheck if the Disconnect-request(FIN packet ) has been received. User can confirm the \nreception of FIN packet as below. \nFirst method : \n{ \nif (Sn_IR(DISCON) == ‘1’) Sn_IR(DISC ON)=‘1’; goto CLOSED stage;  \n/* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to IR, \nIMR Sn_IMR and Sn_IR. */ \n} \nSecond method : \n{ \nif (Sn_SR == SOCK_CLOSE_WAI T) goto CLOSED stage; \n} \n \nESTABLISHMENT : Check disconne ct / disconnecting process \nWhen the user does not need data communicati on with others, or receives a FIN packet, \ndisconnect the connection SOCKET . \n{ \n/* set DISCON command */ \nSn_CR = DISCON; \n} \n \nESTABLISHMENT : Check closed \nConfirm that the Socket n  is disconnected  or closed by DISCON or close command. \nFirst method : \n{ \nif (Sn_IR(DISCON) == ‘1’) goto CLOSED stage;  \n/* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to IR, \nIMR Sn_IMR and Sn_IR. */ \n} \nSecond method : \n{ \nif (Sn_SR == SOCK_CLOSED)  goto CLOSED stage; \n} \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n53 \niEthernet  W5200 ESTABLISHMENT: Timeout \nThe timeout can occur by Connect-request(SYN packet) or its response(SYN/ACK packet), \nthe DATA packet or its response(DATA/ACK pa cket), the Disconnect-request(FIN packet) \nor its response(FIN/ACK packet) and transmissi on all TCP packet. If it cannot transmit \nthe above packets within ‘tim eout’ which is configured at RTR and RCR, the TCP final \ntimeout(TCP TO) occurs and the state of Sn_SR is se t to SOCK_CLOSED. Confirming method \nof the TCP TO is as below: \nFirst method : \n{ \nif (Sn_IR(TIMEOUT bit) == ‘1’) Sn_IR( TIMEOUT)=‘1’; goto CLOSED stage; \n/* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to IR, \nIMR Sn_IMR and Sn_IR. */ \n} \nSecond method : \n{ \nif (Sn_SR == SOCK_CLOSED)  goto CLOSED stage; \n} \n \nSOCKET Close \nIt can be used to close the Socket n , wh ich disconnected by di sconnect-process, or \nclosed by TCP TO or closed by host’s need  without disconnect-process. \n{ \n/* clear the remained interrupts of Socket n */ \nSn_IR = 0xFF; \n   I R ( n) = ‘1’; \n/* set CLOSE command */ \nSn_CR = CLOSE; \n} \n \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n54 \niEthernet  W5200 5.2.1.2  TCP CLIENT \nIt is same as TCP server except ‘CONNECT’ state. User can refer to the “5.2.1.1 TCP \nSERVER”. \n \nFigure 11 TCP CLIENT Operation Flow  \n \nCONNECT \nTransmit the connect-request (SYN packet) to  “TCP SERVER”. It may occurs the timeout \nsuch as ARP TO, TCP TO when make the “connection SOCKET” with “TCP SERVER” \n{ \nSn_DIPR0 = server_ip;  /* set TCP SERVER IP address*/  \n  Sn_DPORT0 = server_port; /* set TCP SERVER listen port number*/  \nSn_CR = CONNECT;  /* set CONNECT command */  \n} \n \n  \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n55 \niEthernet  W5200 5.2.2  UDP \nThe UDP is a Connection-less protocol. It communicates without “connection SOCKET .” \nThe TCP protocol guarantees reliable data  communication, but the UDP protocol uses \ndatagram communication which has no guaran tees of data communication. Because the \nUDP does not use “connection SOCKET ,” it can communicate with many other devices \nwith the known host IP address and port  number. This is a great advantage; \ncommunication with many others by using just one SOCKET , but also it has many problems such as loss of transmitted data, unwanted data received from others, etc. To \navoid these problems and guar antee reliability, the host retransmits damaged data or \nignores the unwanted data which is received  from others. The UDP protocol supports \nunicast, broadcast, and multicast communication. It follows the below communication flow.  \n \nFigure 12 UDP Operation Flow  \n \n5.2.2.1  Unicast and Broadcast \nThe unicast is one method of UDP communicati on. It transmits data to one destination \nat one time. On the other hand, the broadc ast communication transmits data to all \nreceivable destinations by using ‘broadcast IP address (255.255.255.255)’. For example, \nsuppose that the user transmits data to  destination A, B, and C. The unicast \ncommunication transmits each destination A, B, and C at each time. At this time, the \nARP TO c a n  a l s o  o c c u r  w h e n  t h e user gets the destination hardware address of \ndestinations A, B and C. User cannot transm it data to destinations which have ARP TO. \nThe broadcast communication can simultaneously  transmit data to destination A, B and \nC at one time by using “255.255.255.255” or “l ocal address | (~subnet address)” IP \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n56 \niEthernet  W5200 address. At this time, there is no need to  get the destination hardware address about \ndestination A, B and C, and also ARP TOis not occurred. \n Note:  Broadcast IP  \n=> The Broadcast IP address can be obtained  by performing a bit-wise logical OR \noperation between the bit complement of the subnet mask and the host’s IP address. \nex> If IP:”222.98.173.123” and the subnet mask:“255.255.255.0”, broadcast IP is “222.98.173.255” \nDescription Decimal Binary \nHOST IP 222.098.173.123  11011110.01100010.10101101.01111011  \nBit Complement Subnet mask 000.000.000.255  00000000.00000000.00000000.11111111  \nBitwise OR - - \nBroadcast IP 222.098.173.255  11011110.01100010.10101101.11111111  \n  \nSOCKET Initialization \nFor the UDP data communication, SOCKET initia lization is required; it opens the SOCKET . \nThe SOCKET open process is as followed. At first, choose one SOCKET among the 8 \nSOCKETS of W5200, then set the protocol mo de (Sn_MR(P3:P0)) of the chosen SOCKET \nand set the source port number Sn_PORT0 fo r communication. Finally, execute the OPEN \ncommand. After the OPEN comma nd, the state of Sn_SR is changed to SOCK_UDP . Then \nthe SOCKET initialization is complete. \n{ \nSTART: \nSn_MR = 0x02;   /* sets UDP mode */ \nSn_PORT0 = source_port;  /* sets source port number */ \nSn_CR = OPEN;   /* sets OPEN command */ \n/* wait until Sn_SR is changed to SOCK_UDP */ \nif (Sn_SR != SOCK_UDP) Sn_CR = CLOSE; goto START; \n} \n \nCheck received data \nCheck the reception of UDP data from destinat ion. User can also check for received data \nvia TCP communication. It is strongly reco mmended to use the second method because \nof the same reasoning from TCP . Plea se refer to the “5.2.1.1 TCP SERVER”. \n \nFirst method : \n{ \nif (Sn_IR(RECV) == ‘1’) Sn_IR(RECV) = ‘1’; goto Receiving Process stage; \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n57 \niEthernet  W5200 /* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to IR, \nIMR Sn_IMR and Sn_IR. */ \n} \nSecond Method : \n{ \n   if (Sn_RX_RSR0 != 0x0000) goto Receiving Process stage; \n} \n \nReceiving process \nProcess the received UDP data in Internal RX memory.  \nThe structure of received UDP data is as below. \n \nFigure 13 The Received UDP data Format \nThe received UDP data consists of 8bytes PACKET-INFO, and DATA packet. The PACKET-\nINFO contains transmitter’s information (IP a ddress, Port number) and the length of DATA \npacket. The UDP can receive UDP data from many others. User can classify the transmitter by transmitter’s information of P A C K E T - I N F O .  I t  a l s o  r e c e i v e s  b r o a d c a s t  \nSOCKET by using “255.255.255.255” IP address.  So the host should ignore unwanted \nreception by analysis of transmitter’s information. If the DATA size of Socket n  is larger th an Internal RX memory free size, user cannot \nreceive that DATA and also ca nnot receive fragmented DATA. \n{ \n/* calculate offset address */ \nsrc_mask = Sn_RX_RD &g Sn_RX_MASK;    // src_mask is offset address \n/* calculate start address(physical address) */ \nsrc_ptr = gSn_RX_BASE + src_mask;    // src_ptr is physical start address \n \n/* read head information (8 bytes) */ \nheader_size = 8; \n/* if overflow SOCKET RX memory */ \nif ( (src_mask + header_siz e) > (gSn_RX_MASK + 1) ) \n{ \n/* copy upper_size  bytes of src_ptr  to header_addr */ \nupper_size = (gSn_RX_MASK + 1) – src_mask; \nmemcpy(src_ptr, header, upper_size); \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n58 \niEthernet  W5200 /* update header_addr */ \nheader_addr += upper_size; \n/* copy left_size  bytes of gSn_RX_BASE  to header_address  */ \nleft_size = header_size – upper_size; \nmemcpy(gSn_RX_BASE, header, left_size); \n/* update src_mask  */ \nsrc_mask = left_size; \n} \nelse \n{ \n/* copy header_size  bytes of get_start_address  to header_address  */ \nmemcpy(src_ptr, header, header_size); \n/* update src_mask  */ \nsrc_mask += header_size; \n} \n/* update src_ptr  */ \nsrc_ptr = gSn_RX_BASE + src_mask; \n \n/* save remote peer informatio n & received data size */ \npeer_ip = header[0 to 3]; \npeer_port = header[4 to 5]; \nget_size = header[6 to 7]; \n \n/* if overflow SOCKET RX memory */ \nif ( (src_mask + get_size) > (gSn_RX_MASK + 1) ) \n{ \n/* copy upper_size  bytes of src_ptr  to destination_address  */ \nupper_size = (gSn_RX_MASK + 1) – src_mask; \nmemcpy(src_ptr, destinat ion_addr, upper_size); \n/* update destination_addr */ \ndestination_addr += upper_size; \n/* copy left_size  bytes of gSn_RX_BASE  to destination_address  */ \nleft_size = get_size – upper_size; \nmemcpy(gSn_RX_BASE, destination_addr, left_size); \n} \nelse \n{ \n/* copy len bytes of src_ptr  to destination_address  */ \nmemcpy(src_ptr, destination_addr, get_size);  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n59 \niEthernet  W5200 } \n/* increase Sn_RX_RD as length of len+ header_size  */ \nSn_RX_RD = Sn_RX_RD + header_size + get_size; \n/* set RECV command */ \nSn_CR = RECV; \n} \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n60 \niEthernet  W5200 Check send data / sending process \nThe size of DATA that the user wants to tr ansmit cannot be larger than Internal TX \nmemory. If it is larger than MTU, it is au tomatically divided by MTU unit and transmitted. \nThe Sn_DIPR0 is set “255.255.255.255” when user wants to broadcast. \n{ \n/* first, get the free TX memory size */ \nFREESIZE: \nfreesize = Sn_TX_FSR0; \nif (freesize<len) goto FREESIZE;    // len is send size \n \n/* Write the value of remote_ip, remote_port  to the Socket n  Destination IP Address \nRegister(S n_DIPR), Socket n  Destination Port Register(S n_DPORT). */ \n   Sn_DIPR0 = remote_ip; \n   Sn_DPORT0 = remote_port; \n \n/* calculate offset address */ \ndst_mask = Sn_TX_WR0 & gSn_TX_MASK;    // dst_mask is offset address \n/* calculate start address(physical address) */ \ndst_ptr = gSn_TX_BASE + dst_mask;    // dst_ptr is physical start address \n \n/* if overflow SOCKETTX memory */ \nif ( (dst_mask + len) > (gSn_TX_MASK + 1) ) \n{ \n/* copy upper_size  bytes of source_address  to dst_ptr  */ \nupper_size = (gSn_TX_MASK + 1) – dst_mask; \nmemcpy(src_ptr, destinat ion_addr, upper_size);  \n \n/* update source_address */ \nsource_address += upper_size; \n/* copy left_size  bytes of source_address  to gSn_TX_BASE  */ \nleft_size = send_size – upper_size; \nmemcpy(src_ptr, destination_addr, left_size);  \nelse \n{ \n/* copy len bytes of source_address  to dst_ptr  */ \nmemcpy(src_ptr, destination_addr, len);  \n} \n/* increase Sn_TX_WR0 as length of len */ \nSn_TX_WR0 += len; \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n61 \niEthernet  W5200 /* set SEND command */ \nSn_CR = SEND; \n} \n \nCheck complete sending / Timeout \nTo transmit the next data, user must check that the prior SEND command is completed. \nThe larger the data size, the more time to  complete the SEND command. Therefore, the \nuser must properly divide the data to transmit. The ARP TO can occur when user transmits \nUDP data. If ARP TO occurs, the UDP data tr ansmission has failed. \nFirst method :  \n{ \n/* check SEND command completion */ \nwhile(Sn_IR(SENDOK)==‘0’)  /* wait interrupt of SEND completion */ \n{ \n/* check ARP TO */ \n  if (Sn_IR(TIMEOUT)==‘1’) Sn_IR( TIMEOUT)=‘1’; goto Next stage; \n} \nSn_IR(SENDOK) = ‘1’; /* clear previous interrupt of SEND completion */ \n} \nSecond method :  \n{ \nIf (Sn_CR == 0x00) transmission is completed. \nIf (Sn_IR(TIMEOUT bit) == ‘1’) goto next stage; \n/* In this case, if the interrupt of Socket n  is activated, interrupt occurs. Refer to \nInterrupt Register(IR), Interrupt Mask Register (IMR) and Socket n  Interrupt Register (Sn_IR). \n*/ \n} \n \nCheck Finished / SOCKET close \nIf user doesn’t need the communicati on any more, close the Socket n .  \n{ \n/* clear remained interrupts */ \nSn_IR = 0x00FF; \n   I R ( n) = ‘1’; \n/* set CLOSE command */ \nSn_CR = CLOSE; \n} \n \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n62 \niEthernet  W5200 5.2.2.2  Multicast \nThe broadcast communication communicates wi th many and unspecified others. But the \nmulticast communication communicates with ma ny specified others who registered at a \nmulticast-group. Suppose that A, B, and C ar e registered at a specified multicast-group. \nIf user transmits data to m ulticast-group (contains A), B an d C also receive the DATA for \nA. To use multicast communication, the destin ation list registers to multicast-group by \nusing IGMP protocol. The multicast-group cons ists of ‘Group hardware address,’ ‘Group \nIP address,’ and ‘Group port number.’ User cannot change the ‘Group hardware address’ \nand ‘Group IP address.’ But the ‘Group port number’ can be changed. The ‘Group hardware address’ is se lected at the assigned range (From \n“01:00:5e:00:00:00”to “01:00:5e:7f:ff:ff”) and the ‘Group IP address’ is selected in D-\nclass IP address (From “224.0.0.0” to “239.255. 255.255”, please refer to the website; \nhttp://www.iana.org/assign ments/multicast-addresses\nU).  \nWhen selecting, the upper 23bit of 6bytes ‘Group hardware address’ and the 4bytes \n‘Group IP address’ must be the same. For ex ample, if the user selects the ‘Group IP \naddress’ to “244.1.1.11,” the ‘Group ha rdware address’ is selected to \n“01:00:5e:01:01:0b.” Please refer to the “RFC1112” ( Uhttp://www.ietf.org/rfc.html U). \nIn the W5200, IGMP processing to regist er the multicast-group is internally \n(automatically) processed. When the user opens the Socket n  with multicast mode, \nthe “Join” message is interna lly transmitted. If the user closes it, the “Leave” message \nis internally transmitted. After the SOCKET opens, the “Report” message is periodically \nand internally transmitted wh en the user communicates. \nThe W5200 support IGMP version 1 and version 2 only. If user wants use an updated version, the host processes IGMP dire ctly by using the IPRAW mode SOCKET . \n \nSOCKET Initialization \nChoose one SOCKET for multicast communication among 8 SOCKETS of W5200. Set the \nSn_DHAR0 to ‘Multicast-group hardware addr ess’ and set the Sn_DIPR0 to ‘Multicast-\ngroup IP address.’ Then set the Sn_PORT0  and Sn_DPORT0 to ‘Multicast-group port \nnumber.’ Set the Sn_MR(P3:P0) to UDP and set the Sn_MR(MULTI) to ‘1.’ Finally, execute \nOPEN command. If the state of Sn_SR is ch anged to SOCK_UDP after the OPEN command, \nthe SOCKET initialization is completed. \n{ \nSTART: \n/* set Multicast-Group information */ \nSn_DHAR0 = 0x01; /* set Multicast-Group H/W a ddress(01:00:5e:01:01:0b) */ \nSn_DHAR1 = 0x00; \nSn_DHAR2 = 0x5E; \nSn_DHAR3 = 0x01; \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n63 \niEthernet  W5200 Sn_DHAR4 = 0x01; \nSn_DHAR5 = 0x0B; \nSn_DIPR0 = 211; /* set Multicast-Group IP address(211.1.1.11) */  \nSn_DIPR1 = 1; \nSn_DIPR2 = 1; \nSn_DIRP3 = 11; \nSn_DPORT0 = 0x0BB8; /* set Multicast-GroupPort number(3000) */ \nSn_PORT0 = 0x0BB8; /* set SourcePort number(3000) */ \nSn_MR = 0x02 | 0x80; /* set UDP mode & Multicast on Socket n  Mode Register */ \n \nSn_CR = OPEN; /* set OPEN command */  \n \n/* wait until Sn_SR is changed to SOCK_UDP */ \nif (Sn_SR != SOCK_UDP) Sn_CR = CLOSE; goto START;  \n} \n \nCheck received data \nRefer to the “5.2.2.1 Unicast & Broadcast.” \n \nReceiving process \nRefer to the “5.2.2.1 Unicast & Broadcast.”  \nCheck send data / Sending Process \nSince the user sets the information about mult icast-group at SOCKET initialization, user \ndoes not need to set IP address and port number for destination any more. Therefore, copy the transmission data to internal TX memory and executes SEND command. \n{ \n/* first, get the free TX memory size */ \nFREESIZE: \nfreesize = Sn_TX_FSR; \nif (freesize<len) goto FREESIZE;    // len is send size \n \n/* calculate offset address */ \ndst_mask = Sn_TX_WR0 &gSn_TX_MASK;    // dst_mask  is offset address \n/* calculate start address(physical address) */ \ndst_ptr = gSn_TX_BASE + dst_mask;    // dst_ptr  is physical start address \n/* if overflow SOCKETTX memory */ \nif ( (dst_mask + len) > (gSn_TX_MASK + 1) ) \n{ \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n64 \niEthernet  W5200 /* copy upper_size  bytes of source_addr  to destination_address  */ \nupper_size = (gSn_TX_MASK + 1) – dst_mask; \nmemcpy((0x0000 + source_addr), (0x0000 + dst_ptr), upper_size); \n/* update source_addr */ \nsource_addr += upper_size; \n/* copy left_size  bytes of source_addr  to gSn_TX_BASE  */ \nleft_size = len – upper_size; \nmemcpy( source_addr, gSn_TX_BASE, left_size); \n} \nelse \n{ \n/* copy len bytes of source_addr  to dst_ptr  */ \nmemcpy( source_addr, dst_ptr, len);  \n} \n/* increase Sn_TX_WR as length of len */ \nSn_TX_WR0 += send_size; \n/* set SEND command */ \nSn_CR = SEND; \n} \n \nCheck complete sending / Timeout \nSince the host manages all protocol process for data communication, timeout cannot \noccur. \n{ \n/* check SEND command completion */ \nwhile(S0_IR(SENDOK)==‘0’);  /* wait interrupt of SEND completion */ \nS0_IR(SENDOK) = ‘1’;        /* clear previous interrupt  of SEND completion */ \n} \n \nCheck finished / SOCKET close \nRefer to the “5.2.2.1 Unicast & Broadcast.” \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n65 \niEthernet  W5200 5.2.3  IPRAW \nIPRAW is data communication using TCP , UDP , and IP layers, which are the lower protocol \nlayers. IPRAW supports IP layer protocol such as ICMP (0x01) and IGMP (0x02) according to the protocol number. The ‘ping’ of ICMP or IGMP v1/v2 is already included in W5200 \nby hardware logic. But if the user needs, the host can directly process the IPRAW by \nopening the Socket n  to IPRAW. In the ca se of using IPRAW mode, user must set the \nprotocol number field of the IP header to what the user wants to use. The protocol \nnumber is defined by IANA. Refer to the web (\nUhttp://www.iana.org \n/assignments/protocol-numbers U). The protocol number must be configured to \nSn_PROTO before ‘SOCKET open.’ In IPRAW mode, W5200 does not support TCP (0x06) \nor UDP (0x11) protocol number. The SOCKET communication of IPRAW mode only allows \nthe communication of an assigned protocol  number. The ICMP SOCKET cannot receive \nunassigned protocol data except assi gned protocol data such as IGMP. \n \nFigure 14 IPRAW Operation Flow  \n \nSOCKET Initialization \nSelect the SOCKET and set th e protocol number. Then set the Sn_MR(P3:P0) to IPRAW \nmode and execute ‘OPEN’ command. If the Sn _SR is changed to SOCK_IPRAW after the \n‘OPEN’ command, the SOCKET initialization is completed. \n{ \nSTART: \n/* sets Protocol number */ \n/* The protocol number is used in Protocol Field of IP Header. */ \nSn_PROTO = protocol_num; \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n66 \niEthernet  W5200 /* sets IP raw mode */ \nSn_MR = 0x03; \n/* sets OPEN command */ \nSn_CR = OPEN; \n/* wait until Sn_SR is changed to SOCK_IPRAW */ \nif (Sn_SR != SOCK_IPRAW) Sn_CR = CLOSE; goto START; \n} \n \nCheck received data \nRefer to the “5.2.2.1 Unicast & Broadcast.” \n \nReceiving process \nProcess the IPRAW data which is received in internal RX memory. The structure of \nreceived IPRAW data is as below. \n \nFigure 15 The receive IPRAW data Format \nThe IPRAW data consists 6 bytes PACKET -INFO and DATA pack et. The PACKET-INFO \ncontains information about the transmitter (IP address) and the length of the DATA-\npacket. The data reception of IPRAW is the same as UDP data reception except \nprocessing the port number of the transmitte r in UDP PACKET-INFO. Refer to the “5.2.2.1 \nUnicast & Broadcast.” If the tran smitted DATA size is larger than RX memory free size of \nSocket n , user cannot receive that DATA and also cannot receive fragmented DATA. \n \nChecks send data / Sending process \nThe size of DATA which user wants to transmit  cannot be larger than Internal TX memory \nand default MTU. The transmission of IPRAW data is the same as transmission of UDP \ndata except setting ‘Destination port number’. Refer to the “5.2.2.1 Unicast & \nBroadcast.”  \nComplete sending / Timeout \nSame as UDP , please refer to the “5.2.2 UDP .” \nCheck finished / SOCKET closed \nSame as UDP , please refer to the “5.2.2 UDP .” \n5.2.4  MACRAW \nThe MACRAW communication is based on Ethe rnet MAC, and it can flexibly use upper \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n67 \niEthernet  W5200 layer protocol to suit the host’s needs. \nThe MACRA W mode can only be used with a SOCKET . If the user uses the SOCKET  in MACRAW mode, not only can it use the SOC KET1~7 in the ‘Hardwired TCP/IP stack’, but \nit can also be used as a NIC (Network In terface Controller). Therefore, any SOCKET1~7 \ncan be used with ‘Software TCP/IP stack’. Since the W5200 supports ‘Hardwired TCP/IP \nstack’ and ‘Software TCP/IP stack’, it calls ‘Hybrid TCP/IP stack’. If user wants more \nSOCKETs beyond the supported 8 SOCKETS, th e SOCKET in which the user wants high \nperformance should be utilizing the ‘‘Hardwi red TCP/IP stack’, and the others should \nbe using ‘Software TCP/IP stack’ by MACRAW mode. So it overcomes the limited capacity \nof 8 SOCKETS. The SOCKET of MACRAW mode can process all protocols except using in \nSOCKET1~7. Since the MACRAW communication is pure Ethernet packet communication \n(there is no other processing), the MACRAW designer should use the ‘Software TCP/IP \nstack’ to process the protocol . The MACRAW data should basically contain the 6bytes of \n‘Source hardware address’, 6b ytes of ‘destination hardware address’ and 2bytes of \n‘Ethernet type’ because it is based on Ethernet MAC.  \n \nFigure 16 MACRAW Operation Flow  \n \n  \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n68 \niEthernet  W5200 SOCKET Initialization \nSelect the SOCKET and set the SN_MR(P3:P0) to MACRAW mode. Then  execute the ‘OPEN’ \ncommand. After the ‘OPEN’ command, if the Sn_SR is successfully changed to \n‘SOCK_MACRAW’, the SOCKET initialization is  completed. Since all information about \ncommunication (Source hardware address, So urce IP address, Source port number, \nDestination hardware address, Destination IP address, Destin ation port number, Protocol \nheader, etc.) is in the ‘MACRAW data’, there is no more register setting. \n{ \nSTART: \n/* sets MAC raw mode */ \nS0_MR = 0x04; \n/* sets OPEN command */ \nS0_CR = OPEN; \n/* wait until Sn_SR is changed to SOCK_MACRAW */ \nif (Sn_SR != SOCK_MACRAW) S0_CR = CLOSE; goto START; \n} \n \nCheck received data \nRefer to the “5.2.2.1 Unicast & Broadcast.” \n \nReceiving process \nProcess the MACRAW data of the SOCKET which received it in internal RX memory.  \nThe structure of the MACRAW data is as below : \n \nFigure 17  The received MACRAW data Format \nThe MACRAW data consists of ‘PACKET-INFO,’ ‘DATA packet’ and 4bytes CRC. The ‘PACKET-\nINFO’ is the length of the DATA packet. The ‘D ATA packet’ consists of 6bytes ‘Destination \nMAC address,’ 6bytes ‘Source MAC address’ and 2bytes ‘Type,’ 46~1500 bytes ‘Payload.’ The ‘Payload’ of DATA packet consists of Intern et protocol such as ARP , IP according to the \n‘Type.’ The details of ‘Type’ please refer to the web:  (\nUhttp://www.iana.org/assi gnments/ethernet-numbers U) \n{ \n/* calculate offset address */ \nsrc_mask = Sn_RX_RD & gSn_RX_MASK;    // src_mask  is offset address \n/* calculate start address(physical address) */ \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n69 \niEthernet  W5200 src_ptr = gSn_RX_BASE + src_mask;    // src_ptr  is physical start address \n/* get the received size */ \nlen = get_Byte_Size_Of_Data_packet // get Byte size of DATA packet from Packet-INFO  \n/* if overflow SOCKET RX memory */ \nIf((src_mask + len) > (gSn_RX_MASK + 1)) \n{ \n/* copy upper_size  bytes of get_start_address  to destination_address  */ \nupper_size = (gSn_RX_MASK + 1) – src_mask; \nmemcpy(src_ptr, dst_addr, upper_size);  \n/* update destination_address  */ \ndst_addr += upper_size; \n/* copy left_size  bytes of gSn_RX_BASE to destination_address  */ \nleft_size = len – upper_size; \nmemcpy(src_ptr, dst_addr, left_size); \n} \nelse \n{ \n/* copy len bytes of src_ptr  to destination_address  */ \nmemcpy(src_ptr, dst_addr, len); \n} \n/*  increase Sn_RX_RD as length of len */ \nSn_RX_RD += len; \n/* extract 4 bytes CRC from internal RX memory and then ignore it */ \nmemcpy(src_ptr, dst_addr, len); \n/* set RECV command */ \nSn_CR = RECV; \n} \n<Notice> \nIf the free size of the internal RX memory is smaller than the MACRAW data, a problem may \noccasionally occur where some parts of that PACKET-INFO and DATA packet are stored to the internal RX memory. Since the problem occurs as an analysis error for PACKET-INFO, it cannot \nprocess the MACRAW data correctly. The closer the internal RX memory is to being full, the \nhigher the probability is for an error to occur. This problem can be resolved if user allows some loss of the MACRAW data. The solution is as follows: ▪ Process the internal RX memory as fast as possible to prevent that it closes to full. \n▪ Reduce the receiving load by reception only its MACRAW data by setting the MF (MAC Filter) \nbit of S0_MR in sample code of SOCKET initialization. \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n70 \niEthernet  W5200 { \nSTART: \n/* sets MAC raw mode with enabling MAC filter */ \nS0_MR = 0x44; \n/* sets OPEN command */ \nS0_CR = OPEN; \n/* wait until Sn_SR is changed to SOCK_MACRAW */ \nif (Sn_SR != SOCK_MACRAW) S0_CR = CLOSE; goto START; \n} \n \n▪If the free size of the internal RX memory is  smaller than ‘1528 - Default MTU(1514)+PACKET \nINFO(2) + DATA packet(8) + CRC(4)’, close the SOCKET and process all received data. Then \nreopen the SOCKET . After closing the SOCKET , the received MACRAW data from closing time can be lost. \n{ \n/* check the free size of internal RX memory */  \nif((Sn_RXMEM_SIZE(0) * 1024) - Sn_RX_RSR0(0) < 1528)  \n{ \nrecved_size = Sn_RX_RSR0(0);  /* backup Sn_RX_RSR */  \n   Sn_CR0 = CLOSE;  /* SOCKET Closed */ \nwhile(Sn_SR != SOCK_CLOSED); /* wait until SOCKET is closed */ \n/* process all data remained in internal RX memory */ \nwhile(recved_size> 0) \n     { /* calculate offset address */ \nsrc_mask = Sn_RX_RD&gSn_RX_MASK;    / /  src_mask  is offset address \n/* calculate start address(physical address) */ \nsrc_ptr = gSn_RX_BASE + src_mask;   / /  src_ptr  is physical start address \n/* if overflow SOCKET RX memory */ \nIf((src_mask + len) > (gSn_RX_MASK + 1)) \n{ \n/* copy upper_size  bytes of get_start_address  to destination_address  */ \nupper_size = (gSn_RX_MASK + 1) – src_mask; \nmemcpy(src_ptr, dst_addr, upper_size); \n/* update destination_address  */ \ndst_address += upper_size; \n/* copy left_size  bytes of gSn_RX_BASE to destination_address  */ \nleft_size = len – upper_size; \nmemcpy(src_ptr, dst_addr, left_size); \n} \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n71 \niEthernet  W5200 else \n{  / *  c o p y  len bytes of src_ptr  to destination_address  */ \nmemcpy(src_ptr, dst_addr, len); \n \n} \n/* increase Sn_RX_RD as length of len */ \nSn_RX_RD += len; \n/* extract 4 bytes CRC from internal RX memory and then ignore it */ \nmemcpy(src_ptr, dst_addr, len); \n/* calculate the size of remained data in internal RX memory*/  \nrecved_size = recved_size – 2 – len – 4;  \n     }  \n/* Reopen the SOCKET */ \n/* sets MAC raw mode with enabling MAC filter */ \nS0_MR = 0x44; /* or S0_MR = 0x04 */ \n/* sets OPEN command */ \nS0_CR = OPEN; \n/* wait until Sn_SR is changed to SOCK_MACRAW */ \nwhile (Sn_SR != SOCK_MACRAW); \n} \nelse /* process normally the DATA pa cket from internal RX memory */  \n{/* This block is same as the code of “Receiving process” stage*/  \n} \n} \n \nCheck send data / sending process \nThe size of the data which the user wants to transmit cannot be larger than the internal \nTX memory and default MTU. The host genera tes the MACRAW data in the same format \nas the “Receiving proces s” data packet, and transmits it. At  this time, if the size of the \ngenerated data is smaller than 60bytes, the tr ansmitted Ethernet packet internally fills \nto 60bytes by “Zero padding” and then it is transmitted. \n{ \n/* first, get the free TX memory size */ \nFREESIZE: \nfreesize = S0_TX_FSR; \nif (freesize<send_size) goto FREESIZE; \n/* calculate offset address */ \ndst_mask = Sn_TX_WR0 &gSn_TX_MASK;    // dst_mask  is offset address \n/* calculate start address(physical address) */ \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n72 \niEthernet  W5200 dst_ptr = gSn_TX_BASE + dst_mask;    // dst_ptr  is physical start address \n \n/* if overflow SOCKETTX memory */ \nif ( (dst_mask + len) > (gSn_TX_MASK + 1) ) \n{/* copy upper_size  bytes of source_addr  to destination_address  */ \nupper_size = (gSn_TX_MASK + 1) – dst_mask; \nmemcpy(src_ptr, dst_addr, upper_size); \n/* update source_addr */ \nsource_addr += upper_size; \n/* copy left_size  bytes of source_addr  to gSn_TX_BASE  */ \nleft_size = len – upper_size; \nmemcpy(src_ptr, dst_addr, left_size); \n} \nelse \n{/* copy len bytes of source_addr  to destination_address  */ \nmemcpy(src_ptr, dst_addr, len); \n} \n/* increase Sn_TX_WR as length of len */ \nSn_TX_WR += send_size; \n \n/* set SEND command */ \n   S0_CR = SEND; \n} \n \nCheck complete sending \nSince the host manages all protocol proc essors to communicate, the timeout can \nnotoccur. \n{ \n/* check SEND command completion */ \nwhile(S0_IR(SENDOK)==‘0’);  /* wait interrupt of SEND completion */ \nS0_IR(SENDOK) = ‘1’;        /* clear previous interrupt of SEND completion */ \n} \n \nCheck finished / SOCKET close \nRefer to the “5.2.2.1 Unicast & Broadcast.” \n \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n73 \niEthernet  W5200 6 External Interface \nFor the communication with MCU, W5200 prov ides SPI I/F modes. For the communication \nwith Ethernet PHY , MII is used.  \n6.1 SPI (Serial Peripheral Interface) mode \nSerial Peripheral Interface Mode uses only four pins for data communication. \nFour pins are CSn, SC LK, MOSI, and MISO.  \n \nFigure 18 SPI Interface \n6.2 Device Operations \nW5200 is controlled by a set of instruction th at is sent from a external host , commonly \nreferred to as the SPI Master. The SPI Mast er communicates with W5200 via the SPI bus, \nwhich is composed of four signal lines: Slav e Chip Select (CSn), Serial Clock (SCLK), MOSI \n(Master Out Slave In) and MISO (Master In Slave Out). The SPI protocol defines four modes for its operation (Mode 0-3). Each mode differs according to the SCLK polarity and phase - ho w the polarity and phase control the flow of \ndata on the SPI bus. The W5200 operates as SPI Slave device and supports the most common \nmodes - SPI Mode 0 and 3. The only difference between SPI Mode 0 and 3 is the polarity of the SCLK signal at the \ninactive state. With SPI Mode 0 and 3, data is always latched in on the rising edge of SCLK \nand always output on the falling edge of SCLK.  \n \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n74 \niEthernet  W5200 6.3 Process of using general SPI Master device \n1. Configure Input/Output direction on SPI Master Device pins. \n2. Configure CSn as ‘High’ on inactive \n3. Write target address for transmission on  SPDR register (SPI Data Register). \n4. Write OP code and data length fo r transmission on SPDR register. \n5. Write desired data for transmission on SPDR register. \n6. Configure CSn as ‘Low’ (data transfer start) \n7. Wait for reception complete \n8. If all data transmission ends, configure CSn as ‘High’ \n \n \nFigure 19 W5200 SPI Frame Format \n \n \nFigure 20 Address and OP/DATA Length Sequence Diagram \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n75 \niEthernet  W5200 READ Processing \nThe READ Processing Sequence Diagram is sh own in Figure 20. The READ processing is \nentered by driving CSn low, followed by the Address, the OP code, the Data Length and the Dummy data byte on MOSI. And then W5200 read  the data byte on MISO. The Address, the \nOP/Data Length Sequence Diagram and the Data are shown in Figure 19. The OP code (OP) is defined type of the READ OP and WIRTE OP . On OP = 0, the read operation is selected. \nOtherwise, On OP = 1, the write operation is selected. In W5200 SPI mode, the Byte READ proces sing and the burst READ processing are \nprovided. The Byte READ processing takes 4 instructions which is consist of the 16-bit \nAddress, the 1-bit OP code(0x0 ), the 15-bit Data length and 8-bit Data. Otherwise, The \nBurst READ processing only takes the Data in struction after the setting of the burst read \nprocessing. To distinguish between the Byte  READ and the burst READ processing, the \nData length is used. If the Da ta length is ‘1,’ the Byte READ processing is operated. \nOtherwise, the Burst READ Processing is operat ed when the Data length is more than two. \nThe MISO pin should be selected by driving MISO low after the falling edge of the CSn. \n \nFigure 21 READ Sequence  \n/* Pseudo Code for Read da ta of 8bit per packet */ \n#define data_read_command    0x00  \nuint16 addr;     // Address : 16bits  \nint16 data_len;   // Data length :15bits \nuint8 data_buf[];  // Array for data  \nSpiSendData();   // Send data from MCU to W5200  \nSpiRecvData();   // Receive data from W5200 to MCU  \n \n{ \nISR_DISABLE();  // Interrupt Service Routine disable \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n76 \niEthernet  W5200 \n \n  CSoff();  // CS=0, SPI start  \n \n// SpiSendData \nSpiSendData(((addr+idx) & 0xFF00) >> 8);    // Address byte 1  \nSpiSendData((addr+idx) & 0x00FF);     // Address byte 2  \n \n// Data write command + Data length upper 7bits \nSpiSendData((data_re ad_command| ((d ata_len& 0x7F00) >> 8))); \n// Data length bottom 8bits \nSpiSendData((data_len& 0x00FF));  \n \n// Read data:On data_len> 1, Burst Read Processing Mode. \nfor(int idx = 0; idx<data_len; idx++) \n{ \nSpiSendData(0);  // Dummy data  \ndata_buf[idx] = SpiRecvData(idx);  // Read data  \n} \nCSon();  // CS=1, SPI end \nISR_ENABLE();  // Interrupt Service Routine disable \n} \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n77 \niEthernet  W5200 WRITE Processing \nThe WRITE Processing Sequence Diagram is shown in Figure 21.The WRITE processing is \nentered by driving CSn low, followed by the Address, the OP code, the Data Length, and \nthe Data byte on MOSI.  \n \nIn W5200 SPI mode, the Byte WRITE processing and the Burst WRITE processing are provided. The Byte WRITE processing takes 4 instructions which is consist of the 16-bit Address, the \n1-bit OP code(0x1), the 15-bit Data length and 8-bit Data. Otherwise, The Burst WRITE \nprocessing only takes the Data instruction af ter the setting of the Burst WRITE processing. \nTo distinguish between the Byte WRITE and the Burst WRITE processing, the Data length is \nused. If the Data length is ‘1,’ the Byte WRIT E processing is operated. Otherwise, the Burst \nWRITE Processing is operated when the Data le ngth is more than two. The MOSI pin should \nbe selected by driving MOSI low after the falling edge of the CSn.  \n \n \nFigure 22 Write Sequence \n/* Pseudo Code for Write data of 8bit per packet */ \n#define data_write_command    0x80 \nuint16 addr;     // Address : 16bits  \nint16 data_len;     // Data length :15bits \nuint8 data_buf[];  // Array for data  \nSpiSendData();   //Send data from MCU to W5200  \n \n{ \n \nISR_DISABLE(); // Interrupt Service Routine disable \nCSoff(); // CS=0, SPI start  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n78 \niEthernet  W5200 \n  \n \n     \nSpiSendData(((addr+idx) & 0xFF00) >> 8);  // Address byte 1  \nSpiSendData((addr+idx) & 0x00FF);  // Address byte 2  \n \n// Data write command + Data length upper 7bits \nSpiSendData((data_write_command | ((data_len& 0x7F00) >> 8))); \n// Data length bottom 8bits \nSpiSendData((data_len& 0x00FF)); \n \n// Write data: On data_len> 1, Burst Write Processing Mode.  \nfor(int idx = 0; idx<data_len; idx++) \nSpiSendData(data_buf[idx]); \n \nCSon();  // CS=1, SPI end   \nIINCHIP_ISR_ENABLE();  // Interrupt Service Routine disable \n} \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n79 \niEthernet  W5200 7 Electrical Specifications \n \n7.1 Absolute Maximum Ratings \nSymbol Parameter Rating Unit \nVDD DC Supply voltage -0.5 to 3.63 V \nVIN DC input voltage -0.5 to 5.5 (5V tolerant) V \nIIN DC input current \uf0b15 mA \nTOP Operating temperature -40 to +85 \uf0b0C \nTSTG Storage temperature -55 to 125 \uf0b0C \n*COMMENT : Stressing the device beyond the “Absol ute Maximum Ratings” may cause permanent \ndamage. \n \n7.2 DC Characteristics \nSymbol Parameter Test Condition Min Typ Max Unit \nVDD DC Supply voltage Junction \ntemperature is from -55°C to 125°C 2.97\n  3.63 V \nVIH High level input voltage  2.0  5.5 V \nVIL Low level input voltage  - 0.3   0.8 V \nVOH High level output voltage IOH = 4 ~8 mA 2.4   V \nVOL Low level output voltage IOL = 4 ~8mA   0.4 V \nII Input Current VIN = VDD   \uf0b15 \uf06dA \n \n7.3 POWER DISSIPATION(Vcc 3.3V Temperature 25°C) \nCondition Min Typ Max Unit \n100M Link - 160 175 mA \n10M Link - 110 125 mA \nLoss Link - 125 140 mA \n100M Transmitting - 160 175 mA \n10M Transmitting - 110 125 mA \nPower Down mode - 2 4 mA \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n80 \niEthernet  W5200 7.4 AC Characteristics \n7.4.1  Reset Timing \n \nFigure 23 Reset Timing  \nSymbol Description Min Max \nTRC Reset Cycle Time 2 us - \nTPL RSTn internal PLOCK - 150 ms \n \n \n7.4.2  Crystal Characteristics \nParameter Range \nFrequency 25 MHz \nFrequency Tolerance (at 25 ℃) ±30 ppm \nShunt Capacitance 7pF Max \nDrive Level 59.12uW/MHz \nLoad Capacitance 27pF \nAging (at 25 ℃) ±3ppm / year Max \n \n  \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n81 \niEthernet  W5200 7.4.3  SPI Timing \n \nFigure 24 SPI Timing \n \n  \n                                                 \n \n5 Theoretical Guaranteed Speed \nEven though theoretical design speed is 80MHz, the signal in the high speed may be distorted because of \nthe circuit crosstalk and the length of the signal li ne. The minimum guaranteed speed of the SCLK is 33.3 \nMHz which was tested and measured with the stable waveform. \n \n6 2.1ns is when pn loaded with 30pF . The time is shorter with lower capacitance. \n Symbol Description Min Max Units \nFSCK SCK Clock Frequency   80/33.35 MHz \nTWH SCK High Time 6  ns \nTWL SCK Low Time 6  ns \nTCS CSn High Time 5  ns \nTCSS CSn Setup Time 5 - ns \nTCSH CSn Hold Time 5  ns \nTDS Data In Setup Time 3  ns \nTDH Data In Hold Time 3  ns \nTOV Output Valid Time  5 ns \nTOH Output Hold Time 0  ns \nTCHZ CSn High to Output Hi-Z  2.16 ns \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n82 \niEthernet  W5200 7.4.4  Transformer Characteristics \nParameter Transmit End Receive End \nTurn Ratio 1:1 1:1 \nInductance 350 uH 350 uH \n \nFigure 25 Transformer Type  \nIn case of using internal PHY mode, be sure to use symmetric transformer in order to \nsupport Auto MDI/MDIX(Crossover).  \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n83 \niEthernet  W5200 8 IR Reflow Temperature Profile (Lead-Free) \nMoisture Sensitivity Level : 3 \nDry Pack Required: Yes  \nAverage Ramp-Up Rate \n(Tsmax to Tp) 3° C/second max. \nPreheat \n– Temperature Min (Ts min) \n– Temperature Max (Ts max) \n– Time (ts min to ts max)  \n150 °C 200 °C 60-120 seconds \nTime maintained above: \n– Temperature (TL) \n– Time (tL)  \n217 °C 60-150 seconds \nPeak/Classification Temperature (Tp) 265 + 0/-5°C \nTime within 5 °C of actual Peak Temperature (tp) 30 seconds \nRamp-Down Rate 6 °C/second max. \nTime 25 °C to Peak Temperature 8 minutes max. \n \n \nFigure 26 IR Reflow Temperature  \n \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n84 \niEthernet  W5200 9 Package Descriptions \n \nFigure 27 Package Dimensions  \nNote: \n1. All dimensions are in millimeters. \n2. Die thickness allowable is 0.0304 mm  MAXMUM (0.012 Inches MAXIMUM) \n3. Dimension & tolerances conform to same Y14.5M. -1994. \n4. Dimension applies to plated terminal  and is measured between 0.20 and \n0.25mm from terminal tip. \n5. The pin #1 identifier must be placed on  the top surface of the package by using \nindentation mark or other feature of package body. \n6. Exact shape and size of th is feature is optional. \n\n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n85 \niEthernet  W5200 7. Package warpage max 0.08 mm. \n8. Applied for exposed pad and terminals. Exclude embedding part of exposed pad \nfrom measuring \n9. Applied only to terminals \n10.  Package corners unless otherwise specified are R0.175+/- 0.025mm \n  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n86 \niEthernet  W5200 Document History Information \n \nVersion Date Descriptions \nVer. 1.0.0 Mar2011 Released with W5200 Launching  \nVer. 1.1.0  13MAR2011  1.Changed  “IMR address (0x16 to 0x36)” (P.14, P.18)  \n2.Changed  “IMR2 address (0x36 to 0x16)” (P.14, P.22)  \nVer. 1.2.0 22APR2011 1. Corrected description of “RSV at 1.3 Miscellaneous Signals ” (P.10)  \n2. Corrected the values of “typical at 7.3 power dissipation ” (P.77) \n3. Added values of “maximum at 7.3 power dissipation  ”(P.77)  \n4. Removed “PIN31 at 1.3 Miscellaneous Signals ” ( P.10)  \nVer. 1.2.1 2AUG2011 Corrected the description of “READ processing at 6.3 Processing of using \ngeneral SPI Master device ”(P.73)  \nVer. 1.2.2 25NOV2011 Corrected “Block Diagram” (P.4) \nVer. 1.2.3 3FEB2012 Added “Figure2 of XTAL_VDD at 1.4 Power Supply Signals ” (P.11)  \nVer. 1.2.4 16FEB2012 Corrected “Pin names and sequence diagr ams of READ processing and \nWRITE processing at 6.3 Processing of using general SPI Master device ” \n(P.73, 75)  \nVer. 1.2.5 12APR2012 1. Corrected some miss phrase and words.  \n2. Corrected “Figure18 of SPI frame format at  6.1 SPI mode ”(P.72)  \nVer. 1.2.6 4JUN2012 \n 1. Corrected value of “memory map at  2 Memory Map ” (P.13) \n2. Corrected code of “write processing at 6.3 Process of using general \nSPI Master device”  (P.75)  \ncorrected SpiSendData function location  \nVer. 1.2.7 27JULY2012 1.Updated “Pin names at 1 Pin Assignment ” (P.8)  \nfrom PowerOut to 1V8O (PIN 14) \n2.Changed “IMR address (0x36 to 0x16)” (P14, P.22-> P.18)  \n3.Changed “IMR2 address (0x16 to 0x36)” (P14, P.18->P.22)  \n4.Corrected table of “DIPR size format at 4.2 Socket Register ” (P.33)  \n5.Corrected the table and figure of “RX, TX memory size format at 4.2 \nSocket Register  ” (P.35,41)  \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n87 \niEthernet  W5200 Ver. 1.2.8 13NOV2012 1. Updated description of “W5200” (P.2) \n2. Added more information about “indirect interface mode at 1.1 \nMCU Interface Signals ”(P.8) \n3. Updated “ Figure 1 at 1.1 MCU Interface Signals  ”(P.8) \ncorrected Pin6~7, Pin30~39, Pin42~43 \n4. Updated “pin descriptions at 1.1 MCU Interface Signals ”(P.8-13)  \n5. Updated description of “INTn at 1.1 MCU Interface Signals ”(P.9) \n   Added Sn_IR in description 6. Updated “Socket register at 3.2 Socket registers ”(P.16)  \ncorrected from Socket 0 to Socket n \n7. Updated description of Table   \nAdded WOL in Table of “ Mode register at 4.1 Common Registers ” \n(P.17)  \nAdded MF in Table of “ Sn_MR at 4.2 Socket Registers  ”(P.24)  \n8. Updated description of  “INTLEVEL at 4.1 Common Registers ”\n \n(P.21)  \n9. Corrected “ Figure24 and Table at  7.4.3 SPI Timing ”(P.80)  \ncorrected from Tcss(Hold time) to Tcss(Setup time) in Table \n10. Corrected Table , “FSCK and T CHZ at 7.4.3 SPI Timing ” (P.80)  \n FSCK from 80MHz to 80/33.3MHz \nTCHZ from 5ns to 2.1ns \n11. Corrected typo for: \nfrom registor to resistor in notes at 1.3 Miscellaneous Signals (P.11)  \nfrom 1v80 to 1v8O(TYPO) in Table at 1.4 Power Supply Signals (P.11)  \nfrom Interrupt Mask to Interrupt at 4.2 Socket Registers  (P.29)  \nfrom IR to IR2 at 4.1 Common Registers (P.21) \nVer. 1.2.9 5APR2013 1.Corrected “Figure 1at 1 Pin Assignment ” (P.8) \nfrom MDC/SPIEN to SPIEN, from MDIO to RSV \n2.Corrected Table  \nfrom MDC/SPIEN to SPIEN at 1.1 MCU Interface Signals (P.10) \nfrom MDIO to RSV at 1.3 MCU Interface Signals (P.10) \nNotes: Pull-Up/Down resistor 75k ->10k \n3.Corrected “Figure 2,3 at 1.4 Power Supply Signal ” (P.11~12)  \n4. Corrected “Timeout expression at 4.1 Common Registers ”(P.20)  \n5.Updated “Description of SOCK_LAST_ACK at  4.2 Socket \nRegister ”(P.30)  \n \n \n© Copyright 2013  WIZnet Co.,Ltd.  All rights reserved. \n88 \niEthernet  W5200 Ver.1.3.0 8JUL2013 1.  Corrected  “PHYSTATUS at 4.1 Common Registers” (P.23) \nfrom reserve to Power Save Mode \n2. Corrected “IMR at 4.1 Common Registers” (P.19)  \nfrom Sn_INT to Sn_IMR,n is socket number \n3. Added more information about PLL_CLK “ INTLEVEL at 4.1 \nCommon Registers” (P.21)  \n4. Corrected typo for :  \nfrom IMR to IMR2 in IR at 4.1 Common Registers (P.18)  \nfrom IR to IR2 in IMR at 4.1 Common Registers (P.19)   \nVer.1.4.0 10NOV2014 1. Corrected “ Figure 3 of Power Design at 1.4 Power Supply \nSignal ” (P .12)  \n \n \n \n   \nCopyright Notice \nCopyright 2013 WIZnet Co.,Ltd.  All Rights Reserved. \nTechnical Support: support@wiznet.co.kr  \nSales & Distribution: sales@wiznet.co.kr  \nFor more information, visit our website at http://www.wiznet.co.kr \n \n'}]
!==============================================================================!
### W5200 Ethernet Controller Summary

**Component Overview:**
The W5200 is a hardwired TCP/IP embedded Ethernet controller designed by WIZnet. It facilitates easy internet connectivity for embedded systems through a Serial Peripheral Interface (SPI). The W5200 integrates a TCP/IP stack, Ethernet MAC, and PHY, making it suitable for applications requiring a single-chip solution for network communication.

**Key Specifications:**
- **Voltage Ratings:**
  - Operating Voltage: 3.3V (with 5V I/O signal tolerance)
  
- **Current Ratings:**
  - Power Consumption:
    - 100M Link: 160-175 mA
    - 10M Link: 110-125 mA
    - Power Down Mode: 2-4 mA

- **Power Consumption:**
  - Typical power consumption varies based on operation mode (active vs. power down).

- **Operating Temperature Range:**
  - -40°C to +85°C

- **Package Type:**
  - 48-pin QFN (Quad Flat No-lead)

- **Special Features:**
  - Supports 8 independent sockets simultaneously.
  - Integrated 32KB memory for Tx/Rx buffers.
  - Wake on LAN (WOL) and power down mode.
  - Auto-negotiation for full/half duplex and 10/100 Mbps.
  - Supports ADSL connection with PPPoE protocol.
  - Multi-function LED outputs for link status and speed.

- **Moisture Sensitive Level (MSL):**
  - MSL Level: 3 (Dry Pack Required)

**Description:**
The W5200 is an Ethernet controller that allows embedded systems to connect to the internet easily. It features a hardwired TCP/IP stack that supports various protocols, including TCP, UDP, IPv4, ICMP, ARP, IGMP, and PPPoE. The controller is designed to simplify the implementation of Ethernet applications, enabling developers to focus on application logic rather than complex networking protocols.

**Typical Applications:**
The W5200 is suitable for a wide range of embedded applications, including:
- **Home Network Devices:** Set-top boxes, digital media adapters, and personal video recorders (PVRs).
- **Serial-to-Ethernet Converters:** Access controls, LED displays, and wireless access point relays.
- **Parallel-to-Ethernet Devices:** Point of Sale (POS) systems, mini printers, and copiers.
- **USB-to-Ethernet Adapters:** Network printers and storage devices.
- **GPIO-to-Ethernet Interfaces:** Home network sensors and automation systems.
- **Security Systems:** Digital video recorders (DVRs), network cameras, and kiosks.
- **Factory and Building Automation:** Industrial control systems and monitoring equipment.
- **Medical Monitoring Equipment:** Devices requiring network connectivity for data transmission.

The W5200's combination of features and ease of integration makes it a versatile choice for developers looking to add Ethernet connectivity to their embedded systems.